<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="前端," />





  <link rel="alternate" href="/atom.xml" title="Sonnet's Blog" type="application/atom+xml" />






<meta name="description" content="主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。">
<meta name="keywords" content="前端">
<meta property="og:type" content="article">
<meta property="og:title" content="理解回调函数">
<meta property="og:url" content="http://yoursite.com/2016/12/10/理解回调函数/index.html">
<meta property="og:site_name" content="Sonnet&#39;s Blog">
<meta property="og:description" content="主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2018-02-23T08:27:58.328Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="理解回调函数">
<meta name="twitter:description" content="主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"always","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2016/12/10/理解回调函数/"/>





  <title>理解回调函数 | Sonnet's Blog</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Sonnet's Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            关于
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2016/12/10/理解回调函数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="ulson">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Sonnet's Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">理解回调函数</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-10T00:00:00+08:00">
                2016-12-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p>主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。</p>
<a id="more"></a>
<p>函数是第一类对象，这是javascript中的一个重要的概念。意味着函数可以像对象一样按照第一类管理被使用，所以在javaScript中的函数：</p>
<p>**☑ **  能“存储”在变量中</p>
<p>** ☑**   能作为函数的实参被传递</p>
<p>**☑ **  能在函数中被创建</p>
<p>** ☑**   能从函数中返回</p>
<p><strong>百科里面是这么解释的：</strong></p>
<p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应。</p>
<p>因此从上面可以看出来，回调本质上是一种设计原则，并且jQuery的设计原则遵循了这个模式。</p>
<p>在后端的编程语言中，传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入和一个输出。简单的理解函数本质上就<strong>是输入和输出之间实现过程的映射</strong>。</p>
<p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用。</p>
<p><strong>jQuery中遍地都是回调的设计：</strong></p>
<p><strong>异步回调：</strong></p>
<p>事件句柄回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(callback);</span><br><span class="line">$(document).on(‘click’,callback)</span><br></pre></td></tr></table></figure>
<p>Ajax异步请求成功失败回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;aaron.html&quot;,</span><br><span class="line">  context: document</span><br><span class="line">&#125;).done(function() &#123; </span><br><span class="line">        //成功执行</span><br><span class="line">&#125;).fail(function() &#123;</span><br><span class="line">        //失败执行</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>动画执行完毕回调</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#clickme&apos;).click(function() &#123;</span><br><span class="line">    $(&apos;#book&apos;).animate(&#123;</span><br><span class="line">        opacity: 0.25,</span><br><span class="line">        left: &apos;+=50&apos;,</span><br><span class="line">        height: &apos;toggle&apos;</span><br><span class="line">    &#125;, 5000, function() &#123;</span><br><span class="line">        // Animation complete.</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>以上都是jQuery的回调直接运用，运用基本都是将匿名函数作为参数传递给了另一个函数或方法。而且以上都有一个特点，执行的代码都是异步的。</p>
<p><strong>同步回调：</strong></p>
<p>当然回调不仅仅只是处理异步，一般同步(很耗时的任务)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p>
<p>一个同步(阻塞)中使用回调的例子，目的是在test1代码执行完成后执行回调callback</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var test1 = function(callback) &#123;</span><br><span class="line">    //执行长时间操作</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line">test1(function() &#123;</span><br><span class="line">    //执行回调中的方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>所以理解回调函数最重要的2点：</strong></p>
<p>1、一个回调函数作为参数传递给另一个函数是，我们仅仅传递了函数定义。我们并没有在参数中执行函数。我们并不传递像我们平时执行函数一样带有一对执行小括号()的函数</p>
<p>2、回调函数并不会马上被执行，它会在包含它的函数内的某个特定时间点被“回调”。</p>
<h2>回调的灵活运用</h2>
<p>我们经常会这样使用函数回调：</p>
<p><strong>☑</strong>  事件触发通知</p>
<p><strong>☑</strong>  资源加载通知</p>
<p><strong>☑</strong>  定时器延时</p>
<p><strong>☑</strong>  ajax、动画通知等等。</p>
<p>以上都是很单一的事件监听回调的处理方式，但是jQuery把回调函数的用法设计成一个更高的抽像，用于解耦与分离变化。</p>
<p>如何理解这个设计？我们看下面的例子。</p>
<p><strong>例子一：</strong></p>
<p>jQuery针对Dom的处理提供了append、prepend、before、after等方法的处理，这几个方法的特征：</p>
<p>1、参数的传递可以是HTML字符串、DOM元素、元素数组或者jQuery对象</p>
<p>2、为了优化性能针对节点的处理需要生成文档碎片</p>
<p>可见几个方法都是需要实现这2个特性的，那么我们应该如何处理？</p>
<p><strong>高层接口：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">before: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">after: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>.nextSibling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<p><strong>底层实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">domManip: <span class="function"><span class="keyword">function</span>(<span class="params">args, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Flatten any nested arrays</span></span><br><span class="line">    args = concat.apply([], args);</span><br><span class="line">    <span class="comment">// We can't cloneNode fragments that contain checked, in WebKit</span></span><br><span class="line">    <span class="keyword">if</span> (isFunction ||</span><br><span class="line">        <span class="comment">//多参数处理</span></span><br><span class="line">        self.domManip(args, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l) &#123;</span><br><span class="line">        <span class="comment">//生成文档碎片</span></span><br><span class="line">        fragment = jQuery.buildFragment(args, <span class="keyword">this</span>[<span class="number">0</span>].ownerDocument, <span class="literal">false</span>, <span class="keyword">this</span>);</span><br><span class="line">        callback.call(<span class="keyword">this</span>[i], node, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们观察下jQuery的实现，通过抽象出一个domManip方法，然后在这个方法中处理共性，合并多个参数的处理与生成文档碎片的处理，然后最终把结果通过回调函数返回给每一个调用者。</p>
<p><strong>例子二：</strong></p>
<p>在很多时候需要控制一系列的函数顺序执行。那么一般就需要一个队列函数来处理这个问题。</p>
<p>我们看一段代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Ulson(List, callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        var task;</span><br><span class="line">        if (task = List.shift()) &#123;</span><br><span class="line">            task(); //执行函数</span><br><span class="line">        &#125;</span><br><span class="line">        if (List.length &gt; 0) &#123; //递归分解</span><br><span class="line">            arguments.callee(List)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 25)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">Ulson([</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;a&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;b&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;c&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">], function() &#123;</span><br><span class="line">    alert(&apos;callback&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 分别弹出 ‘a’ , ‘b’ ,&apos;c&apos;,’callback</span><br></pre></td></tr></table></figure>
<p>传入一组函数参数，靠递归解析，分个执行，其实就是靠setTimeout可以把函数加入到队列末尾才执行的原理，这样的写法就有点就事论事了，聚合对象完全是一个整体，无法再次细分出来，所以我们需要一种方案，用来管理分离每一个独立的对象。</p>
<p><strong>我们换成jQuery提供的方式:</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;a&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;b&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.fire(); //输出结果: &apos;a&apos; &apos;b&apos;</span><br></pre></td></tr></table></figure>
<p>是不是便捷很多了，代码又很清晰，所以Callbacks它是一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。</p>
<p>那么我们使用回调函数，总的来说<strong>弱化耦合</strong>，让调用者与被调用者分开，调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件的被调用函数。</p>
<h2>理解观察者模式</h2>
<p>讲解jQuery回调对象之前，我们有必要先理解其背后的设计思想 - “观察者模式”。</p>
<p>观察者模式 (pub/sub) 的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。观察者也被叫作订阅者（Subscriber），它指向被观察的对象，既被观察者（Publisher 或 subject)。当事件发生时，被观察者（Publisher）就会通知观察者（subscriber）。</p>
<p><strong>观察者的使用场合</strong></p>
<p>观察者的使用场合就是：<strong>当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式</strong>。先看官网的demo这个例子，涉及到了 add 与 fire方法，熟悉设计模式的童鞋呢，一眼就能看出，其实又是基于发布订阅（Publish/Subscribe）的观察者模式的设计。</p>
<p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统，将 $.Callbacks 作为一个队列。</p>
<p><strong>我们来模拟常规下最简单的实现：</strong></p>
<p>JS里对观察者模式的实现是通过回调来实现的，我们来先定义一个Observable对象，其内部包含了2个方法：订阅add方法与发布fire方法，如下代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用add开始订阅：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(1)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>使用fire开始发布：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.fire(); // 1, 2</span><br></pre></td></tr></table></figure>
<p><strong>设计的原理：</strong></p>
<p>开始构建一个存放回调的数组，如<code>this.callbacks= []</code>添加回调时，将回调push进this.callbacks，执行则遍历this.callbacks执行回调，也弹出1跟2了。当然这只是简洁的设计，便于理解，整体来说设计的思路代码都是挺简单的，那么我们从简单的设计深度挖掘下这种模式的优势。</p>
<p>注意：如果没有做过复杂交互设计，或者大型应用的开发者，可能一开始无法理解这模式的好处，就简单的设计而言用模式来处理问题，有点把简单的问题复杂化。我们不是为了使用模式而使用的。</p>
<p><strong>组件开发为了保证组件可以在不同的项目中都适用，其必须是对其常用功能抽象出来加以实现，绝不会包含具体的业务逻辑而某一特定的项目使用者在其业务场景中使用组件时不可避免的要加入不同场景的业务逻辑。</strong></p>
<h2>模式的实际运用</h2>
<p>在进行组件开发中，为了保证组件可以在不同的类似项目场景中都能适用，那么就必须是对其常用功能抽象出来加以实现。</p>
<p>我们来看看具体的实际用处：</p>
<p>假设一段ajax的请求，成功后通过done返回结果数据：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"test.html"</span>,</span><br><span class="line">  context: <span class="built_in">document</span>.body</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//data数据的处理</span></span><br><span class="line">  $(<span class="string">'aaron1'</span>).html(data.a)</span><br><span class="line">  $(<span class="string">'aaron2'</span>).html(data.b)</span><br><span class="line">  $(<span class="string">'aaron3'</span>).html(data.c)</span><br><span class="line">  <span class="comment">//其余处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>咋一看好像都挺好，没什么问题，但是仔细观察我们会发现所有的逻辑是不是都写在done方法里面，这样确实是无可厚非的，但是问题就是逻辑太复杂了。Done里面有数据处理、html渲染、还可能有其它不同场景的业务逻辑。这样如果是换做不同的人去维护代码，增加功能就会显得很混乱而且没有扩展性。那么观察者模式能很好的解决了这个的问题。</p>
<p>我们优化下代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">    pocessData()</span><br><span class="line">    pocessHtml()</span><br><span class="line">    pocessOther()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessData() &#123;</span><br><span class="line">    //处理数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessHtml() &#123;</span><br><span class="line">    $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">    $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">    $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessOther() &#123;</span><br><span class="line">    //处理其他逻辑</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>这种方式的好处是，分离出各种的业务函数，从而降低了代码之间的耦合度，但是这样代码写法几乎就是“就事论事”的处理，达不到<strong>抽象复用</strong>。</p>
<p>那么我们用之前的观察者模式加工一下上面的代码：（这只是伪代码，用于理解）</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessData</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">  $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">  $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessOther</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">  Observable.fire(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>设计该模式背后的主要动力是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称为观察者，而被观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者并且可能经常以事件对象的形式传递消息。</p>
<p>总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;fn(data);&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    arg.successful(arg.data+ <span class="string">',返回获取到后台的数据'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用add开始订阅：</span></span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_one: '</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_two: '</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一段ajax请求，成功后处理</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  data:<span class="string">'Hello'</span>,</span><br><span class="line">  successful:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    Observable.fire(data); <span class="comment">//触发动作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h2>jQuery回调对象</h2>
<p>jQuery.Callbacks一般开发者接触的很少，虽然jQuery向开发者提供了外部接口调用，但是$.Callbacks()模块的开发目的是为了给内部$.ajax() 和 $.Deferred()模块提供统一的基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p>
<p>jQuery.Callbacks是jquery在1.7版本之后加入的，是从1.6版中的_Deferred对象中抽离的，主要用来进行函数队列的add、remove、fire、lock等操作，并提供once、memory、unique、stopOnFalse四个option进行一些特殊的控制。</p>
<p>这个函数常见的应用场景是事件触发机制，也就是设计模式中的观察者模式的发布、订阅机制，目前Callbacks对象用于queue、ajax、Deferred对象中，本小节主要是一些简单的例子去理解的使用。</p>
<p>我们看官网提供的demo：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以将上述两个方法作为回调函数，并添加到 $.Callbacks 列表中，并按下面的顺序调用它们:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line"><span class="comment">// outputs: foo!</span></span><br><span class="line">callbacks.fire(<span class="string">"foo!"</span>);</span><br><span class="line">callbacks.add(fn2);</span><br><span class="line"><span class="comment">// outputs: bar!, fn2 says: bar!</span></span><br><span class="line">callbacks.fire(<span class="string">"bar!"</span>)</span><br></pre></td></tr></table></figure>
<p>这样做的结果是，当构造复杂的回调函数列表时，将会变更很简单。可以根据需要，很方面的就可以向这些回调函数中传入所需的参数。</p>
<p>上面的例子中，我们使用了 $.Callbacks() 的两个方法: .add() 和 .fire()。 .add() 和 .fire() .add() 支持添加新的回调列表, 而.fire() 提供了一种用于处理在同一列表中的回调方法的途径。</p>
<p>另一种方法是$.Callbacks 的.remove()方法，用于从回调列表中删除一个特定的回调。下面是.remove()使用的一个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">// outputs: foo!</span><br><span class="line">callbacks.fire( &quot;foo!&quot; );</span><br><span class="line">callbacks.add( fn2 );</span><br><span class="line">// outputs: bar!, fn2 says: bar!</span><br><span class="line">callbacks.fire( &quot;bar!&quot; );</span><br><span class="line">callbacks.remove( fn2 );</span><br><span class="line">// only outputs foobar, as fn2 has been removed.</span><br><span class="line">callbacks.fire( &quot;foobar&quot; );</span><br></pre></td></tr></table></figure>
<p>这个运用内部就是观察者模式的一种设计实现，只是相对比较复杂。我们看看jQuery的回调函数到底为哪些模块服务？</p>
<p>异步队列模块：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deferred: function(func) &#123;</span><br><span class="line">  var tuples = [</span><br><span class="line">    // action, add listener, listener list, final state</span><br><span class="line">    [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">    [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">    [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">  ]，………….</span><br></pre></td></tr></table></figure>
<p>队列模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_queueHooks: function(elem, type) &#123;</span><br><span class="line">  var key = type + &quot;queueHooks&quot;;</span><br><span class="line">  return data_priv.get(elem, key) || data_priv.access(elem, key, &#123;</span><br><span class="line">    empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() &#123;</span><br><span class="line">      data_priv.remove(elem, [type + &quot;queue&quot;, key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Ajax模块</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax: function(url, options) &#123;</span><br><span class="line">  //省略代码</span><br><span class="line">  deferred = jQuery.Deferred(),</span><br><span class="line">  completeDeferred = jQuery.Callbacks(&quot;once memory&quot;)</span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不难发现jQuery.Callbacks还提供“once memory”等参数用来处理：</p>
<p>☑  once: 确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)。</p>
<p>☑  memory: 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p>
<p>☑  unique: 确保一次只能添加一个回调(所以在列表中没有重复的回调)。</p>
<p>☑  stopOnFalse: 当一个回调返回false 时中断调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks(<span class="string">'once'</span>);</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'a'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'b'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.fire(); <span class="comment">//输出结果: 'a' 'b'</span></span><br><span class="line">callbacks.fire(); <span class="comment">//未执行</span></span><br></pre></td></tr></table></figure>
<p>once的作用是使callback队列只执行一次。</p>
<p>最后，我们大概知道这个是干嘛用的了，可以开始上正菜了。</p>
<h2>jQuery回调模块结构</h2>
<p>整个$.Callbacks的源码很少，它是一个工厂函数，使用函数调用（非new，它不是一个类）创建对象，它有一个可选参数flags用来设置回调函数的行为，对外的接口也就是self的返回。</p>
<p>jQuery.Callbacks()的API列表如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callbacks.add()        ：回调列表中添加一个回调或回调的集合。</span><br><span class="line">callbacks.disable()    ：禁用回调列表中的回调。</span><br><span class="line">callbacks.disabled()   ：确定回调列表是否已被禁用。 </span><br><span class="line">callbacks.empty()      ：从列表中删除所有的回调。</span><br><span class="line">callbacks.fire()       ：用给定的参数调用所有的回调。</span><br><span class="line">callbacks.fired()      ：访问给定的上下文和参数列表中的所有回调。 </span><br><span class="line">callbacks.fireWith()   ：访问给定的上下文和参数列表中的所有回调。</span><br><span class="line">callbacks.has()        ：确定列表中是否提供一个回调。</span><br><span class="line">callbacks.lock()       ：锁定当前状态的回调列表。</span><br><span class="line">callbacks.locked()     ：确定回调列表是否已被锁定。</span><br><span class="line">callbacks.remove()     ：从回调列表中的删除一个回调或回调集合。</span><br></pre></td></tr></table></figure>
<p>源码结构：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.Callbacks = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?</span><br><span class="line">        (optionsCache[options] || createOptions(options)) :</span><br><span class="line">        jQuery.extend(&#123;&#125;, options);</span><br><span class="line">    <span class="comment">//实现代码</span></span><br><span class="line">    fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    self = &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        has: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;&#125;,</span><br><span class="line">        empty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disable: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disabled: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        lock: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        locked: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fireWith: <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;&#125;,</span><br><span class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fired: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>整个结构要分三部分：</p>
<p>☑   Options参数缓存</p>
<p>☑   内部fire触发器的设计</p>
<p>☑   外部</p>
<p><strong>参数的缓存设计</strong></p>
<p>Callbacks是可以是接受的字符串的组合传参数，可以使用空格分割，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var opts = &apos;unique memory&apos;;</span><br><span class="line">var object = &#123;&#125;</span><br><span class="line">jQuery.each(opts.match(/\S+/g) || [], function(_, flag) &#123;</span><br><span class="line">  object[flag] = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这样的操作其实是不需要重复的，所以我们可以设计一个缓存池，用来储存重复的操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var optionsCache = &#123;&#125;;</span><br><span class="line">function createOptions(options) &#123;</span><br><span class="line">  var object = optionsCache[options] = &#123;&#125;;</span><br><span class="line">  jQuery.each(options.match(rnotwhite) || [], function(_, flag) &#123;</span><br><span class="line">    object[flag] = true;</span><br><span class="line">  &#125;);</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们传递参数的时候，如果参数是字符串，我们可以直接从optionsCache缓存中去查找：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = typeof options === &quot;string&quot; ?</span><br><span class="line">        ( optionsCache[ options ] || createOptions( options ) ) :</span><br><span class="line">        jQuery.extend( &#123;&#125;, options );</span><br></pre></td></tr></table></figure>
<p><strong>接口的设计：</strong></p>
<p>通过学习了观察者模式的思路，我们知道callback需要在内部维护着一个list的队列数组，用于保存订阅的对象数据。同时也需要提供了add、remove、fire等订阅、发布、删除类似的接口。</p>
<p>那么我们代码是不是很简单是就是把订阅对象给push给内部list列表？</p>
<p>实现思路就是: 构建一个存放回调的数组，如<code>var list = []</code>，通过闭包使这条回调数组保持存在。添加回调时，将回调push进list，执行则遍历list执行回调。</p>
<p>后面几节我们会通过简单的模拟实现去剖析设计的思路。</p>
<h2>默认回调对象设计</h2>
<p>不传入任何参数，调用add的时候将函数add到内部的list中，调用fire的时候顺序触发list中的回调函数：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says:&apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks();</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">console.log(&apos;........&apos;)</span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;)</span><br></pre></td></tr></table></figure>
<p>结果就是按照顺序叠加触发，如下列表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn1 says:foo </span><br><span class="line">………………………</span><br><span class="line">fn1 says:bar </span><br><span class="line">fn2 says bar</span><br></pre></td></tr></table></figure>
<p>这种就是最简单的处理了，可以直接模拟，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks() &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      list.forEach(function(fn) &#123;</span><br><span class="line">        fn(args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>once的设计</h2>
<p>这一小节我们来讲一下once。</p>
<p>once的作用确保回调列表只执行（.fire()）一次(像一个递延 Deferred)，如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val)&#123;</span><br><span class="line">    console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br></pre></td></tr></table></figure>
<p>结果你会发现cbs.fire(‘foo’)只执行了一次。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo  //只显示一次</span><br></pre></td></tr></table></figure>
<p>once定义是很明确的，确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)，所以针对这种once的处理可以有多种不同的途径实现。</p>
<p>1、add的时候抛弃</p>
<p>2、在fire的时候抛弃多个。</p>
<p>但是jQuery是在执行第一个fire的时候直接给清空list列表了，然后在add的地方给判断下list是否存在，从而达到这样的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        list.forEach(function(fn) &#123;</span><br><span class="line">          fn(args);</span><br><span class="line">        &#125;)</span><br><span class="line">        if (options === &apos;once&apos;) &#123;</span><br><span class="line">          list = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在fire之后，判断参数是否为once，直接把list给清理掉，所以之后的所有fire都被抛弃掉了，而从达到了once的效果。</p>
<p><strong>jQuery.Callbacks的处理</strong></p>
<p>在fire中调用了 self.disable(); 方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 禁用回调列表中的回调。</span><br><span class="line">disable: function() &#123;</span><br><span class="line">    list = stack = memory = undefined;</span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>
<h2>memory的设计</h2>
<p>memory：保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p>
<p>回调函数是从异步队列Deferred分离出来的，所以很多的接口设计都是为了契合Deferred接口，memory用的很多，这个缓存的设计这里提及一下</p>
<p>主要是用来实现deferred的异步收集与pipe管道风格的数据传递的，具体在Deferred有详解，这里大概了解下作用范围。</p>
<p>memory这个有点不好理解，我们还是通过列子说明下，看下面的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var cbs = Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn3(val) &#123;</span><br><span class="line">  console.log(&apos;fn3 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cbs = $.Callbacks(&apos;memory&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line"></span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line">cbs.add(fn3);</span><br><span class="line">cbs.fire(&apos;aaron&apos;);</span><br></pre></td></tr></table></figure>
<p>结果可以看出，我们在执行cbs.add(fn2);的时候，此时除了把fn2添加到了回调队列之外而且还立刻执行了这个方法，唯一的区别就是，参数是用的之前的。所以解释就叫“<strong>保持以前的值</strong>”。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo </span><br><span class="line">.......... </span><br><span class="line">fn2 says foo </span><br><span class="line">fn1 says bar </span><br><span class="line">fn2 says bar </span><br><span class="line">.......... </span><br><span class="line">fn3 says bar </span><br><span class="line">fn1 says aaron </span><br><span class="line">fn2 says aaron </span><br><span class="line">fn3 says aaron</span><br></pre></td></tr></table></figure>
<p>所以这个<code>memory</code>设计需要解决的问题就是：</p>
<p>1：如何取到上一个参数</p>
<p>2：add后如何执行</p>
<p>看看我们实现的代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callbacks</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = [];</span><br><span class="line">  <span class="keyword">var</span> self;</span><br><span class="line">  <span class="keyword">var</span> firingStart;</span><br><span class="line">  <span class="keyword">var</span> memory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fire</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    memory = options === <span class="string">'memory'</span> &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || <span class="number">0</span>;</span><br><span class="line">    firingStart = <span class="number">0</span>;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    <span class="keyword">for</span> (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> start = list.length;</span><br><span class="line">      list.push(fn)</span><br><span class="line">      <span class="keyword">if</span> (memory) &#123;</span><br><span class="line">        firingStart = start; <span class="comment">//获取最后一值</span></span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   	fire: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先add之后要能触发fire的动作，所以我们把fire作为内部的一个私有方法实现_fire，比较合逻辑，这样外部的fire只是一个门面方法的调用。</p>
<p>私有变量memory缓存这上一个参数的属性，我们靠firingStart用来定位最后通过add增加的回调数据的索引。在遍历的时候直接通过firingStart的起始索引定位，然后传递memory的参数，而且实现这种“保持以前的值”的设计。</p>
<h2>unique的设计</h2>
<p>Unique：确保一次只能添加一个回调(所以在列表中没有重复的回调)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var callbacks = $.Callbacks( &quot;unique&quot; );</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.add( fn1 ); // repeat addition</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.fire( &quot;foo&quot; );</span><br></pre></td></tr></table></figure>
<p>结果：过滤了相同的add操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo</span><br></pre></td></tr></table></figure>
<p>过滤重复的比较简单，因为是数组的保存方式，我们可以在入口处通过indexOf判断即可</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2>stopOnFalse</h2>
<p>stopOnFalse: 当一个回调返回false 时中断调用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var callbacks = $.Callbacks(&quot;stopOnFalse&quot;);</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line">callbacks.fire(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">callbacks.add(fn2);</span><br><span class="line">callbacks.fire(&quot;bar&quot;);</span><br></pre></td></tr></table></figure>
<p>结果虽然fn1被添加到了回调列表，但是因为fn1返回了false，那么意思之后的回调都不会被调用了。如果还有fn3，在f2上返回false，fn3也将不会被调用。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure>
<p></p>
<p>这个设计我们只要控制好函数返回的处理的布尔值，通过这个值用来判断是否需要下一个遍历</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码可以如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex =</span><br><span class="line">      firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上是几种单独的处理情况的用法，我们可以看到jQuery都是组合使用的，最常见的就是</p>
<p>jQuery.Callbacks(“once memory”)的组合了，其实以上的思路都讲解过了，无非就是组合起来的时候要考虑一些判断了。</p>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/wechatpay.jpg" alt="ulson 微信支付"/>
        <p>微信支付</p>
      </div>
    

    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/前端/" rel="tag"># 前端</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2016/10/28/JQuery源码解读 02-对象构建/" rel="next" title="JQuery源码解读 02-对象构建">
                <i class="fa fa-chevron-left"></i> JQuery源码解读 02-对象构建
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2016/12/20/理解异步/" rel="prev" title="理解异步">
                理解异步 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar.jpg"
                alt="ulson" />
            
              <p class="site-author-name" itemprop="name">ulson</p>
              <p class="site-description motion-element" itemprop="description">Lying in the gutter, but looking at the stars.</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">13</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="ulsonhu@gmail.com" target="_blank" title="Gmail">
                      
                        <i class="fa fa-fw fa-envelope"></i>Gmail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.instagram.com/ulson_hu/" target="_blank" title="Instagram">
                      
                        <i class="fa fa-fw fa-instagram"></i>Instagram</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/tour_hyc/activities" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/ulsonhu" target="_blank" title="微博">
                      
                        <i class="fa fa-fw fa-weibo"></i>微博</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">1.</span> <span class="nav-text">回调的灵活运用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">2.</span> <span class="nav-text">理解观察者模式</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">3.</span> <span class="nav-text">模式的实际运用</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">4.</span> <span class="nav-text">jQuery回调对象</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">5.</span> <span class="nav-text">jQuery回调模块结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">6.</span> <span class="nav-text">默认回调对象设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">7.</span> <span class="nav-text">once的设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">8.</span> <span class="nav-text">memory的设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">9.</span> <span class="nav-text">unique的设计</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#undefined"><span class="nav-number">10.</span> <span class="nav-text">stopOnFalse</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">ulson</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        
<div class="busuanzi-count">
  <script async src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      <i class="fa fa-user"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      
    </span>
  

  
    <span class="site-pv">
      <i class="fa fa-eye"></i>
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      
    </span>
  
</div>








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  

</body>
</html>
