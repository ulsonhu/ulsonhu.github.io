<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sonnet&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ulsonhu.cn/"/>
  <updated>2018-07-26T15:30:38.502Z</updated>
  <id>http://ulsonhu.cn/</id>
  
  <author>
    <name>Pic by John Lennon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>红楼梦-骚客词集</title>
    <link href="http://ulsonhu.cn/%E7%BA%A2%E6%A5%BC%E6%A2%A6-%E9%AA%9A%E5%AE%A2%E8%AF%8D%E9%9B%86.html"/>
    <id>http://ulsonhu.cn/红楼梦-骚客词集.html</id>
    <published>2018-06-23T16:00:00.000Z</published>
    <updated>2018-07-26T15:30:38.502Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>《好了歌》世人都晓神仙好，惟有功名忘不了！古今将相在何方？荒冢一堆草没了。世人都晓神仙好，只有金银忘不了！终朝只恨聚无多，及到多时眼闭了。世人都晓神仙好，只有姣妻忘不了！君生日日说恩情，君死又随人去了。世人都晓神仙好，只有儿孙忘不了！痴心父母古来多，孝顺儿孙谁见了？甄士隐说：“你唱什么？我只听见‘好’‘了’、‘好’‘了’两个字。道人说：好便是了，了便是好。若不了，便不好；若要好，须是了。</p></blockquote><blockquote></blockquote><p>陋室空堂，当年笏满床；衰草枯杨，曾为歌舞场。蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。说什么脂正浓、粉正香，如何两鬓又成霜？昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。金满箱，银满箱，展眼乞丐人皆谤。正叹他人命不长，那知自己归来丧！训有方，保不定日后作强梁。择膏粱，谁承望流落在烟花巷！因嫌纱帽小，致使锁枷扛；昨怜破袄寒，今嫌紫蟒长：乱烘烘你方唱罢我登场，反认他乡是故乡。甚荒唐，到头来都是为他人作嫁衣裳！</p><blockquote><p>“女儿是水作的骨肉，男人是泥作的骨肉。”</p></blockquote><blockquote></blockquote><p>“天地生人，除大仁大恶两种，馀者皆无大异。若大仁者，则应运而生，大恶者，则应劫而生。运生世治，劫生世危。尧、舜、禹、汤、文、武、周、召、孔、孟、董、韩、周、程、张、朱，皆应运而生者。蚩尤、共工、桀、纣、始皇、王莽、曹操、桓温、安禄山、秦桧等，皆应劫而生者。大仁者，修治天下；大恶者，挠乱天下。清明灵秀，天地之正气，仁者之所秉也；残忍乖僻，天地之邪气，恶者之所秉也。今当运隆祚永之朝，太平无为之世，清明灵秀之气所秉者，上至朝廷，下及草野，比比皆是。所馀之秀气，漫无所归，遂为甘露、为和风，洽然溉及四海。彼残忍乖僻之邪气，不能荡溢于光天化日之中，遂凝结充塞于深沟大壑之内，偶因风荡，或被云摧，略有摇动感发之意，一丝半缕误而泄出者，偶值灵秀之气适过，正不容邪，邪复妒正，两不相下，亦如风水雷电，地中既遇，既不能消，又不能让，必至搏击掀发后始尽。故其气亦必赋人，发泄一尽始散。使男女偶秉此气而生者，在上则不能成仁人君子，下亦不能为大凶大恶。置之于万万人中，其聪俊灵秀之气，则在万万人之上；其乖僻邪谬不近人情之态，又在万万人之下。若生于公侯富贵之家，则为情痴情种；若生于诗书清贫之族，则为逸士高人；纵再偶生于薄祚寒门，断不能为走卒健仆，甘遭庸人驱制驾驭，必为奇优名娼。如前代之许由、陶潜、阮籍、嵇康、刘伶、王谢二族、顾虎头、陈后主、唐明皇、宋徽宗、刘庭芝、温飞卿、米南宫、石曼卿、柳耆卿、秦少游，近日之倪云林、唐伯虎、祝枝山，再如李龟年、黄幡绰、敬新磨、卓文君、红拂、薛涛、崔莺、朝云之流，此皆易地则同之人也。”</p><blockquote></blockquote><p>不一时，只见三个奶嬷嬷并五六个丫鬟，簇拥着三个姐妹来了。第一个肌肤微丰，合中身材，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。第二个削肩细腰，长挑身材，鸭蛋脸面，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆饰。</p>]]></content>
    
    <summary type="html">
    
      摘自红楼梦中一些词句，不妄附庸风雅。
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="文字" scheme="http://ulsonhu.cn/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>概率论的两个问题-球盒模型、匹配问题</title>
    <link href="http://ulsonhu.cn/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98-%E7%90%83%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98.html"/>
    <id>http://ulsonhu.cn/概率论的两个问题-球盒模型、匹配问题.html</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2018-07-26T15:31:32.559Z</updated>
    
    <content type="html"><![CDATA[<p>怎样利用“数数”的基本公式，来正确（不漏、不重）数出具体问题的数，并不是件容易的事儿。</p><h2>基础概念</h2><h3>1. 可重复组合数</h3><p>从 $n$ 种不同的元素中取 $m$ 个元素（方法是从 $n$ 个元素中每次取出一个后，放回，再取另外一个，直到取出 $m$ 个元素）有 $C_{n+m-1}^m$ 个不同的结果。</p><blockquote><p>证明（顺便提到球盒模型用到的“隔板法”）：<br>首先明确，所谓有重复组合就是不考虑取出的元素的顺序，通俗来说，你第一次取出 $1$ 号元素第二次取出 $3$ 号元素和你第一次取出 $3$ 号元素第二次取出 $1$ 号元素是一样的情况。<br>可以把该过程看作是一个“放球模型”； $n$ 个不同的元素看作是 $n$ 个格子，去掉头尾之后中间一共有 $n-1$ 块相同的隔板；用 $m$ 个相同的小球代表取 $m$ 次；则原问题可以简化为将 $m$ 个不加区别的小球放进 $n$ 个格子里面，问有多少种放法；<br>注意到格子的头尾两块隔板无论什么情况下位置都是不变的，故去掉不用考虑；相当于 $m$ 个相同的小球和 $n-1$ 块相同的隔板先进行全排列：一共有 $(m+n-1)!$ 种排法，再由于m个小球和（n-1）块隔板是分别不加以区分的，所以除以重复的情况：$m!*(n-1)!$;<br>于是答案就是：$\frac{(m+n-1)!}{m!*(n-1)!}=C_{n+m-1}^{m}$。</p></blockquote><h3>2. 第二类Stiring数：</h3><p>$n$ 个人分成 $k$ 组的分组方案的数量。$$S(n,k) = \frac{1}{k!}\sum_{j=1}^{k}(-1)^{k-j}C_k^j j^n$$$S(n,n-1)=C_n^2=\frac{n(n-1)}{2}$</p><h3>3. Jordan公式：</h3><p>概率加法公式的推广$$P(\bigcup_{i=1}^{n}A_i) = S_1-S_2+S_3-\cdots+(-1)^{n-1}S_n \\S_k = \underset{1&lt; i_1 &lt; i_2 &lt; \cdots&lt; i_k &lt; n}{\sum}P(A_{i_1}A_{i_2}\cdots A_{i_k})$$</p><h2>球盒模型</h2><h3>简例 - 1</h3><p>先从简单的例子讲起，$m$ 个球随机放入 $n$ 个盒子中，$n$ 个盒子都有球的概率。其中，“随机”的含义，可分两种情况讨论：</p><h4>1）球可分辨</h4><p>记 $B=n\text{个盒子中至少一个为空}$,$A_i = $第 $i$ 个盒子为空于是$$B=\bigcup_{i=1}^{n}A_i$$因而$$P(B) = p(\bigcup_{i=1}^{n}A_i). \\ P(A_i)=\frac{(n-1)^m}{n^m}, P(A_1A_2)=\frac{(n-2)^m}{n^m},\cdots \\ P(A_1\cdots A_{n-1})=\frac{1}{n^m},P(A_1\cdots A_{n}) = 0.$$按 Jordan 公式$$P(B)=\sum_{i=1}^{n}(-1)^{i-1}C_n^i \frac{(n-i)^m}{n^m}$$所求事件概率为 $1-P(B)$</p><h4>2）球不可分辨</h4><p>记 $A=n\text{个盒子都有球}$,可根据上述可重复组合数公式得$P(A)=C_{n+m-1}^{m}$，即数出 $n$ 个盒子都有球的情况数。</p><h3>标准模型</h3><p>标准的球盒模型，分别讨论球是否有区别、盒子是否有标志以及是否存在空盒，共计 $2^3=8$ 种状态。</p><table><thead><tr><th>Seq</th><th>Ball</th><th>Box</th><th>Amt in Box</th></tr></thead><tbody><tr><td>1</td><td>Non-Diff</td><td>Mark</td><td>No-limit</td></tr><tr><td>2</td><td>Non-diff</td><td>Mark</td><td>No empty box</td></tr><tr><td>3</td><td>Non-diff</td><td>Unmark</td><td>No-limit</td></tr><tr><td>4</td><td>Non-diff</td><td>Unmark</td><td>No empty box</td></tr><tr><td>5</td><td>Diff</td><td>Mark</td><td>No-limit</td></tr><tr><td>6</td><td>Diff</td><td>Mark</td><td>No empty box</td></tr><tr><td>7</td><td>Diff</td><td>Unmark</td><td>No-limit</td></tr><tr><td>8</td><td>Diff</td><td>Unmark</td><td>No empty box</td></tr></tbody></table><h3>简例 - 2</h3><p>简化上述理论，从8个排列组合问题来体会。</p><ol><li>8个相同的球放进3个相同的盒子里，每盒至少一个，有几种方法</li></ol><p>取球最少的盒子取1，取球第二少的盒子可以取[1,3]   3种取球最少的盒子取2，取球第二少的盒子可以取[2,3]   2种取球最少的盒子取3，此情况不存在，一共5种按取球多寡来分类讨论可以做到不遗漏，不重复</p><ol start="2"><li>8个相同的球放进3个不同的盒子里，每盒至少一个，有几种方法</li></ol><p>插板法，$C_7^2=21$</p><ol start="4"><li>8个不同的球放进3个相同的盒子里，每盒至少一个，有几种方法</li></ol><p>取球最少盒子取 1 时，有116, 125, 134三种情况，分别有$C_8^6=28,C_8^1*C_7^2=168, C_8^1*C_7^3=280$.取球最少盒子取 2 时，有224，233二种情况，分别有$\frac{C_8^2*C_6^2}{2}=210,\frac{C_8^3*C_5^3}{2}=280$.一共 $28+168+280+210+280=966.$</p><ol start="3"><li>8个不同的球放进3个不同的盒子里，每盒至少一个，有几种方法</li></ol><p>4问中的966种情况，每种情况的三个元素都是互异的，比如 116（因为球是不同的），这三个元素进行全排列$P_3^3=6$, 乘以 966=5796 即为所求</p><ol start="5"><li>8个相同的球放进3个相同的盒子里，有几种方法</li></ol><blockquote><p>最少盒子取0，次盒子取[0,4]<br>最少盒子取1，次盒子取[1,3]<br>最少盒子取2，次盒子取[2,3]<br>一共 5+3+2=10 种</p></blockquote><ol start="6"><li><p>8个相同的球放进3个不同的盒子里，有几种方法<br>预先在三个盒子种各放入一小球，则问题转化为11同球放3不同盒子，每盒至少1个，几种方法？ 用插板法，$C_10^2=45$</p></li><li><p>8个不同的球放进3个不同的盒子里，有几种方法</p></li></ol><p>每个球都有3种选择，8个球就有$3^8=6561$.</p><ol start="8"><li>8个不同的球放进3个相同的盒子里，有几种方法</li></ol><p>(7问) 中的一般情况(3个元素都相异)，比如116，一共有6种排列(球是不同的)，此问中，盒子是相同的，因此这6种排列都只算一种情况。 但如果2个元素相同的时候，有且只有008，只有3种排列，我们多添加3种进去，令其也重复6次，则6561+3就是 所有的情况都重复了6次，$\frac{6561+3}{6}=1094$ 即为所求。</p><h2>匹配问题</h2><p>问题：两套各标上号码 $1$ 至 $n$ 的卡片被随机地匹配，1）问至少有一对匹配成功的概率为多少？2）问至少有$k(k\leq n)$ 对匹配成功的概率为多少?</p><p>记$B=\text{至少有一对匹配成功}$，$A_i=\text{第i对卡片匹配成功},i=1,2,\cdots ,n$</p><p>事件 $B$ 跟较简单的事件$A_1,A_2,\cdots ,A_n$间有如下关系，$$B=\bigcup_{i=1}^{n}A_i$$</p><p>按Jordan公式，为求 $P(B)$ ，需求 $S_1,S_2,\cdots ,S_n$。为此，先来求 $P(A_1)$</p><p>$$P(A_1)=\frac{(n-1)!}{n!} = \frac{1}{n}$$</p><p>$P(A_2)=P(A_3)=\cdots =P(A_n)=P(A_1)$，所以 $S_1=n\cdot \frac{1}{n}=1$</p><p>至于 $S_1,S_2,\cdots ,S_n$类似求得$$P(A_1A_2)=\frac{(n-2)!}{n!}=\frac{1}{n(n-1)}, \quad S_2=C_n^2 \frac{1}{n(n-1)}=\frac{1}{2!} ;$$$$P(A_1A_2A_3)=\frac{1}{n(n-1)(n-2)}, \quad S_3=C_n^3 \frac{1}{n(n-1)(n-2)}=\frac{1}{3!} ;$$$$\cdots \cdots \cdots$$$$P(\bigcap_{i=1}^{n}A_i)=\frac{1}{n!}, \quad S_n = \frac{1}{n!} $$</p><p>$$P(B) = 1-\frac{1}{2!}+\frac{1}{3!}-\cdots +(-1)^{n-1}\frac{1}{n!}$$</p><p>其中，</p><p>$$1-e^{-1} = 1-\frac{1}{2!}+\frac{1}{3!}-\cdots +(-1)^{n-1}\frac{1}{n!}+\cdots = \sum_{n=1}^{\inf}\frac{(-1)^{n-1} }{n!}$$</p>]]></content>
    
    <summary type="html">
    
      学习概率论，首先要会“数数”，其中涉及到初步的组合数学知识，概率论中两个经典问题--球盒模型、匹配问题。
    
    </summary>
    
      <category term="概率论" scheme="http://ulsonhu.cn/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
      <category term="Mathematic" scheme="http://ulsonhu.cn/tags/Mathematic/"/>
    
      <category term="概率论" scheme="http://ulsonhu.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>Schwarz不等式知识归纳</title>
    <link href="http://ulsonhu.cn/Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3.html"/>
    <id>http://ulsonhu.cn/Schwarz不等式知识归纳.html</id>
    <published>2018-06-09T16:00:00.000Z</published>
    <updated>2018-07-04T14:30:15.741Z</updated>
    
    <content type="html"><![CDATA[<p>Schwarz 不等式是个应用广泛的不等式，常见于线性代数的内积空间，数学分析的无穷级数，连续函数的积分以及概率论中的方差、协方差。</p><p>一般表述为</p><p>$\vert \langle x,y\rangle \vert ^2 \leq \langle x,x\rangle \dot \langle y,y \rangle$</p><p>在欧几里得空间$\mathcal{R^n}$中，$$(\sum_{i=1}^{n}x_i y_i)^2 \leq (\sum_{i=1}^{n}x_i^2)(\sum_{i=1}^{n}y_i^2)$$</p><p>$$\vert \int f^*(x)g(x)dx \vert ^2 \leq \int \vert f(x) \vert ^2dx \dot \int \vert g(x) \vert ^2dx$$</p><p>复向量空间 $\mathbb{C}^n$ 中，考虑两个向量 $x=(x_1,\ldots,x_n),y=(y_1,\ldots,y_n)$将 Schwarz 不等式两边平方并使用标准向量内积，可得$$\vert \sum_{i=1}^{n}\overline{x_i}{y_i}\vert ^2\leq \sum_{i=1}^{n}\vert x_i\vert ^2\cdot\sum_{j=1}^n\vert y_i\vert^2$$上面的式子描述了数列乘积之和与数列平方和乘积的 Cauchy 不等式。由于上式与 Schwarz 不等式本质上相同，故我们经常将上式称作 <strong>Cauchy-Schwarz</strong> 不等式。现在考虑我们熟悉的区间 $[0,1]$上的连续函数空间，Schwarz 不等式形式可以表达成,</p><p>$$\vert \int_0^1 \bar{f(t)}g(t) dt \vert^2 \leq \int_0^1 \vert f(t) \vert ^2dt \dot \int_0^1 g(t) \vert ^2dt$$</p><p>在一般的广义向量空间，我们定义二向量 $x$ 和 $y$ 的距离为</p><p>$$d(\mathbf{x},\mathbf{y})=\vert \mathbf{x}-\mathbf{y} \Vert = \sqrt{\langle\mathbf{x}-\mathbf{y},\mathbf{x}-\mathbf{y} \rangle}$$</p><p>注意，$d$ 称作向量范数，需要满足以下三个性质：</p><ol><li>$d(\mathbf{x},\mathbf{y})=d(\mathbf{y},\mathbf{x})$</li><li>$d(\mathbf{x},\mathbf{y})\geq 0$ ，当且仅当 $\mathbf{x}=\mathbf{y} $时，$d(\mathbf{x},\mathbf{y})=0$。</li><li>$d(\mathbf{x},\mathbf{y})\leq d(\mathbf{x},\mathbf{z})+d(\mathbf{z},\mathbf{y})$</li></ol><p>显然，向量范数 满足(1) 和 (2)，性质 (3) 即为三角不等式，此式可由 Schwarz 不等式导出，如下：</p><h3>关于证明</h3><p>可参考：<a href="https://ccjou.wordpress.com/2010/03/10/schwarz-%E4%B8%8D%E7%AD%89%E5%BC%8F/" target="_blank" rel="noopener">以 Bessel 不等式证明 Schwarz 不等式</a></p><h3>延伸点</h3><p>从数学分析到泛函分析里最重要的一些不等式:</p><ul><li>Schwarz不等式</li><li>Jesen不等式（凸分析与随机数学中出现得比较多）</li><li>赫尔德（Holder）不等式</li><li>闵可夫斯基（Minkowski）不等式</li><li>Hilbert空间的贝塞尔不等式</li><li>Poincare不等式（变分学中非常重要的不等式）</li><li>Soblev空间嵌入定理（在变分学和偏微分方程中非常重要的不等式）</li></ul><p>以上这些不等式，是必须记住、经常用到（不仅仅在数学自身学科中用到）的最基本的不等式。</p><p>结合运筹学与控制论方向，顺便说一说必须牢牢记住的、最常用的<strong>分析学</strong>定理:</p><ul><li>Banach不动点定理</li><li>Hilbert空间的投影定理</li><li>Hahn-Banach定理（核心中的核心）与分离超平面定理</li><li>反函数定理和隐函数定理（赋范线性空间的微分学）</li><li>阿尔采拉-阿斯科利定理</li><li>Sobolev嵌入定理</li><li>Rellich Kontracheev紧嵌入定理</li><li>Eblerlin Schulyman定理</li><li>Lagrange乘子定理</li><li>Kuhn-Tucker定理（无限维空间的版本，基于Hahn-Banach定理）</li><li>Pontryagin最大值原理（利用Frechet微分理论和前面的乘子定理去理解即可）</li><li>Brouwer（布劳威尔）不动点定理</li><li>Schaulder（绍德）不动点定理</li></ul><h3>复变函数中的柯西不等式</h3><p>设 $ f(z)$ 在区域 $D$ 及其边界上解析，$a$ 为 $D$ 内一点，以 $a$ 为圆心做圆周 $C_R: |z-a|=R$，只 $C_R$ 及其内部 $G$ 均被 $D$ 包含，则有：</p><p>$$\vert f^{(n)}(z_0) \vert \leq \frac{n!M}{R^n}$$</p><p>其中，$M$ 是 $\vert f(z) \vert$ 的最大值，$M= \max \vert f(x) \vert$</p><h3>其它推广</h3><p>$$\sqrt {\sum _{i=1}^{n} (\sum _{j=1}^{m} a_{ij})^2} \leq \sum _{j=1}^{m} \sqrt {\sum _{i=1}^{n}a_{ij}^2} \\ m \req \alpha &gt; 0,(\sum _{i=1}^{n} \prod _{j=1}^{m} a_{ij})^{\alpha }\leq \prod _{j=1}^{m}\sum _{i=1}^{n} a_{ij}^\alpha$$</p>]]></content>
    
    <summary type="html">
    
      Schwarz 不等式是个应用广泛的不等式，常见于线性代数的内积空间，数学分析的无穷级数，连续函数的积分以及概率论中的方差、协方差。
    
    </summary>
    
      <category term="数学" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Mathematic" scheme="http://ulsonhu.cn/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>理解拓扑空间的紧性</title>
    <link href="http://ulsonhu.cn/%E7%90%86%E8%A7%A3%E6%8B%93%E6%89%91%E7%A9%BA%E9%97%B4%E7%9A%84%E7%B4%A7%E6%80%A7.html"/>
    <id>http://ulsonhu.cn/理解拓扑空间的紧性.html</id>
    <published>2018-04-27T16:00:00.000Z</published>
    <updated>2018-05-04T14:54:39.593Z</updated>
    
    <content type="html"><![CDATA[<p>文章转载自<a href="http://blog.pluskid.org/?p=785" target="_blank" rel="noopener">链接</a></p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1525365294/2018_05_03-00.png" width="80%" height="80%"><p>关于空间的紧性，我们在之前的分析中已经见过了：例如在实数轴上的有界闭区间就是典型的紧集，紧集具有很多优良的性质，比如我们知道在有界闭区间上的连续函数一定是一致连续的，并且能取到最大值和最小值。所以，在将空间的概念推广到一般的拓扑空间之后，我们也希望将紧性这一优良性质也带到拓扑空间中来。为此，我们需要找到什么是紧集最本质的东西。在实数轴上的紧集 $K$，有如下的一些等价刻画：</p><ul><li>$K$ 是有界闭集</li><li>$K$ 的任意无限子集必存在极限点</li><li>$K$ 中的任意序列必有收敛子列</li><li>$K$ 的任意开覆盖必有有限子覆盖</li></ul><p>其中第一条无法在拓扑空间中使用，因为“有界”的概念无法定义。第二或者第三条曾经被认为是实质性的，但是后来由于 $\text{Tychonoff}$ 定理，人们发现最后一条才是真正好的定义，因此将其作为拓扑空间紧性的定义，而第二条和第三条分别被叫做“极限点紧(<a href="http://en.wikipedia.org/wiki/Limit_point_compact" target="_blank" rel="noopener">Limit point compact</a>）”和“序列紧（<a href="http://en.wikipedia.org/wiki/Sequentially_compact_space" target="_blank" rel="noopener">Sequencially compact</a>）”。下面是正式内容，在给出定义之前，我先给出一个提纲：</p><ul><li>首先当然是要给出拓扑空间紧性的定义。</li><li>接下来当然是会举一些例子，一方面是把枯燥的定义从抽象中拉回来，另一方面也是非常重要的是给出紧空间的存在性的证据，因为定义总是可以随便给的，这样子我可以给出具有任意优良性质的定义来，然而所定义的东西如果是不存在的话，相关的一切性质其实都是空谈。</li><li>然后我们将介绍从已有的紧空间构造新的紧空间的方法：<font color="blue">包括集合的交、并、补，以及子空间、商空间和积空间——这一系列都是标准套路。</font>在这里将会出现一个大定理，就是刚才提到的 $\text{Tychonoff}$  定理。</li><li>接下来将暂时中断一下，讨论一下稍微具体一点的度量空间(Metric Space)中的紧性。因为度量空间更加具体一些，所以能得到的性质也更丰富一些。</li><li>最后我们将简要介绍一些将非紧空间（non-compact space）转化为紧空间（compactification，紧化）的初步知识。</li></ul><p>但从度量空间的紧性开始那部分内容并不在这里论述。</p><blockquote><p><strong>定义 1</strong>：设 $X$ 是一个集合，它的一族子集 $\mathcal{A}=\{A_\lambda | \lambda\in\Lambda\}$ 如果满足$$\bigcup_{\lambda\in\Lambda}A_\lambda = X$$则称为 $\mathcal{A}$ 为 $X$ 的一个覆盖，或 $\mathcal{A}$ 覆盖 $X$ 。特别地，如果 $X$ 是一个拓扑空间，而且每个 $A_\lambda$，$\lambda\in\Lambda$ 都是 $X$ 中的开集，则称 $\mathcal{A}$ 为 $X$ 的一个开覆盖。</p></blockquote><blockquote><p><strong>定义 2</strong>：拓扑空间 $X$ 称为紧的，如果它的任意开覆盖有有限子覆盖。</p></blockquote><p>其实根据这个定义里的描述，也可以看出紧性之所以好的一些端倪了，<font color="blue">不精确地说，利用紧性我们可以把无限的东西转化为有限的情况来处理。</font></p><p>我们最熟悉的紧空间的例子应该就是 $\mathbb{R}$ 中的闭区间了，在数学分析中已经证明过它是紧的。其他我们还可以举一些简单的例子，比如：</p><ul><li>任意由有限点集所构成的拓扑空间是紧的。因为无论在它上面给怎么样的拓扑，它所有的开集的个数总是有限的，所以任意开覆盖本身就是有限覆盖了。</li><li>具有余有限拓扑（cofinite topology ）的空间是紧的。因为假设 $\mathcal{A}$ 是具有 cofinite topology 的空间 $X$ 的一个开覆盖，从 $\mathcal{A}$ 中任选一个非空的元素 $A_0$，由 cofinite topology 的定义，知道 $X-A_0$ 只有有限个元素 $x_1,\ldots,x_n$ ，对于每一个 $x_i$，$i=1,\ldots,n$ 可以找到一个 $A_i\in\mathcal{A}$ 使得 $x_i\in A_i$ ，这样，${A_0,A_1,\ldots,A_n}$ 就是 $X$ 的开覆盖 $\mathcal{A}$ 的一个有限子覆盖。</li></ul><p>非紧空间的例子也很好举，例如 $\mathcal{R}$ 上的区间 $(0,1]$ 就不是紧的，因为我们可以构造一个开覆盖 $\{(1/n,1] \}_{n=1}^\infty$ ，它的任意一个有限子集族总是无法覆盖 $(0,1]$ 。</p><p>有了基本的例子之后，下面我们来讨论如何从已有的紧空间构造新的紧空间。从集合的角度来看，构造新的集合常用的操作有 $\cap$、$\cup$ ，从空间的角度来看则有子空间（$\iota$）、商空间（$\pi$）、积空间（$\Pi$），下面我们就依次讨论在这些操作下紧性是否能得到保持。</p><p><strong>首先是紧空间的交集</strong>，因为任意拓扑空间的交集上，最自然的拓扑就是这一系列包含映射所诱导的始端拓扑（<a href="http://en.wikipedia.org/wiki/Initial_topology" target="_blank" rel="noopener">Initial Topology</a>），如果这些拓扑空间互相之间没有什么关系的话，讨论起来就比较复杂了，通常我们会讨论所有要取交的拓扑空间是一个大的拓扑空间的子空间的情况，这个时候它们的交集实际上就是子空间的一种特殊情况，所以我们放到讨论子空间的紧性的时候再讨论。</p><p><strong>其次是并集</strong>。任意多个并的情况显然是不对的，例如 $\mathbb{R}$ 上可数个紧集 $[n,n+1]$，$n\in\mathbb{Z}$ 的并集是 $\mathbb{R}$ 本身，并不是紧的。不过有限个的情况表现还是良好的。</p><blockquote><p><strong>命题 1</strong>：若 $X_1,\ldots,X_n$ 是空间 $X$ 的有限个紧子集，则它们的并也是紧的。</p></blockquote><p>证明：记 $Y=\cup_{i=1}^n X_i$ 。设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $Y$ 的任一开覆盖，则显然它也是每一个 $X_i$，$i=1,\ldots,n$ 的开覆盖，因此对于每个 $X_i$ ，存在 $\mathcal{A}$ 的一个有限子集族 $\mathcal{A}_i$ 仍然覆盖 $X_i$ 。令$$ \mathcal{A}’=\bigcup_{i=1}^n \mathcal{A}_i $$</p><p>则显然 $\mathcal{A}’$ 是 $\mathcal{A}$ 的一个有限子集族，并且它仍然覆盖 $Y$ 。</p><p><strong>接下来我们讨论拓扑子空间的紧性</strong>。一个紧空间的子空间是否一定是紧的呢？显然不一定，明显的反例是紧空间 $[0,1]$ 的子空间 $(0,1]$ ，但是如果限制到闭子集的话，就可以做到了：</p><blockquote><p><strong>定理 1</strong>：紧空间的闭子集是紧的。</p></blockquote><p>注意这里我们称一个空间的子集是紧的，实际上是在说这个子集配上子空间拓扑之后是一个紧空间。在证明这个定理之前，我们先给一个方便的验证子空间紧性的判定定理：</p><blockquote><p><strong>定理 2</strong>：设 $Y$ 是 $X$ 的子空间，$Y$ 是紧的，当且仅当任意一族覆盖 $Y$ 的 $X$ 中的开集包含一个覆盖 $Y$ 的有限子族。</p></blockquote><p>这里的意思是说，如果 $Y$ 是 $X$ 的子空间，判断 $Y$ 的紧性的时候，用 $X$ 中的开集来覆盖还是用 $Y$ 中的开集来覆盖都是一样的。这个定理可以省去我们在验证的时候的一些麻烦。</p><p><font color="blue">证明：</font>首先证正向：设 $Y$ 是紧的，$\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是一族覆盖 $Y$ 的 $X$ 中的开集，则 $\mathcal{A}’={A_\lambda\cap Y|\lambda\in\Lambda}$ 是 $Y$ 的一个开覆盖，根据紧性，存在有限子覆盖$$\{A_{\lambda_1}\cap Y,\ldots,A_{\lambda_n}\cap Y\}$$显然对应的 $\mathcal{A}$ 的子族$$\{A_{\lambda_1},\ldots,A_{\lambda_n}\}$$仍然覆盖 $Y$ 。</p><p>再证反过来，设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $Y$ 的一族开集，它覆盖了 $Y$ ，则根据子空间拓扑的定义，对于每个 $A_\lambda$，$\lambda\in\Lambda$ ，存在 $X$ 中的开集 $U_\lambda$ 使得 $A_\lambda=U_\lambda\cap Y$ ，因此 ${U_\lambda|\lambda\in\Lambda}$ 是一族覆盖 $Y$ 的 $X$ 中的开集，由定理假设，它包含一个有限子族$$\{U_{\lambda_1},\ldots,U_{\lambda_n}\}$$仍然覆盖 $Y$ ，则对应的$$\{U_{\lambda_1}\cap Y=A_{\lambda_1},\ldots,U_{\lambda_n}\cap Y=U_{\lambda_n}\}$$是 $\mathcal{A}$ 的一个有限子族，并且仍然覆盖 $Y$ ，由此得 $Y$ 是紧的，即证。</p><p><font color="blue">定理 1 的证明</font>：设 $X$ 是紧空间，$K$ 是 $X$ 的闭子集，$\mathcal{A}$ 是 $K$ 的任一开覆盖，则$$\mathcal{B}=\mathcal{A}\cup\{X-K\}$$是 $X$ 的一个开覆盖，由 $X$ 的紧性，存在 $\mathcal{B}$ 的一个有限子族 $\mathcal{B}’;$ 仍然覆盖 $X$ 。如果 $X-K\in\mathcal{B}’$ 则将它从中去掉，否则不做任何操作，得到$$\mathcal{A}’=\mathcal{B}’-\{X-K\}$$是 $\mathcal{A}$ 的一个有限子族，并且它是覆盖 $K$ 的。证完。</p><p>借助子空间紧性的结论，对于刚才提到的紧集的交的紧性，我们可以有这样一个推论：</p><blockquote><p><strong>推论 1</strong>：设 $X$ 是一个拓扑空间，$\{K_\lambda|\lambda\in\Lambda\}$ 是 $X$ 的一族紧且闭的子集。那么它们的交 $\cap_\lambda K_\lambda$ 也是紧的。由任意闭集的交集是闭集，并且这个交集是其中某一个（任意一个）紧集 $K_\lambda$ 的子集，根据定理 1 立即得到。接下来我们讨论紧空间的商空间，紧性在这里的表现是很好的，但是我们并不直接给出商空间的紧性，而是叙述一个更一般的结论：</p></blockquote><blockquote><p><strong>定理 3</strong>：设 $f:X\rightarrow Y$ 是连续映射，$X$ 是紧空间，那么 $f(X)$ 也是紧的。由商映射的连续性以及到上性（满射），根据这个定理立即可以得到任意紧空间的商空间仍然是紧的。</p></blockquote><p><font color="blue">证明：</font>设 $\mathcal{A}=\{A_\lambda|\lambda\in\Lambda\}$ 是 $F(X)$ 的一个开覆盖，则由 $f$ 的连续性知$$\mathcal{B}=\{f^{-1}(A_\lambda)|\lambda\in\Lambda\}$$是 $X$ 的一个开覆盖。由 $X$ 的紧性，存在 $\mathcal{B}$ 的一个有限子集族$$\mathcal{B}’=\{f^{-1}(A_{\lambda_1}),\ldots,f^{-1}(A_{\lambda_n})\}$$仍然覆盖 $X$ 。则对应的集族$$\mathcal{A}’=\{A_{\lambda_1},\ldots,A_{\lambda_n}\}$$是 $\mathcal{A}$ 的一个有限子集族并且仍然覆盖 $f(X)$ 。证完。</p><p>由这个定理可以立即得到，<font color="blue">如果两个拓扑空间 $X$ 和 $Y$ 是同胚的，其中一个紧那么另一个必定也是紧的。</font>换句话说，紧性是一个拓扑性质。这样的性质通常可以用来方便地区分两个（在同胚意义下）不同的拓扑空间，因为要证明两个空间同胚，只要找出一个同胚映射就可以了，但是要证明两个空间不同胚，则是要证明不可能有同胚存在，通常是一个更加困难的问题，比较好解决的情况通常都用反证法来做了，就是假设同胚，但是又发现两个空间的某个拓扑性质是不一样，就导出矛盾。</p><p>例如，用紧性可以证明球面 $S^2$ 和平面 $\mathbb{R}^2$ 是不同胚的。类似地可以证明 $[0,1]$ 和 $(0,1)$ 是不同胚的。</p><p>不过，这里既然提到了同胚和连续映射，就正好也说一下<strong>紧空间的好处</strong>吧（因为我实在不知道这一小部分内容放在哪里讲比较好了）。我们知道从 $\mathbb{R}$ 上的紧集打出去的连续函数一定是一致连续的，一致连续是比连续要强得多的条件，不过在一般的拓扑空间中并不能方便地定义“一致连续”的概念，不过从紧空间打出去的连续映射仍然具有一些良好的性质：</p><blockquote><p><strong>定理 4</strong>：设 $f:X\rightarrow Y$ 是连续映射，如果 $X$ 是紧空间，$Y$ 是 <a href="http://en.wikipedia.org/wiki/Hausdorff_space" target="_blank" rel="noopener">Hausdorff</a> 空间，则 $f$ 是闭映射。闭映射是一个很好的东西，例如我们有一个非常直接的推论：</p></blockquote><blockquote><p><strong>推论 2</strong>：设 $f:X\rightarrow Y$ 是连续的双射，若 $X$ 是紧空间，$Y$ 是 Hausdorff 空间，则 $f$ 是同胚映射。为了证明定理 4 ，我们再引入另外两个结论，当然它们本身也是相当重要的，因此也是作为定理出现。首先我们要注意到，在一般的拓扑空间中，紧集不一定是闭的（类比 $\mathbb{R}$ 中：有界闭集等价于紧集）。例如最开始我们举的余有限拓扑空间中，任意集合都是紧的，然而只有有限集才是闭的。不过，如果加上了 Hausdorff 条件的话，这一点就可以得到保证了：</p></blockquote><blockquote><p><strong>定理 5</strong>：Hausdorff 空间中的紧子集是闭集。</p></blockquote><p>这个定理的证明过程本身是比较有用的，因此被抽取出来也作为一个定理：</p><blockquote><p><strong>定理 6</strong>：设 $K$ 是 Hausdorff 空间 $X$ 中的紧子集，$p\in X-K$ ，则存在 $X$ 中互不相交的开集 $U$、$V$，使得 $K\subset U$ 和 $p\in V$ 。</p></blockquote><p><font color="blue">证明</font>：$\forall x\in K$ ，由 $X$ 的 Hausdorff 性，存在互不相交的开集 $U_x$ 和 $V_x$ ，使得 $x\in U_x$、 $p\in V_x$ 。当 $x$ 取遍 $K$ 时，我们得到$$\mathcal{U}={U_x|x\in K}$$是 $K$ 的一个开覆盖，根据 $K$ 的紧性，存在 $\mathcal{U}$ 的一个有限子集族$${U_{x_1},\ldots,U_{x_n}}$$仍然覆盖 $K$ 。下面令$$U = \bigcup_{i=1}^n U_{x_i},\quad V=\bigcap_{i=1}^n V_{x_i}$$则 $U$ 和 $V$ 为互不相交的开集，且 $K\subset U$ 、$p\in V$ 。证完。</p><p><font color="blue">定理 5 的证明</font>：设 $K$ 是 Hausdorff 空间 $X$ 中的紧子集，我们现在证明 $X-K$ 是开集。对任意的 $x\in X-k$ ，根据定理 6 ，存在 $X$ 中互不相交的开集 $U$、$V$ 使得 $K\subset U$ 、 $p\in V$，因此 $p\in V\subset X-K$ ，即证。</p><p><font color="blue">定理 4 的证明</font>：任取 $X$ 中的闭集 $C$ ，由 $X$ 的紧性和定理 1 知 $C$ 是紧集，由 $f$ 的连续性和定理 3 知 $f© $ 是紧的，再由定理 $Y$ 的 Hausdorff 性和定理 5 知 $f© $ 是闭的。即证。</p><p>下面我们再回到主线：接下来只剩下积空间的紧性的讨论了。紧性在这里的表现也是优良的，Tychonoff 定理保证了任意一族紧空间的积空间也是紧的。这是一个很要紧的地方，因为我们在最开始列了 4 条 $\mathbb{R}$ 中紧性的刻画，其中末尾 3 条在度量空间中是等价的，然而在一般的拓扑空间中则不行了，那究竟选哪一条作为紧性的定义呢？正是 Tychonoff 定理一锤定音——选择当前的这个定义，可以得到 Tychonoff 定理的结论，而其他的定义则无法做到。</p><p>不过，在讲 Tychonoff 定理之前，我们先来看一下有限个紧空间的积空间的紧性。虽然有限个的情况证明方法和 Tychonoff 中任意积的证明完全不一样，但是有限的情况会引出一个本身也很有用的 <a href="http://en.wikipedia.org/wiki/Tube_lemma" target="_blank" rel="noopener">Tube Lemma</a> ，所以是不容错过的。由于有限积可以由两两积归纳得到，并且我们之后会有更加一般的情况，这里只给出两个紧空间的积空间的描述：</p><blockquote><p><strong>定理 7</strong>：若 $X$ 和 $Y$ 是紧空间，则 $X\times Y$ 也是紧的。</p></blockquote><p>证明这个定理需要用到下面的 <strong>Tube Lemma</strong> ：</p><blockquote><p><strong>定理 8 (Tube Lemma)</strong>：设 $X$ 和 $Y$ 是拓扑空间，其中 $Y$ 是紧的，若 $X\times Y$ 中的任一开集 $N$ 包含了“切片” $x_0\times Y$ ，则存在 $X$ 中 $x_0$ 的开领域 $W$ 使得 $W\times Y$ 也包含在 $N$ 中。证明过程可以参考下图，图取自 Munkres 的《Topology》</p></blockquote><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1525365294/2018_05_03-01.png" width="95%" height="95%"><p><font color="blue">证明</font>：首先，由于 $N$ 是开集，对于每一点 $(x_0,y)\in N$ ，存在其开领域 $N_y\subset N$ ，特别地，我们可以取积拓扑中的基开邻域 $N_y=U_y\times V_y$。令 $y$ 取遍 $Y$ 得到 $x_0\times Y$ 的一个开覆盖。</p><p>由于 $x_0\times Y$ 同胚于 $Y$ ，因此是紧的，故存在有限子覆盖。亦即存在有限个点 $y_1,\ldots,y_n\in Y$ ，使得$$\mathcal{N}={N_{y_1},\ldots,N_{y_n}}$$覆盖 $x_0\times Y$ ，令$$W=\bigcap_{i=1}^n U_{y_i}$$则 $W\times Y$ 为 $X\times Y$ 中的开集，且 $x_0\times Y\subset W\times Y$ ，下面只需要证明 $W\times Y\subset N$ 即可。任取 $(x,y)\in W\times Y$ ，对应点 $(x_0,y)\in x_0\times Y$ 必定被包含于 $\mathcal{N}$ 中的某一个元素里（有多个的时候任取一个即可），记为 $N_0=U_0\times V_0$ ，则我们有 $y\in V_0$ ，又由于 $x\in W\subset U_0$ ，因此得 $(x,y)\in U_0\times V_0$ ，再由于我们之前取的所有基开邻域 $N_{y}$ 都是包含于 $N$ 中的，因此 $(x,y)\in N$ ，即证。</p><p><font color="blue">定理 7 的证明</font>：设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X\times Y$ 的任一开覆盖。对任意的 $x_0\in X$ ，$x_0\times Y$ 是紧的，因此可以被有限个元素 ${A_{\lambda_1},\ldots,A_{\lambda_n}}$ 覆盖，记$$N=\bigcup_{i=1}^n A_{\lambda_i}$$则由 Tube Lemma ，存在 $x_0$ 的开领域 $W$ 使得 $W\times Y\subset N$ ，此时 $W\times Y$ 也被 $A_{\lambda_1}$ 到 $A_{\lambda_n}$ 这有限个 $\mathcal{A}$ 的元素所覆盖。</p><p>下面对于每个 $x\in X$ ，可以得到对应的 $W_x$ ，这构成 $X$ 的一个开覆盖$$\mathcal{W}={W_x|x\in X}$$再由 $X$ 的紧性知道，开覆盖 $\mathcal{W}$ 存在有限子覆盖，亦即存在有限个点 $x_1,\ldots,x_m$ ，使得 ${W_{x_1},\ldots,W_{x_m}}$ 仍然覆盖 $X$ 。因此所有的 tube 构成整个空间：$$X\times Y = \bigcup_{i=1}^m W_{x_i}\times Y$$又由于每个 tube 都可以被有限个 $\mathcal{A}$ 中的元素覆盖，因此整个空间（有限个 tube 的并）可以被有限个 $\mathcal{A}$ 中的元素覆盖。证完。</p><p>不过，以上的证明方法只适用于有限积的情况，如果是任意个空间的积空间的话，就没法做了，当然，结论还是成立的：</p><blockquote><p><strong>定理 9 (Tychonoff Theorem)</strong>：设 ${X_\lambda|\lambda\in\Lambda}$ 是任意一族紧空间，则 $\prod_\lambda X_\lambda$ 是紧的。</p></blockquote><p>要证明这个定理需要做许多准备工作。首先我们将暂时抛开开集，而用闭集来刻画空间的紧性。</p><blockquote><p><strong>定义 3</strong>：设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X$ 的一族子集，称 $\mathcal{A}$ 满足有限交条件，如果任意有限个 $\mathcal{A}$ 中的元素的交集是非空的。</p></blockquote><blockquote><p><strong>定理 10</strong>：拓扑空间 $X$ 是紧的，当且仅当 $X$ 的任一满足有限交条件的闭集族的交非空。</p></blockquote><p><font color="blue">证明</font>：$X$ 的紧性的定义等价于：对于 $X$ 中的一族开集 $\mathcal{A}$ ，如果 $\mathcal{A}$ 的任意有限子集族都不能覆盖 $X$ ，则 $\mathcal{A}$ 不能覆盖 $X$ 。</p><p>将开集族中的每个元素取补集可以得到一族对应的闭子集，因此上面的条件又等价于：对于任意一族闭子集 $\mathcal{A}’$ ，如果 $\mathcal{A}’$ 的任意有限子集族的交非空（满足有限交条件），则 $\mathcal{A}’$ 的交非空。即证。</p><blockquote><p><strong>定义 4</strong>：设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X$ 的一个开覆盖，称 $\mathcal{A}$ 为 $X$ 的</p></blockquote><ul><li>基开覆盖，如果每个 $A_\lambda\in\mathcal{A}$ 属于 $X$ 的某个给定的拓扑基；</li><li>子基开覆盖，如果每个 $A_\lambda\in\mathcal{A}$ 属于 $X$ 的某个给定的子基拓扑。</li></ul><p>为了接下来的叙述方便，下面再定义几个在其他地方不太常用的概念</p><blockquote><p>定义 5：我们称 $X$ 的一族闭子集 $\mathcal{B}$ 为</p></blockquote><ul><li>闭基，如果 ${X-B|B\in\mathcal{B}}$ 是 $X$ 的一个基；</li><li>闭子基，如果 ${X-B|B\in\mathcal{B}}$ 是 $X$ 的一个子基。</li></ul><blockquote><p><strong>定理 11</strong>：设 $X$ 是拓扑空间，如下命题等价：</p></blockquote><ul><li>(1)$X$ 是紧的；</li><li>(2)$X$ 的任一基开覆盖有有限子覆盖；</li><li>(3)$X$ 的任意一族满足有限交性质的闭基集合的交非空。</li></ul><p><font color="blue">证明</font>：(1) $\Rightarrow$ (2) 显然。(2) $\Leftrightarrow$ (3) 证明过程和定理 10 的证明完全类似。(2) $\Rightarrow$ (1) 设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X$ 的任一开覆盖，任一 $A_\lambda\in\mathcal{A}$ 都是 $X$ 的一些基开集的并，因此$$\mathcal{B}=\{B|B\text{ is base set}, B\subset A_\lambda\text{ for some } A_\lambda\in\mathcal{A}\}$$是 $X$ 的一个基开覆盖，由条件，有有限多个 $B_{\lambda_1},\ldots,B_{\lambda_n}\in \mathcal{B}$ 覆盖 $X$ ，在 $\mathcal{A}$ 中取 $A_{\lambda_1},\ldots,A_{\lambda_n}$ 使得 $B_{\lambda_i}\subset A_{\lambda_i}$， $i=1,\ldots,n$ ，则 $\{A_{\lambda_1},\ldots,A_{\lambda_n}\}$ 是 $\mathcal{A}$ 的有限子覆盖。</p><blockquote><p><strong>定理 12 (Alexander Theorem, 1939)</strong>：设 $X$ 是拓扑空间，如下命题等价：</p></blockquote><ul><li>(1)$X$ 是紧的；</li><li>(2)$X$ 的任意子基开覆盖有有限子覆盖；</li><li>(3)$X$ 的任意一族满足有限交性质的闭子基集合有非空的交。</li></ul><p><font color="blue">证明：</font></p><ul><li>(1) $\Rightarrow$ (2) 显然。</li><li>(2) $\Leftrightarrow$ (3) 证明和定理 10 的证明完全类似。</li><li>接下来我们不直接证明 (3) $\Rightarrow$ (1) ，而是证明由本定理的 (3) 可以得到定理 11 的 (3) 。设 $\mathcal{B}={B_\lambda|\lambda\in\Lambda}$ 是 $X$ 中任意一族满足有限交性质的闭基集合，我们要证明它们的交非空。</li></ul><p>首先我们来构造一个“极大的”包含了 $\mathcal{B}$ 的具有有限交性质的闭基集族 $\mathcal{C}$。“极大”就是说没有比它更大了，稍后会精确定义，这里的想法是，如果我们能证明这个 $\mathcal{C}$ 的交是非空的，那么自然 $\mathcal{B}$ 的交也是非空的。这看上去好像把问题变难了，因为直观上来讲集族变大之后它们的交集就变小了，所以要保证交集非空就更加困难了。不过，这里的思想大致是将集族扩大到“合适”的程度，使得我们在寻找非空的那个交集的时候没有 $\mathcal{B}$ 那么多的自由度，关键就在于“极大性”上，让我们在构造的时候能做到“恰到好处”。</p><p>下面我们用 <a href="http://en.wikipedia.org/wiki/Zorn%27s_lemma" target="_blank" rel="noopener">Zorn’s Lemma</a> 来构造这个 $\mathcal{C}$ ，先令 $\mathbb{B} = \{\mathcal{D}|D$ 是满足有限交条件的闭基集族, $\mathcal{B}\subset\mathcal{D}\}$ 。首先 $\mathbb{B}\neq\emptyset$ ，因为 $\mathcal{B}\in\mathbb{B}$ 。我们以包含关系作为 $\mathbb{B}$ 里的一个偏序，下面证明任意一条链（全序子集）都在 $\mathbb{B}$ 中有上界。</p><p>设 $\{\mathcal{D}_k|k\in K\}\subset \mathbb{B}$ 是任意一个全序子集，令 $\mathcal{E}=\cup_k \mathcal{D}_k$ ，则对任意的 $k\in K$ ，$\mathcal{D}_k\subset \mathcal{E}$ 。如果我们证明 $\mathcal{E}$ 满足有限交条件，则 $\mathcal{E}\in\mathbb{B}$ ，显然，它是我们要找的上界。</p><p>任取有限个元素 $E_1,\ldots,E_m\in\mathcal{E}$ ，由链的有序性知，存在 $k_0\in K$ ，使得 $E_1,\ldots,E_m \in \mathcal{D}_{k_0}$ ，再由 $\mathcal{D}_{k_0}$ 满足有限交条件，知 $\cap_{i=1}^m E_i\neq\emptyset$ 。</p><p>以上我们证明了 Zorn’s Lemma 的条件是满足的，因此，$\mathbb{B}$ 存在最大元 $\mathcal{C}$ 。下面我们来证明集族 $\mathcal{C}$ 的交非空。</p><p>$\mathcal{C}$ 的每个元素是一个闭集集合，由于每个基集合都是有限个子基集合的交，我们有每个闭基集合都是有限个闭子基集合的并。即 $\forall C_\mu \in \mathcal{C}, \mu\in M$$$C_\mu = S_1\cap\cdots\cap S_n$$这里为了避免下标爆炸，只好乱用一下符号了。实际上对于每个不同的 $\mu$ ，$n$ 是不一样的，而且 $S_1$ 到 $S_n$ 也可能是不同的集合。接下来的下标也会有点乱……现在我们考虑某个特定的 $\mu$ ，如果我们能证明至少存在一个 $i$ 使得 $S_i\in\mathcal{C}$ ，那么对于每个闭基集合 $C_\mu, \mu\in M$ ，取对应的那个 $S_i$ 组成一个集族 ${S_\mu}\subset \mathcal{C}$ ，因此它满足有限交条件，由 (3) 的条件知（注意每个 $S_\mu$ 是闭子基集合），它们的交非空。由此可以立即得到：集族 $\mathcal{C}$ 的交也非空。</p><p>最后我们就来证明至少存在一个 $i$ 使得 $S_i\in\mathcal{C}$ ，这里终于要用到 $\mathcal{C}$ 的极大性了。用反证法，假设对任意的 $i=1,\ldots,n$ 都有 $S_i\not\in\mathcal{C}$ 。由于闭子基集合同时也是闭基集合，对于每一个 $i=1,\ldots,n$， 由 $\mathcal{C}$ 的极大性，知道$$\mathcal{C}\subsetneq\left(\mathcal{C}_i=\{S_i\}\cup \mathcal{C}\right)$$其中 $\mathcal{C}_i$ 必定不能满足有限交条件，亦即，存在 $\mathcal{C}_i$ 的有限子集族 $\mathcal{C}’_i$ （显然 $S_i$ 包含在其中），其交为空集。将所有这些（有限个） $S_i$ 并起来，我们得到 $C_\mu \in \mathcal{C}$ ，而将对应的 $\mathcal{C}’_i$ 交起来，我们得到一个 $\mathcal{C}$ 的子集族$$\mathcal{C}_f=\bigcap_{i=1}^n\mathcal{C}’_i$$由刚才的构造，知道$$C_\mu\cup\left(\bigcap_{C\in\mathcal{C}_f}C\right)=\emptyset$$</p><p>而 $\{C_\mu\}\cup \mathcal{C}_f$ 是 $\mathcal{C}$ 的一个有限子集族，这与 $\mathcal{C}$ 满足有限交条件相矛盾。证完。</p><p>有了这些准备工作之后，Tychonoff 的证明也就变得简单了：</p><p><font color="blue">定理 9 的证明</font>：空间 $\prod_{\lambda}X_\lambda$ 的一族子基是$$\{p^{-1}_\lambda(V_\lambda)|V_\lambda\subset X_\lambda, V_\lambda\text{open},\lambda\in \Lambda\}$$因此对应的闭子基的每个元素集合是形状如$$\prod_{\lambda\in\Lambda}C_\lambda$$的集合，其中 $C_\lambda$ 是 $X_\lambda$ 中的闭集（实际上除了最多一个之外，其他的全都是整个空间 $X_\lambda$ ）。对于任意一族如上形式的闭子基集族 $\mathcal{A}$ ，如果它们满足有限交性质，我们证明它们的交非空即可。根据上面的形式可以知道，将 $\mathcal{A}$ 以自然投影投影到任意的 $X_\lambda$ 中，仍然得到一族满足有限交性质的闭集，由 $X_\lambda$ 本身的紧性，知道它们的交非空，因此可以选择其中一点 $x_\lambda$ 。所有的这些点就构成了 $\prod_\lambda X_\lambda$ 中 $\bigcap_{A\in\mathcal{A}}A$ 里的一点 $(x_\lambda)_{\lambda\in\Lambda}$ ，即证。</p><p>最后，闲聊一下文章标题图片 Klein Bottle ，课堂上提到拓扑必然会举到的例子，什么橡皮泥啊、克莱因瓶之类的。默比乌斯带还是可以理解的，因为可以做出实物来，但是当时一直觉得克莱因瓶是不对的，所谓顺着瓶子的壁可以从里面爬到外面，我看这各种克莱因瓶的图，都觉得是不对的。到现在终于知道为什么了——确实是不对的，不过不是说 Klein Bottle 不存在，如果用 schematic representation 的话，还是比较可以接受的，只是关于 Klein Bottle 的 visualization ，却是有问题的，因为 Klein Bottle 不能嵌入到 $\mathbb{R}^3$ 中，直观地来说，我们无法在我们生活的三维世界里造出一个克莱因瓶来，如果强行把它放到 $\mathbb{R}^3$ 中，就会出现自相交了，也就是平时所看到的那些图里明显的不对劲的地方了。</p><p>不过我比较奇怪，其实用图片来做 visualization 的话，实际上是在 $\mathbb{R}^2$ 中了，结果最大的问题还是出在人类的想象力上吗？不过我觉得这里贴的这张图似乎有点意思了——因为看不太出那么明显的自交。</p>]]></content>
    
    <summary type="html">
    
      关于空间的紧性，我们在之前的分析中已经见过了：例如在实数轴上的有界闭区间就是典型的紧集，紧集具有很多优良的性质，比如我们知道在有界闭区间上的连续函数一定是一致连续的，并且能取到最大值和最小值。
    
    </summary>
    
      <category term="数学" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E5%AD%A6/"/>
    
    
      <category term="Mathematic" scheme="http://ulsonhu.cn/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>Note-关于事件的运算</title>
    <link href="http://ulsonhu.cn/Note-%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E7%AE%97.html"/>
    <id>http://ulsonhu.cn/Note-关于事件的运算.html</id>
    <published>2018-04-19T16:00:00.000Z</published>
    <updated>2018-05-04T14:59:25.393Z</updated>
    
    <content type="html"><![CDATA[<h2>关于事件的运算</h2><p>$$\underset{n \rightarrow \infty}{\overline{lim}} A_n= \bigcap _{k=1}^{\infty} \bigcup _{n=k}^{\infty} A_n$$</p><p>$$\underset{n \rightarrow \infty}{\underline{lim}} A_n= \bigcup _{k=1}^{\infty} \bigcap _{n=k}^{\infty} A_n$$</p><p>其中，$\underset{n \rightarrow \infty}{\overline{lim}} A_n​$ 为事件序列$\{A_n\}​$的上限事件，表示$A_n​$发生无穷多次。类似的，称 $\underset{n \rightarrow \infty}{\underline{lim}} A_n​$ 为事件序列的下限事件，表示$A_n​$之多只有有限个不发生。</p><p>显然，有$$\underset{n \rightarrow \infty}{\overline{lim}} A_n \supset \underset{n \rightarrow \infty}{\underline{lim}} A_n$$</p><p>特别的，当$\underset{n \rightarrow \infty}{\overline{lim}} A_n = \underset{n \rightarrow \infty}{\underline{lim}} A_n$ 时，记 $ \underset{n \rightarrow \infty}{lim} A_n \equiv \underset{n \rightarrow \infty}{\overline{lim}} A_n = \underset{n \rightarrow \infty}{\underline{lim}} A_n$，并称它为事件序列$\{A_n\}$的极限事件。</p><p>由德摩根定律，有</p><p>$$\overline{(\bigcap _{k=1}^{\infty} \bigcup _{n=k}^{\infty} A_n)}=\bigcup _{k=1}^{\infty} \bigcap _{n=k}^{\infty} \overline{A_n}$$</p><p>$$\overline{(\bigcup _{k=1}^{\infty} \bigcap _{n=k}^{\infty} A_n)}=\bigcap _{k=1}^{\infty} \bigcup _{n=k}^{\infty} \overline{A_n}$$</p><p>因此$$\underset{n \rightarrow \infty}{\underline{lim}} \overline{A_n} = \overline{(\underset{n \rightarrow \infty}{\overline{lim}} A_n)}$$$$\underset{n \rightarrow \infty}{\overline{lim}} \overline{A_n} = \overline{(\underset{n \rightarrow \infty}{\underline{lim}} A_n)}$$</p><p>由此引出的$\text{Borel-Cantelli}$引理，在概率论中有着众多应用。</p><p>$\text{Borel-Cantelli lemma}$:</p><ol><li><p>若随机事件序列$\{A_n\}$满足$$\sum_{n=1}^{\infty}P(A_n)&lt;\infty$$则$$P\{ \underset{n \rightarrow \infty}{\overline{lim}} A_n\}=0, P\{ \underset{n \rightarrow \infty}{\underline{lim}} \overline{A_n}\}=1$$</p></li><li><p>若$\{A_n\}$是相互独立的随机事件序列，则$$\sum_{n=1}^{\infty}P(A_n)=\infty$$的充要条件为</p><p>$$P(\underset{n \rightarrow \infty}{\overline{lim}} A_n)=1 \text{  or  } P(\underset{n \rightarrow \infty}{\underline{lim}} \overline{A_n})=0 ​$$</p></li></ol><p>由此，我们可以进一步讨论以概率1收敛.</p><p>$$\xi_n(\omega) \overset{a.s.}{\rightarrow} \xi (\omega)$$</p>]]></content>
    
    <summary type="html">
    
      Note系列为日常笔记。
    
    </summary>
    
      <category term="Note" scheme="http://ulsonhu.cn/categories/Note/"/>
    
    
      <category term="数理统计" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
      <category term="Mathematic" scheme="http://ulsonhu.cn/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>接触向量自回归模型</title>
    <link href="http://ulsonhu.cn/%E6%8E%A5%E8%A7%A6%E5%90%91%E9%87%8F%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://ulsonhu.cn/接触向量自回归模型.html</id>
    <published>2018-04-13T16:00:00.000Z</published>
    <updated>2018-05-04T14:58:37.115Z</updated>
    
    <content type="html"><![CDATA[<p>VAR方法通过把系统中每一个内生变量,作为系统中<strong>所有内生变量的滞后值的函数</strong>来构造模型，从而回避了结构化模型的要求。Engle, Granger（1987）指出两个或多个非平稳时间序列的线性组合可能是平稳的。假如这样一种平稳的或的线性组合存在，这些非平稳（有单位根）时间序列之间被认为是具有协整关系的。这种平稳的线性组合被称为协整方程且可被解释为变量之间的长期均衡关系。VAR模型对于相互联系的时间序列变量系统是有效的预测模型，同时，向量自回归模型也被频繁地用于分析不同类型的随机误差项对系统变量的动态影响。如果变量之间不仅存在滞后影响，而不存在同期影响关系，则适合建立VAR模型，因为VAR模型实际上是把当期关系隐含到了随机扰动项之中。</p><h2>目录</h2><ul><li>定义</li><li>概述</li><li>平稳性检验</li><li>向量自回归模型（VAR）</li><li>E-G检验与JJ检验</li><li>误差修正模型</li><li>脉冲响应函数</li><li>方差分解</li></ul><h2>定义</h2><p>向量自回归模型（英语：Vector Autoregression model，简称VAR模型）是一种常用的计量经济模型，由C.Sims提出。它扩充了只能使用一个变量的自回归模型(AR(1))，使容纳大于1个变量，因此经常用在多变量时间序列模型的分析上。</p><p>VAR模型描述在同一样本期间内的 $n$ 个变量（内生变量）可以作为它们过去值的线性函数。</p><p>一个 $VAR§$ 模型可以写成为：</p><p>$$y_{t}=c+A_{1}y_{t-1}+A_{2}y_{t-2}+\cdots +A_{p}y_{t-p}+e_{t},$$</p><p>其中：$c$ 是 $n* 1$ 常数向量，$A_i$ 是 $n*n$ 矩阵。$e_t$ 是 $n*1$ 误差向量，满足：</p><ol><li>$E(e_t)=0$ ,误差项的均值为 $0$</li><li>$E(e_{t}e_{t}’)=\Omega $, 误差项的协方差矩阵为 $\Omega$.（一个 $n*n$ 正定矩阵）</li><li>$E(e_{t}e_{t-k}’)=0$, （对于所有不为 $0$ 的 $k$ 都满足）,误差项不存在自相关</li></ol><h3>结构向量自回归</h3><p>一个结构向量自回归（Structural VAR）模型可以写成为：</p><p>$$ B_{0}y_{t}=c_{0}+B_{1}y_{t-1}+B_{2}y_{t-2}+\cdots +B_{p}y_{t-p}+\epsilon _{t},$$</p><p>其中：$c_0$ 是 $n*1$ 常数向量，$B_i$ 是 $n*n$ 矩阵，$\epsilon_t$ 是 $n*1$ 误差向量。</p><h2>概述</h2><p>简单说VAR模型建立</p><p>第一步：不问序列如何均可建立初步的VAR模型（建立过程中数据可能前平稳序列，也可能是部分平稳，还可能是没协整关系的同阶不平稳序列，也可能是不同阶的不平稳序列，滞后阶数任意指定。所有序列一般视为内生向量)，</p><p>第二步：在建立的初步VAR后进行</p><ol><li>滞后阶数检验，以确定最终模型的滞后阶数</li><li>在滞后阶数确定后进行因果关系检验，以确定哪些序列为外生变量</li></ol><p>至此重新构建VAR模型（此时滞后阶数已定，内外生变量已定），再进行AR根图表分析，</p><ul><li>如单位根均小于1，VAR构建完成可建立误差修正模型、脉冲响应函数及方差分解。</li><li>如单位根有大于1的，考虑对原始序进行降阶处理（一阶单整序列处理方法：差分或取对数，二阶单整序列：理论上可以差分与取对数同时进行，但由于序列失去了经济含义，应放弃此处理，可考虑序列的趋势分解，如分解后仍然不能满足要求，可以罢工，不建立任何模型，休息或是打砸了电脑），处理过后对新的序列（包括最初的哪些平稳序列）不断重复第一步与第二步，直至满足稳定性为止</li></ul><p>第三步，建立最终的VAR后，可考虑SVAR模型。如果变量不仅存在滞后影响，还存在同期影响关系，则建立VAR模型不太合适，这种情况下需要进行结构分析。</p><h2>平稳性检验</h2><p>平稳性检验有3个作用：</p><ol><li>检验平稳性，若平稳，做格兰杰检验，非平稳，作协整检验。</li><li>协整检验中要用到每个序列的单整阶数。</li><li>判断时间序列的数据生成过程。</li></ol><p>VAR建模时<code>lag intervals for endogenous</code>要填滞后期，但是此时你并不能判断哪个滞后时最优的，因此要多次尝试，选择不同的滞后期，至 $AIC$ 或 $SC$ 最小时，所对应着的滞后为最优滞后，此时做出来的VAR模型才较为可靠。</p><p>协整检验前需要提前估计VAR模型，原因在于，协整检验是对滞后期和检验形式非常敏感的检验，首先需要确定最优滞后。由于VAR是无约束的，而协整是有约束的，因此协整检验的最优滞后一般为VAR的最优滞后减去1，确定了最优滞后后，再去诊断检验形式，最终才能做协整。</p><h2>E-G检验与JJ检验</h2><p>当检验的数据是非平稳（即存在单位根），并且各个序列是同阶单整（协整检验的前提），想进一步确定变量之间是否存在协整关系，可以进行协整检验，协整检验主要有EG两步法和JJ检验</p><ul><li>EG两步法是基于回归残差的检验，可以通过建立OLS模型检验其残差平稳性</li><li>JJ检验是基于回归系数的检验，前提是建立VAR模型（即模型符合ADL模式），确定最优滞后阶数</li></ul><h3>Granger因果检验</h3><p>协整说的是变量之间存在长期的稳定关系，这只是从数量上得到的结论，但不能确定谁是因，谁是果。而因果关系检验就是为了解决这个问题。故，如果存在协整关系，如果存在协整可进一步检测格兰杰因果检验，看看某一个变量的先前的变化对另一个变量是否有影响。</p><h3>步骤</h3><p>变量 $X$ 是否为变量 $Y$ 的Granger原因，是可以检验的。 检验 $X$ 是否为引起 $Y$ 变化的Granger原因的过程如下：</p><p>第一步：检验原假设“$H_0$：X不是引起Y变化的Granger原因”。首先，估计下列两个回归模型：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1524449564/2018_04_14-01.png" width="95%"><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1524449564/2018_04_14-02.png" width="95%"><p>第二步：将 $Y$ 与 $X$ 的位置交换，按同样的方法检验原假设“$H_0$：Y不是引起X变化的Granger原因”。</p><p>第三步：要得到“ $X$ 是 $Y$ 的Granger原因”的结论，必须同时拒绝原假设“$H_0$：X不是引起Y变化的Granger原因”和接受原假设“$H_0$：Y不是引起X变化的Granger原因”。</p><blockquote><p>格兰杰检验<strong>只能用于平稳序列</strong> 这是格兰杰检验的前提，而其因果关系并非我们通常理解的因与果的关系，而是说 $X$ 的前期变化能有效地解释 $Y$ 的变化，所以称其为“格兰杰原因”。</p></blockquote><h2>误差修正模型（VEC）</h2><p>VEC是有协整约束（即有长期稳定关系）的VAR模型。当变量之间存在协整关系时，可以建立ECM进一步考察短期关系</p><h2>参考文献</h2><ul><li>《高级计量经济学与Stata应用》.陈强</li><li><a href="https://wenku.baidu.com/view/e56480cb9ec3d5bbfd0a746b.html" target="_blank" rel="noopener">向量自回归模型与向量误差修正模型的理论及EVIEWS操作</a></li><li>[应用VAR模型时的15个注意点]<a href="http://bbs.pinggu.org/forum.php?mod=viewthread&amp;tid=3219921&amp;ctid=2272" target="_blank" rel="noopener">http://bbs.pinggu.org/forum.php?mod=viewthread&amp;tid=3219921&amp;ctid=2272</a></li><li><a href="https://blog.csdn.net/oxuzhenyi/article/details/77850516" target="_blank" rel="noopener">R语言建立VAR模型分析联合内生变量的动态关系</a></li></ul>]]></content>
    
    <summary type="html">
    
      向量自回归（VAR,Vector Auto regression）常用于预测相互联系的时间序列系统以及分析随机扰动对变量系统的动态影响。
    
    </summary>
    
      <category term="经济学" scheme="http://ulsonhu.cn/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
      <category term="计量经济学" scheme="http://ulsonhu.cn/tags/%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>HMM-隐马尔可夫模型</title>
    <link href="http://ulsonhu.cn/HMM-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B.html"/>
    <id>http://ulsonhu.cn/HMM-隐马尔可夫模型.html</id>
    <published>2018-03-31T16:00:00.000Z</published>
    <updated>2018-04-13T08:55:24.280Z</updated>
    
    <content type="html"><![CDATA[<h2>马尔科夫链</h2><p>在介绍$\text{HMM}$之前，我们先要了解什么是马尔科夫链。马尔科夫链是一个随机过程，简单来说就是当前时刻的状态与前 $p$ 个时刻的状态有关，即</p><p>$$P(z(t) | z(t-1),z(t-2),\cdots,z(1),z(0)) = P(z(t)|z(t-1),z(t-2),\cdots,z(t-p))$$</p><p>这种被称作 $p$ 阶马尔科夫链；为了简化这个过程以方便应用到模型中，我们有两个假设：</p><ul><li>在序列中，当前时刻状态只依赖于前一时刻的状态，也就是$P(z(t)|z(t-1), z(t-2),\cdots, z(1), z(0)) = P(z(t)|z(t-1))$。</li><li>状态转移的分布不随时间的改变而改变，也就是说任意时刻下的状态产生与时间无关，仅仅与前一状态有关。</li></ul><p>但是实际生活中，这种状态本身是很难观测到的，我们只能根据其他的特征来观测这些状态，同时状态之间的 <strong>转移矩阵</strong>也是很难直接获得的，这就需要隐马尔科夫模型了.</p><h2>HMM 形象的例子描述</h2><p>在引入$\text{HMM}$的公式化描述之前，为了更好的理解 HMM 模型，我们先用一个掷骰子的例子来形象的描述 HMM模型.</p><p>模型描述假设我手里有三个不同的骰子。</p><ul><li><p>第一个骰子是我们平常见的骰子（称这个骰子为D6），6个面，每个面$（1，2，3，4，5，6）$出现的概率是1/6。</p></li><li><p>第二个骰子是个四面体（称这个骰子为D4），每个面$（1，2，3，4）$出现的概率是1/4。</p></li><li><p>第三个骰子有八个面（称这个骰子为D8），每个面$（1，2，3，4，5，6，7，8）$出现的概率是1/8。</p></li></ul><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523585401/2018_04_10-4.png" width="95%" height="95%"><p>假设我们开始掷骰子，我们先从三个骰子里挑一个，挑到每一个骰子的概率都是1/3。然后我们掷骰子，得到一个数字，$1，2，3，4，5，6，7，8$中的一个。不停的重复上述过程，我们会得到一串数字，每个数字都是$1，2，3，4，5，6，7，8$中的一个。例如我们可能得到这么一串数字（掷骰子10次）：$1 6 3 5 2 7 3 5 2 4$</p><p>这串数字叫做<strong>可见状态链</strong>。但是在隐马尔可夫模型中，我们不仅仅有这么一串可见状态链，还有一串<strong>隐含状态链</strong>。在这个例子里，这串隐含状态链就是你用的骰子的序列。比如，隐含状态链有可能是：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8</p><p>一般来说，$\text{HMM}$中说到的马尔可夫链其实是指隐含状态链，因为隐含状态（骰子）之间存在转换概率（transition probability）。<font color="blue">在我们这个例子里，D6的下一个状态是D4，D6，D8的概率都是1/3。</font>D4，D8的下一个状态是D4，D6，D8的转换概率也都一样是1/3。这样设定是为了最开始容易说清楚，但是我们其实是可以随意设定转换概率的。比如，我们可以这样定义，D6后面不能接D4，D6后面是D6的概率是0.9，是D8的概率是0.1。这样就是一个新的$\text{HMM}$。</p><p>同样的，尽管可见状态之间没有转换概率，但是隐含状态和可见状态之间有一个概率叫做<strong>输出概率</strong>（emission probability）。就我们的例子来说，六面骰（D6）产生1的输出概率是1/6。产生2，3，4，5，6的概率也都是1/6。我们同样可以对输出概率进行其他定义。比如，我有一个被赌场动过手脚的六面骰子，掷出来是1的概率更大，是1/2，掷出来是2，3，4，5，6的概率是1/10。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523584361/2018_04_10-1.png" width="95%" height="95%">隐马尔可夫示意图<p>其实对于 $\text{HMM}$ 来说，<font color="blue">如果</font>提前知道所有隐含状态之间的转换概率和所有隐含状态到所有可见状态之间的输出概率，做模拟是相当容易的。</p><p>但是应用$\text{HMM}$模型时候呢，往往是缺失了一部分信息的，有时候你知道骰子有几种，每种骰子是什么，但是不知道掷出来的骰子序列；有时候你只是看到了很多次掷骰子的结果，剩下的什么都不知道。如果应用算法去估计这些缺失的信息，就成了一个很重要的问题。</p><h2>HMM模型解决的三个问题</h2><p><font color="blue">1. 知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想知道每次掷出来的都是哪种骰子（隐含状态链）</font></p><blockquote><p>这个问题呢，在语音识别领域呢，叫做 <strong>解码问题</strong>。这个问题其实有两种解法，会给出两个不同的答案。每个答案都对，只不过这些答案的意义不一样。</p><ul><li>第一种解法求最大似然状态路径，说通俗点呢，就是我求一串骰子序列，这串骰子序列产生观测结果的概率最大。</li><li>第二种解法呢，就不是求一组骰子序列了，而是求每次掷出的骰子分别是某种骰子的概率。比如说我看到结果后，我可以求得第一次掷骰子是D4的概率是0.5，D6的概率是0.3，D8的概率是0.2</li></ul></blockquote><p><font color="blue">2. 还是知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想知道掷出这个结果的概率</font></p><p>看似这个问题意义不大，因为你掷出来的结果很多时候都对应了一个比较大的概率。问这个问题的目的呢，其实是检测观察到的结果和已知的模型是否吻合。如果很多次结果都对应了比较小的概率，那么就说明我们已知的模型很有可能是错的，有人偷偷把我们的骰子給换了</p><p><font color="blue">3. <strong>知道骰子有几种（隐含状态数量），不知道每种骰子是什么（转换概率），观测到很多次掷骰子的结果（可见状态链），我想反推出每种骰子是什么(转换概率)</strong></font></p><blockquote><p>这个问题很重要，因为这是最常见的情况。很多时候我们只有可见结果，不知道$\text{HMM}$模型里的参数，我们需要从可见结果估计出这些参数，这是建模的一个必要步骤</p></blockquote><p>在实际应用中，比如中文分词，我们更多的是利用<strong>第三个问题</strong>去建模( 当然，如果利用工具的话，你拿到手的时候这部分的参数都是已经训练好了的 )，然后用<strong>第一个问题</strong>的解码去求隐含状态序列（这也是我们的目标，比如分词、词性标注等）.</p><h3>破解骰子序列</h3><p>举例来说，我知道我有三个骰子，六面骰，四面骰，八面骰。我也知道我掷了十次的结果<code>1 6 3 5 2 7 3 5 2 4</code>，我不知道每次用了那种骰子，我想知道最有可能的骰子序列</p><p>其实最简单而暴力的方法就是穷举所有可能的骰子序列，然后依照第零个问题的解法把每个序列对应的概率算出来。然后我们从里面把对应最大概率的序列挑出来就行了。如果马尔可夫链不长，当然可行。如果长的话，穷举的数量太大，就很难完成了。</p><p>另外一种很有名的算法叫做 Viterbi algorithm.</p><h2>HMM 的几个要素</h2><p>经过上面形象化的例子描述，读者应该对隐马尔科夫模型有了大致的了解，下面通过引入数学化描述，来正式介绍 $\text{HMM}$.读者在阅读 $\text{HMM}$ 数学化描述时，可以对照前面掷骰子的问题来理解.</p><ul><li><font color="blue">StatusSet : </font>状态值集合，常用 $S=\{S_1,S_2,\cdots ,S_Q\}$ 来表示系统的隐状态集合，其中 $Q$ 为隐状态数。用 $q_t=S_i$ 表示系统在时刻 $t$ 处于隐状态 $S_i$，隐状态序列为$Q=\{q_1,q_2,\cdots ,q_t\}$</li></ul><p>例如上面的三个不同的骰子，这些状态之间满足马尔科夫性质，是马尔科夫模型中实际所隐含的状态，这些状态通常无法直接观察得到.</p><ul><li><font color="blue">ObservedSet :</font>观察值集合，观测序列记为 $O = (o_1,o_2,\cdots,o_T)$，其中 $T$ 为观测序列的长度； $O_t$为时刻$t$  的观测随机变量，可以是一个数值或向量.</li></ul><blockquote><p>例如上面的 $1,2,3,4,5,\cdots $ 等值，在模型中与隐含状态相关联，可通过直接观测得到.</p></blockquote><ul><li><font color="blue">TransProbMatrix :</font>转移概率矩阵，状态转移的概率分布可表示为 $A=\{a_{ij}\}$，其中 $a_{ij} = P(q_{t+1} = S_j | q_t = S_i), 1 \leq i,j \leq Q$，且满足$a_{ij} \geq 0,\sum_{j=1}^Q a_{ij} = 1$ ，表示时刻 $t$ 从状态 $a_i$ 状态转移到时刻 $t+1$ 状态 $a_j$ 的概率.</li></ul><blockquote><p>例如上面的取不同骰子的概率，描述了 $\text{HMM}$ 模型中各个状态之间的转移概率，</p></blockquote><ul><li><font color="blue">EmitProbMatrix :发射概率矩阵，假设观测变量的样本空间为$V$ ，在状态 $S_i$ 时输出观测变量的概率分布可表示为:$B = \{ b_i(v),1 \leq i \leq Q,v \in V \}$ ，其中$b_i(v) = f\{ O_t = v | q_t = S_i \}$ 。</font></li></ul><blockquote><p>例如上面的每个骰子取不同值的概率，令 $N$代表隐含状态数目， $M$代表可观测状态数目，则 $B_{ij} = P(O_i | S_j),1 \leq i \leq M,1 \leq j \leq N$ 表示在 $t$ 时刻、隐含状态是$S_j$  条件下，观察状态为$O_i$  的概率.</p></blockquote><ul><li><font color="blue">InitStatus :</font>初始状态分布，一般用 $\pi $ 来表示，即 $\pi = \{ \pi_i,1 \leq i \leq Q \}$，其中 $\pi_i = P\{ q_1 = S_i \}$例如上面我们假设投掷的是第一枚骰子，表示隐含状态在初始时刻 $t=1$ 的概率矩阵.</li></ul><p>从定义可知，隐马尔科夫模型作了<strong>两个基本假设:</strong></p><ul><li><p><strong>齐次马尔科夫假设</strong>即假设隐藏的马尔科夫链在任意时刻  的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻  无关.$$P(q_t | q_{t-1},o_{t-1},\cdots,q_1,o_1) = P(q_t | q_{t-1}),t = 1,2,\cdots,T$$</p></li><li><p><strong>观测独立性假设</strong>即假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测及状态无关.$$P(o_t | q_T,o_T,q_{T-1},o_{T-1},\cdots,q_{t+1},o_{t+1},q_t,q_{t-1},o_{t-1},\cdots,q_1,o_1) = P(o_t | q_t)$$</p></li></ul><h2>观测序列的生成过程</h2><p>上面的例子中我们也大致讲了序列如何生成的，这里我们用数学描述提炼一下：</p><p><strong>输入</strong>: 隐马尔科夫模型 $\lambda=\{A,B,\pi \}$，观测序列长度 $T$;</p><p><strong>输出</strong>: 观测序列 $O = (o_1,o_2,\cdots,o_T)$</p><ul><li>按照初始状态分布 $\pi$ 产生状态 $q_1$</li><li>令 $t=1$</li><li>按照状态 $q_t$ 的观察概率分布 $b_{q_t}(v)$ 生成 $o_t$</li><li>按照状态 $q_t$ 的状态转移概率分布 $\{q_{ij}\}$ 产生状态 $q_{t+1},q_{t+1} \in \{ S_1,S_2,\cdots,S_Q \}$</li><li>令 $t=t+1$ ；如果 $t&lt;T$，转步 3；否则，终止.</li></ul><h2>$\text{HMM}$ 的基本问题</h2><p>隐马尔科夫模型在实际中运用，必须解决下面三个基本问题 :</p><p>给定观察序列 $O = (o_1,o_2,\cdots,o_T)$ 和模型 $\lambda=\{A,B,\pi \}$，如何有效地计算观测值序列的输出概率?</p><p><font color="blue">给定观察值序列和输出该观察值序列的隐马尔科夫模型 ，如何有效确定与之对应的最佳状态序列?</font>即估计出模型产出观察值序列最有可能经过的路径.</p><p>对于初始模型和给定用于训练的观察值序列 $O = (o_1,o_2,\cdots,o_T)$，如何调整模型参数$\lambda=\{A,B,\pi \}$ ，使得输出概率最大 $P(O|\lambda)$ ？</p><p>Note:对应到上面掷骰子的例子中所说的三个问题</p><h2>基本算法</h2><h3>直接计算</h3><p>给定模型 $\lambda=\{A,B,\pi \}$ 和观测序列 $O = (o_1,o_2,\cdots,o_T)$,计算观测序列 $O$ 出现的概率 $P(O|\lambda)$ . 最直接的方法就是按概率公式直接算：通过列举所有可能的长度为 $T$ 的状态序列 $Q={Q_1,Q_2,\cdots Q_t}$，求各个状态序列 $Q$ 与观测序列 $O = (o_1,o_2,\cdots,o_T)$ 的联合概率$P(O,Q|\lambda)$ ，然后对所有可能的状态序列求和，得到 $P(O|\lambda)$.</p><p>状态序列 $Q={Q_1,Q_2,\cdots Q_t}$ 的概率是$$P(Q|\lambda) = \pi_{q_1} a_{q_1 q_2} a_{q_2 q_3} \cdots a_{q_{T-1} q_{T}}$$</p><p>对固定的状态序列 $Q={Q_1,Q_2,\cdots Q_t}$, 观测序列 $O = (o_1,o_2,\cdots,o_T)$ 的概率是$$P(O|Q,\lambda) = b_{q_1}(o_1) b_{q_2}(o_2) \cdots b_{q_T}(o_T)$$</p><p>则 $O,Q$ 同时出现的联合概率为:$$P(O,Q|\lambda) = P(O|Q,\lambda) P(Q|\lambda) \\ = \pi_{q_1} b_{q_1}(o_1) a_{q_1 q_2} b_{q_2}(o_2) \cdots a_{q_{T-1} q_T} b_{q_T}(o_T) $$</p><p>然后，对所有可能的状态序列 $Q$ 求和，得到观测序列 $O$ 的概率 $P(O|\lambda)$ ，即</p><p>$$P(O|\lambda) = \sum_{Q} P(O|Q,\lambda) P(Q|\lambda) \\ = \sum_{q_1,q_2,\cdots,q_T} \pi_{q_1} b_{q_1}(o_1) a_{q_1 q_2} b_{q_2}(o_2) \cdots a_{q_{T-1} q_T} b_{q_T}(o_T) $$</p><p>但是，该式计算量很大，是 $O(TN^T)$ 阶的，这种算法不可行.</p><h3>前向-后向算法</h3><p>解决问题 1 的最常用、最有效的方法就是 <em>Baum</em> 等人提出的前向-后向算法。</p><p>该算法定义<strong>前向概率变量</strong>$$\alpha_t(i) : \alpha_t(i) = P(o_1,o_2,\cdots,o_t,q_t = S_i | \lambda)$$$\alpha(t_i)$ 可由下面递推公式计算得到 :</p><p>初始化:$\alpha_1(i) = \pi_i b_i(o_1), 1 \leq i \leq Q$</p><p>递推:$$\alpha_{t+1}(j) = [ \sum_{i=1}^Q \alpha_t(i) a_{ij} ] b_j(o_{t+1}) , 1 \leq j \leq Q,1 \leq t \leq T-1$$</p><p>结束:$P(O | \lambda) = \sum_{i=1}^Q \alpha_T(i)$</p><p>其中$\sum_{i=1}^Q \alpha_T(i)$  是把最后 $T$ 时刻的所有可能的状态下观察到 $O$ 的概率求和；因为到最后 $T$ 时刻时，每一条状态路径都能观察到观测序列 $O$，且有一个生成概率，即$\alpha_T(i)$，于是将  $T$时刻所有可能的状态对应的前向概率变量累加，就是将所有可能观察到观测序列的状态序列的概率相加，即 $P(O|\lambda)$上述前向算法的递推关系如图所示:</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523584358/2018_04_10-2.png" width="95%" height="95%"><p>与前向算法相似，后向算法是从后向前递推计算输出概率的方法。定义后向概率变量$$\beta_t(i) : \beta_t(i) = P(o_{t+1},o_t,\cdots,o_T | q_t = S_i,\lambda)$$</p><p>则 $\beta_t(i)$ 可由下面递推公式计算，后向算法的递推关系图如下所示:</p><p>初始化 : $\beta_T(i) = 1, 1 \leq i \leq Q$</p><p>递推公式:$$\beta_t(i) = \sum_{j=1}^Q a_{ij} b_j(o_{t+1}) \beta_{t+1}(j), 1 \leq i \leq Q,t = T-1,\cdots,1$$</p><p>结束 : $P(O | \lambda) = \sum_{i=1}^Q \beta_1(i) \pi_i = \beta_0(1)$</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523584358/2018_04_10-3.png" width="95%" height="95%"><p>根据前向变量和后向变量的定义，显然下式成立 ：</p><p>$$P(O | \lambda) = \sum_{i=1}^Q \sum_{j=1}^Q \alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j),1 \leq t \leq T-1$$</p><p><font color="blue">如何来理解该式子？</font></p><p>$\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)$表示 $t$ 时刻为状态 $q_i$ 的前向概率（根据前向概率的定义，已经计算了 $t$ 时刻状态为 $q_i$ 时观测到 $o_t$ 的概率）， $t$时刻状态 $q_i$ 转移到 $t+1$ 时刻的状态 $q_j$，在 $t+1$ 时刻状态 $q_j$ 下观测到$o_{t+1}$ 的概率，最后乘以 $t+1$ 时刻状态为  $q_j$的后向概率（因为按后向概率的定义不包含当前状态的观察概率 $b_j(o_{t+1})$ 的计算）；分别求所有可能的状态 $q_i,q_j$ 的组合，就是$P(O|\lambda)$ .</p><p>利用该算法减少计算量的原因在于每一次计算直接引用前一个时刻的计算结果，避免重复计算.这样，利用前向概率计算 $P(O|\lambda)$  的计算量是 $O(N^2T)$ 阶的，而不是直接计算的 $O(TN^T)$ 阶.</p><h3>监督学习方法</h3><p>对于 $\text{HMM}$ 参数估计问题，可按训练数据的特点来分是有监督学习还是无监督学习，如果是有监督学习的话，可直接通过对训练样本做一些统计即可得到 $\text{HMM}$ 的参数估计；在中文自然语言处理中，许多标注问题就是这么做的.</p><p>假设已给训练数据包含 $K$ 个长度相同的观察序列和对应的状态序列 ${(O_1,Q_1),(O_2,Q_2),\cdots,(O_K,Q_K)}$，那么我们可以直接利用极大似然估计法来估计隐马尔科夫模型的参数，具体如下:</p><p>转移概率 $a_{ij}$ 的估计设样本中时刻 $t$ 处于状态 $q_i$，时刻 $t+1$ 时刻由状态 $q_i$ 转移到了 $q_j$，此种情况出现的频数为 $A_{ij}$ ，那么转移概率$a_{ij}$ 的估计值为</p><p>$$\hat{a}_{ij} = \frac{ A_{ij} }{\sum_{j=1}^Q A_{ij} },i = \{S_1,S_2,\cdots,S_Q\};j = \{S_1,S_2,\cdots,S_Q\}$$</p><p>即统计由状态 $q_i$ 转移到状态 $q_j$ 占状态 $q_i$ 转移出去的比例.</p><p>观测概率 $b_{q_j}(v)$ 的估计设样本中状态为$q_j$  并观测为 $o_v$ 的频数是 $B_{jv}$，那么状态为 $q_j$ 观测为 $o_v$ 的概率 $b_{q_j}(v)$ 的估计是:</p><p>$$\hat{b}_{q_j}(v) = \frac{B_{jv} }{\sum_{v=1}^M B_{jv} }$$</p><p>其中，$j = 1,2,\cdots,T;\quad v = 1,2,\cdots,M$.</p><h3>Baum-Welch 算法</h3><p><font color="blue">对于无监督学习的 HMM 参数估计问题，可以使用 Baum-Welch算法.</font></p><p>首先定义两个变量$r_t(i)$  和$\xi_t(i,j)$ ，给定观察序列 $O(e_1,e_2,\cdots ,e_T)$ 和模型参数 $\lambda=\{A,B,\pi \}$;</p><ul><li><p>$r_t(i)$为系统在时刻 $t$ 系统处在状态 $S_i$ 的概率，即$$r_t(i) = P(q_t = S_i | O,\lambda)$$</p></li><li><p>$\xi_t(i,j)$为 $t$ 时刻状态为 $S_j$ ，到 $t+1$ 时刻系统状态转为 $S_j$ 的概率，即$$\xi_t(i,j) = P(q_t = S_i,q_{t+1} = S_j | O,\lambda)$$</p></li></ul><p>根据前向-后向算法中 $\alpha_t(i)$ 和 $\beta_t(i)$ 定义有:</p><p>$$r_t(i) = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j=1}^Q \alpha_t(j) \beta_t(j)},1 \leq i \leq Q \\ \xi_t(i,j) = \frac{\alpha_t(i) a_{ij} b_j(e_{t+1}) \beta_{t+1}(j)}{P(O|\lambda)} \\ \qquad =\frac{\alpha_t(i) a_{ij} b_j(e_{t+1}) \beta_{t+1}(j)}{\sum_{m=1}^Q \sum_{n=1}^Q \alpha_t(m) a_{mn} b_n(e_{t+1}) \beta_{t+1}(n)} ,1 \leq i,j \leq Q$$</p><p>则对于观察序列 $O(e_1,e_2,\cdots ,e_T)$ 而言，系统所处于状态 $S_j$ 的总次数（期望值）为 $\sum_{i=1}^Q r_t(i)$ ；同样，系统从状态 $S_i$ 转移到 $S_j$ 的总次数为 $\sum_{i=1}^Q \xi_t(i,j)$ .假设给定训练数据只包含 $K$ 个长度为 $T$ 的观测序列 $\{O_1,O_2,\cdots,O_K \}$ 而没有对应的状态序列，目标是学习隐马尔科夫模型 $\lambda=\{A,B,\pi \}$ 的参数.我们将观测序列数据看作观测数据 $O$，状态序列数据看作不可观测的隐数据 $I$，那么隐马尔科夫模型事实上是一个含有隐变量的概率模型</p><p>$$P(O|\lambda) = \sum_{I} P(O|I,\lambda) P(I|\lambda)$$</p><p>它的参数学习可以用<font color="blue">EM算法</font>来实现.</p><ol><li><p>确定完全数据的对数似然函数所有观测数据写成$O = (o_1,o_2,\cdots,o_T)$ ，所有隐数据写成 $I = (i_1,i_2,\cdots,i_T)$，完全数据是 $(O,I) = (o_1,o_2,\cdots,o_T,i_1,i_2,\cdots,i_T)$，完全数据的对数似然函数是 $\log(P(O,I|\lambda))$</p></li><li><p>EM 算法的 E 步: 求 $Q$ 函数 $Q(\lambda,\overline{\lambda})$$$Q(\lambda,\overline{\lambda}) = \sum_{I} \log \left( P(O,I|\lambda) P(O,I|\overline{\lambda}) \right)$$其中，$\overline{\lambda}$ 是隐马尔科夫模型参数的当前估计值，$\lambda$ 是要极大化的隐马尔科夫模型参数.$$P(O,I|\lambda) = \pi_{i_1} b_{i_1}(o_1) a_{i_1 i_2} b_{i_2}(o_2) \cdots a_{i_{T-1} i_T} b_{i_T}(o_T)$$于是函数 $Q(\lambda,\overline{\lambda})$ 可以写成:$$Q(\lambda,\overline{\lambda}) = \sum_{I} ( \log \pi_{i_1} ) P(O,I|\overline{\lambda}) \\ \sum_{I} ( \sum_{t=1}^{T-1} \log a_{i_t i_{t+1}} ) P(O,I|\overline{\lambda}) + \sum_{I} ( \sum_{t=1}^T \log b_{i_t}(o_t) ) P(O,I|\overline{\lambda})$$式中求和都是对所有训练数据的序列总长度 $T$ 进行的.</p></li></ol><blockquote><p>这其中的 $Q$ 函数，是直接用的《统计学习方法》中的概念，这本书中的 $Q$ 函数比较难懂.</p></blockquote><ol start="3"><li>EM 算法的 M 步: 极大化 $Q$ 函数 $Q(\lambda,\overline{\lambda})$ 求模型参数 $A,B,\pi$由于要极大化的参数在 $Q(\lambda,\overline{\lambda})$ 中单独地出现在 3 个项中，所以只需对各项分别极大化.</li></ol><p>(1). 第一项可以写成:$$\sum_{I} ( \log \pi_{i_1} ) P(O,I|\overline{\lambda}) = \sum_{i=1}^N (\log \pi_i) P(O,i_1 = i | \overline{\lambda})$$注意到 $\pi_i$ 满足约束条件$\sum_{}^N \pi_i = 1$ ，利用拉格朗日乘子法，写出拉格朗日函数:$$L(\pi_i,\gamma) = \sum_{i=1}^N (\log \pi_i) P(O,i_1 = i | \overline{\lambda}) + \gamma ( \sum_{i=1}^N \pi_i - 1 )$$对其求偏导数并令结果为零:$$\frac{\partial L}{\partial \pi_i} = \frac{1}{\pi_i} P(O,i_1 = i | \overline{\lambda}) + \gamma = 0 \\ P(O,i_1 = i | \overline{\lambda}) + \gamma \pi_i = 0 \\ \gamma = -P(O|\overline{\lambda}) \\ \pi_i = \frac{P(O,i_1 = i | \overline{\lambda})}{P(O|\overline{\lambda})}$$</p><p>(2). 第 2 项可以写成:$$\sum_{I} ( \sum_{t=1}^{T-1} \log a_{i_t i_{t+1}} ) P(O,I|\overline{\lambda}) \\ = \sum_{i=1}^N \sum_{j=1}^N \sum_{t=1}^{T-1} (\log a_{ij}) P(O,i_t = i,i_{t+1} = j|\overline{\lambda})$$</p><p>注意到约束条件 $\sum_{j=1}^N a_{ij} = 1$，应用拉格朗日乘子法得:$$L(a_{ij},\gamma) = \sum_{i=1}^N \sum_{j=1}^N \sum_{t=1}^{T-1} (\log a_{ij}) P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) + \gamma ( \sum_{j=1}^N a_{ij} - 1 )$$求其对 $\alpha_{ij}$ 的偏导，并令其等于零:$$\frac{\partial L}{\partial a_{ij}} = \sum_{t=1}^{T-1} ( \frac{1}{a_{ij}} P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) ) + \gamma = 0 \\ \sum_{t=1}^{T-1} P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) + \sum_{t=1}^{T-1} a_{ij} \gamma = 0$$</p><p>对 $j$ 求和:$$\sum_{j=1}^N \sum_{t=1}^{T-1} P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) + \sum_{j=1}^N \sum_{t=1}^{T-1} a_{ij} \gamma = 0 \\ \sum_{t=1}^{T-1} P(O,i_t = i|\overline{\lambda}) + \sum_{t=1}^{T-1} \gamma = 0 \\ a_{ij} = \frac{\sum_{t=1}^{T-1} P(O,i_t = i,i_{t+1} = j | \overline{\lambda})}{\sum_{t=1}^{T-1} P(O,i_t = i|\overline{\lambda})}$$</p><p>(3). 第 3 项与第 2 项的计算类似:$$\sum_{I} \left( \sum_{t=1}^T \log b_{i_t}(o_t) \right) P(O,I|\overline{\lambda}) = \sum_{j=1}^N \sum_{t=1}^T \log b_j(o_t) P(O,i_t = j | \overline{\lambda})$$同样用拉格朗日乘子法，约束条件是 $\sum_{k=1}^M b_j(k) = 1$ .注意，只有在 $o_t=v_k$ 时 $b_j(o_t)$ 对 $b_j(k)$ 的偏导数才不为 $0$，以 $I(o_t=v_k)$ 表示，求得$$b_j(k) = \frac{\sum_{t=1}^T P(O,i_t = j | \overline{\lambda}) I(o_t = v_k)}{\sum_{t=1}^T P(O,i_t = j | \overline{\lambda})}$$</p><h4>Note</h4><p>则上面的概率公式整理一下，并用 $\gamma_t(i),\xi_t(i,j)$ 表示为:$$ a_{ij} = \frac{\sum_{t=1}^{T-1} \xi_t(i,j)}{\sum_{t=1}^{T-1} \gamma_t(i)} \\ b_j(k) = \frac{\sum_{t=1,o_t = v_k}^T \gamma_t(j)}{\sum_{t=1}^T \gamma_t(j)} \\ \pi_i = \gamma_1(i)$$</p><p>于是整理 Baum-Welech 完整算法描述如下:</p><p>输入：观测数据  $O=(o_1,o_2,\cdots,o_T)$输出：隐马尔科夫模型参数.</p><ul><li>初始化对 $n=0$，选取 $a_{ij}^{(0)},b_j(k)^{(0)},\pi_i^{(0)}$，得到模型 $\lambda^{(0)} = (A^{(0)},B^{(0)},\pi^{(0)})$</li><li>递推，对 $n = 1,2,\cdots$$$a_{ij}^{(n+1)} = \frac{\sum_{t=1}^{T-1} \xi_t(i,j)}{\sum_{t=1}^{T-1} \gamma_t(i)} \\ b_j(k)^{(n+1)} = \frac{\sum_{t=1,o_t = v_k}^T \gamma_t(j)}{\sum_{t=1}^T \gamma_t(j)} \\ \pi_i^{(n+1)} = \gamma_1(i) $$右端各值按观测 $O = (o_1,o_2,\cdots,o_T)$ 和模型 $\lambda^{(n)} = (A^{(n)},B^{(n)},\pi^{(n)})$ 计算.</li><li>终止，得到模型参数 $\lambda^{(n+1)} = (A^{(n+1)},B^{(n+1)},\pi^{(n+1)})$</li></ul><h2>R中的HMM</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"HMM"</span>)</span><br><span class="line"><span class="keyword">library</span>(HMM)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后向算法求观察值出现的概率</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>),c(<span class="string">"L"</span>,<span class="string">"R"</span>),transProbs = matrix(c(<span class="number">0.8</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">0.8</span>),<span class="number">2</span>),emissionProbs = matrix(c(<span class="number">0.6</span>,<span class="number">0.4</span>,<span class="number">0.4</span>,<span class="number">0.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># 序列观察值</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line">logBackwardProbabilities = backward(hmm,observations)</span><br><span class="line">print(exp(logBackwardProbabilities))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过前向算法求观察值出现的概率</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>), c(<span class="string">"L"</span>,<span class="string">"R"</span>), transProbs=matrix(c(<span class="number">.8</span>,<span class="number">.2</span>,<span class="number">.2</span>,<span class="number">.8</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observations</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line"><span class="comment"># Calculate forward probablities</span></span><br><span class="line">logForwardProbabilities = forward(hmm,observations)</span><br><span class="line">print(exp(logForwardProbabilities))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过Baum-Welch算法训练 hmm参数</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>),c(<span class="string">"L"</span>,<span class="string">"R"</span>))</span><br><span class="line">transProbs = matrix(c(<span class="number">0.9</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.9</span>),<span class="number">2</span>)</span><br><span class="line">emissionProbs = matrix(c(<span class="number">0.5</span>,<span class="number">0.51</span>,<span class="number">0.5</span>,<span class="number">0.49</span>),<span class="number">2</span>)</span><br><span class="line">print(hmm)</span><br><span class="line">a = sample(c(rep(<span class="string">"L"</span>,<span class="number">100</span>),rep(<span class="string">"R"</span>,<span class="number">300</span>)))</span><br><span class="line">b = sample(c(rep(<span class="string">"L"</span>,<span class="number">300</span>),rep(<span class="string">"R"</span>,<span class="number">100</span>)))</span><br><span class="line">observation = c(a,b)</span><br><span class="line"><span class="comment"># Baum-Welch</span></span><br><span class="line">bw = baumWelch(hmm,observation,<span class="number">10</span>)</span><br><span class="line">print(bw$hmm)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察序列最可能出现的概率</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>), c(<span class="string">"L"</span>,<span class="string">"R"</span>), transProbs=matrix(c(<span class="number">.8</span>,<span class="number">.2</span>,<span class="number">.2</span>,<span class="number">.8</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observations</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line"><span class="comment"># Calculate posterior probablities of the states</span></span><br><span class="line">posterior = posterior(hmm,observations)</span><br><span class="line">print(posterior)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Viterbi算法解码，求最可能的隐状态序列</span></span><br><span class="line"><span class="comment"># Initialise HMM</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>), c(<span class="string">"L"</span>,<span class="string">"R"</span>), transProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observations</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line"><span class="comment"># Calculate Viterbi path</span></span><br><span class="line">viterbi = viterbi(hmm,observations)</span><br><span class="line">print(viterbi)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练hmm参数</span></span><br><span class="line"><span class="comment"># Initial HMM</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>),c(<span class="string">"L"</span>,<span class="string">"R"</span>),</span><br><span class="line">              transProbs=matrix(c(<span class="number">.9</span>,<span class="number">.1</span>,<span class="number">.1</span>,<span class="number">.9</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.5</span>,<span class="number">.51</span>,<span class="number">.5</span>,<span class="number">.49</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observation</span></span><br><span class="line">a = sample(c(rep(<span class="string">"L"</span>,<span class="number">100</span>),rep(<span class="string">"R"</span>,<span class="number">300</span>)))</span><br><span class="line">b = sample(c(rep(<span class="string">"L"</span>,<span class="number">300</span>),rep(<span class="string">"R"</span>,<span class="number">100</span>)))</span><br><span class="line">observation = c(a,b)</span><br><span class="line"><span class="comment"># Viterbi-training</span></span><br><span class="line">vt = viterbiTraining(hmm,observation,<span class="number">10</span>)</span><br><span class="line">print(vt$hmm)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      隐马尔可夫模型（Hidden Markov Model，$\text{HMM}$）是统计模型，它用来描述一个含有隐含未知参数的马尔可夫过程。其难点是从可观察的参数中确定该过程的隐含参数。然后利用这些参数来作进一步的分析，例如模式识别。
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>概率论（离散空间）杂谈</title>
    <link href="http://ulsonhu.cn/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9D%82%E8%B0%88%E7%AF%87%E4%B8%80.html"/>
    <id>http://ulsonhu.cn/概率论杂谈篇一.html</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-28T11:22:20.487Z</updated>
    
    <content type="html"><![CDATA[<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521877258/2018_03_09_01.jpg" height="90%"><p>关于概率论与统计学的不同，相信学过统计学的同学，看过上图后一定能秒懂。</p><blockquote><p>统计学：根据手中信息，猜猜桶里有啥？</p></blockquote><blockquote><p>概率论：根据桶中信息，猜猜手里有啥？</p></blockquote><h2>概率空间</h2><p>所有基本事件组成的集合，其中的每一个基本事件又称做样本点，样本空间用$\boldsymbol {\Omega }$表示，样本点用$\omega$表示,$\Omega=\{\omega \}$</p><ol><li>$\mathcal{\Omega}$－Sample space 样本空间，试验中所有可能结果的集合。（注：每个结果需要互斥，所有可能结果必须被穷举）</li><li>$\mathcal{F}$－Set of events 事件集合，是$\Omega$的一些子集构成的集合，并且它需要满足以下三点特性（也就是必须是$\sigma$－field）：</li></ol><ul><li>$\mathcal{\Phi \in F}$（也就是必须包含不可能事件）</li><li>如果$E\in F,E^C \in \mathcal{F}$。</li><li>如果$E_1,E_2,\cdots ,E_i \in \mathcal{F}$,那么 $U_{i=1}^{\infty}E_i \in \mathcal{F}$</li></ul><ol start="3"><li>$\mathcal{P}$－Probability measure 概率测度（或概率），描述一次随机试验中被包含在 $\mathcal{F}$中的所有事件的可能性。并且它「碰巧」也需要满足三点特性：</li></ol><ul><li>$0\leq P(E_i)\leq 1$（实际限制了总测度为1）</li><li>$P(\Omega)=1$（包含样本空间并且概率为1）</li><li>如果$E_1,E_2,\cdots ,E_i$是互斥事件,那么$P\{U_{i=1}^{\infty} E_i \}=\sum_{i=1}^{\infty} E_i$</li></ul><h2>谈斯特林公式</h2><p>$$n! \sim \sqrt{2\pi }n^{n+\frac{1}{2} }e^{-n} $$</p><p>证明见附录，这是概率论中非常重要的理论，基于此可以得到一些精确的数值估计</p><h3>Stirling与概率问题</h3><p>什么是一个事件（event）的概率？这是概率论最基本也是争议最多的问题【例】：抛一枚硬币，出现正面的概率？</p><p>这是什么意思，通常认为，将这枚硬币独立的抛「很多次」，那么正面出现的次数「大约」占一半。这是在随机事件中很确定的事。所谓的「平均律」(The law of average)或「大数定律」(The law of large numbers)隐约也是在解释这个说法。现在我们从常识出发，来考虑数学表达。</p><p>【问题1】抛 $2n$ 次硬币，正面恰好出现 $n$ 次的概率又多大？根据组合学，抛 $2n$ 次硬币，共有 $2^{2n}$ 种可能，假设每一种发生的结果机会均等，那么 $2n$ 次中有 $n$ 次正面的结果共有$C_{n}^{2n}$种，故得概率为</p><p>$p_{2n} = \frac{C_n^{2n}}{2^{2n}} = \frac{(2n)!}{2^{2n}\cdot n!\cdot n!} \qquad (1)$</p><p>更有趣的是，当$n$趋向$\infty$时，$p_{2n}$会趋近多少？上述常识性的解释似乎是说， $\lim_{n \to \infty } p_{2n} = 1$，这成立吗？这需要对$(1)$式作精确的估计，于是引出下面的问题</p><p>【问题2】当$n$很大时，如何估算？明确地说：当$n$趋向$\infty$时，$n!$的渐进相等式（Asymptotically equal formula）是什么？</p><p>即要找一个${a_n}$使得</p><p>$$\lim_{n \to \infty} \frac{n!}{a_n} = 1,\quad n! \sim a_n$$</p><p>我们希望找到这样的${a_n}$，然后带入$(1)$式中计算极限值 $\lim_{n \to \infty} p_{2n}$，就可以检验上述常识性的说法是否正确。</p><p>$n!$的渐进相等式（Asymptotically equal formula）存在吗？如何找？这时候就需要Stirling公式出场了。</p><h3>初步否定常识性的概率</h3><p>现在我们要利用Stirling 公式来探讨概率之谜(the enigma of probability)。</p><p>首先观察到一个显然的</p><p>【补题】设$\{a_n\},\{b_n\},\{c_n\}$及$\{d_n\}$皆为正项数列且  $\lim_{n \to \infty} \frac{a_n}{b_n} = l$。若 $a_n \sim c_n$且$b_n \sim d_n$，则  $\lim_{n \to \infty} \frac{c_n}{d_n} = l$。接着计算「丢$2n$次硬币，恰好出现$n$次正面的机率$p_{2 n}$在  $n \to \infty$的极限」</p><p>$$\lim_{n \to \infty}p_{2n} = \lim_{n \to \infty} \frac{(2n)!}{2^{2n}n!n!} \\=\lim_{n \to \infty} \frac{\sqrt{2\pi 2n}(2n)^{2n}e^{-2n}}{2^{2n}\cdot 2\pi \cdot  n\cdot n^{2n}\cdot e^{-2n}} \\=\lim_{n \to \infty}\frac{1}{\sqrt{\pi n}}=0$$</p><p>【定理3】  $ \lim_{n \rightarrow \infty} p_{2n} = 0$。因此，当 $n \to \infty$时，$p_{2n}$不但不如原先预计的趋近于1（即必然发生），反而是趋近于0（即不可能发生）。这警告我们，概率的解释与经验有很大出入。</p><p>【常识性的说法】「丢很多次硬币正面大约占一半。」如果将「大约占一半」， 解释为「恰好是一半」的说法，点估计显然是不对的。如何修正呢？自然想到的是改用区间估计的说法。</p><p>为了叙述方便起见，我们引入随机变量(random variable)的概念。对于$k =1, 2, 3, \cdots $，令随机变量</p><p>$$f(n) =\begin{cases}\epsilon_k =  1, &amp; \text{第$K$次硬币得到正面 } \\\epsilon_k =  0, &amp; \text{第$K$次硬币得到反面}\end{cases}$$</p><p>再令$$S_n = \epsilon_1 + \epsilon_2 + \cdots + \epsilon_n$$</p><p>这也是一个随机变数，定义在某个机率空间$\mathcal{(\Omega, F , P )}$上，代表丢$n$次硬币中，正面出现次数之随机变数，它具有二项分布。于是「$S_{2 n} = n$」就表示丢$2n$次正面恰好出现$n$次的事件，其概率记为$P ( S_{2 n} = n )$。</p><p>因此【定理3】是说。  $\lim_{n \rightarrow \infty} P(S_{2n}=n)=0$</p><p>进一步我们猜想：$S_{2n}$落在$n$的附近之概率应该会大起来吧？</p><p>也许这是「正面大约占一半」更贴切的解释。精确的计算是探求隐晦奥秘的不二法门，让我们就来算算看。</p><p>令$a &gt; 0​$唯一个固定数，那么</p><p>$$P(n-a \leq S_{2n} \leq n+a) = \sum_{k=n-a}^{n+a} C_{k}^{2n}\cdot \frac{1}{2^{2n} } \\ \sim \frac{2a}{ \sqrt{\pi n}} \rightarrow 0 ,when \quad  n \rightarrow \infty$$</p><p>因此我们又得到一个不出所料的结果：</p><p>【定理4】：对任意固定数$a &gt; 0$，$$\lim_{b \to \infty} P( \mid S_{2n} - n \mid \leq a ) = 0$$</p><p>换言之，以$n$为中心，左右之长皆为$a$之区间，概率依然为零！另外，将偶数$2n$改成奇数$2 n +1$，【定理4】仍然成立。因为当  $n \to \infty$时，相应项的比值为</p><p>$$\frac{ C_{k}^{2n+1}\cdot \frac{1}{ 2^{2n+1} } }{C_{k}^{2n} \frac{1}{2^{2n}}} = \frac {2n+1}{2n+1-k} \cdot \frac{1}{2} \to \frac{1}{2}$$所以$$P( -a \leq S_{2n+1} - \frac{2n+1}{2} \leq a )  \\ = \sum_{k=-a+ \frac {2n+1}{2}}^{a+ \frac {2n+1}{2}}  C_k^{2n} \frac{1}{2^{2n+1}}\\\sim \frac{1}{2}\sum_{k=-a+ \frac {2n+1}{2}}^{a+ \frac {2n+1}{2}}  C_k^{2n} \frac{1}{2^{2n}} \to 0$$</p><p>所以得到【定理5】：对任意有限正数$a$，恒有$$\lim_{n \to \infty} P(-a \leq S_{2n+1} - \frac{2n+1}{2} \leq a) = 0$$</p><p>将上述【定理4】与【定理5】归结起来就得到：</p><p>【定理6】：对任意有限正数$a$，恒有</p><p>$$\lim_{n \to \infty} P(-a \leq S_n - \frac{n}{2} \leq a) = 0 $$</p><p>这是一个令人惊异的结果，但也令人失望！逻辑的闷棍把常识的观点打得眼冒金星。用任何有限区间$[- a , a\ ]$来网罗住  $S_n - \frac{n}{2}$所散布的概率，当 $n \to \infty$时，根本没有往到任何概率，概率全部流失掉！</p><p>换言之，丢$n$次，出现正面的次数，落在包含$\frac{n}{2}$的任何有限区间的机会，当$n$很大时，微乎其微。</p><p>什么是概率？它仍然是很神秘！</p><blockquote><ol><li>表面来看，Stirling 公式并不漂亮，但却很多用途，它是揭开许多深刻奥秘的钥匙。在研究二项分布的性质时，De Moivre 最先得到这个公式（1718年）；后来James Stirling 在1730年又重新得到它。</li></ol></blockquote><blockquote><ol start="2"><li>$n!$的连续变化就是Gamma函数，内容精彩丰富，这是Euler的贡献。</li></ol></blockquote><h2>附录</h2><blockquote><p>斯特林公式证明，相当于一道考研题目</p></blockquote><p>$$log{n!}=log{1}+log{2}+\cdots+log{n} $$</p><p>因为$\log x$为单调函数，所以</p><p>$$\int_{k-1}^{k} \log{x} dx &lt; \log{n!} &lt; \int_{k}^{k+1}\log{x}dx $$把上式对$k$从$1$到$n$相加得到</p><p>$$\int_{0}^{n}\log{x}dx &lt; \log{n!} &lt; \int_{1}^{n+1}\log{x}dx \qquad(1)$$$$\Leftrightarrow n\log{n}-n &lt; \log{n!} &lt; (n+1)\log{(n+1)}-n \qquad(2)$$这是一个双重不等式，提示我们把$\log {n!}$与两端数的算数平均做比较，即想到$(n+\frac{1}{2})\log{n}-n$$$d_n=\log{n!}-(n+\frac{1}{2})\log{n}+n \qquad (3)$$$$d_n - d_{n+1}=\log{n!}-(n+\frac{1}{2})\log\frac{n+1}{n}-1$$$$\frac{n+1}{n}=\frac{1+\frac{1}{2n+1}}{1-\frac{1}{2n+1}}$$$\boldsymbol{Taylor}$展开得$$d_n - d_{n+1}=\frac{1}{3(2n+1)^2}+\frac{1}{5(2n+1)^4}+\cdots $$把上式与一个公比的几何级数进行比较得$$0 &lt; d_n-d_{n+1} &lt; \frac{1}{3\left [ (2n+1)^2-1 \right ]}=\frac{1}{12n}-\frac{1}{12(n+1)}$$知是${d_n}$下降序列，说明序列${d_n-(12n)^{-1} }$是上升的，因此，极限$\lim d_n = C$存在且有限，但是，由$(3)$知：$d_n \rightarrow C$等价于$$n! \sim e^C \cdot n^{n+\frac{1}{2} } \cdot e^{-n}$$</p><p>这就是斯特林公式的初步证明，其中关于$C$（$e^C=\sqrt{2\pi}$）的证明较复杂，有兴趣可参考相关文章，在此不赘述。</p>]]></content>
    
    <summary type="html">
    
      什么是一个事件（event）的概率？这是概率论最基本也是争议最多的问题。我们是试着从常识出发，来考虑数学表达。
    
    </summary>
    
      <category term="概率论" scheme="http://ulsonhu.cn/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
      <category term="Mathematic" scheme="http://ulsonhu.cn/tags/Mathematic/"/>
    
      <category term="概率论" scheme="http://ulsonhu.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>用python做数据分析与科学计算(篇一)</title>
    <link href="http://ulsonhu.cn/%E7%94%A8python%E5%81%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97(%E7%AF%87%E4%B8%80).html"/>
    <id>http://ulsonhu.cn/用python做数据分析与科学计算(篇一).html</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-03-24T15:55:57.498Z</updated>
    
    <content type="html"><![CDATA[<p>用python做数据分析与科学计算主要涉及Numpy, Pandas, Scipy, Scikit-learn, Scipy等库，工作环境为Anaconda，这个IDE集成了大部分常用的包。同时，可以实现本地环境下Python的多版本切换，可参考之前文章,<a href="https://ulsonhu.github.io/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html" target="_blank" rel="noopener">MacOS下使用python的多版本方案</a></p><a id="more"></a><p>  通常做数据分析&amp;挖掘的workflow：拿到数据之后先要做一个数据的预处理(pandas+numpy+scipy)，接着会要对数据包含的特征做一些可视化输出(matplotlib)，之后需要提取特征&amp;建模调参(numpy+scikit-learn)，有了模型与结果，最后归纳整理做presentation &amp; report.</p><h2>Numpy</h2><p>用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多，本身是由C语言开发。这个是很基础的扩展，其余的扩展都是以此为基础。数据结构为ndarray,一般有三种方式来创建。</p><table><thead><tr><th>Function</th><th>Useage</th></tr></thead><tbody><tr><td>array.shape</td><td>查看或改变数组的大小</td></tr><tr><td>array.reshape</td><td>修改数组的尺寸，原数组不变，两个数组共享内存，如果修改值的话这两个数组都会变</td></tr><tr><td>array.size</td><td>数组元素的总个数，等于shape属性中元组元素的乘积</td></tr><tr><td>array.ndim</td><td>数组的维数</td></tr><tr><td>array.dtype</td><td>array的数据规格</td></tr><tr><td>numpy.zeros(dim1,dim2)</td><td>创建dim1*dim2的零矩阵</td></tr><tr><td>numpy.eye(n)</td><td>创建$n*n$单位矩阵</td></tr><tr><td>numpy.identity(n)</td><td>创建$n*n$单位矩阵</td></tr><tr><td>numpy.arange</td><td>类似于list的range函数，通过指定初始值，终值，和步长来生成一维数组</td></tr><tr><td>array.astype(numpy.float64)</td><td>更换矩阵的数据形式</td></tr><tr><td>array * array</td><td>矩阵点乘</td></tr><tr><td>array[a:b]</td><td>切片</td></tr><tr><td>array.copy()</td><td>得到ndarray的副本，而不是视图</td></tr><tr><td>array [a] [b]=array [ a, b ]</td><td>两者等价</td></tr><tr><td>data[[4,3,0,6]]</td><td>索引，将第4,3,0,6行摘取出来，组成新数组</td></tr><tr><td>numpy.reshape(a,b)</td><td>将a<em>b的一维数组排列为a</em>b的形式</td></tr><tr><td>array([a,b,c,d],[d,e,f,g])</td><td>返回一维数组，分别为[a,d],[b,e],[c,f],[d,g]</td></tr><tr><td>array.T</td><td>array的转置</td></tr><tr><td>numpy.random.randn(a,b)</td><td>生成$a*b$的随机数组</td></tr><tr><td>numpy.dot(matrix_1,matrix_2)</td><td>矩阵乘法</td></tr><tr><td>array.transpose( (1,0,2,etc.) )</td><td>对于高维数组，转置需要一个由轴编号组成的元组</td></tr></tbody></table><p>numpy库提供了matrix类，使用matrix类创建的是矩阵对象，它们的加减乘除运算缺省采用矩阵方式计算。但是由于NumPy中同时存在ndarray和matrix对象，因此很容易将两者弄混。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用ones()创建一个2*4的全1矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mat(np.ones((<span class="number">2</span>,<span class="number">4</span>))) </span><br><span class="line">matrix([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">        [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><h2>Pandas</h2><p>基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。最具有统计意味的工具包，某些方面优于R软件。数据结构有一维的Series，二维的DataFrame(类似于Excel或者SQL中的表，如果深入学习，会发现Pandas和SQL相似的地方很多，例如merge函数)，三维的Panel（Pan（el) + da(ta) + s，知道名字的由来了吧）。</p><p>学习Pandas你要掌握的是：</p><ol><li>汇总和计算描述统计，处理缺失数据 ，层次化索引</li><li>清理、转换、合并、重塑、GroupBy技术</li><li>日期和时间数据类型及工具</li></ol><p><a href="http://pandas.pydata.org/pandas-docs/stable/10min.htmlml" target="_blank" rel="noopener">入门理解：</a></p><iframe src="http://nbviewer.jupyter.org/github/ulsonhu/mltest/blob/master/python_backup/Pandas_learn.ipynb" width="95%" height="300"></iframe><h3>使用pandas清洗数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">column_names = [<span class="string">"sex"</span>, <span class="string">"length"</span>, <span class="string">"diameter"</span>, <span class="string">"height"</span>, <span class="string">"whole weight"</span>, <span class="string">"shucked weight"</span>, <span class="string">"viscera weight"</span>, <span class="string">"shell weight"</span>, <span class="string">"rings"</span>]</span><br><span class="line">alone_df = pd.read_csv(<span class="string">'alone.csv'</span>,names=column_names)</span><br><span class="line">alone_df[<span class="string">'sex'</span>] = alone_df[<span class="string">'sex'</span>].map(&#123;<span class="string">'F'</span>:<span class="number">1</span>,<span class="string">'M'</span>:<span class="number">0</span>,<span class="string">'I'</span>:<span class="number">2</span>&#125;)</span><br><span class="line">alone_df[<span class="string">'sex'</span>] = alone_df.rings.map(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">alone_df.head()</span><br></pre></td></tr></table></figure><h2>Matplotlib</h2><p>Python中最著名的绘图系统，很多其他的绘图例如Seaborn（针对pandas绘图而来）也是由其封装而成。其中针对不是很复杂的数据，推荐使用Seaborn，容易上手，图表美观。<a href="http://seaborn.pydata.org/index.html" target="_blank" rel="noopener">Seaborn参考</a></p><p>需要掌握的内容</p><ol><li>散点图，折线图，条形图，直方图，饼状图，箱形图的绘制。</li><li>绘图的三大系统：pyplot，pylab(不推荐)，面向对象</li><li>坐标轴的调整，添加文字注释，区域填充，及特殊图形patches的使用</li><li>金融的同学要注意的是：可以直接调用Yahoo财经数据绘图（很好用）</li></ol><h3>简单的散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902375/2018_03_09_03.png" width="90%" height="90%"><h3>使用子图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment"># （行，列，活跃区）</span></span><br><span class="line">plt.plot(x, np.sin(x), <span class="string">'r'</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">'g'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902375/2018_03_09_02.png" width="90%" height="90%"><p>使用子图只需要一个额外的步骤。即在调用 <code>plot()</code> 函数之前需要先调用<code>subplot()</code>函数。该函数的第一个参数代表子图的总行数，第二个参数代表子图的总列数，第三个参数代表活跃区域.</p><p>标题，标签和图例当需要快速创建图形时，你可能不需要为图形添加标签。但是当构建需要展示的图形时，你就需要添加标题，标签和图例。</p><h3>添加标题，坐标轴标记和图例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">plt.plot(x, np.sin(x), <span class="string">'r-x'</span>, label=<span class="string">'Sin(x)'</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">'g-^'</span>, label=<span class="string">'Cos(x)'</span>)</span><br><span class="line">plt.legend() <span class="comment"># 展示图例</span></span><br><span class="line">plt.xlabel(<span class="string">'Rads'</span>) <span class="comment"># 给 x 轴添加标签</span></span><br><span class="line">plt.ylabel(<span class="string">'Amplitude'</span>) <span class="comment"># 给 y 轴添加标签</span></span><br><span class="line">plt.title(<span class="string">'Sin and Cos Waves'</span>) <span class="comment"># 添加图形标题</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>为了给图形添加图例，我们需要在 <code>plot()</code> 函数中添加命名参数 <code>label</code> 并赋予该参数相应的标签。然后调用 <code>legend()</code> 函数就会在我们的图形中添加图例。</p><p>接下来我们只需要调用函数 <code>title()</code>，<code>xlabel()</code> 和 <code>ylabel()</code> 就可以为图形添加标题和标签。</p><p>你会得到类似于下面这张拥有标题、标签和图例的图形：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902376/2018_03_09_04.png" width="90%" height="90%"><p>参考文献</p><ol><li><a href="http://deeplearning.net/tutorial/" target="_blank" rel="noopener">Deep Learning Tutorials</a></li><li><a href="http://www.scipy-lectures.org/" target="_blank" rel="noopener">Scipy Lecture</a></li><li><a href="https://www.kesci.com/" target="_blank" rel="noopener">KeSci平台</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/10min.html" target="_blank" rel="noopener">10 Minutes to pandas</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用python做数据分析与科学计算主要涉及Numpy, Pandas, Scipy, Scikit-learn, Scipy等库，工作环境为Anaconda，这个IDE集成了大部分常用的包。同时，可以实现本地环境下Python的多版本切换，可参考之前文章,&lt;a href=&quot;https://ulsonhu.github.io/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacOS下使用python的多版本方案&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="Python" scheme="http://ulsonhu.cn/tags/Python/"/>
    
      <category term="Machine Learning" scheme="http://ulsonhu.cn/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SAS基础学习篇(一)</title>
    <link href="http://ulsonhu.cn/SAS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80).html"/>
    <id>http://ulsonhu.cn/SAS基础学习篇(一).html</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-03-21T02:59:56.496Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍</p><ol><li>《SAS编程与数据挖掘商业案例》（预热）</li><li>「the Little SAS Book」(推荐)</li><li>「Applied Econometrics Using The SAS System」</li></ol><p>SAS编程主要包括<code>DATA</code>和<code>PROC</code>两部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* create sas data set named toads;</span><br><span class="line">* read the data file ToadJump.dta using list input;</span><br><span class="line">DATA toads;</span><br><span class="line">INFILE &apos;~/desktop/ToadJump.dta&apos;;</span><br><span class="line">INPUT ToadJump $ Weight Jump1 Jump2 Jump3;</span><br><span class="line">RUN;</span><br><span class="line">* print the data to make sure the file was read correctly;</span><br><span class="line">* PROC PRINT DATA = toads;</span><br><span class="line">TITLE &apos;SAS Data Set Toads&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>这样就建立了一个名为<code>toads</code>的临时数据集，然后读入外部文件<code>ToadJump.dat</code>，然后告诉SAS有四个变量，其中第一个是文本型,缺失值用一个点<code>.</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* Create a SAS data set named sales;</span><br><span class="line">* Read the data file OnionRing.dat using column input;</span><br><span class="line">DATA sales;</span><br><span class="line">INFILE ’~/desktop/OnionRing.dat’;</span><br><span class="line">INPUT VisitingTeam $ 1-20 ConcessionSales 21-24 BleacherSales 25-28</span><br><span class="line">OurHits 29-31 TheirHits 32-34 OurRuns 35-37 TheirRuns 38-40;</span><br><span class="line">RUN;</span><br><span class="line">* Print the data to make sure the file was read correctly;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">TITLE ’SAS Data Set Sales’;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h2>基本函数</h2><table><thead><tr><th>SAS文本类函数</th><th></th></tr></thead><tbody><tr><td>ANYALNUM(arg,start)</td><td>返回第一次出现任意数字或字母的位置，可选开始位置start</td></tr><tr><td>ANYALPHA(arg,start)</td><td>返回第一次出现任意字母的位置，可选开始位置start</td></tr><tr><td>ANYDIGIT(arg,start)</td><td>返回第一次出现任意数字的位置，可选开始位置start</td></tr><tr><td>ANYSPACE(arg,start)</td><td>返回第一次出现任意空白的位置，可选开始位置start</td></tr><tr><td>CAT(arg1,arg2,…argn)</td><td>连接字符串，留下头尾空白</td></tr><tr><td>CATS(arg1,arg2,…argn)</td><td>连接字符串，删除头尾空白</td></tr><tr><td>CATX(‘separator-string’, arg-1,…,arg-n)</td><td>连接字符串，删除头尾空白并用指定标点连接</td></tr><tr><td>COMPRESS(arg, ‘char’)</td><td>移除字符串中的空格和可选字符</td></tr><tr><td>INDEX(arg, ‘string’)</td><td>返回指定字符在变量中的位置</td></tr><tr><td>LEFT(arg)</td><td>字符串左对齐</td></tr><tr><td>LENGTH(arg)</td><td>返回字符串长度，不考虑尾部空格</td></tr><tr><td>PROPCASE(arg)</td><td>首字母大写</td></tr><tr><td>SUBSTR(arg,position,n)</td><td>从字符串中提取指定开始位置指定长度字符</td></tr><tr><td>TRANSLATE(source,to1,from1,…ton,fromn)</td><td>替换字符</td></tr><tr><td>TRANWRD(source,from,to)</td><td>替换字符串</td></tr><tr><td>TRIM(arg)</td><td>删除尾部空白</td></tr><tr><td>UPCASE(arg)</td><td>替换成大写</td></tr></tbody></table><table><thead><tr><th>SAS数值函数</th><th></th></tr></thead><tbody><tr><td>INT(arg)</td><td>返回整数</td></tr><tr><td>LOG(arg)</td><td>自然对数</td></tr><tr><td>LOG10(arg)</td><td>$10$为底对数</td></tr><tr><td>MAX(arg1,arg2,…argn)</td><td>最大值</td></tr><tr><td>MEAN(arg1,arg2,…argn)</td><td>均值</td></tr><tr><td>MIN(arg1,arg2,…argn)</td><td>最小值</td></tr><tr><td>N(arg1,arg2,…argn)</td><td>非缺失值个数</td></tr><tr><td>NMISS(arg1,arg2,…argn)</td><td>缺失值个数</td></tr><tr><td>ROUND(arg, roundoffunit)</td><td>保留几位小数</td></tr><tr><td>SUM(arg1,arg2,…argn)</td><td>求和</td></tr></tbody></table><table><thead><tr><th>SAS日期函数</th><th></th></tr></thead><tbody><tr><td>DATEJUL(julian-date)</td><td>标准julian日期到SAS日期</td></tr><tr><td>DAY(date)</td><td>返回「日」</td></tr><tr><td>MDY(month,day,year)</td><td>年月日到SAS日期</td></tr><tr><td>MONTH(date)</td><td>返回「月」</td></tr><tr><td>QTR(date)</td><td>返回季度</td></tr><tr><td>TODAY()</td><td>今日</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几（周日为1）</td></tr><tr><td>YEAR(date)</td><td>返回「年」</td></tr><tr><td>YRDIF(start-date,end- date,’ACTUAL’)</td><td>返回相差年份</td></tr></tbody></table><h2>判断结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* if then structure</span><br><span class="line">if model = &apos;Pink&apos; then make = &apos;Floyd&apos;;</span><br><span class="line"></span><br><span class="line">* 执行多项命令，需要嵌套do；可以用and和or</span><br><span class="line">if Year then Model = &apos;Mac&apos; or Model = &apos;pro&apos; then Make = &apos;Jobs&apos;;</span><br><span class="line">if Model = &apos;iphone5&apos; then do;</span><br><span class="line">Make = &apos;Tim&apos;;</span><br><span class="line">Seats = 2;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">* if else</span><br><span class="line">if Cost = . then CostGroup = &apos;Missing&apos;;</span><br><span class="line">else if Cost else if Cost else CostGroup = high;</span><br><span class="line"></span><br><span class="line">* use if to select sub-set</span><br><span class="line">if sex = &apos;m&apos;;if sex = &apos;m&apos; then detele;</span><br></pre></td></tr></table></figure><h2>数组操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* Change all 9 to missing values;</span><br><span class="line">DATA songs;</span><br><span class="line">INFILE &apos;~/desktop/WBRK.dat&apos;;</span><br><span class="line">INPUT City $ 1-15 Age domk wj hwow simbh kt aomm libm tr filp ttr;</span><br><span class="line">ARRAY song (10) domk wj hwow simbh kt aomm libm tr filp ttr;</span><br><span class="line">DO i = 1 TO 10;</span><br><span class="line">IF song(i) = 9 THEN song(i) = .;</span><br><span class="line">END;</span><br><span class="line">RUN;</span><br><span class="line">PROC PRINT DATA = songs;</span><br><span class="line">TITLE &apos;WBRK Song Survey&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h2>基本模块调用</h2><p>搞定基本的函数之后，开始鼓捣$SAS$里面的模型。也就是说，要开始写<code>PROC</code>了。其实，$SAS$比较像$Stata$（计量经济学主流软件），无论是从输出的样式，还是语法。不习惯没有()的模型调用呀。若是说$SAS$和$Stata$的区别，怕只是$Stata$更侧重于<strong>计量模型</strong>而$SAS$则是服务于大多数<strong>统计模型</strong>吧。</p><h3>PROC的基本内容：CONTENT</h3><p><code>PROC:content</code>，可以显示数据集的主要特性。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBNAME tropical &apos;~/MySASLib&apos;;</span><br><span class="line">PROC CONTENTS DATA = tropical.banana;</span><br></pre></td></tr></table></figure><p>这里主要是两个声明:<code>TITLE</code>和<code>FOOTNOTE</code>。前者输出时候会产生一个标题，后者会产生尾注。用法也是比较直接的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TITLE ”Here’s another title”;</span><br><span class="line">TITLE ’Here’’s another title’;</span><br><span class="line">FOOTNOTE3 ’This is the third footnote’;</span><br></pre></td></tr></table></figure><h3>SAS PROC求子集:WHERE</h3><p>如果要在<code>PROC</code>里面先求子集的话，可以直接调用<code>WHERE</code>。感觉这里和$SQL$的思路比较像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROC PRINT DATA = &apos;～/desktop/MySASLib/style&apos;;</span><br><span class="line">WHERE Genre = &apos;Impressionism&apos;;</span><br><span class="line">TITLE &apos;Major Impressionist Painters&apos;;</span><br><span class="line">FOOTNOTE &apos;F = France N = Netherlands U = US&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h3>SAS PROC 数据进行排序:SORT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA marine;</span><br><span class="line">INFILE &apos;~/desktop/Lengths.dat&apos;;</span><br><span class="line">INPUT Name $ Family $ Length @@;</span><br><span class="line">RUN;</span><br><span class="line">* Sort the data;</span><br><span class="line">PROC SORT DATA = marine OUT = seasort NODUPKEY;</span><br><span class="line">BY Family DESCENDING Length;</span><br><span class="line">PROC PRINT DATA = seasort;</span><br><span class="line">TITLE &apos;Whales and Sharks&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>这样数据就按照<code>Family</code>、<code>Length</code>（递减）排序了。</p><h3>SAS PROC 输出数据:PRINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Candy.dat&apos;;</span><br><span class="line">INPUT Name $ 1-11 Class @15 DateReturned MMDDYY10. CandyType $</span><br><span class="line">Quantity;</span><br><span class="line">Profit = Quantity * 1.25;</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY Class;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">BY Class;</span><br><span class="line">SUM Profit;</span><br><span class="line">VAR Name DateReturned CandyType Profit;</span><br><span class="line">TITLE &apos;Candy Sales for Field Trip by Class&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h3>SAS PROC里面改变输出格式：FORMAT</h3><p>基本就是<code>FORMAT</code>一下就可以了，再就是<code>PUT</code>的时候也可以调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Candy.dat&apos;;</span><br><span class="line">INPUT Name $ 1-11 Class @15 DateReturned MMDDYY10. CandyType $</span><br><span class="line">Quantity;</span><br><span class="line">Profit = Quantity * 1.25;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">VAR Name DateReturned CandyType Profit;</span><br><span class="line">FORMAT DateReturned DATE9. Profit DOLLAR6.2;</span><br><span class="line">TITLE &apos;Candy Sale Data Using Formats&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>常用的格式有：</p><ul><li>文本型：<code>$HEXw.</code>和<code>$w.</code></li><li>日期型：<code>DATEw.</code>（输出为ddmmyy或者ddmmyyyy）、<code>DATETIMEw.d</code>（输出为ddmmyy:hh:mm:ss）、<code>DAYw.</code>（输出为dd）、<code>EURDFDDw.</code> 、<code>JULIANw.</code>、<code>MMDDYYw.</code>（输出为mmddyy或mmddyyyy）、<code>TIMEw.d</code>（输出为hh:mm:ss）、<code>WEEKDATEw.</code>（输出为工作日）、<code>WORDDATEw.</code>(输出为单词)。</li><li>数字型：<code>BESTw.</code>（自动选择）、<code>COMMAw.d</code>（逗号分隔）、<code>DOLLARw.d</code>（货币）、<code>Ew.</code>（科学计数法）、<code>PDw.d</code>、<code>w.d</code>（标准小数）</li></ul><p>输出的样本见下：</p><p>当然<code>FORMAT</code>还可以自定义<code>factor</code>型变量的输出格式，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA carsurvey;</span><br><span class="line">INFILE &apos;~/deskktop/Cars.dat&apos;;</span><br><span class="line">INPUT Age Sex Income Color $;</span><br><span class="line">PROC FORMAT;</span><br><span class="line">VALUE gender 1 = &apos;Male&apos; </span><br><span class="line">2 = &apos;Female&apos;;</span><br><span class="line">VALUE agegroup 13 -&lt; 20 = &apos;Teen&apos;</span><br><span class="line">20 -&lt; 65 = &apos;Adult&apos;</span><br><span class="line">65 - HIGH = &apos;Senior&apos;;</span><br><span class="line">VALUE $col &apos;W&apos; = &apos;Moon White&apos;</span><br><span class="line">&apos;B&apos; = &apos;Sky Blue&apos;</span><br><span class="line">&apos;Y&apos; = &apos;Sunburst Yellow&apos;</span><br><span class="line">&apos;G&apos; = &apos;Rain Cloud Gray&apos;;</span><br><span class="line">* Print data using user-defined and standard (DOLLAR8.) formats;</span><br><span class="line">PROC PRINT DATA = carsurvey;</span><br><span class="line">FORMAT Sex gender. Age agegroup. Color $col. Income DOLLAR8.;</span><br><span class="line">TITLE &apos;Survey Results Printed with User-Defined Formats&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>就可以把数字型的1，2转换为对应的文本<code>male</code>和<code>female</code>等，还可以把变量离散化。</p><h3>SAS总结数据:MEANS</h3><p>$SAS$当然还有类似于$Excel$的数据透视表和$R$的<code>data.table</code>的模块，就是<code>MEANS</code>。可以输出的描述性统计值，包括最大值、最小值、平均值、中位数、余非缺失值个数、缺失值个数、范围、标准差、和等等。此外，还可以使用<code>BY</code>或者<code>CLASS</code>进行分组统计，<code>VAR</code>选择变量等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Flowers.dat&apos;;</span><br><span class="line">INPUT CustomerID $ @9 SaleDate MMDDYY10. Petunia SnapDragon</span><br><span class="line">Marigold;</span><br><span class="line">Month = MONTH(SaleDate);</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY Month;</span><br><span class="line">* Calculate means by Month for flower sales;</span><br><span class="line">PROC MEANS DATA = sales;</span><br><span class="line">BY Month;</span><br><span class="line">VAR Petunia SnapDragon Marigold;</span><br><span class="line">TITLE &apos;Summary of Flower Sales by Month&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Summary of  Flower Sales by Month 1</span><br><span class="line">---------------- Month=5 --------------</span><br><span class="line">The MEANS Procedure</span><br><span class="line">Variable N Mean Std Dev Minimum Maximum</span><br><span class="line">----------------------------------------</span><br><span class="line">Petunia 3 86.6666667 35.1188458 50.0000000 120.0000000</span><br><span class="line">SnapDragon 3 113.3333333 41.6333200 80.0000000 160.0000000</span><br><span class="line">Marigold 3 81.6666667 25.6580072 60.0000000 110.0000000</span><br><span class="line">---------------- Month=6 ---------------</span><br><span class="line">Variable N Mean Std Dev Minimum Maximum</span><br><span class="line">-----------------------------------------</span><br><span class="line">Petunia 4 81.2500000 16.5201897 60.0000000 100.0000000</span><br><span class="line">SnapDragon 4 97.5000000 47.8713554 60.0000000 160.0000000</span><br><span class="line">Marigold 4 83.7500000 19.7378655 60.0000000 100.0000000</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure><p>当然这些统计量也可以直接的写入一个SAS数据表，只需要加上一个<code>OUTPUT</code>就可以了。原数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">756-01 05/04/2008 120 80 110</span><br><span class="line">834-01 05/12/2008 90 160 60</span><br><span class="line">901-02 05/18/2008 50 100 75</span><br><span class="line">834-01 06/01/2008 80 60 100</span><br><span class="line">756-01 06/11/2008 100 160 75</span><br><span class="line">901-02 06/19/2008 60 60 60</span><br><span class="line">756-01 06/25/2008 85 110 100</span><br></pre></td></tr></table></figure><p>SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Flowers.dat&apos;;</span><br><span class="line">INPUT CustomerID $ @9 SaleDate MMDDYY10. Petunia SnapDragon Marigold;</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY CustomerID;</span><br><span class="line">* Calculate means by CustomerID, output sum and mean to new data set;</span><br><span class="line">PROC MEANS NOPRINT DATA = sales;</span><br><span class="line">BY CustomerID;</span><br><span class="line">VAR Petunia SnapDragon Marigold;</span><br><span class="line">OUTPUT OUT = totals MEAN(Petunia SnapDragon Marigold) =</span><br><span class="line">MeanPetunia MeanSnapDragon MeanMarigold</span><br><span class="line">SUM(Petunia SnapDragon Marigold) = Petunia SnapDragon Marigold;</span><br><span class="line">PROC PRINT DATA = totals;</span><br><span class="line">TITLE &apos;Sum of Flower Data over Customer ID&apos;;</span><br><span class="line">FORMAT MeanPetunia MeanSnapDragon MeanMarigold 3.;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终结果为：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_01.png" width="90%" height="90%"></p><h3>SAS PROC统计频率：FREQ</h3><p>计数的话，就要靠SAS里面的<code>FREQ</code>模块了。比如我们有一个数据集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp w cap d cap w kon w ice w kon d esp d kon w ice d esp d</span><br><span class="line">cap w esp d cap d Kon d . d kon w esp d cap w ice w kon w</span><br><span class="line">kon w kon w ice d esp d kon w esp d esp w kon w cap w kon w</span><br></pre></td></tr></table></figure><p>然后可以用<code>FREQ</code>来统计一些基本量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA orders;</span><br><span class="line">INFILE &apos;~/desktop/Coffee.dat&apos;;</span><br><span class="line">INPUT Coffee $ Window $ @@;</span><br><span class="line">* Print tables for Window and Window by Coffee;</span><br><span class="line">PROC FREQ DATA = orders;</span><br><span class="line">TABLES Window Window * Coffee;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终会得到一个$2*5$的表格：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_02.png" width="90%" height="90%"></p><h3>SAS PROC汇报表格：TABULATE</h3><p>基本看到TABULATE就可以想到那个著名的软件Tabular了…不过貌似SAS也自带了一个类似的表格模块。这个东西可以变得非常复杂，不过鉴于一时半会儿还用不到，没有细细看。抄个例子吧。</p><p>原数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Silent Lady Maalea sail sch 75.00</span><br><span class="line">America II Maalea sail yac 32.95</span><br><span class="line">Aloha Anai Lahaina sail cat 62.00</span><br><span class="line">Ocean Spirit Maalea power cat 22.00</span><br><span class="line">Anuenue Maalea sail sch 47.50</span><br><span class="line">Hana Lei Maalea power cat 28.99</span><br><span class="line">Leilani Maalea power yac 19.99</span><br><span class="line">Kalakaua Maalea power cat 29.50</span><br><span class="line">Reef Runner Lahaina power yac 29.95</span><br><span class="line">Blue Dolphin Maalea sail cat 42.95</span><br></pre></td></tr></table></figure><p>SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36;</span><br><span class="line">RUN;</span><br><span class="line">* Tabulations with three dimensions;</span><br><span class="line">PROC TABULATE DATA = boats;</span><br><span class="line">CLASS Port Locomotion Type;</span><br><span class="line">TABLE Port, Locomotion, Type;</span><br><span class="line">TITLE &apos;Number of Boats by Port, Locomotion, and Type&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终结果：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_03.png" width="90%" height="90%"></p><p>类似的，还可以增加统计量（类似于<code>MEANS</code>那里）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36;</span><br><span class="line">RUN;</span><br><span class="line">* PROC TABULATE report with options;</span><br><span class="line">PROC TABULATE DATA = boats FORMAT=DOLLAR9.2;</span><br><span class="line">CLASS Locomotion Type;</span><br><span class="line">VAR Price;</span><br><span class="line">TABLE Locomotion ALL, MEAN*Price*(Type ALL)</span><br><span class="line">/BOX=&apos;Full Day Excursions&apos; MISSTEXT=&apos;none&apos;;</span><br><span class="line">TITLE;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以得到：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_04.png" width="90%" height="90%"></p><p>最后还可以混合<code>FORMAT</code>等等，可以变得相当的复杂。貌似这东西是美国劳工部鼓捣出来的格式…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36 Length 38-40;</span><br><span class="line">RUN;</span><br><span class="line">* Using the FORMAT= option in the TABLE statement;</span><br><span class="line">PROC TABULATE DATA = boats;</span><br><span class="line">CLASS Locomotion Type;</span><br><span class="line">VAR Price Length;</span><br><span class="line">TABLE Locomotion ALL,</span><br><span class="line">MEAN * (Price*FORMAT=DOLLAR6.2 Length*FORMAT=6.0) * (Type ALL);</span><br><span class="line">TITLE &apos;Price and Length by Type of Boat&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>BOSS级汇报表格呈现了…</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_05.png" width="90%" height="90%"><p>我只能感慨，不愧是商业软件啊，用户需求考虑的真的是特别的周到…这种费时费力做汇报表格的事情也被搞定了，强悍。</p><p>SAS里面的报告：REPORT还有一个REPORT，看到有TABULATE的时候我已经不奇怪并略略的有些期待一个做报告的模块出现了。这东西基本就是前面几个的超级混合体，反正你想搞到的汇报模式总是能够搞出来的。</p><p>又是一堆数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17 sci 9 bio 28 fic 50 mys 13 fic 32 fic 67 fic 81 non 38 non</span><br><span class="line">53 non 16 sci 15 bio 61 fic 52 ref 22 mys 76 bio 37 fic 86 fic</span><br><span class="line">49 mys 78 non 45 sci 64 bio 8 fic 11 non 41 fic 46 ref 69 fic</span><br><span class="line">34 fic 26 mys 23 sci 74 ref 15 sci 27 fic 23 mys 63 fic 78 non</span><br><span class="line">40 bio 12 fic 29 fic 54 mys 67 fic 60 fic 38 sci 42 fic 80 fic</span><br></pre></td></tr></table></figure><p>然后一堆SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DATA books;</span><br><span class="line">INFILE &apos;c:\MyRawData\LibraryBooks.dat&apos;;</span><br><span class="line">INPUT Age BookType $ @@;</span><br><span class="line">RUN;</span><br><span class="line">* Define formats to group the data;</span><br><span class="line">PROC FORMAT;</span><br><span class="line">VALUE agegpa</span><br><span class="line">0-18 = &apos;0 to 18&apos;</span><br><span class="line">19-25 = &apos;19 to 25&apos;</span><br><span class="line">26-49 = &apos;26 to 49&apos;</span><br><span class="line">50-HIGH = &apos; 50+ &apos;;</span><br><span class="line">VALUE agegpb</span><br><span class="line">0-25 = &apos;0 to 25&apos;</span><br><span class="line">26-HIGH = &apos; 26+ &apos;;</span><br><span class="line">VALUE $typ</span><br><span class="line">&apos;bio&apos;,&apos;non&apos;,&apos;ref&apos; = &apos;Non-Fiction&apos;</span><br><span class="line">&apos;fic&apos;,&apos;mys&apos;,&apos;sci&apos; = &apos;Fiction&apos;;</span><br><span class="line">RUN;</span><br><span class="line">*Create two way table with Age grouped into four categories;</span><br><span class="line">PROC FREQ DATA = books;</span><br><span class="line">TITLE &apos;Patron Age by Book Type: Four Age Groups&apos;;</span><br><span class="line">TABLES BookType * Age / NOPERCENT NOROW NOCOL;</span><br><span class="line">FORMAT Age agegpa. BookType $typ.;</span><br><span class="line">RUN;</span><br><span class="line">* Create two way table with Age grouped into two categories;</span><br><span class="line">PROC FREQ DATA = books;</span><br><span class="line">TITLE &apos;Patron Age by Book Type: Two Age Groups&apos;;</span><br><span class="line">TABLES BookType * Age / NOPERCENT NOROW NOCOL;</span><br><span class="line">FORMAT Age agegpb. BookType $typ.;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>然后一堆交叉计数的结果就出来了：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_06.png" width="90%" height="90%"></p><p>当然，简单的计算和分类统计也不在话下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA natparks;</span><br><span class="line">INFILE &apos;c:\MyRawData\Parks.dat&apos;;</span><br><span class="line">INPUT Name $ 1-21 Type $ Region $ Museums Camping;</span><br><span class="line">RUN;</span><br><span class="line">*Statistics in COLUMN statement with two group variables;</span><br><span class="line">PROC REPORT DATA = natparks NOWINDOWS HEADLINE;</span><br><span class="line">COLUMN Region Type N (Museums Camping),MEAN;</span><br><span class="line">DEFINE Region / GROUP;</span><br><span class="line">DEFINE Type / GROUP;</span><br><span class="line">TITLE &apos;Statistics with Two Group Variables&apos;;</span><br><span class="line">RUN;</span><br><span class="line">*Statistics in COLUMN statement with group and across variables;</span><br><span class="line">PROC REPORT DATA = natparks NOWINDOWS HEADLINE;</span><br><span class="line">COLUMN Region N Type,(Museums Camping),MEAN;</span><br><span class="line">DEFINE Region / GROUP;</span><br><span class="line">DEFINE Type / ACROSS;</span><br><span class="line">TITLE &apos;Statistics with a Group and Across Variable&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以得到一个看起来很fancy的表格：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_07.png" width="90%" height="90%"></p><h3>SAS数据总结综述</h3><p>我的感觉是，<code>MEANS</code>, <code>TABULATE</code>和<code>REPORT</code>这三个模块各有千秋，基本就是可以替代EXCEL的数据透视表，虽然效率上说不好谁比谁高。</p>]]></content>
    
    <summary type="html">
    
      由于接触到SAS，本人电脑为Macbook，暂时无法安装SAS，所以通过网上收集相关知识，Mark下
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="SAS" scheme="http://ulsonhu.cn/tags/SAS/"/>
    
  </entry>
  
  <entry>
    <title>Excel知识点备忘</title>
    <link href="http://ulsonhu.cn/Excel%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%87%E5%BF%98.html"/>
    <id>http://ulsonhu.cn/Excel知识点备忘.html</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-23T15:52:50.368Z</updated>
    
    <content type="html"><![CDATA[<p>Excel系统学习：<a href="http://study.163.com/course/courseMain.htm?courseId=670032" target="_blank" rel="noopener">视频教程</a></p><h2>相对引用与绝对引用</h2><ul><li><code>$A1</code>列绝对引用</li><li><code>A$1</code>行绝对引用</li><li><code>$A$1</code>行列都为绝对引用</li></ul><p>快捷键<code>F4</code></p><h2>条件格式</h2><p>学会使用条件格式，其中与混合应用交叉，可实现相关功能</p><h2>排序</h2><ul><li>一般排序</li><li>多条件排序</li><li>按照特定字段排序</li><li>排序的延伸</li></ul><h2>筛选</h2><h2>一、时间与日期函数</h2><ol><li><code>today()</code>返回日期格式的当前日期,输入日期快捷键<code>Ctrl+;</code></li><li><code>now()</code>,输入日期时间快捷键<code>Ctrl+Shift+;</code></li><li><code>weekday(serial_number,return_type)</code></li><li><code>workday()</code></li><li><code>dateif(start_date,end_date,unit[Y|M|D])</code>返回两个日期之间年/月/日的间隔数</li></ol><p>输入日期快捷键<code>Ctrl+;</code></p><h2>二、统计函数</h2><ol><li><code>count</code></li><li><code>countif(range,criteria)</code>计算区域中满足指定条件的单元格个数</li><li><code>countifs(range1,criteria1,range2,criteria2,...)</code></li><li><code>sumif(range,criteria,sum_range)</code></li><li><code>sumifs(sum_range,criteria_range1,criteria1,criteria_range2,criteria2,...)</code></li></ol><h2>三、查找和引用函数</h2><ol><li><code>vlookup(lookup_value,table_array,col_index_num,range_lookup)</code></li></ol><ul><li><code>lookup_value</code>需要在数据表第一列查找的数值</li><li><code>table_array</code>需要查找的数据区域</li><li><code>col_index_num</code>为待返回的匹配值的列序号</li><li><code>range_lookup</code>精确匹配与模糊匹配</li></ul><h3>关于跨表引用</h3><table><thead><tr><th>产品编号</th><th>系列</th><th>产品名称</th><th>进货单价</th></tr></thead><tbody><tr><td>AP11001</td><td>老婆饼</td><td>老婆饼（花生）</td><td>6.5</td></tr><tr><td>AP11002</td><td>老婆饼</td><td>老婆饼（桂花）</td><td>6.5</td></tr></tbody></table><p>如根据“产品编号”自动返回基本信息表“系列”字段内容<code>vlookup($D2,产品基本信息表!$B$3:$F$38,2,false)</code></p><blockquote><p>跨表查询，工作中常用</p></blockquote><p>注意：</p><ul><li>查找值一定要在第一列</li><li>模糊匹配时第一列一定要升序排列</li></ul><ol start="2"><li><code>index(查找的区域，区域内第几行，区域内第几列)</code>与<code>match(查找指定的值，查找所在区域，查找方式的参数)</code>，两者连用，基本可以替代’Vlookup()'的查找，其中’Vlookup()'只是针对文本内容的查找</li></ol><p>如<code>index(A:A,match(C1,B:B,0))</code></p><ol start="3"><li><blockquote><p>=Lookup（查找的值，值所在的位置，返回相应位置的值）</p></blockquote></li></ol><p><code>lookup()</code>函数弥补了<code>vlookup()</code>函数第三参数的劣势，但其本身也存在缺点，即不能精确匹配使用<code>lookup()</code>函数需要熟悉Excel数组的运算.详见<a href="http://study.163.com/course/courseLearn.htm?courseId=670032#/learn/video?lessonId=823422&amp;courseId=670032" target="_blank" rel="noopener">视频18课时62:00</a></p><ol start="4"><li><p><code>choose(index_num, value1, [value2], ...)</code></p></li><li><p><code>Offset(指定点，偏移多少行，偏移多少列，返回多少行，返回多少列)</code>建立坐标系，以坐标系为原点，返回距离原点的值或者区域。正数代表向下或向右，负数则相反。通过’Offset()'函数可以实现动态图标、动态数据透视表</p></li><li><p><code>Row()</code></p></li></ol><p>返回单元格所在的行</p><ol start="7"><li><code>Column()</code></li></ol><p>返回单元格所在的列</p><h2>四、文本函数</h2><ul><li><code>text(text)</code>设置数字格式并将其转换为文本</li><li><code>concatenate(text1,text2,...)</code>将几个文本项合并为一个文本项</li><li><code>len(text)</code>计算字符串的长度</li><li><code>mod(number,divisor)</code> 返回两数相除的余数。</li><li><code>right(text,num_chars)</code> 返回文本值中最右边的字符</li><li><code>left(text,num_chars)</code>返回文本值中最左边的字符</li><li><code>mid(text,start_num,num_chars))</code>从文本字符串中的指定位置起返回特定个数的字符</li><li><code>trim(text)</code>设置数字格式并将其转换为文本</li></ul><h2>五、数据透视表</h2><p>Excel中十分重要的一项功能，主要功能是将数据聚合，按照各子段进行<code>sum()</code>，<code>count()</code>的运算。应用范围</p><ul><li>包括大量复杂数据的表格，希望快速整理出一份具有实际意义的报表</li><li>希望找出同类数据在不同时期的某种特定关系</li><li>希望对数据进行合理有效的分组</li><li>需要经常查询分析数据的变化趋势</li><li>数据源经常变化，然而有需要经常分析和处理最新的数据源</li></ul><h3>数据分析</h3><p>查找<code>Ctrl+F</code>与替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=if(average(A2:A5)&gt;50,sum(B2:B5),0)</span><br><span class="line">=if(A2=10,&quot;科技处&quot;,if(A2=20,&quot;财务处&quot;,&quot;人事处&quot;))</span><br><span class="line">=sumif(销售记录汇总!$A$2:$A$107,$B5,销售记录汇总!$G$2,$G$107)</span><br><span class="line">=sumif(条件区域,条件值,求和区域)</span><br><span class="line"></span><br><span class="line">=sumifs(求和区域,条件区域,条件值)</span><br><span class="line">=sumif(销售记录汇总!$G$2,$G$107,销售记录汇总!$A$2:$A$107,$B5)</span><br></pre></td></tr></table></figure><p>条件可以是数字、表达式或文本，但是要使用引号</p><h3>数组计算相关</h3><p>计算结果<code>Ctrl+Shift+Enter</code></p><h2>杂类技巧</h2><ol><li>选择性粘贴 $\rightarrow $ 转置</li><li><code>column()``row()</code>返回当前列(行)数</li><li><code>Ctrl+Enter</code>，以当前单元格为始，往下填充数据和函数。</li><li><code>Ctrl+Space</code>，选定整列。<code>Shift+Space</code>，选定整行。</li><li><code>Alt+Enter</code>，换行。</li></ol>]]></content>
    
    <summary type="html">
    
      数据分析需要掌握的一些基本Excel姿势拾遗，后续不断更新
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Excel" scheme="http://ulsonhu.cn/tags/Excel/"/>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语句学习及总结</title>
    <link href="http://ulsonhu.cn/MySQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93.html"/>
    <id>http://ulsonhu.cn/MySQL语句学习及总结.html</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-04-28T07:54:34.101Z</updated>
    
    <content type="html"><![CDATA[<p>  推荐：<a href="http://zh.sqlzoo.net/" target="_blank" rel="noopener">在线SQL编辑网站</a></p><h1>一、数据库基础</h1><ol><li>创建数据库</li></ol><p><code>CREATE DATABASE database_name;</code></p><ol start="2"><li>查询数据库</li></ol><p><code>show create database &lt;database_name&gt;;</code></p><ol start="3"><li>删除数据库</li></ol><p><code>drop database &lt;database_name&gt;;</code></p><ol start="4"><li>修改数据库</li></ol><p><code>alter database &lt;database_name&gt; character set &lt;str_coll&gt; collate &lt;rules&gt;</code></p><p><strong>补充</strong>:</p><ul><li>切换数据库 <code>use db_name;</code> -&gt; 当有多个数据库的情况,需要<code>use db_name;</code> 先切换到要操作的数据库</li><li>查看当前正在使用数据库: <code>select database();</code></li></ul><ol start="5"><li>数据表操作:</li></ol><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">   column_1 column_1_type,</span><br><span class="line">   column_2 column_2_type,</span><br><span class="line">   column_3 column_3_type,</span><br><span class="line">   column_4 column_4_type</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2>1. SQL功能概述</h2><p>SQL（Structured Query Language，结构化查询语言）是用户操作关系数据库的通用语言。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520904956/2018_03_06.png" width="80%" height="80%"></p><h2>基本数据类型</h2><table><thead><tr><th>数据类型</th><th>说明</th><th>存储空间</th></tr></thead><tbody><tr><td>bit</td><td>数据类型是整型，其值只能是0、1或空值。(很省空间的一种数据类型，如果能够满足需求应该尽量多用)</td><td>$1$ byte</td></tr><tr><td>tinyint</td><td>数据类型能存储从$0~255$之间的整数。</td><td>$1$ byte</td></tr><tr><td>smallint</td><td>数据类型可以存储从$-32768~32767$之间的整数。这种数据类型对存储一些常限定在特定范围内的数值型数据非常有用</td><td>$2$ byte</td></tr><tr><td>int</td><td>数据类型可以存储从$-2^{31}-2^{31}$之间的整数。存储到数据库的几乎所有数值型的数据都可以用这种数据类型</td><td>$4$ byte</td></tr><tr><td>numeric(p,s) or decimal(p,s)</td><td>数据类型能用来存储从$-10^{38}-1~10^{38}-1$的固定精度和范围的数值型数据。</td><td>$\leq17$byte</td></tr><tr><td>char(n)</td><td>char数据类型用来存储指定长度的定长非统一编码型的数据,$n$表示字符串的最大长度，取值范围为$1~8000$ （若实际字符串控件小于n,系统自动在后面补空格）</td><td>$n$ byte</td></tr><tr><td>varchar(n)</td><td>可变长度的字符串类型,n表示字符串的最大长度。</td><td>字符数+2字节额外开销</td></tr><tr><td>text</td><td>text 数据类型用来存储大量的非统一编码型字符数据。</td><td>每个字符一个字节</td></tr><tr><td>nchar(n)</td><td>用来存储定长统一编码字符型数据。此数据类型能存储4000种字符，使用的字节空间上增加了一倍.</td><td>$2n$ byte</td></tr><tr><td>nvarchar(n)</td><td>数据类型用作变长的统一编码字符型数据。此数据类型能存储4000种字符，使用的字节空间增加了一倍.</td><td>字符数+2字节额外开销</td></tr><tr><td>ntext</td><td>可存储$2^{30}-1$个字符</td><td>每个字符$2$byte</td></tr></tbody></table><p><a href="http://download.csdn.net/detail/u012792686/9757894" target="_blank" rel="noopener">MySQL5中文参考手册</a> -&gt; 部分不知道的字段可以通过这个文档查询</p><h1>二、SQL数据操作语言</h1><h2>1.数据查询语句</h2><h3>1.1 查询语句的基本结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;目标列名序列&gt;  <span class="comment">--需要哪些列</span></span><br><span class="line">    <span class="keyword">From</span> &lt;表名&gt;      <span class="comment">--来自哪张表</span></span><br><span class="line">    [<span class="keyword">WHERE</span> &lt;行选择条件&gt;]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组依据列&gt;]</span><br><span class="line">    [<span class="keyword">HAVING</span> &lt;组&gt;]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序依据列&gt;]</span><br></pre></td></tr></table></figure><p><code>SELECT</code>子句用于指定输出的字段</p><p><code>FROM</code>子句用于指定数据的来源</p><p><code>WHERE</code>子句用于指定数据的选择条件</p><p><code>GROUP BY</code>子句用于对检索到的记录进行分组</p><p><code>HAVING</code> 子句用于指定组的选择条件</p><p><code>ORDER BY</code> 子句用于对查询的结果进行排序</p><h3>1.2 单表查询</h3><ol><li>选择表中列数据</li></ol><p><code>SELECT &lt;column_name[*]&gt; FROM &lt;table_name&gt;</code></p><p>例子 ：<code>SELECT Sname,year(getdata()) - year(Birthdate) FROM Student</code></p><ol start="2"><li>选择表中的若干元祖</li></ol><ul><li>消除取值相同的行：<code>DISTINCT</code></li></ul><p><code>SELECT DISTINCT &lt;val&gt; FROM &lt;table_name&gt;</code></p><p>例子 ：<code>SELECT DISTINCT Tom FROM Student</code></p><ul><li>查询满足条件的元组</li></ul><table><thead><tr><th>查询条件</th><th>谓 词</th></tr></thead><tbody><tr><td>比较</td><td>=、&gt;、&gt;=、&lt;=、&lt;、&lt;&gt;、!=、!&gt;、!&lt;</td></tr><tr><td>确定范围</td><td>BETWEEN…AND、 NOT BETWEEN…AND</td></tr><tr><td>确定集合</td><td>IN 、NOT IN</td></tr><tr><td>字符匹配</td><td>LIKE 、NOT LIKE</td></tr><tr><td>空值</td><td>IS NULL、IS NOT NULL</td></tr><tr><td>多重条件（逻辑谓词）</td><td>AND、OR</td></tr></tbody></table><ol start="3"><li>对查询结果进行排序:将查询结果按照指定的顺序显示。<code>ASC</code>表示按列值升序排列（从上往下，值从大到小）。<code>DESC</code>表示按列值降序排列（从上往下，值从小到大）。默认为<code>ASC</code>。</li></ol><p><code>ORDER BY &lt;column_name&gt; [ASC|DESC]</code></p><p>例子 ：<code>SELECT Sno,Grade FROM SC ORDER BY Grade DESC</code></p><ol start="4"><li>使用聚合函数统计数据:聚合函数也称为统计函数或集合函数，作用是对一组值进行计算并返回一个统计结果。</li></ol><table><thead><tr><th>聚合函数</th><th>含义</th></tr></thead><tbody><tr><td>COUNT(*)</td><td>统计表中元组的个数</td></tr><tr><td>COUNT([DISTINCT]&lt;column_name&gt;)</td><td>统计本列的非空列值个数</td></tr><tr><td>SUM(&lt;column_name&gt;)</td><td>计算列值的和值（必须是数值型列）</td></tr><tr><td>AVG(&lt;column_name&gt;)</td><td>计算列值的平均值（必须是数值型列）</td></tr><tr><td>MAX(&lt;column_name&gt;)</td><td>计算列值的最大值</td></tr><tr><td>MIN(&lt;column_name&gt;)</td><td>计算列值的最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（统计学生总人数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计“001”学号学生的考试平均成绩）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno = <span class="string">'001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询“C001”号课程考试成绩的最高分和最低分）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(Grade) 最高分,<span class="keyword">MIN</span>(Grade) 最低分 <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br></pre></td></tr></table></figure><p>注意：聚合函数不能出现在WHERE子句中！</p><ol start="5"><li>对数据进行分组统计:需要先对数据进行分组，然后再对每个组进行统计。分组子句<code>GROUP BY</code>。在一个查询语句中，可以用多个列进行分组。分组子句跟在<code>WHERE</code>子句的后面：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY &lt;分组依据列&gt;[,...n]</span><br><span class="line">    [HAVING &lt;组筛选条件&gt;]</span><br></pre></td></tr></table></figure><h3>1.3 多表连接查询</h3><p>若一个查询同时涉及到两张或以上的表，则称为连接查询。</p><p>####1. 内连接:使用内连接时，如果两个表的相关字段满足条件，则从两个表中提取数据组成新的记录。</p><p><code>FROM &lt;table1&gt; [INNER] JOIN &lt;table2&gt; ON &lt;Join Condition&gt;</code></p><p>注意：连接条件中的连接字段必须是可比的，必须是语义相同的列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询学生及选课的详细信息）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.Sno = SC.Sno</span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询计算机系学生的选课情况，列出该学生的名字、所修课程号、成绩）---行选择条件</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname,Cno,Grade <span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计每个系的平均成绩） ---分组的多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> Dept,<span class="keyword">AVG</span>(Grade) <span class="keyword">AS</span> AverageGrade <span class="keyword">FROM</span> Student S <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">Group</span> <span class="keyword">BY</span> Dept</span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计计算机系每个学生的选课门数、平均成绩、最高成绩、最低成绩）--分组和行选择条件的多表连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">COUNT</span>(*),<span class="keyword">AVG</span>(Grade),<span class="keyword">MAX</span>(Grade),<span class="keyword">MIN</span>(Grade) <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span> <span class="keyword">Group</span> <span class="keyword">BY</span> Dept</span><br></pre></td></tr></table></figure><h4>补充：</h4><p><font color="blue">INNER JOIN连接三个表、五个表以上时的SQL语句</font></p><ul><li>连接三个数据表，语法格式可以概括为：</li></ul><p>FROM (table1 INNER JOIN table2 ON table1.key = table2.key) INNER JOIN table3 ON table1.key = table3.key</p><ul><li>连接四个数据表，语法格式可以概括为：</li></ul><p>FROM ((table1 INNER JOIN table2 ON table1.key=table2.key) INNER JOIN table3 ON table1.key=table3.key) INNER JOIN table4 ON Member.key=table4.key</p><blockquote><p>遵循的规则就是从内而外依次执行</p></blockquote><h4>2. 自连接:</h4><p>自连接是一种特殊的内连接，相互连接的表在物理上是一张表，但在逻辑上可以看做是两张表。</p><p><code>FROM &lt;table1&gt; AS T1 JOIN &lt;table1&gt; AS T2</code></p><p>通过为表取别名的方法，可以让物理上的一张表在逻辑上成为两张表。<font color="blue">（一定要为表取别名！）</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询与刘晨在同一个系学习的学生的姓名、所在系）</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.Sname,S1.Dept <span class="keyword">FROM</span> Student S1 <span class="keyword">JOIN</span> Student S2 </span><br><span class="line"><span class="keyword">ON</span> S1.Dept = S2.Dept   <span class="comment">--同一个系的学生</span></span><br><span class="line"><span class="keyword">WHERE</span> S2.Sname = <span class="string">'刘晨'</span>  <span class="comment">--S2表作为查询条件</span></span><br><span class="line"><span class="keyword">AND</span> S1.Sname != <span class="string">'刘晨'</span>  <span class="comment">--S1表作为结果表，并从中去掉‘刘晨’本人信息</span></span><br></pre></td></tr></table></figure><h4>3. 外连接:</h4><p>在内连接操作中，只有满足条件的元祖才能出现在查询结果集中。外连接是只限制一张表中的数据必须满足条件，而另一张表的数据可以不满足条件。</p><p><code>FROM &lt;table1&gt; LEFT|RIGHT [OUTER] JOIN &lt;table2&gt; ON &lt;Join Condition&gt;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEFT [OUTER] JOIN <span class="comment">--称为左外连接，含义是限制表2中的数据必须满足条件，但不管表1中的数据是否满足条件，均输出表1中的数据。 </span></span><br><span class="line">LEFT [OUTER] JOIN <span class="comment">--称为右外连接，含义是限制表1中的数据必须满足条件，但不管表2中的数据是否满足条件，均输出表2中的数据。</span></span><br></pre></td></tr></table></figure><h2>2.数据更改功能</h2><h3>2.1 插入数据</h3><p><code>INSERT INTO &lt;table_name&gt;[(column_name)] VALUES (val)</code></p><p>（1）简单插入语句</p><p>INSERT INTO Student VALUES (‘001’,‘陈东’,‘男’,‘1996/6/23’,‘信息管理系’)</p><p>（2）多行插入语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">VALUES</span>(<span class="string">'001'</span>,<span class="string">'C001'</span>,<span class="number">90</span>),</span><br><span class="line">                     (<span class="string">'001'</span>,<span class="string">'C002'</span>,<span class="number">30</span>),</span><br><span class="line">                     (<span class="string">'001'</span>,<span class="string">'C005'</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>（3）不按表顺序插入语句</p><p>按与表列顺序不同的顺序插入数据<code>INSERT INTO Student(Sno,Sname,Sex,Dept) VALUES ('001','陈东','男','1996/6/23','信息管理系')</code></p><h3>2.2 更新数据</h3><p><code>UPDATE &lt;table_name&gt; SET column_name = val</code></p><p>（1）无条件更新</p><p><code>UPDATE SC SET Grade = Grade+10</code></p><p>（2）有条件更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（将“C001”号课程的学分改成5分）</span></span><br><span class="line"><span class="keyword">UPDATE</span> Course <span class="keyword">SET</span> Grade = <span class="number">5</span> <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（将计算机系全体学生的成绩加5分）</span></span><br><span class="line"><span class="keyword">UPDATE</span> SC <span class="keyword">SET</span> Grade = Grade+<span class="number">5</span> <span class="keyword">FROM</span> SC <span class="keyword">JOIN</span> Student S <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span></span><br></pre></td></tr></table></figure><h3>2.3 删除数据</h3><p><code>DELETE [TOP (expression) [PERCENT]] FROM &lt;table_name&gt;</code></p><p>（1）无条件删除</p><p><code>DELETE FROM Student</code></p><p>（2）有条件删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（删除所有考试成绩不合格的学生的选课记录）</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Grade &lt; <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（删除Student表中2.5%的行数据）</span></span><br><span class="line"><span class="keyword">DELETE</span> TOP (<span class="number">2.5</span>) <span class="keyword">PERCENT</span> <span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><h1>三、高级查询</h1><h2>1. CASE函数</h2><p>CASE函数是一种多分支函数，它可以根据条件列表的值返回多个可能的结果表达式中的一个。</p><h3>1.1 简单CASE函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">    WHEN when_expression THEN result_expression</span><br><span class="line">    [...n]</span><br><span class="line">    [ELSE else_expression]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li><code>input_expression</code>：所计算的表达式，可以是一个变量名、字段名、函数或子查询。</li><li><code>when_expression</code> ：要与input _expression进行比较的简单表达式。简单表达式中不可包含比较运算法，只需给出被比较的表达式或值。</li><li><code>else_expression</code> ： 比较结果均不为TRUE时返回的表达式。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询选了JAVA课程的学生的学号、姓名、所在系、成绩，</span></span><br><span class="line"><span class="comment">--若所在系为“计算机系”，则显示“CS”；若所在系为“信息管理系”，则显示“IM”；若所在系为“通信工程系”，则显示“COM”）</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> Dept</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'计算机系'</span> <span class="keyword">THEN</span> <span class="string">'CS'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'信息管理系'</span> <span class="keyword">THEN</span> <span class="string">'IM'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'通信工程系'</span> <span class="keyword">THEN</span> <span class="string">'COM'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 所在系,Grade 成绩</span><br><span class="line">    <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno </span><br><span class="line">    <span class="keyword">JOIN</span> Course C <span class="keyword">ON</span> C.Cno = SC.Cno</span><br><span class="line">    <span class="keyword">WHERE</span> Cname = <span class="string">'Java'</span></span><br></pre></td></tr></table></figure><h3>1.2 搜索CASE函数</h3><p>简单 CASE函数只能将<code>input_expression</code>与一个单值进行比较，如果需要跟一个范围内的值进行比较，就需要搜索<code>CASE</code>函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">    WHEN Boolean_expression THEN result_expression</span><br><span class="line">    [...n]</span><br><span class="line">    [ELSE else_expression]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><code>Boolean_expression</code> ：比较表达式，可以包含比较运算符，直接将两者进行比较。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上述例子也可以用搜索CASE函数：</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'计算机系'</span> <span class="keyword">THEN</span> <span class="string">'CS'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'信息管理系'</span> <span class="keyword">THEN</span> <span class="string">'IM'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'通信工程系'</span> <span class="keyword">THEN</span> <span class="string">'COM'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 所在系,Grade 成绩</span><br><span class="line">    <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno </span><br><span class="line">    <span class="keyword">JOIN</span> Course C <span class="keyword">ON</span> C.Cno = SC.Cno</span><br><span class="line">    <span class="keyword">WHERE</span> Cname = <span class="string">'Java'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询C001课程的考试情况，列出学号和成绩，然后根据成绩划分等级）</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> Grade &gt;= <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">'优'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">99</span> <span class="keyword">THEN</span> <span class="string">'良'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">79</span> <span class="keyword">THEN</span> <span class="string">'中'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">69</span> <span class="keyword">THEN</span> <span class="string">'及格'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 成绩</span><br><span class="line">    <span class="keyword">FROM</span>  SC <span class="keyword">ON</span> <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br></pre></td></tr></table></figure><h2>2. 子查询</h2><p>如果一个<code>SELECT</code>语句嵌套在另一个<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>语句中，则称为子查询或内层查询；而包含子查询的语句称为主查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> cunstomers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> cust_id </span><br><span class="line">        <span class="keyword">FROM</span> orders </span><br><span class="line">        <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num </span><br><span class="line">                <span class="keyword">FROM</span> orderitems </span><br><span class="line">                <span class="keyword">WHERE</span> prod_id = <span class="string">'TN2'</span>););</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用联结操作简化子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> cunstomers,orders,orderitems <span class="comment">--good</span></span><br><span class="line"><span class="keyword">WHERE</span> cunstomers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'TN2'</span>;</span><br></pre></td></tr></table></figure><p>子查询通常用于满足下列需求之一：</p><ul><li>把一个查询分解成一系列的逻辑步骤</li><li>提供一个列表作为<code>WHERE</code>子句和<code>IN</code>、<code>EXISTS</code>、<code>ANY</code>、<code>ALL</code>的目标对象</li><li>提供由外层查询中每一条记录驱动的查询</li></ul><p>子查询通常有几种形式：</p><ul><li><code>WHERE 列名 [NOT] IN (子查询)</code></li><li><code>WHERE 列名 比较运算符 (子查询)</code></li><li><code>WHERE EXISTS(子查询)</code></li></ul>]]></content>
    
    <summary type="html">
    
      准备面试数据分析岗，学习一下数据库和SQL语言知识，总结如下。
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="SQL" scheme="http://ulsonhu.cn/tags/SQL/"/>
    
      <category term="数据库" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VC维理论-统计学习理论基础</title>
    <link href="http://ulsonhu.cn/VC%E7%BB%B4%E7%90%86%E8%AE%BA-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"/>
    <id>http://ulsonhu.cn/VC维理论-统计学习理论基础.html</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-03-12T16:25:46.823Z</updated>
    
    <content type="html"><![CDATA[<p>目录：</p><ul><li>说说历史</li><li>Hoeffding不等式</li><li>Connection to Learning</li><li>学习可行的两个核心条件</li><li>Effective Number of Hypotheses</li><li>Growth Function</li><li>Break Point与Shatter</li><li>VC Bound</li><li>VC dimension</li><li>深度学习与VC维</li><li>小结</li><li>参考文献</li></ul><p>VC维在机器学习领域是一个很基础的概念，它给诸多机器学习方法的可学习性提供了坚实的理论基础，但有时候，对我们而言，SVM，LR，深度学习等可能都已经用到线上了，但却不理解VC维。</p><p>这里，在台湾大学<a style="color: #109eff" href="https://www.coursera.org/course/ntumlone" target="_blank" rel="noopener">机器学习基石</a>课程的基础上，我们简单聊聊“VC维的来龙去脉”。我们将解决以下问题：为什么某机器学习方法是可学习的？为什么会有过拟合？拿什么来衡量机器学习模型的复杂度？深度学习与VC维的关系？</p><h2>说说历史</h2><p>在讲VC维之前，我们不妨来说说VC维的历史。而说起VC维的历史，又不得不提起神经网络，一方面是因为神经网络与VC维的发明过程是交织在一起的，另一方面是由于神经网络乏善可陈的泛化控制方法，深度学习在理论基础上一直被怀疑，甚至神经网络和VC维的代表SVM还一起争风吃醋过好多年。</p><ul><li>1943年，模拟神经网络由麦卡洛可（McCulloch）和皮茨（Pitts)提出，他们分析了理想化的人工神经元网络，并且指出了它们进行简单逻辑运算的机制。</li><li>1957年，康奈尔大学的实验心理学家弗兰克·罗森布拉特(Rosenblatt)在一台IBM–704计算机上模拟实现了一种他发明的叫作“感知机”（Perceptron）的神经网络模型。神经网络与支持向量机都源自于感知机（Perceptron）。</li><li>1962年，罗森布拉特著作：《神经动力学原理：感知机和大脑机制的理论》（Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms）。</li><li>1969年，明斯基和麻省理工学院的另一位教授佩普特合作著作：《感知机：计算几何学》（Perceptrons: An Introduction to Computational Geometry)。在书中，明斯基和佩普特证明单层神经网络不能解决XOR（异或）问题。</li><li>1971年，V. Vapnik and A. Chervonenkis在论文“On the uniform convergence of relative frequencies of events to their probabilities”中提出<strong>VC维</strong>的概念。</li><li>1974年，V. Vapnik提出了结构风险最小化原则。</li><li>1974年，沃波斯（Werbos）的博士论文证明了在神经网络多加一层，并且利用“后向传播”（Back-propagation）学习方法，可以解决XOR问题。那时正是神经网络研究的低谷，文章不合时宜。</li><li>1982年，在加州理工担任生物物理教授的霍普菲尔德，提出了一种新的神经网络，可以解决一大类模式识别问题，还可以给出一类组合优化问题的近似解。这种神经网络模型后被称为霍普菲尔德网络。</li><li>1986年，Rummelhart与McClelland发明了神经网络的学习算法Back Propagation。</li><li>1993年，Corinna Cortes和Vapnik等人提出了支持向量机(support vector machine)。神经网络是多层的非线性模型，支持向量机利用核技巧把非线性问题转换成线性问题。</li><li>1992~2005年，SVM与Neural network之争，但被互联网风潮掩盖住了。</li><li>2006年，Hinton提出神经网络的Deep Learning算法。Deep Learning假设神经网络是多层的，首先用Restricted Boltzmann Machine（非监督学习）学习网络的结构，然后再通过Back Propagation（监督学习）学习网络的权值。</li><li>现在，deep learning的应用越来越广泛，甚至已经有超越SVM的趋势。一方面以Hinton，Lecun为首的深度学习派坚信其有效实用性，另一方面Vapnik等统计机器学习理论专家又坚持着理论阵地，怀疑deep learning的泛化界。</li></ul><h2>Hoeffding不等式</h2><p>Hoeffding不等式是关于一组随机变量均值的概率不等式。 如果$X_1,X_2,\cdots,X_n$为一组独立同分布的参数为$p$的伯努利分布随机变量，$n$为随机变量的个数。定义这组随机变量的均值为：$$\bar{X}=\frac{X_1+X_2+\cdots+X_n}{n}$$</p><p>对于任意$\sigma &gt; 0$, Hoeffding不等式可以表示为</p><p>$$P(|\bar{X}-E(\bar{X})|\geq \sigma) \leq exp(-2{\sigma}^2n^2)$$</p><p>更多请参考:<a style="color: #109eff" href="http://science.scileaf.com/library/2461" target="_blank" rel="noopener">Hoeffding不等式</a>，<a style="color: #109eff" href="http://zh.wikipedia.org/zh-cn/%E9%9B%86%E4%B8%AD%E4%B8%8D%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">集中不等式</a></p><h3>示例:</h3><p>在统计推断中，我们可以利用样本的统计量(statistic)来推断总体的参数(parameter)，譬如使用样本均值来估计总体期望。如下图所示，我们从罐子里抽球，希望估计罐子里红球和绿球的比例。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780790/2018_03_04_01bin_sample.png" alt="bin_sample" width="60%" height="60%">直觉上，如果我们有更多的样本(抽出更多的球)，则样本期望$v$应该越来越接近总体期望$\mu $。事实上，这里可以用hoeffding不等式表示如下：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780789/2018_03_04_02.png" width="50%" height="50%">从hoeffding不等式可以看出，当$n$逐渐变大时，不等式的UpperBound越来越接近0，所以样本期望越来越接近总体期望。</p><h2>Connection to Learning</h2><p>接下来，我们希望可以将机器学习关联到上一节讨论的hoeffding不等式。一个基本的机器学习过程如下图所示。其中的概念定义为：</p><ul><li>$f$ 表示理想的方案(可以是一个函数，也可以是一个分布)</li><li>$H$ 是该机器学习方法的假设空间</li><li>$g$ 表示我们求解的用来预测的假设，$g$属于$H$</li></ul><p><font color="blue">机器学习的过程就是：通过算法$A$，在假设空间$H$中，根据样本集$D$，选择最好的假设作为$g$。选择标准是$g$近似于$f$。</font><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780789/2018_03_04_03.png" width="80%" height="80%"></p><p>拿<a style="color: #109eff" href="http://zh.wikipedia.org/zh/%E6%84%9F%E7%9F%A5%E5%99%A8" target="_blank" rel="noopener">感知机(perceptron)</a>来举例。</p><p>感知机（perceptron）是一个线性分类器(linear classifiers）。 线性分类器的几何表示：直线、平面、超平面。</p><p>perceptron的假设空间，用公式描述，如下所示：$$h(x)=sign((\sum_{i=1}^{n})-threshod)$$</p><p>感知器的优化目标如下式所示，$w_g$就是我们要求的最好的假设。$$W_g\rightarrow argmin\sum_{n=1}^{N}\left [y_n \neq sign(W^Tx_n)  \right ]$$</p><p>设定两个变量，如下图所示，图中 $f(x)$表示理想目标函数，$h(x)$是我们预估得到的某一个目标函数，$h(x)$是假设空间$H$中的一个假设。<strong>$E_{out}(h)$</strong>，可以理解为在理想情况下(已知f)，总体(out-of-sample)的损失(这里是0–1 loss)的期望，称作expected loss。<strong>$E_{in}(h)$</strong>，可以理解为在训练样本上(in-of-sample)，损失的期望，称作expirical loss。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781757/2018_03_05learning_hoeffding.png" width="80%" height="80%"><p>当训练样本量$N$足够大，且样本是独立同分布的，类比于上面“抽球”的例子，可以通过样本集上的expirical loss $E_{in}(h)$ 推测总体的expected loss $E_{out}(h)$。基于Hoeffding不等式，我们得到下面式子：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781760/2018_03_05_02.png" width="80%" height="80%">根据上面不等式，我们可以推断，当$N$足够大时，expected loss和expirical loss将非常接近。注意在上面推导中，我们是针对某一个特定的解$h(x)$。在我们的假设空间$H$中，往往有很多个假设函数(甚至于无穷多个)，这里我们先假定$H$中有$M$个假设函数。那么对于整个假设空间，也就是这M个假设函数，可以推导出下面不等式：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781758/2018_03_05hoeffding_12.png" width="80%" height="80%"></p><p>上面式子的含义是：在假设空间$H$中，设定一个较小的$\epsilon$值，任意一个假设$h$，它的$E_{in}(h)$与$E_{out}(h)$的差由该值$2\cdot M\cdot exp{-2\epsilon^2\cdot N}$所约束住。注意这个bound值与 “样本数$N$和假设数$M$” 密切相关。</p><h2>学习可行的两个核心条件</h2><p>在往下继续推导前，先看一下<strong>什么情况下Learning是可行的</strong>?</p><p>如果假设空间$H$的size M是有限的，当$N$足够大时，那么对假设空间中任意一个$g$，$E_{out}(g)$约等于$E_{in}(g)$；利用算法A从假设空间$H$中，挑选出一个$g$，使得$E_{in}(g)$接近于0，那么<a style="color: #109eff" href="http://en.wikipedia.org/wiki/Probably_approximately_correct_learning" target="_blank" rel="noopener">probably approximately correct</a>而言，$E_{out}(g)$也接近为0；</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781759/2018_03_05x.png" width="80%" height="80%">上面这两个核心条件，也正好对应着test和train这两个过程。train过程希望损失期望(即$E_{in}(g)$)尽可能小；test过程希望在真实环境中的损失期望也尽可能小，即$E_{in}(g)$接近于$E_{out}(g)$。<p>但往往我们更多在关心，如何基于模型的假设空间，利用最优化算法，找到$E_{in}$最小的解$g$。但容易忽视test这个过程，如果让学习可行，不仅仅是要在训练集表现好，在真实环境里也要表现好。从上述推导出来的不等式，我们看到假设数$M$在这两个核心条件中有着重要作用。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781760/2018_03_05.png" width="80%" height="80%"></p><p>$M$太小，当$N$足够大时，$E_{in}和$E_{out}$比较接近，但如果候选假设集太小，不容易在其中找到一个$g$，使得$E_{in}(g)$约等于0，第二项不能满足。而如果$M$太大，这时候选集多了，相对容易在其中找到一个$g$，使得$E_{in}(g)$约等于0，但第一项就不能满足了。所以假设空间$H$的大小$M$很关键。</p><p>对于一个假设空间，$M$可能是无穷大的。要能够继续推导下去，那么有一个直观的思路，能否找到一个有限的因子$m_H$来替代不等式bound中的$M$。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_06.png" width="80%" height="80%"><p>虽说假设空间很大，上述推导里，我们用到了$P(h_1,h_2,\cdots ,h_m) \leq P(h_1) + P(h_2) + \cdots + P(h_m)$。但事实上，多个$h$之间并不是完全独立的，他们是有很大的重叠的，也就是在$M$个假设中，可能有一些假设可以归为同一类。</p><p>下面我们以二维假设空间为例，来解释一下该空间下各假设在确定的训练样本上的重叠性。</p><p>举例来说，如果我们的算法要在平面上(二维空间)挑选一条直线方程作为$g$，用来划分一个点$x_1$。假设空间$H$是所有的直线，它的size M是无限多的。但是实际上可以将这些直线分为两类，一类是把$x_1$判断为正例的，另一类是把$x_1$判断为负例的。如下图所示：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_07.png" width="50%" height="50%"></p><p>那如果在平面上有两个数据点$x_1,x_2$，这样的话，假设空间$H$中的无数条直线可以分为4类。那依次类推，3个数据点情况下，$H$中最多有8类直线。4个数据点，$H$中最多有14类直线<font color="blue">(注意：为什么不是16类直线)</font>。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_08.png" width="60%" height="60%">从上面在二维假设空间中的分析，我们可以推测到一个结论，假设空间size M是很大，但在样本集$D$上，有效的假设函数数目是有限的。接下来我们将继续推导这个有效的假设函数值。</p><h2>Effective Number of Hypotheses</h2><p>对于这个有效的假设函数值，我们尝试用一个数学定义来说明：从$H$中任意选择一个方程$h$，让这个$h$对样本集合$D$进行二元分类，输出一个结果向量。例如在平面里用一条直线对2个点进行二元分类，输出可能为${1,–1}，{–1,1}，{1,1}，{–1,–1}$，这样每个输出向量我们称为一个dichotomy。</p><p>下面是hypotheses与dichotomies的概念对比：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782701/2018_03_05_09.png" width="80%" height="80%">注意到，如果对平面上的4个点来分类，根据前面分析，输出的结果向量只有14种可能，即有14个dichotomies。如果有$N$个样本数据，那么有效的假设个数定义为： $effective(N) = H$作用于样本集$D$“最多”能产生多少不同的dichotomy。所以有一个直观思路，能否用$effective(N)$来替换Hoeffding不等式中的M。接下来我们来分析下$effective(N)$。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_10.png" width="80%" height="80%"><h2>Growth Function</h2><p>$H$作用于$D$“最多”能产生多少种不同的dichotomies？</p><p>这个数量与假设空间$H$有关，跟数据量$N$也有关。将$H$作用于$D$“最多”能产生的dichotomies数量(即effective(N) )表示为数学符号：$max_H(x_1,x_2,\cdots,x_N)$</p><p>这个式子又称为“成长函数”(growth function)。在$H$确定的情况下，growth function是一个与$N$相关的函数。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782701/2018_03_05_11.png" width="80%" height="80%"></p><p>下图举4个例子，分别计算其growth function：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783290/2018_03_05_12.png" width="80%" height="80%">对于第一个例子，positive ray，相当于是正向的射线。该假设空间，作用于1个样本点，可以产生2种dichotomies：(–1)，(+1)。作用于2个样本点，可以产生3种dichotomies：(–1,+1)，(–1,–1)，(+1,+1)。作用于3个样本点，可以产生4种dichotomies。依次类推，可以推导出其成长函数 $m_H(N)=N+1$；求解出$m_H(N)$后，那是不是可以考虑用$m_H(N)$替换$M$? 如下所示：$$P[|E_{in}(g)-E_{out}(g)|>\epsilon]\leq 2\cdot m_H(N)\cdot N $$<h2>Break Point与Shatter</h2><p>在进一步推导前，再看两个概念：<font color="blue">shatter，break point。</font></p><p><strong>Shatter的概念</strong>：当假设空间H作用于$N$个input的样本集时，产生的dichotomies数量等于这$N$个点总的组合数$2N$是，就称：这$N$个inputs被$H$给shatter掉了。</p><p>要注意到 shatter 的原意是“打碎”，在此指“$N$个点的所有(碎片般的)可能情形都被H产生了”。所以$m_{H}=2N$的情形是即为“shatter”。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520784111/2018_03_05_13.png"><p>对于给定的成长函数$m_H(N)$，从$N=1$出发，$N$慢慢变大，当增大到$k$时，出现$m_{H}(N)&lt;2k$的情形，则我们说k是该成长函数的<strong>break point</strong>。对于任何$N&lt; k$个inputs而言，$H$都没有办法再shatter他们了。</p><p>举例来说，对于上面的positive ray的例子，因为$m_H(N)=N+1$，当$N=2$时，$m_H(2)&lt;2^2$， 所以它的break point就是2。</p><h2>VC Bound</h2><p>说完break point的概念后，再回到成长函数。我们将成长函数的上界，设为$B(N,k)$，意为：maximum possible $m_H(N)$ when $break point = k$。</p><p>那么我们做一些简单的推导：</p><ul><li>$B(2,2)=3$。因为break point=2，任意两个点都不能被shatter，$m_H(2)$肯定小于$2^2$，所以$B(2,2)=3$。</li><li>$B(3,2)=4$。因为任意两个点都不能被shatter，那么3个点产生的dichotomies不能超过4，所以$B(3,2)=4$。</li><li>$B(N,1)=1$。</li><li>$B(N,k)=2^N \quad for \quad N &lt; k$;$\qquad B(N,k)=2^{N–1} \quad for \quad N=k$；</li><li>$B(4,3)=？$去掉其中的一个数据点$x_4$后，考虑到break point=3，余下数据$(x1,x2,x3)$的dichotomies数目不能超过$B(3,3)$。当扩展为$(x1,x2,x3,x4)$时，$(x1,x2,x3)$上的dichotomies只有部分被重复复制了，设被复制的dichotomies数量为$a$，未被复制的数量为$b$。于是有$B(3,3) = a+b; B(4,3) = 2a + b$。因为$a$被复制了，表示$x_4$有两个取值，那么$(x1,x2,x3)$上的$a$应该小于等于$B(3,2)$。所以推导出$B(4,3) = 2a + b \leq B(3,3) + B(3,2)$。对于任意$N&gt;k$，类推可以得到，$B(N,k) \leq B(N−1,k)+B(N−1,k−1)$</li></ul><p>最后利用数学归纳法，可以证明得到下面的bounding function($N&gt;k$)：$$m_H{N}\leq \sum_{i=0}^{k-1}\binom{N}{i}$$</p><p>这个式子显然是多项式的，多项式的最高幂次项为：$N^{k–1}$。</p><p>所以我们得到结论：如果break point存在（有限的正整数），生长函数$m_{H}(N)$是多项式的。</p><p>再重复一遍，$H$作用于数据量为$N$的样本集$D$，方程的数量看上去是无穷的，但真正有效(effective)的方程的数量却是有限的，这个数量为$m_H(N)$。$H$中每一个$h$作用于$D$都能算出一个$E_{in}$来，一共有$m_H(N)$个不同的$E_{in}$。</p><p>OK，到目前为止，关于$m_H(N)$的推导结束。回到growth function小节提出的问题，能否用<strong>$m_H(N)$直接替换M?</strong></p><p>既然得到了$m_H(N)$的多项式上界，我们希望对之前的不等式中$M$进行替换，用$m_H(N)$来替换$M$。这样替换后，当break point存在时，$N$足够大时，该上界是有限的。$$P[h\in H\quad s.t \quad |E_{in}(h)-E_{out}(h)|&gt;\epsilon]\leq 2 \\m_{H}N\cdot exp(-2\cdot {\epsilon}^2\cdot N)$$</p><p>然而直接替换是存在问题的，主要问题是：$E_{in}$的可能取值是有限个的，但$E_{out}$的可能取值是无限的。可以通过将$E_{out}$ 替换为验证集(verification set) 的$E_{in}$来解决这个问题。</p><p>下面是推导过程：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783670/2018_03_05_14.png" width="80%" height="80%"></p><p>最后我们得到下面的VC bound:<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_15.png" width="80%" height="80%"></p><p>关于这个公式的数学推导，我们可以暂且不去深究。我们先看一下这个式子的意义，如果假设空间存在有限的break point，那么$m_H(2N)$会被最高幂次为$k–1$的多项式上界给约束住。随着$N$的逐渐增大，指数式的下降会比多项式的增长更快，所以此时VC Bound是有限的。更深的意义在于，$N$足够大时，对$H$中的任意一个假设$h，E_{in}(h)$都将接近于$E_{out}(h)$，这表示学习可行的第一个条件是有可能成立的。</p><h2>VC dimension</h2><p>说了这么多，VC维终于露出庐山真面目了。此概念由Vladimir Vapnik与Alexey Chervonenkis提出。一个假设空间$H$的<strong>VC dimension</strong>，是这个$H$最多能够shatter掉的点的数量，记为$d_{vc}(H)$。如果不管多少个点$H$都能shatter它们，则$d_{vc}=\infty$。还可以理解为：$vc-dim$就是$argmax\quad x_n\quad {growth function=2^n}$。</p><p>根据定义，可以得到一个明显的结论：$$k = d_{vc}(H) + 1$$</p><p>根据前面的推导，我们知道VC维的大小：与学习算法$A$无关，与输入变量$X$的分布也无关，与我们求解的目标函数$f$ 无关。<font color="blue">它只与模型和假设空间有关。</font></p><p>我们已经分析了，对于2维的perceptron，它不能shatter 4个样本点，所以它的VC维是3。此时，我们可以分析下2维的perceptron，如果样本集是线性可分的，perceptron learning algorithm可以在假设空间里找到一条直线，使$E_{in}(g)=0$；另外由于其VC维=3，当$N$足够大的时候，可以推断出：$E_{out}(g)$约等于$E_{in}(g)$。这样学习可行的两个条件都满足了，也就证明了2维感知器是可学习的。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783663/2018_03_05_16.png" width="80%" height="80%"></p><p>总结回顾一下，要想让机器学到东西，并且学得好，有2个条件：</p><ul><li>$H$的$d_{vc}$是有限的，这样VC bound才存在。(good H)；$N$足够大(对于特定的$d_{vc}$而言)，这样才能保证VC bound不等式的bound不会太大。(good D)</li><li>算法A有办法在$H$中顺利的挑选一个使得$E_{in}最小的$g$。(good A)</li></ul><p>回到最开始提出的学习可行的两个核心条件，尝试用VC维来解释：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_17.png" width="80%" height="80%"></p><p>从上图可以看出，当VC维很小时，条件1容易满足，但因为假设空间较小，可能不容易找到合适的$g$,使得$E_{in}(g)$约等于0。当VC维很大时，条件2容易满足，但条件1不容易满足，因为VC bound很大。</p><p>VC维反映了假设空间$H$的强大程度(powerfulness)，VC 维越大，$H$也越强，因为它可以打散(shatter)更多的点。</p><p>定义模型自由度是，模型当中可以自由变动的参数的个数，即我们的机器需要通过学习来决定模型参数的个数。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_18.png" width="80%" height="80%"><p>一个实践规律：VC 维与假设参数$w$的自由变量数目大约相等。$d_{VC} \approx  free parameters$。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783663/2018_03_05_19.png" width="80%" height="80%"><p>上面式子中的第3项表示模型复杂度。模型越复杂，VC维大，$E_{out}$可能距离$E_{in}$ 越远。如下图所示，随着$d_{vc}$的上升，$E_{in}$不断降低，而模型复杂度不断上升。</p><p>它们的上升与下降的速度在每个阶段都是不同的，因此我们能够寻找一个二者兼顾的，比较合适的$d_{vc}$，用来决定应该使用多复杂的模型。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785729/2018_03_05_20.png" width="80%" height="80%"></p><p>模型较复杂时($d_{vc}$ 较大)，需要更多的训练数据。 理论上，数据规模$N$约等于 $10000*d_{vc}$（称为采样复杂性，sample complexity）；然而，实际经验是，只需要 $N = 10*d_{vc}$。</p><p>造成理论值与实际值之差如此之大的最大原因是，VC Bound 过于宽松了，我们得到的是一个比实际大得多的上界。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785731/2018_03_05_21.png" height="80%"></p><p>注意在前述讨论中，理想的目标函数为$f(x)$，error measure用的是“0–1 loss”。如果在unknown target上引入噪声(+noise)，或者用不同的error measure方法，VC theory还有效吗？这里只给出结论，VC theory对于绝大部分假设空间(or 加入噪声)和error度量方法，都是有效的。</p><p>除此外，我们为了避免overfit，一般都会加正则项。那加了正则项后，新的假设空间会得到一些限制，此时新假设空间的VC维将变小，也就是同样训练数据条件下，$E_{in}$更有可能等于$E_{out}$，所以泛化能力更强。这里从VC维的角度解释了正则项的作用。</p><h2>深度学习与VC维</h2><p>对于神经网络，其VC维的公式为：$d_{VC} = O(V\cdot D)$，其中$V$表示神经网络中神经元的个数，$D$表示weight的个数，也就是神经元之间连接的数目。(注意：此式是一个较粗略的估计，深度神经网络目前没有明确的VC bound)<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785730/2018_03_05_22.png"></p><p>举例来说，一个普通的三层全连接神经网络：input layer是1000维，hidden layer有1000个nodes，output layer为1个node，则它的VC维大约为$O(1000*1000*1000)$。</p><p>可以看到，神经网络的VC维相对较高，因而它的表达能力非常强，可以用来处理任何复杂的分类问题。根据上一节的结论，要充分训练该神经网络，所需样本量为10倍的VC维。如此大的训练数据量，是不可能达到的。所以在20世纪，复杂神经网络模型在out of sample的表现不是很好，容易overfit。</p><p>但现在为什么深度学习的表现越来越好。原因是多方面的，主要体现在：</p><ul><li>通过修改神经网络模型的结构，以及提出新的regularization方法，使得神经网络模型的VC维相对减小了。例如卷积神经网络，通过修改模型结构(局部感受野和权值共享)，减少了参数个数，降低了VC维。2012年的AlexNet，8层网络，参数个数只有60M；而2014年的<a style="color: #109eff" href="http://www.cs.unc.edu/~wliu/papers/GoogLeNet.pdf" target="_blank" rel="noopener">GoogLeNet</a>，22层网络，参数个数只有7M。</li><li>dropout，drop connect，denosing等regularization方法的提出，也一定程度上增加了神经网络的泛化能力。</li><li>训练数据变多了。随着互联网的越来越普及，相比于以前，训练数据的获取容易程度以及量和质都大大提升了。训练数据越多，$E_{in}$越容易接近于$E_{out}$。而且目前训练神经网络，还会用到很多data augmentation方法，例如在图像上，剪裁，平移，旋转，调亮度，调饱和度，调对比度等都使用上了。</li><li>除此外，pre-training方法的提出，GPU的利用，都促进了深度学习。</li></ul><p>但即便这样，深度学习的VC dimension和VC Bound依旧很大，其泛化控制方法依然没有强理论支撑。但是实践又一次次证明，深度学习是好用的。所以VC维对深度学习的指导意义，目前不好表述，有一种思想建议，深度学习应该抛弃对VC维之类概念的迷信，尝试从其他方面来解释其可学习型，例如使用泛函空间（如<a style="color: #109eff" href="http://en.wikipedia.org/wiki/Banach_space" target="_blank" rel="noopener">Banach Space</a>）中的概率论。</p><p>更多细节请参考下面链接：</p><ol><li><a style="color: #109eff" href="http://ttic.uchicago.edu/~tewari/lectures/lecture12.pdf" target="_blank" rel="noopener">VC Dimension of Multilayer Neural Networks</a>，该文章给出了多层神经网络的VC bound的相关证明。</li><li><a style="color: #109eff" href="http://www.kdnuggets.com/2014/02/exclusive-yann-lecun-deep-learning-facebook-ai-lab.html" target="_blank" rel="noopener">Lecun: What is the relationship between Deep Learning and Support Vector Machines / Statistical Learning Theory?</a>Vapnik really believes in his bounds. He worried that neural nets didn’t have similarly good ways to do capacity control (although neural nets do have generalization bounds, since they have finite VC dimension).Lecun’s counter argument was that the ability to do capacity control was somewhat secondary to the ability to compute highly complex function with a limited amount of computation.</li></ol><h2>小结</h2><p>上面仔细分析了VC维的来龙去脉，讲述了VC维在机器学习理论中的指导意义。考虑到VC维在机器学习领域虽是基础，却也是大坑，难免有理解不深或不当之处，敬请谅解。若希望获得更深理解，请参考下面的参考文献。</p><h2>参考文献</h2><ol><li><a style="color: #109eff" href="http://www.autonlab.org/tutorials/vcdim.html" target="_blank" rel="noopener">VC dimension Tutorial Slides by Andrew Moore</a></li><li><a style="color: #109eff" href="https://www.coursera.org/course/ntumlone" target="_blank" rel="noopener">机器学习基石</a> x(上文的截图均出自于该课程的讲义)</li><li><a style="color: #109eff" href="http://www.svms.org/vc-dimension/" target="_blank" rel="noopener">vc-dimension in svms</a></li><li><a style="color: #109eff" href="http://www.36dsj.com/archives/21236" target="_blank" rel="noopener">机器学习简史</a></li><li><a style="color: #109eff" href="http://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory" target="_blank" rel="noopener">Vapnik–Chervonenkis theory</a></li><li><a style="color: #109eff" href="http://www.cs.nyu.edu/~yann/talks/lecun-ranzato-icml2013.pdf" target="_blank" rel="noopener">Deep Learning Tutorial</a></li><li><a style="color: #109eff" href="http://www.zhihu.com/question/27434103" target="_blank" rel="noopener">深度学习的研究领域是否有被过度夸大</a></li><li><a style="color: #109eff" href="http://freemind.pluskid.org/slt/vc-theory-vapnik-chervonenkis-dimension" target="_blank" rel="noopener">VC Theory: Vapnik–Chervonenkis Dimension</a></li></ol>]]></content>
    
    <summary type="html">
    
      VC维在机器学习领域是一个很基础的概念，它给诸多机器学习方法的可学习性提供了坚实的理论基础，但有时候，对我们而言，SVM，LR，深度学习等可能都已经用到线上了，但却不理解VC维。
    
    </summary>
    
      <category term="机器学习相关" scheme="http://ulsonhu.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="Machine Learning" scheme="http://ulsonhu.cn/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Lasso回归算法</title>
    <link href="http://ulsonhu.cn/LASSO%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95.html"/>
    <id>http://ulsonhu.cn/LASSO回归算法.html</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-24T14:49:32.426Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://rokia.org/?tag=p_value" target="_blank" rel="noopener">关于P值滥用的简要介绍</a></p><p>计量模型中关于变量选择，很多同学可能第一个想到的是：前进法，后退法，向前向后逐步回归。但是，这些方法存在一些固有的缺陷,它们会导致某些可能为最优的变量组合无法共同进入模型。</p><p>我们抛开传统的统计学教材，把眼光瞄向统计学习理论，就会发现，其实有大量的模型可供我们选择。今天，先介绍最基础的方法：lasso。</p><h2>一、The lasso的提出</h2><p>Lasso,即Lesat absolute shrinkage and seletion operator.改方法由统计学习领域的执牛耳者<a href="http://statweb.stanford.edu/~tibs/lasso/lasso.pdf" target="_blank" rel="noopener">Robert Tibshirani于1996年开创</a>。至今为止，这篇文章被引用次数已达14000多次。据说，在学术领域，被引用次数能达到几十次已经可以引以为傲。经过将近20年的发展，这个方法养活了一大群人，同时也发展出了很多更为成熟的理论，如Adaptive lasso，The Grouped lasso,SCAD。</p><h2>二、The lasso的原理</h2><p>lasso的思想其实很简单，就是在传统的最小二乘估计上对模型的系数施加一个$L_1$惩罚。模型形式如下。$$\widehat{\beta}^{lasso} =\quad  argmin_{\beta}\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 \\ \qquad s. t\sum_{j = 1}^{p}|\beta_j|\leq t.$$</p><p>上式等价于</p><p>$$\widehat{\beta}^{lasso} = argmin_{\beta}{\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 + \lambda\sum_{j = 1}^{p}|\beta_j|}$$</p><p>看到这个表达式，有没有一种熟悉的感觉？看！</p><p>$$\widehat{\beta}^{ridge} = argmin_{\beta} {\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 + \lambda\sum_{j = 1}^{p}\beta_{j}^2}$$</p><p>没错！它其实跟我们在回归分析教材中介绍的岭回归(ridge regression)非常相似，只是将$L_2$惩罚换成了$L_1$惩罚。Zou and Hastie在2005年，提出了一种在ridge regression和the lasso之间折衷的方法：the <strong>elastic net</strong> penalty,思想也非常简单，但是却很有影响力。</p><p>回头看下，lasso为何如此流行。这么做的好处是一举多得的：</p><ul><li>可以解决岭回归能够解决的问题：多重共线性问题,过拟合问题等；</li><li>还可以解决岭回归不能解决的问题：将一部分变量的系数压缩至0，即实现变量选择。</li></ul><p>我们可以从一张图看出来。<br><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764085/2018_03_04p1.png" width="70%" height="70%"></p><p>这幅图可以这样理解蓝色的区域是$\beta$的可行域。由于the lasso的约束是$L_1$约束，必然是方形区域，区域的大小取决于$t$的大小；而ridge regression是$L_2$约束，所以可行域呈圆形。</p><p>$$Z = \sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2$$</p><p>从上面的式子可以看出，（如果我的空间解析几何没记错的话，）函数$Z(\beta_1,\beta_2)$描述的是一个椭圆抛物面的形状。而椭圆抛物面在$(\beta_1,\beta_2)$平面上的投影就是类似上图红色圆圈所表述的形状，每一圈代表着不同的$Z$值。而中间的黑点，自然就是最小的$Z$，即没有约束下，普通最小二乘得到的解。我们可以想象，当蓝色的圆圈足够大，以至于涵盖了中间的小黑点时，约束没有起到作用，取到的解就是中间的小黑点，此时等价于普通最小二乘；当约束比较紧，取到的解靠近0，为两个区域相切的点。</p><p>我们可以直观地看到，the lasso更容易取到角点解，即：使得某些变量的系数压缩至零。如果你还是不相信自己的眼睛，我们待会还可以从一个示例中看出这一特点。</p><p>一些爱思考的同学可能会继续追问：“它能够保证留下来的变量都是对因变量有着更大影响的吗？”这一点稍微思考一下，应该是可以保证的。但是，如果存在一组高度相关的变量时，Lasso倾向于选择其中的一个变量，而忽视其他所有的变量。这样可能会导致结果的不稳定性。要解决这个问题，可以去探究一下 <strong>elastic net</strong> penalty。</p><h2>三、lasso的R实现</h2><p>lasso的实现可以采用glmnet包。glmnet包作者是Friedman, Hastie, and Tibshirani这三位统计学习领域的大牛，可信度无可置疑。这个包采用的算法是循环坐标下降法（cyclical coordinate descent），能够处理的模型包括 linear regression,logistic and multinomial regression models, poisson regression 和 the Cox model，用到的正则化方法就是$l1$范数（lasso）、$l2$范数（岭回归）和它们的混合 （elastic net）。</p><p>这里，给出一个实现lasso的示例。</p><p>数据来源于ISLR包中的Hitters数据集，该数据集描述了美国1986年和1987年的棒球运动员相关数据。我们来探究一下对运动员薪水起主要作用的因素有哪些。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ISLR)</span><br><span class="line">str(Hitters)&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 'data.frame':    322 obs. of  20 variables:</span></span><br><span class="line"><span class="comment">##  $ AtBat    : int  293 315 479 496 321 594 185 298 323 401 ...</span></span><br><span class="line"><span class="comment">##  $ Hits     : int  66 81 130 141 87 169 37 73 81 92 ...</span></span><br><span class="line"><span class="comment">##  $ HmRun    : int  1 7 18 20 10 4 1 0 6 17 ...</span></span><br><span class="line"><span class="comment">##  $ Runs     : int  30 24 66 65 39 74 23 24 26 49 ...</span></span><br><span class="line"><span class="comment">##  $ RBI      : int  29 38 72 78 42 51 8 24 32 66 ...</span></span><br><span class="line"><span class="comment">##  $ Walks    : int  14 39 76 37 30 35 21 7 8 65 ...</span></span><br><span class="line"><span class="comment">##  $ Years    : int  1 14 3 11 2 11 2 3 2 13 ...</span></span><br><span class="line"><span class="comment">##  $ CAtBat   : int  293 3449 1624 5628 396 4408 214 509 341 5206 ...</span></span><br><span class="line"><span class="comment">##  $ CHits    : int  66 835 457 1575 101 1133 42 108 86 1332 ...</span></span><br><span class="line"><span class="comment">##  $ CHmRun   : int  1 69 63 225 12 19 1 0 6 253 ...</span></span><br><span class="line"><span class="comment">##  $ CRuns    : int  30 321 224 828 48 501 30 41 32 784 ...</span></span><br><span class="line"><span class="comment">##  $ CRBI     : int  29 414 266 838 46 336 9 37 34 890 ...</span></span><br><span class="line"><span class="comment">##  $ CWalks   : int  14 375 263 354 33 194 24 12 8 866 ...</span></span><br><span class="line"><span class="comment">##  $ League   : Factor w/ 2 levels &amp;quot;A&amp;quot;,&amp;quot;N&amp;quot;: 1 2 1 2 2 1 2 1 2 1 ...</span></span><br><span class="line"><span class="comment">##  $ Division : Factor w/ 2 levels &amp;quot;E&amp;quot;,&amp;quot;W&amp;quot;: 1 2 2 1 1 2 1 2 2 1 ...</span></span><br><span class="line"><span class="comment">##  $ PutOuts  : int  446 632 880 200 805 282 76 121 143 0 ...</span></span><br><span class="line"><span class="comment">##  $ Assists  : int  33 43 82 11 40 421 127 283 290 0 ...</span></span><br><span class="line"><span class="comment">##  $ Errors   : int  20 10 14 3 4 25 7 9 19 0 ...</span></span><br><span class="line"><span class="comment">##  $ Salary   : num  NA 475 480 500 91.5 750 70 100 75 1100 ...</span></span><br><span class="line"><span class="comment">##  $ NewLeague: Factor w/ 2 levels &amp;quot;A&amp;quot;,&amp;quot;N&amp;quot;: 1 2 1 2 2 1 1 1 2 1 ...&lt;/code&gt;&lt;</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Hitters&lt;-na.omit(Hitters)</span><br><span class="line"><span class="comment">## sampling</span></span><br><span class="line">x&amp;lt;-model.matrix(Salary~.,Hitters)[,-<span class="number">1</span>]</span><br><span class="line">y&amp;lt;-Hitters$Salary</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">train&amp;lt;-sample(<span class="number">1</span>:nrow(x),nrow(x)/<span class="number">2</span>)</span><br><span class="line">test&amp;lt;-(-train)</span><br><span class="line">y.test&amp;lt;-y[test]</span><br><span class="line"></span><br><span class="line"><span class="comment">## ridge regression</span></span><br><span class="line"><span class="keyword">library</span>(glmnet)</span><br><span class="line">grid&amp;lt;-<span class="number">10</span>^seq(<span class="number">10</span>,-<span class="number">2</span>,length = <span class="number">100</span>)</span><br><span class="line">ridge.mod&amp;lt;-glmnet(x,y,alpha = <span class="number">0</span>,lambda = grid)</span><br><span class="line">plot(ridge.mod, main = &amp;quot;The ridge&amp;quot;)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018.03_04lasso01.png" width="70%" height="70%"><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## the lasso</span></span><br><span class="line">lasso.mod&amp;lt;-glmnet(x[train,],y[train],alpha = <span class="number">1</span>,lambda = grid)</span><br><span class="line">plot(lasso.mod, main = &amp;quot;The lasso&amp;quot;)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018_03_04lasso02.png" width="70%" height="70%"><p>从上面两幅图对比可知，the lasso相比起ridge regression，在压缩变量方便表现更出色。当然，你还可以使用这个包内部的交叉验证函数对<span class="math inline">(\lambda)</span>进行参数优化，使得模型更具有稳健性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## cross-validation</span><br><span class="line">set.seed(1)</span><br><span class="line">cv.out&amp;lt;-cv.glmnet(x[train,],y[train],alpha = 1)</span><br><span class="line">plot(cv.out)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018_03_04_lasso03.png" width="70%" height="70%"><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bestlam&amp;lt;-cv.out$lambda.min</span><br><span class="line">lasso.pred&amp;lt;-predict(lasso.mod,s = bestlam,newx = x[test,])</span><br><span class="line">mean((lasso.pred - y.test)^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## [1] 100743.4</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out&amp;lt;-glmnet(x,y,alpha = <span class="number">1</span>,lambda = grid)</span><br><span class="line">lasso.coef&amp;lt;-predict(out,type = &amp;quot;coefficients&amp;quot;,s = bestlam)[<span class="number">1</span>:<span class="number">20</span>,]</span><br><span class="line">lasso.coef</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  (Intercept)        AtBat         Hits        HmRun         Runs </span></span><br><span class="line"><span class="comment">##   18.5394844    0.0000000    1.8735390    0.0000000    0.0000000 </span></span><br><span class="line"><span class="comment">##          RBI        Walks        Years       CAtBat        CHits </span></span><br><span class="line"><span class="comment">##    0.0000000    2.2178444    0.0000000    0.0000000    0.0000000 </span></span><br><span class="line"><span class="comment">##       CHmRun        CRuns         CRBI       CWalks      LeagueN </span></span><br><span class="line"><span class="comment">##    0.0000000    0.2071252    0.4130132    0.0000000    3.2666677 </span></span><br><span class="line"><span class="comment">##    DivisionW      PutOuts      Assists       Errors   NewLeagueN </span></span><br><span class="line"><span class="comment">## -103.4845458    0.2204284    0.0000000    0.0000000    0.0000000</span></span><br></pre></td></tr></table></figure><p>可见，很多变量的系数确实被压缩至零。</p><h2>四、lasso的优缺点分析</h2><ul><li>相比较于其他变量选择方法，如：best subset，Partial Least Squares(偏最小二乘)，Principal components regression(主成分回归)，the lasso和ridge regression对参数的调整是连续的，并不是一刀切的。</li><li>the lasso相比于ridge regression的优势在于压缩变量表现更出色。</li><li>但是，正如前面所说，lasso还是会有一些潜在的问题，有时候，elastic net等其他的一些lasso的变形会是更好的选择。</li></ul><h2>五、参考文献</h2><ol><li>The Elements of Statistical Learning: Data Mining, Inference and Prediction. Second edition</li><li>An Introduction to Statistical Learning with R</li><li><a href="http://site.douban.com/182577/widget/notes/10567212/note/288551448/" target="_blank" rel="noopener">线性回归建模–变量选择和正则化（1）：R包glmnet</a></li></ol>]]></content>
    
    <summary type="html">
    
      很多人在做变量选择时，眼光依然局限于$R^2$或者$Adjusted-R^2$,以及$P-Value$之中。计量经济学中，对于模型选择，学术界其实更倾向于采用$AIC$和$BIC$等标准来做判断。而对于$P-Value$的滥用与批判，其实已经到了水深火热的地步。抛开背景知识不谈，在变量选择，可以倚靠哪些神奇的准则和方法？
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>因果推断：工具变量（Instrumental Variable）</title>
    <link href="http://ulsonhu.cn/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%98%E9%87%8F%EF%BC%88Instrumental%20Variable%EF%BC%89.html"/>
    <id>http://ulsonhu.cn/因果推断：工具变量（Instrumental Variable）.html</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-03-11T10:55:23.905Z</updated>
    
    <content type="html"><![CDATA[<h2>一、线性回归和最小二乘法</h2><p>线性模型和最小二乘的理论起源于高斯的天文学研究，“回归”（regression）这个名字则是 Francis Galton 在研究优生学的时候提出来的。为了描述的方便，我们假定回归的自变量只有一维，比如个体$i$是否接受某种处理（吸烟与否；参加某个工作；等等），记为$D_i$。 回归的因变量也是一维，表示我们关心的结果（是否有肺癌；是否找到工作培训与否；等等），记为$Y_i$。假定我们的研究中有 $n$ 个个体，下面的线性模型用于描述$D$和$Y$之间的“关系”：</p><p>$$Y_i = \alpha + \beta D_i + \varepsilon_i, i=1, \cdots, n. \quad \quad (1)$$</p><p>一般情形下，我们假定个体间是独立的。模型虽简单，我们还是有必要做一些解释。首先，我们这里的讨论都假定$D_i$是随机变量，对应统计学中的随机设计 （random design）的情形；这和传统统计学中偏好的固定设计（fixed design）有点不同—那里假定$D_i$总是固定的。（统计学源于实验设计，那里的解释变量都是可以控制的，因此统计学教科书有假定固定设计的传统。）假定$D_i$是随机的，既符合很多社会科学和流行病学的背景，又会简化后面的讨论。另外一个问题是 $\varepsilon_i$，它到底是什么含义？Rubin 曾经嘲笑计量经济学家的$\varepsilon_i$道：为了使得线性模型的等式成立，计量经济学家必须加的一项，就叫$\varepsilon_i$。批评的存在并不影响这个线性模型的应用；关键的问题在于，我们在这个$\varepsilon_i$上加了什么假定呢？最根本的假定是：</p><p>$$E(\varepsilon_i) = 0, \text{ and }  \text{cov}(D_i, \varepsilon_i) = 0. \quad \quad (2)$$</p><p>不同的教科书稍有不同，比如 Wooldridge 的书上假定$E(\varepsilon_i\mid D_i ) =0$，很显然，这蕴含着上面两个假定。零均值的假定并不强，因为 $\alpha$“吸收”了$\varepsilon_i$的均值；关键在第二个协方差为零的假定—它通常被称为“外生性”（exogeneity）假定。在这个假定下，我们在 (1) 的两边关于$D_i$取协方差，便可以得到：</p><p>$$\text{cov}(Y_i, D_i )= \beta \text{var}(D_i),$$</p><p>因此，$\beta = \text{cov}(Y_i, D_i) / \text{var}(D_i)$，我们立刻得到了矩估计：</p><p>$$\widehat{\beta}_{OLS}=\frac{\sum_{i=1}^n(Y_i-\bar{Y})(D_i-\bar{D})}{\sum_{i=1}^n(D_i-\bar{D})^2}$$</p><p>上面的估计式也是通常的最小二乘解，这里只是换了一个推导方式。如果将 (1) 看成一个数据生成的机制，在假定 (2) 下我们的确可以估计出因果作用$\beta$.</p><h2>二、内生性和工具变量</h2><p>问题的关键是假定 (2) 很多时候并不成立（$\text{cov}(D_i, \varepsilon_i)\neq 0$），比如，吸烟的人群和不吸烟的人群本身很不相同，参加工作培训的人可能比不参加工作培训的人有更强的找工作动机，等等。因此，包含个体$i$其他所有隐藏信息的变量$\varepsilon_i$不再与$D_i$不相关了—这被称为“内生性”（endogeneity）。这个时候，最小二乘估计收敛到$\beta + \text{cov}(D,\varepsilon)/\text{var}(D)$, 因而在$\text{cov}(D,\varepsilon)\neq 0$时不再是$\beta$的相合估计。</p><p>前面几次因果推断的介绍中提到，完全的随机化实验，可以给我们有效的因果推断。但是很多问题中，强制性的随机化实验是不现实或者不符合伦理的。比如，我们不能强制某些人吸烟，或者不吸烟。但是，“鼓励性实验”依然可行。我们可以随机地给吸烟的人以某种金钱的奖励，如果他们放弃吸烟，则获得某种经济上的优惠。将这个“鼓励性”的变量记为$Z_i$，它定义为是否被鼓励的示性变量，取值 0-1。由于我们的鼓励是完全随机的，有理由假定$\text{cov}(Z_i, \varepsilon_i)=0$。</p><p>以上的各个假定，可以用下面的一个图来形象的描述。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520746493/2018_03_03iv.png" alt="iv" width="70%" height="70%"><p>如图所示，由于$D$和$Y$之间存在一个混杂因素$U$，两者之间的因果作用是不可以用线性回归相合估计的。工具变量$Z$的存在，使得$D$到$Y$的因果作用的识别成为了可能。这里的工具变量$Z$满足如下的条件: $Z\perp U, Z\not \perp D$，并且$Z\perp Y|(D,U)$。第三个条件，可以理解成为“无 $Z$到$Y$的直接作用”。</p><p>此时，我们在线性模型 (1) 两边关于$Z_i$取协方差，得到</p><p>$$\text{cov}(Z_i, Y_i) = \beta \text{cov} (Z_i, D_i),$$</p><p>因此，$\beta = \frac{  \text{cov}(Z_i, Y_i)} {\text{cov} (Z_i, D_i) } $，我们立刻得到如下的矩估计：</p><p>$$\widehat{\beta}_{OLS} = \frac{\sum_{i=1}^n (Y_i – \bar{Y}) (D_i – \bar{D})}{\sum_{i=1}^n (D_i – \bar{D})^2}$$</p><p>根据大数定律，这个“工具变量估计”是$\beta$的相合估计量。上面的式子对一般的$Z_i$都是成立的；当$Z_i$是 0-1 变量时，上面的式子可化简成：</p><p>$$\widehat{\beta}_{IV} = \frac{  \bar{Y}_1 – \bar{Y}_0 } { \bar{D}_1 – \bar{D}_0 },$$</p><p>其中$\bar{Y}_1$表示$Z_i=1$组的平均结果，$\bar{Y}_0$表示$Z_i=0$组的平均结果，关于$D$的定义类似。上面的估计量，很多时候被称为 Wald 估计量（它的直观含义是什么呢？） 需要注意的是，(3) 要求$\text{cov}(Z_i,D_i)\neq 0$，即“鼓励”对于改变人的吸烟行为是有效的；否则上面的工具变量估计量在大样本下趋于无穷大。</p><h2>三、潜在结果视角下的因果作用</h2><p>工具变量估计量在文献中存在已有很多年了，一直到了 Angrist, Imbens and Rubin (1996) 年的文章出现，才将它和潜在结果视角下的因果推断联系起来。关于 Neyman 引进的潜在结果，需要回顾这一系列的第二篇文章。</p><p>一般地， $Z$表示一个 0-1 的变量，表示随机化的变量（1 表示随机化分到非鼓励组；0 表示随机化分到鼓励组）；$D$ 表示最终接受处理与否（1 表示接受处理；0 表示接受对照）；$Y$ 是结果变量。为了定义因果作用，我们引进如下的潜在结果：$(Y_i(1), Y_i(0))$表示个体$i$接受处理和对照下$Y$的潜在结果；$(D_i(1), D_i(0))$表示个体$i$非鼓励组和鼓励组下$D$的潜在结果。由于随机化，下面的假定自然的成立：</p><p>（随机化）$Z_i \perp { D_i(1), D_i(0), Y_i(1), Y_i(0) }.$</p><p>根据鼓励性实验的机制，个体在受到鼓励的时候，更加不可能吸烟，因为下面的单调性也是很合理的：</p><p>（单调性）$D_i(1) \leq D_i(0).$</p><p>由于个体的结果$Y$直接受到所受的处理$D$的影响，而不会受到是否受鼓励$Z$的影响，下面的排除约束（exclusion restriction）的假定，很多时候也是合理的：</p><p>（排除约束）$D_i(1) = D_i(0) $ 蕴含着 $Y_i(1) = Y_i(0)$.</p><p>上面的假定表明，当随机化的“鼓励”$Z$不会影响是否接受处理$D$时，随机化的“鼓励” $Z$也不会影响结果变量$Y$。也可以理解成，随机化的“鼓励” $Z$ 仅仅通过影响是否接受处理$D$来影响结果$Y$，或者说，随机化“鼓励” $Z$本身对与结果变量$Y$没有“直接作用”。</p><p>以上三个假定下，我们得到：</p><p>$$ ACE(Z \rightarrow Y) \\ E{Y_i(1)} -E{Y_i(0)} \\ P{ D_i(1)=1, D_i(0)=0} E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=0 }\\ + P{ D_i(1)=0, D_i(0)=0} E{Y_i(1)-Y_i(0)\mid D_i(1)=0, D_i(0)=0 }\\+P{ D_i(1)=1, D_i(0)=1} E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=1 }\\ P{ D_i(1)=1, D_i(0)=0} E{Y_i(1) -Y_i(0)\mid D_i(1)=1, D_i(0)=0 }.$$</p><p>单调使得 $D$ 的潜在结果的组合只有三种；排除约束假定使得上面分解的后两个式子为$0$。由于对于 $(D_i(1)=0, D_i(0)=0)$ 和 $(D_i(1)=1, D_i(0)=1)$两类人，随机化的“鼓励”对于$D$的作用为$0$，$(D_i(1)=1, D_i(0)=0)$一类人的比例就是$Z$对$D$平均因果作用：$ACE(Z\rightarrow D) = P{ D_i(1)=1, D_i(0)=0} $. 因此，</p><p>$$<br>CACE= E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=0 } = \frac{ ACE(Z \rightarrow Y) }{ ACE(Z\rightarrow D) }.<br>$$</p><p>上面的式子被定义为$CACE$是有理由的。它表示的是子总体$(D_i(1)=1, D_i(0)=0)$中，随机化对于结果的因果作用；由于这类人中随机化和接受的处理是相同的，它也表示处理对结果的因果作用。这类人接受处理与否完全由于是否接受鼓励而定，他们被成为“依从者”（complier），因为这类人群中的平均因果作用又被成为“依从者平均因果作用”（CACE：complier average causal effect）;计量经济学家称它为“局部处理作用”（LATE：local average treatment effect）。</p><p>由于$Z$是随机化的，它对于$D$和$Y$的平均因果作用都是显而易见可以得到的。因为$\widehat{ACE}(Z\rightarrow D) = \bar{D}_1 – \bar{D}_0, \widehat{ACE}(Z\rightarrow Y) = \bar{Y}_1 – \bar{Y}_0$，CACE 的一个矩估计便是</p><p>$$ \frac{\widehat{ACE}(Z\rightarrow Y)  } {  \widehat{ACE}(Z\rightarrow D)   } = \widehat{\beta}_{IV}.$$</p><p>由此可见工具变量估计量的因果含义。上面的讨论既显示了工具变量对于识别因果作用的有效性，也揭示了它的局限性：我们只能识别某个子总体的平均因果作用；而通常情况下，我们并不知道某个个体具体属于哪个子总体。</p><h2>四、实例</h2><p>这部分给出具体的例子来说明上理论的应用，具体计算用到了第五部分的一个函数（其中包括用delta方法算的抽样方差）。这里用到的数据来自一篇政治学的文章 Green et al. (2003) “Getting Out the Vote in Local Elections: Results from Six Door-to-Door Canvassing Experiments”，<a href="http://dvn.iq.harvard.edu/dvn/faces/study/StudyPage.xhtml?globalId=hdl:1902.1/21729&amp;studyListingIndex=5_c49f1060ddaa41a23e5759168940" target="_blank" rel="noopener">数据点击此处可以在此下载</a>。</p><p>文章目的是研究某个社会实验是否能够提到投票率，实验是随机化的，但是并非所有的实验组的人都依从。因此这里的变量 $Z$ 表示随机化的实验，$D$ 表示依从与否，$Y$ 是投票与否的示性变量。具体的数据描述，可参加前面提到的文章。</p><p>原始数据总结如下：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520746493/2018_03_03table1.png" width="70%" height="70%">根据下一个部分的函数，我们得到如下的结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CACE.IV(Y, D, Z)</span><br><span class="line">$CACE</span><br><span class="line">[1] 0.07914375</span><br><span class="line"></span><br><span class="line">$se.CACE</span><br><span class="line">           [,1]</span><br><span class="line">[1,] 0.02273439</span><br><span class="line"></span><br><span class="line">$p.value</span><br><span class="line">             [,1]</span><br><span class="line">[1,] 0.0004991073</span><br><span class="line"></span><br><span class="line">$prob.complier</span><br><span class="line">[1] 0.2925123</span><br><span class="line"></span><br><span class="line">$se.complier</span><br><span class="line">[1] 0.004871619</span><br></pre></td></tr></table></figure><p>由此可见，这个实验对于提高投票率，有显著的作用。</p><h2>五、R code</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## function for complier average causal effect</span></span><br><span class="line">CACE.IV = <span class="keyword">function</span>(outcome, treatment, instrument)</span><br><span class="line">&#123;</span><br><span class="line">Y = outcome</span><br><span class="line">D = treatment</span><br><span class="line">Z = instrument</span><br><span class="line">N = length(Y)</span><br><span class="line"></span><br><span class="line">Y1 = Y[Z == <span class="number">1</span>]</span><br><span class="line">Y0 = Y[Z == <span class="number">0</span>]</span><br><span class="line">D1 = D[Z == <span class="number">1</span>]</span><br><span class="line">D0 = D[Z == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">mean.Y1 = mean(Y1)</span><br><span class="line">mean.Y0 = mean(Y0)</span><br><span class="line">mean.D1 = mean(D1)</span><br><span class="line">mean.D0 = mean(D0)</span><br><span class="line"></span><br><span class="line">prob.complier = mean.D1 - mean.D0</span><br><span class="line">var.complier  = var(D1)/length(D1) + var(D0)/length(D0)</span><br><span class="line">se.complier   = var.complier^<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">CACE = (mean.Y1 - mean.Y0)/(mean.D1 - mean.D0)</span><br><span class="line"></span><br><span class="line"><span class="comment">## COV</span></span><br><span class="line">pi1 = mean(Z)</span><br><span class="line">pi0 = <span class="number">1</span> - pi1</span><br><span class="line"></span><br><span class="line">Omega = c( var(Y1)/pi1, cov(Y1, D1)/pi1, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">           cov(Y1, D1)/pi1, var(D1)/pi1, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>, <span class="number">0</span>, var(Y0)/pi0, cov(Y0, D0)/pi0,</span><br><span class="line">           <span class="number">0</span>, <span class="number">0</span>, cov(Y0, D0)/pi0, var(D0)/pi0 )</span><br><span class="line">Omega = matrix(Omega, byrow = <span class="literal">TRUE</span>, nrow = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Gradient</span></span><br><span class="line">Grad = c(<span class="number">1</span>, -CACE, -<span class="number">1</span>, CACE)/(mean.D1 - mean.D0)</span><br><span class="line"></span><br><span class="line">COV.CACE = t(Grad)%*%Omega%*%Grad/N</span><br><span class="line"></span><br><span class="line">se.CACE = COV.CACE^<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">p.value = <span class="number">2</span>*pnorm(abs(CACE/se.CACE), <span class="number">0</span>, <span class="number">1</span>, lower.tail = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##results</span></span><br><span class="line">res = list(CACE          = CACE,</span><br><span class="line">           se.CACE       = se.CACE,</span><br><span class="line">           p.value       = p.value,</span><br><span class="line">           prob.complier = prob.complier,</span><br><span class="line">           se.complier   = se.complier)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      为了介绍工具变量，我们首先要从线性模型出发。毫无疑问，线性模型是理论和应用统计（包括计量经济学和流行病学等）最重要的工具；对线性模型的深刻理解，可以说就是对一大半统计理论的理解。下面的第一部分先对线性模型，尤其是线性模型背后的假设做一个回顾。
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JUMP少年周刊-最全漫画排行榜</title>
    <link href="http://ulsonhu.cn/JUMP%E5%B0%91%E5%B9%B4%E5%91%A8%E5%88%8A-%E6%9C%80%E5%85%A8%E6%BC%AB%E7%94%BB%E6%8E%92%E8%A1%8C%E6%A6%9C.html"/>
    <id>http://ulsonhu.cn/JUMP少年周刊-最全漫画排行榜.html</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-03-23T04:14:21.695Z</updated>
    
    <content type="html"><![CDATA[<p>其中，一些台词我们仍记忆犹新诸如</p><p>龟–派--汽–功  $\quad \Rightarrow $ 七龙珠<br>你已经死了      $\quad \Rightarrow $北斗神拳<br>教练我想打篮球！ $\quad \Rightarrow $灌篮高手<br>燃烧吧，小宇宙   $\quad \Rightarrow $圣斗士星矢<br>我可是要当海贼王的男人 $\quad \Rightarrow $One Peice<br></p><p>JUMP的连载原则：把在十话内没有得到读者青睐的漫画统统砍掉，并要求高人气作品不准完结，要不顾剧情发展的连载下去。虽然，这样的的条款压抑了创作者空间，但是作为一个企业来说，JUMP以这样的原则给我们呈现了数不清的优秀作品，也获得了巨大的商业成功，稳居日本漫画龙头地位。</p><table><thead><tr><th style="text-align:center">排行</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>香蕉时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>奇异果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>芒果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">No.1</td><td style="text-align:center"><strong>破廉耻学园</strong></td><td style="text-align:center">永井 豪</td><td style="text-align:center">1968-1972</td><td style="text-align:center"><strong>七龙珠</strong></td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1984-1995</td><td style="text-align:center"><strong>海贼王</strong></td><td style="text-align:center">尾田荣一郎</td><td style="text-align:center">2000-2013</td></tr><tr><td style="text-align:center">No.2</td><td style="text-align:center">根性青蛙</td><td style="text-align:center">吉泽保美</td><td style="text-align:center">1970-1976</td><td style="text-align:center">筋肉人</td><td style="text-align:center">蚵仔煎</td><td style="text-align:center">1979-1987</td><td style="text-align:center"><strong>全职猎人</strong></td><td style="text-align:center">富坚 义博</td><td style="text-align:center">1998-</td></tr><tr><td style="text-align:center">No.3</td><td style="text-align:center"><strong>乌龙派出所</strong></td><td style="text-align:center">秋本 治</td><td style="text-align:center">1976-2016</td><td style="text-align:center"><strong>灌篮高手</strong></td><td style="text-align:center">井上 雄彦</td><td style="text-align:center">1990-1996</td><td style="text-align:center"><strong>火影忍者</strong></td><td style="text-align:center">岸本 齐史</td><td style="text-align:center">1999-2013</td></tr><tr><td style="text-align:center">No.4</td><td style="text-align:center">魔投手</td><td style="text-align:center">梶原一骑</td><td style="text-align:center">1971-1974</td><td style="text-align:center"><strong>北斗神拳</strong></td><td style="text-align:center">武论尊</td><td style="text-align:center">1983-1988</td><td style="text-align:center"><strong>美食的俘虏</strong></td><td style="text-align:center">岛袋 光年</td><td style="text-align:center">2008-2016</td></tr><tr><td style="text-align:center">No.5</td><td style="text-align:center"><strong>男儿当大将</strong></td><td style="text-align:center">本宫</td><td style="text-align:center">1968-1973</td><td style="text-align:center">城市猎人</td><td style="text-align:center">北条司</td><td style="text-align:center">1985-1991</td><td style="text-align:center">死神</td><td style="text-align:center">久保 带人</td><td style="text-align:center">2001-2016</td></tr><tr><td style="text-align:center">No.6</td><td style="text-align:center">阿拉蕾</td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1980-1984</td><td style="text-align:center"><strong>足球小将</strong></td><td style="text-align:center">高桥 阳一</td><td style="text-align:center">1981-1988</td><td style="text-align:center"><strong>棋魂</strong></td><td style="text-align:center">堀田由美</td><td style="text-align:center">1999-2003</td></tr><tr><td style="text-align:center">No.7</td><td style="text-align:center">魔神z</td><td style="text-align:center">永井 豪</td><td style="text-align:center">1972-1973</td><td style="text-align:center">High School！奇面组</td><td style="text-align:center">新泽基荣</td><td style="text-align:center">1982-1987</td><td style="text-align:center">游戏王</td><td style="text-align:center">高桥和希</td><td style="text-align:center">1996-2004</td></tr><tr><td style="text-align:center">No.8</td><td style="text-align:center">Play Ball</td><td style="text-align:center">千叶昭雄</td><td style="text-align:center">1973-1978</td><td style="text-align:center"><strong>Jo-Jo奇妙冒险</strong></td><td style="text-align:center">荒木飞吕彦</td><td style="text-align:center">1987-2004</td><td style="text-align:center">银魂</td><td style="text-align:center">空知 英秋</td><td style="text-align:center">2004-至今</td></tr><tr><td style="text-align:center">No.9</td><td style="text-align:center"><strong>猫眼三姐妹</strong></td><td style="text-align:center">北条司</td><td style="text-align:center">1981-1984</td><td style="text-align:center">橙路</td><td style="text-align:center">松本泉</td><td style="text-align:center">1984-1987</td><td style="text-align:center">黑子的篮球</td><td style="text-align:center">藤卷忠俊</td><td style="text-align:center">2009-2014</td></tr><tr><td style="text-align:center">No.10</td><td style="text-align:center">赛道之狼</td><td style="text-align:center"></td><td style="text-align:center">1975-1979</td><td style="text-align:center"><strong>幽游白书</strong></td><td style="text-align:center">富坚义博</td><td style="text-align:center">1990-1993</td><td style="text-align:center"><strong>网球王子</strong></td><td style="text-align:center">许斐刚</td><td style="text-align:center">1999-2008</td></tr><tr><td style="text-align:center">No.11</td><td style="text-align:center"><strong>料理人味平</strong></td><td style="text-align:center">牛次郎</td><td style="text-align:center">1973-1977</td><td style="text-align:center"><strong>浪客剑心</strong></td><td style="text-align:center">和月 伸宏</td><td style="text-align:center">1994-1999</td><td style="text-align:center">死亡笔记</td><td style="text-align:center">大场</td><td style="text-align:center">2004-2006</td></tr><tr><td style="text-align:center">No.12</td><td style="text-align:center">东大一直线</td><td style="text-align:center">小林</td><td style="text-align:center">1976-1979</td><td style="text-align:center"><strong>圣斗士星矢</strong></td><td style="text-align:center">车田 正美</td><td style="text-align:center">1986-1990</td><td style="text-align:center">暗杀教室</td><td style="text-align:center">松井 优征</td><td style="text-align:center">2012</td></tr><tr><td style="text-align:center">No.13</td><td style="text-align:center">天际球团</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">铁拳对钢拳</td><td style="text-align:center">森田真法</td><td style="text-align:center">1988-1997</td><td style="text-align:center">家庭教师HITMAN REBORN</td><td style="text-align:center">天野明</td><td style="text-align:center">2004-1012</td></tr><tr><td style="text-align:center">No.14</td><td style="text-align:center">厕所博士</td><td style="text-align:center"></td><td style="text-align:center">1970-1977</td><td style="text-align:center">魁！！男塾</td><td style="text-align:center">宫下亚喜罗</td><td style="text-align:center">1985-1991</td><td style="text-align:center"><strong>通灵王</strong></td><td style="text-align:center">武井 宏之</td><td style="text-align:center">1998-2004</td></tr><tr><td style="text-align:center">No.15</td><td style="text-align:center">眼睛蛇</td><td style="text-align:center">寺泽 武一</td><td style="text-align:center">1978-1984</td><td style="text-align:center">电影少女</td><td style="text-align:center">桂 正和</td><td style="text-align:center">1989-1992</td><td style="text-align:center">Bobobo-bo Bo-bobo</td><td style="text-align:center">泽井 磐夫</td><td style="text-align:center">2001-2007</td></tr><tr><td style="text-align:center">No.16</td><td style="text-align:center">杜宾刑警</td><td style="text-align:center">武论尊</td><td style="text-align:center">1975-1979</td><td style="text-align:center">幻法小魔星</td><td style="text-align:center">江川 达也</td><td style="text-align:center">1988-1992</td><td style="text-align:center"><strong>草莓100%</strong></td><td style="text-align:center">河下 水希</td><td style="text-align:center">2002-2005</td></tr><tr><td style="text-align:center">No.17</td><td style="text-align:center">停止！！云雀</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1981-1983</td><td style="text-align:center">秀逗泰山</td><td style="text-align:center">德弘正也</td><td style="text-align:center">1988-1995</td><td style="text-align:center">出包王女</td><td style="text-align:center">矢吹 健太郎</td><td style="text-align:center">2006-2009</td></tr><tr><td style="text-align:center">No.18</td><td style="text-align:center">热拳本色</td><td style="text-align:center">车田 正美</td><td style="text-align:center">1977-1981</td><td style="text-align:center">灵异教师神眉</td><td style="text-align:center"></td><td style="text-align:center">1993-1999</td><td style="text-align:center">ROOKIES</td><td style="text-align:center">森田</td><td style="text-align:center">1998-2003</td></tr><tr><td style="text-align:center">No.19</td><td style="text-align:center">赤脚的元</td><td style="text-align:center">中泽 磐治</td><td style="text-align:center">1973-1974</td><td style="text-align:center">银牙</td><td style="text-align:center">高桥义广</td><td style="text-align:center">1983-1987</td><td style="text-align:center">光速蒙面侠21</td><td style="text-align:center">村田雄介</td><td style="text-align:center">2002-2009</td></tr><tr><td style="text-align:center">No.20</td><td style="text-align:center">前进！！海盗</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1997-1980</td><td style="text-align:center">顺带着稀里糊涂</td><td style="text-align:center"></td><td style="text-align:center">1985-1989</td><td style="text-align:center">搞怪吹笛手</td><td style="text-align:center">臼田京介</td><td style="text-align:center">2000-2010</td></tr></tbody></table><blockquote><p>表格注：JUMP于2012年连载的人气漫画诸如：<strong>排球少年、食戟之灵</strong>等优秀作品暂未列入排行榜。</p></blockquote><p>2000年代以来，JUMP三台柱就分别是“死神、火影、海贼王”，但是死神和火影的正式完结，人气却弄的相当低迷，海贼王目前也可以看到，尾田休刊次数也增加不少。目前JUMP少年周刊可以说迎来了一个低迷时期。</p><p>于2008年连载的《美食俘虏》，JUMP虽有意提拔其为台柱，甚至把主角请到《海贼王》中客串，但目前看来依然扶不起。目前连载中算是老油条的《银魂》，也是准备暖身进入最终章了。</p><p>2014年人气漫画，《黑子的篮球》完结。2016年，三台柱中《死神》、《火影忍者》完结，超人气作品《暗杀教室》完结，《食戟之灵》进入新篇章后人气也随之下滑。</p><p>目前，发展看好的有优秀运动向排球漫画《排球少年》，于2014年连载的《我的英雄学院》也一直维持着相当高的人气。</p><p>说了这么多还是希望，海贼王不要烂尾 $$Thanks \\ ShonenJump.$$</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521696877/jum.jpg" width="90%" height="90%">]]></content>
    
    <summary type="html">
    
      关于JUMP少年周刊的一份漫画排行榜。1968年8月6日JUMP少年周刊正式创刊，不是作为日本少年的我们，可能无法对周刊少年JUMP的历史感同身受，但是其中很多作品，一定有自童年或直到现在依然被你喜爱的作品。
    
    </summary>
    
      <category term="漫画兴趣" scheme="http://ulsonhu.cn/categories/%E6%BC%AB%E7%94%BB%E5%85%B4%E8%B6%A3/"/>
    
    
      <category term="JUMP周刊" scheme="http://ulsonhu.cn/tags/JUMP%E5%91%A8%E5%88%8A/"/>
    
      <category term="漫画" scheme="http://ulsonhu.cn/tags/%E6%BC%AB%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>广义矩估计(GMM)方法</title>
    <link href="http://ulsonhu.cn/%E5%B9%BF%E4%B9%89%E7%9F%A9%E4%BC%B0%E8%AE%A1(GMM)%E6%96%B9%E6%B3%95.html"/>
    <id>http://ulsonhu.cn/广义矩估计(GMM)方法.html</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-03-31T15:59:43.886Z</updated>
    
    <content type="html"><![CDATA[<p>首先广义矩估计($GMM$)很容易使我们联想到统计学中参数估计方法之一的矩估计。</p><h2>矩估计</h2><p>矩估计是什么呢？简单的说，就是用样本矩代替总体矩进行统计推断的方法。</p><p>一个最基础的例子是正态总体的参数估计问题。如果$x_i \sim N(\mu,{\sigma}^2)$，如何估计$\mu$和$\sigma$呢？本科的统计学一般会介绍两种方法：极大似然估计和矩估计。其中矩估计是我们今天的主角。观察到：</p><p>$$E(x_i)=\mu,\quad E(x_{i}^2)={\mu}^2+{\sigma}^2$$而根据大数定理，在一定的条件下，我们有：$$\bar{x_i}-\mu=O_p(1),\quad \bar{x_{i}^2}={\mu}^2+{\sigma}^2+O_p(1)$$</p><p>也就是说，当样本量足够大的时候，样本矩与总体矩只差了一个无穷小量，那么我们是不是可以<font color="blue">用样本矩代替总体矩得到参数的估计呢？</font></p><p>按照上面的思路，我们把$O_p(1)$去掉，同时把未知的总体参数写成其估计值，也就是$\hat{x}$的形式，我们得到了：$$\hat{\mu}=\bar{x_i},\quad \hat{\sigma^2}=\bar{x_{i}^2}+\bar{x_i}^2$$</p><p>如此，我们得到了两个总体矩的点估计。<font color="blue">在这个简单的例子里面，你只要把上面的大数定理的结论带到上面两个式子里面，很容易的就可以证明出两个点估计是一致的估计量。当然，值得注意的是，即便我使用的是矩条件，$\sigma$的估计也不是无偏的。一般而言，除了特殊情况，不管是$MLE$还是$MM$还是$GMM$，都不一定可以得到无偏的估计量。特别是在比较复杂的应用里面，一致就很不错了，无偏性的讨论真的繁琐。</font></p><h2>广义矩估计</h2><p>在上面的例子中，我们只使用了<strong>两个矩条件</strong>。然而我们知道，正态分布的矩是有无穷多个可以用的，那么我们是不是可以使用更多的矩条件呢？</p><p>但是有个问题不好解决。在这个例子里面，我们有两个未知参数，如果只使用一阶矩，那么只有一个方程解两个未知数，显然是不可能的。像上面一样，我们用两个矩条件解两个未知数，就解出来了。然而，当我们用一到三阶矩，总共三个方程求解的时候，三个方程求解两个未知数，可能无解。</p><p>方程数多了，反而没有解了，为什么呢？其实很简单，用三个方程中的任意两个方程，都可以求出一组解，那么三个方程我们就可以求出三组解。所以应该如何把这些矩条件都用上呢？到这里我们不妨引入一些记号。还是使用上面的例子，我们把上面的三个矩条件写到一个向量里面去，记：</p><p>$$g(x_i,\theta)=[x_i-\mu,{x_i}^2-\mu^2-\sigma^2,{x_i}^3-\mu^3-3\cdot \mu \sigma^2],\theta={\mu,\sigma^2}$$我们可以得到一个$3*1$的列向量，并且：</p><p>$$Eg(x_i,\theta)=0$$</p><p>上面就是我们要用的矩条件。而根据上面的思路，用其样本矩代替总体矩：</p><p>$$\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})=0$$解这个方程应该就可以得到参数$\theta$的估计。但是正如上面所说的，三个方程两个未知数，并不能确保这个方程有解，所以必须想一些其他办法。一个比较自然的想法是，上面的矩条件等于0，虽然我不太可能保证三个方程同时等于0，但是仿照$OLS$，我们可以让他们的平方和最小，也就是：</p><p>$$\underset{\hat{\theta} }{min}{ [ \frac{1}{N}\sum_{i}g(x_i,\hat{\theta}) ]}’[\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})]$$这样我们就能保证三个矩条件的样本矩都足够贴近于0，当然不可能同时为0。这样不就综合使用了三个矩条件的信息么？</p><p>更一般的，由于上面的$g$函数是一个$3*1$的列向量，我们可以使用一个权重矩阵$W$来赋予每个矩条件以不同的权重：</p><p>$$\underset{\hat{\theta} }{min}{ [ \frac{1}{N}\sum_{i}g(x_i,\hat{\theta}) ]}'W[\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})]$$</p><p>只要这个$W$是一个正定矩阵，那么仍然可以保证每个样本矩都足够贴近于0。那么问题来了，既然对$W$的要求只要求正定矩阵，那么使用不同的权重矩阵就有可能得到不同的结果。</p><p>问题是，有没有一个最优的权重矩阵呢？当然是有的。可以证明，最优的权重矩阵应该是：使用这个权重矩阵，就得到了最有效的估计。</p><blockquote><p>$GMM$估计相当于给不同的矩条件赋予了不同的权重，然后才能这个权重得到最小化条件，不同的权重阵其实就对不同的估计量，“OLS, IV, 2SLS, GLS, RE, FE, SUR, 3SLS, Pooled OLS…全是它的特殊情况”</p></blockquote><h2>GMM延伸</h2><p>计量经济学的很多问题基本都可以归结为$GMM$的问题。从最简单的$OLS、2SLS$到稍微复杂一点的面板数据、动态面板等等，本质上都是在找矩条件。比如工具变量的$2SLS$，可以发现矩条件不过就是：</p><p>$$E[(y_i-{x_i}’\beta)*z_i]=0$$</p><p>套一下上面的公式，最优权重矩阵(的逆)为：</p><p>$$E[(y_i-{x_i}’\beta_0)*z_i*{z_i}’*(y_i-{x_i}’\beta_0)’]=E[e_i^2z_i{z_i}’]=\sigma^2Ez_i{z_i}’$$</p><p>带入到目标函数中，就得到了$2SLS$。甚至，一些其他的估计量，比如$MLE、M-estimator$等，在一定的条件下也可以转化为$GMM$，因为这些估计量的一阶条件可以看成是矩条件。所以$GMM$也就变成了一个统一的框架。为什么$GMM$这么受欢迎呢？因为$GMM$把复杂的统计过程抽象化成为一个（看似）简单的过程：找矩条件。只要你能找到矩条件，你就能估计。$GMM$把估计的繁琐细节全都抽象了，面对一个模型，你所需要做的所有事情就是找到矩条件，证明这个模型是可以识别的，然后什么也不用管，一股脑儿塞进去，结果就出来了。</p><p>所以呢如果你去看一些稍微复杂的模型，基本都可以归结为矩条件。</p><h2>参考</h2><ol><li><a href="https://www.zhihu.com/question/41312883/answer/91484566" target="_blank" rel="noopener">如何用简单的例子解释什么是 Generalized Method of Moments (GMM)?</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89%E7%9F%A9%E4%BC%B0%E8%AE%A1" target="_blank" rel="noopener">广义矩估计</a></li></ol>]]></content>
    
    <summary type="html">
    
      简单的$GMM$快速入门介绍虽然听起来高大上，但背后统计学思想并不复杂。如果你有本科的统计知识，看懂下文是不成问题的。$GMM$的全名是$\text{Generalized Method of Moments}$，也就是广义矩估计。
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>本科计量经济学之回炉重造篇</title>
    <link href="http://ulsonhu.cn/%E6%9C%AC%E7%A7%91%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B9%8B%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%E7%AF%87.html"/>
    <id>http://ulsonhu.cn/本科计量经济学之回炉重造篇.html</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-03-11T04:38:51.612Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于本科的计量经济学课程，主要涉及宏微观、高等数学、线性代数、统计学相关知识。<br>学完我们需要掌握的主要内容包括计量经济学中基本假设及违背基本假设的处理；横截面、面板数据的分析与处理；基础时间序列分析与预测</p><p>参考书籍为</p><ul><li><a href="https://book.douban.com/subject/4717098/" target="_blank" rel="noopener">李子奈.计量经济学</a></li><li><a href="https://book.douban.com/subject/5068097/" target="_blank" rel="noopener">伍德里奇.计量经济学导论</a></li></ul><h2>1 基本假设篇</h2><p>通常在实际研究的计量经济学问题中，完全满足回归的基本假设的情况并不多见。不满足基本假定的情况。称为<strong>违背基本假定</strong>，其情况主要包括:</p><ol><li>随机干扰项存在异方差</li><li>随机干扰项的序列相关（或称自相关）</li><li>解释变量之间的多重共线</li><li>解释变量为随机变量，存在内生性</li></ol><h3>1.1 异方差性</h3><p>线性模型的基本假设中有$Var(\mu|x_1,x_2,\cdots,x_k)=d$，即<strong>随机干扰项的方差不因自变量的不同而不同</strong>。表现在现实的经济生活中，以消费水平受到收入水平的影响为例。$C = b_0 + b_1 * Y + \mu$,对于收入水平Y较低的群众而言，消费情况的变化是比较小的，但是对于收入水平较大的群体而言，其消费水平的变化差异可能就非常大了。用公式表示，即为$var(\mu|x_1,x_2,\cdots,x_k) = f(x_i,d)$</p><h3>1.2 数据异方差性的后果</h3><ol><li>导致参数估计无效，在估计的有效性中，利用了$Ε（\mu '\mu）= d^2I$这条同方差的假设,但是现在d与X是相关的，不能直接拿出来</li><li>参数显著性检验失去意义（显著性检验中，是要用到随机干扰项的误差的，由于异方差性，使用最小二乘法得出来的参数的方差并不是其真实方差了）</li><li>模型预测失效。（模型预测也是要用到随机干扰项的方差的）</li></ol><h3>1.3 检验异方差</h3><ol><li><p><strong>图示检验</strong>（使用Y-X散点图，或者$e^2~X$散点图进行判断，如果呈现一条水平线则是不存在异方差，否则，可能存在），这种方法的问题是：判断并不准确，是否算是水平线还是复杂性的异方差无法判断</p></li><li><p><strong>帕克（Park）检验与戈里瑟检验</strong>。 对样本残差平方$e_i^2$与X之间进行检验。设定模型$e_i^2\sim f(X)+\mu $,如果$e_i^2$与X之间存在显著的相关性，则原模型存在异方差性。<strong>该检验存在的问题</strong>：模型$e_i^2\sim f(X)+\mu $的函数形式和变量选择存在不确定性，而且，该模型本身自己也可能存在异方差性</p></li><li><p><strong>G-Q（Goldfeld-Quandt）检验</strong>:</p></li></ol><ul><li>a.按照某一个被认为可能存在异方差性的变量将样本进行从小到大的排序；</li><li>b.将样本分成两个部分，一个部分自变量大，一个部分自变量小；</li><li>c.对这两个样本分别进行回归，得到各自的残差平方和，在同方差的假设下，这两个残差平方和的大小应当是差异不大的；</li><li>使用上面得出的残差平方和构建F统计量。</li></ul><p><strong>方法的问题</strong>:只能检验单调递增还是单调递减型方差，并且可能需要对各个解释变量进行轮流实验。</p><ol start="4"><li><strong>怀特检验进行辅助回归</strong>：$e_i^2 \sim b_0 + b_1x_1 + b_2x_2 + b_3x_1x_2 + b_4x_1^2 + b_5x_2^2 + \mu $，可以证明，在同方差的假设下，从该辅助回归得到的$R^2$与样本容量的积，渐近服从自由度为辅助回归方程中解释变量个数的卡方分布 $nR^2 \sim \chi^2(k)$ 。WLS加权最小二乘法思想就是将不稳定的方差转换为稳定的方差乘以一个不稳定的函数。通过变换，使得模型变为同方差的情况。</li></ol><p>  假设我们已经知道了随机误差项的方差和自变量之间的关系:$var(\mu_i)=E(\mu_i^2)=d_i^2=f(X_{i,j}) \cdot q^2$(而不是在无异方差的情况下的 $var(\mu |X)=q^2$ )。那么，我们可以使用$\sqrt{f(X_{ij})}$去除以原模型，使得变化后的模型称为无异方差的情况。注：公式中$j$为变量的标号, $i$为样本的标号。 变化后的模型如下：</p><p>$$ Y_i / \sqrt{f(X_{ij})} = b_0 / \sqrt{f(X_{ij})} + b_1x_1 / \sqrt{f(X_{ij})} + \cdots + b_k  x_k / \sqrt{f(X_{ij})} + u_i/\sqrt(f(X_{ij}))$$</p><p>注意到这里，每个变量$X_{ij}$除以的都是其相对应的$f(X_{ij})$. 上面模型，异方差就是不存在的了，便可以用加权后的模型对参数进行估计。现在的问题是，如何对权重$f(x_{ij})$进行估计呢？</p><p>观察可以发现，等式左边可以用样本残差$e_i^2$来代替，等式左边$f(X_{ij})$中有$j$个参数，$q^2$为另一个参数。两边取对数，能够将等式转换为线性模型进行估计。接着就是使用帕克检验的方法，进行各种形式的尝试。从而估计出$f(X_{ij})$的形式 。</p><h3>1.4 异方差稳健标准误法</h3><p><strong>加权最小二乘法</strong>的关键是要寻找模型中随机扰动项$\mu $的方差与解释变量间的适当的函数形式，而这并非一件容易的事。</p><p>如果很难找到的话，可以用异方差的稳健标准误方法，进行替代。 <font color="red">在有异方差的情况下，参数估计仍然是无偏的，但是参数估计的方差和标准差会与传统的有所区别，从而无法保证估计的有效性，但并不影响估计的无偏性和一致性。</font>那么我们仍然采用普通的最小二乘估计量，但是在进行参数检验的时候使用修正后的相应方差。（至于参数的有效性无法满足的问题，并不关注）</p><ol><li>在无异方差下，参数估计的方差为$var(b|X) = d^2 (x’x)^{-1}$，在有异方差下，则为 $var(b) =　(x’x)^{-1}x’D(x’x)^{-1}x’$,这里$D$为$n*1$的向量。使用普通最小二乘法估计的残差平方$e_i^2$形成的向量$e’e$作为向量D的代表。怀特证明了这种做法是对$var(b) =　(x’x)^{-1} * x’ * D * (x’x)^{-1} * x’$的一致估计。</li><li>当存在异方差时，异方差稳健标准误法虽然不能得到有效的参数估计，但是由于得到了普通最小二乘估计量的正确的方差估计，使得以估计量方差为基础的各项检验不再失效，是消除异方差性不良后果的主要手段。</li></ol><h2>2 序列相关性</h2><h3>2.1 序列相关的含义</h3><p>  在经典的线性模型假设中，有<font color="red">随机干扰项独立，即互不相关的假设。</font>这个假设的意思是说，对于造成结果而言，不能由自变量解释到的那部分随机干扰项是独立的。<font color="blue">例如</font>，有两块相邻的水田，其各自产量与施肥量，日照量等有关。但两块水田产量的随机因素之间是不存在关系的，不会因为这块水田随机因素大，那块也大。</p><p>用公式描述，就是：$Cov(\mu _i, \mu _j)=0$， i和j是观测样本。序列相关则意味着样本之间随机因素是具有相关性的，上面例子中，有些无法观测到的对水田产量的因素，例如土壤肥力如果是随机干扰项的话，那么毫无疑问相邻两块土地之间的随机干扰项是具有相关性的。</p><p>通常，由于样本中有$n$个随机干扰项，如果仅存在$E（\mu _i,\mu _{i+1}）\neq 0$，那么称之为一阶自相关，一阶自相关是比较常见的序列相关问题。<font color="blue">例如</font>：一个人的素质可能与他的朋友的素质是相关的，但是与其朋友的朋友的素质之间，相关性就可以忽略了；或者我们可以理解为，一个人素质与其朋友的朋友之间的关系，事实上是通过其朋友来传导的。那么，这样我们就可以将多阶自相关的问题，通过一阶自相关来理解了。</p><p>因此，为了能够便于理解和进行计算，我们通常都进行一阶自相关的研究。我们将一阶自相关用公式表述为：$\mu _i = p*\mu <em>{i+1} + e</em>{i -1}  &lt; p$</p><p>一般经验而言，对于采用时间序列数据作样本的计量经济学问题，由于在不同样本点上解释变量以外的其它因素（随机干扰项）在时间上的连续性，或者说惯性，往往会导致序列相关性。</p><h3>2.2 序列相关性的后果</h3><ol><li><p><strong>参数估计非有效</strong>：在有效性的证明中利用了 $E(uu’) = d^2I$, 但是现在这个条件是无法满足了。所以有效性便不再满足。</p></li><li><p><strong>变量的显著性检验失去意义：</strong>随机干扰项向量的协方差矩阵不再是 $d^2I$，因此原本的参数分布和显著性t检验也不再满足。</p></li><li><p><strong>模型的预测失效：</strong>原因同变量显著性检验失去意义。</p></li></ol><h3>2.3 检验序列相关</h3><ol><li><p><strong>图示法</strong>： 使用OLS的样本残差作为随机干扰项的估计，画出$e_t$和$e_{t-1}$之间的散点图，看二者之间是否存在明显的相关性。该方法存在主观性和不确定性。</p></li><li><p><strong>回归检验法</strong>： 对$e_t$和$e_{t-1}$进行回归检验，看二者之间是否存在显著的关系。</p></li><li><p><strong>DW检验</strong>：构造一个统计量，服从DW分布，然后再使用DW准则进行检验。（用的较少，局限性很大）</p></li><li><p><strong>拉格朗日乘数（LM）检验</strong>：将模型转换为受约束的回归方程即$Y_i=b_0+b_1*x_{i1}+b_2*x_{i2}+\cdots+b_k*x_{ik}+p_1*u_{i-1}+p_2*u_{i-2}+\cdots+p_k*u_{i-k}+e_k$。检验约束条件$H_0：p_1=p_2=\cdots =p_k=0$(k可以自行决定)，再使用检验模型约束条件的LM统计量检验该约束条件即可。</p></li></ol><h3>2.4 如何补救序列相关</h3><p>补救序列相关与补救异方差一样,存在两种思路:</p><ul><li>一就是变换原模型为不存在序列相关的模型,再用OLS来进行估计,即为广义最小二乘法(GLS)和广义差分法（GDM）;</li><li>另一条途径是仍然采用OLS的估计参数，但是对参数估计量的方差或者标准差进行修正。</li></ul><h4>2.4.1 广义最小二乘法</h4><p>  广义最小二乘，是具有普遍意义的最小二乘，普通最小二乘和加权最小二乘是它的特例。<font color="red">广义最小二乘是不需要同方差性和无序列相关的假设的。</font>它将随机变量的协方差矩阵不再表示为 $d^2I$这样的形式， 而是用$cov(u,u’) = p^2 * W$来表示。其中 $W = DD’$.进一步的，变换模型为 $D^{-1}*Y = D^{-1} * X_b + D^{-1}*u$, 该模型便不再有异方差和序列相关，可以对其使用OLS进行估计。（李子奈《计量经济学》pp.127）</p><p>  广义最小二乘法真正的难题是如何去估计协方差矩阵$W$，在序列自相关的情况下，若只有$n$个样本点，要对$\frac{n*(n-1)}{2} + k +2$ 个参数进行估计是几乎不可能的。因此，只能是说对随机干扰项自相关的结构事先给出必要的假设。一般而言，我们假设随机干扰项是一阶自相关的：即$\mu _t = p\mu _{t-1} + e$，对该模型进行估计，便可以得到协方差矩阵W以及权重矩阵D 。</p><h4>2.4.2 广义差分法</h4><p>  广义差分法实质上就是广义最小二乘法，不过是损失了部分样本观测值，具体可见《计量经济学》（李子奈）pp.129。</p><p>随机干扰项相关系数的估计：无论是使用广义最小二乘法还是广义差分法，都需要知道不同样本点之间随机干扰项的相关系数$r_1,r_2\cdots r_p$等，必须对其进行估计，即对$u_t = r_1 * u_{t-1} + r_2 * u_{t-2} + …+ r_p * u_{t-p} + e_t$进行估计。但是事实上$\mu <em>{t}$是无法观测到的，我们只能使用$e</em>{t}$来对其进行近似的估计。</p><p>具体方法为，先使用OLS对原始模型进行估计，对$e_{t},e_{t-1}\cdots e_{t-p}$之间进行线性估计得出随机干扰项的相关系数。再将其带入到广义差分法或者广义最小二乘法中，得到新的$e_{t},e_{t-1}\cdots e_{t-p}$,再次进行估计，得出他们的相关系数，重复上述步骤，直到$e_{t},e_{t-1}\cdots e_{t-p}$的值趋于稳定。我们称该方法为<strong>科克伦-奥科特（Cochrane-Orcutt）迭代法</strong>。</p><p><strong>序列相关稳健标准误法</strong>存在序列相关时，OLS估计的无偏性和一致性仍然是有的，但是有效性无法保证，因此，我们可以对随机干扰项的协方差进行修正，在进行显著性检验时使用改修正的稳健标准误。具体公式过于冗长，可参考《计量经济学》（李子奈）pp.130</p><h3>2.5 虚假序列相关问题</h3><p>  若模型设定中遗漏了重要的解释变量，从而导致了序列相关的出现，我们称之为<strong>虚假序列相关</strong>。我们在处理序列相关问题时，应当要将虚假序列相关的可能性先排除掉，即排除掉遗漏变量的可能。如何避免出现模型设定的偏误问题呢？那就是在开始时建立一个“一般”的模型，然后逐渐剔除缺失不显著的变量。</p><h2>3 多重共线性</h2><p>共线性是指自变量之间存在较大的相关性，导致$|X’X| \neq 0$，从而$(X’X)^{-1}$对角线上的元素较大，随机干扰项的协方差矩阵$d^2(X’X)^{-1}$对角线上的元素也较大，导致一系列的不良后果。主要包括：</p><ol><li>完全共线性下，估计量不存在，完全共线性下$|X’X|=0$，$X’X$没有逆，OLS没法得出参数估计量。</li><li>普通最小二乘法方差变大，导致通过样本计算出来的t值比较小$(X’X）^{-1}$在t统计量的分母中，导致t统计量较小），由于样本本身的共线性问题，导致了t检验的不可靠。同时，也会使得因变量区间预测的“区间”变大，使得预测失去意义，模型不能进行外推。</li><li>参数估计量的经济含义不合理。若$X_1，X_2$之间存在共线性，那么二者其中一个可以由另一个表征出来。他们各自的参数估计量不再代表本身的经济意义，而是代表二者对被解释变量的共同影响。<strong>经验告诉我们，在多元线性回归模型的估计中，如果出现了参数估计值的经济意义明显不合理的情况，应该首先怀疑是否存在多重共线性</strong>。</li></ol><h3>3.1 造成多重共线性的原因</h3><ol><li>经济变量相关的共同趋势。这在时间序列样本中情况比较多。</li><li>滞后变量的引入。例如,居民消费$C$受到总收入以及前期的消费$C_{t-1}$的影响，但是毫无疑问的，前期的消费$C_{t-1}$会影响到当期的收入$Y_{t}$。所以模型中毫无疑问会出现共线性的问题。在这样一种情况下，$Y_{t}$的参数$b_{1}$就不再代表收入对消费的影响了，而是$Y_{t}$与$C_{t-1}$对$C_{t}$的共同影响，二者的参数经济意义不明了。所以可能会出现不合常理的参数估计值。</li><li>样本资料的限制。由于社会科学采用的数据是“社会实验”得出，而并非是控制实验得出，所以自变量样本是不受控制的，某些变量之间可能总是会存在一些共线性。例如时间序列样本就算是这种情况。</li></ol><h3>3.2 多重共线性的检验</h3><p><strong>对两个解释变量</strong>：可以通过解释变量的样本协方差矩阵，发现解释变量之间的两两相关性，对于相关性非常高的两个解释变量，可能存在共线性的问题。</p><p><strong>对多个解释变量之间的相关性</strong>：所谓多个解释变量相关就是如$x_1 = x_2 + x_3 + x_4$这种。使用综合统计检验，如果在OLS下，模型的$R^2$与$F$值较大，但是各参数检验的$t$值较小，说明各解释变量对$Y$的联合线性作用显著。但从较小的$t$值，我们可以估计到，可能存在共线性，从而使得解释变量对$Y$的独立作用不能分辨，故$t$检验不显著。</p><h3>3.3 判别多重共线性的范围</h3><p>知道模型有多重共线性，进一步的，我们希望能够将引起多重共线性的变量找出来，以进一步地对模型进行调整。</p><p>具体的方法有判定系数检验法和逐步回归法。</p><ol><li><p>判定系数检验法：使模型中每个解释变量分别以其余解释变量为解释变量进行回归计算,即 $X_{i} \sim x_{1} + x_{2}+\cdots +x_{i-1} + x_{i+1}+\cdots +x_{k}$。如果发现该模型的判定系数$R^2$较大，则说明该解释变量$x_{i}$能够用其它解释变量表征出来。至于如何判定$R^2$是否足够大，我们可以做$F$检验。</p></li><li><p>逐步回归法：</p></li></ol><ul><li>先做$Y$与各$X_i$分别一元线性回归，找出$R^2$最大的那个$X_i$，以该一元线性回归为基础；</li><li>逐个引入解释变量，观察拟合优度（修正后的拟合优度）的变化（也可以使用AIC准侧），如果拟合优度变化显著，则说明该变量是一个独立解释变量，如果拟合优度变化不显著，说明该解释变量可以用其它变量的线性组合替代，也就是说它与其它变量之间存在共线性关系。</li></ul><h3>3.4 克服多重共线性的办法</h3><ol><li><p><strong>排除引起共线性的变量</strong>：这种方法可能存在的问题是，某变量本来是应当存在于模型当中的，只是由于样本的问题，使得该变量显示出共线性。剔除掉该变量将会导致回归模型在进行预测时的准确性下降。如果换一组样本，可能共线性的情况就不再存在了。因此，是否真的应当剔除掉变量应当还要进行实际经济模型或者实际意义进行考虑。如果某个变量是具有非常明显的经济意义的，那么即使该变量存在共线性，也不能轻易剔除掉。</p></li><li><p><strong>差分法</strong>：常用于时间序列数据中，使用自变量和因变量的增量作为回归的变量。这是由于变量增量的相关性毫无疑问肯定是要比变量本身的相关性弱的。</p></li><li><p><strong>岭回归与LASSO</strong>：可参见<a href="http://www.cnblogs.com/pingzeng/p/5040911.html" target="_blank" rel="noopener">多重共线性的解决方法之——岭回归与LASSO</a></p></li></ol><h2>4 随机解释变量问题 （内生性问题）</h2><p>  计量经济假设中，我们是假设自变量是确定变量，是非随机的。<s>所谓是确定变量，我们可以用科学实验中的对照实验来进行说明，<font color="blue">例如</font>：判断不同的水分条件对粮食产量的影响时，我们将控制其它对产量有影响的变量，如光照，土壤，种子等，仅仅使得水分条件不一样，进而判断水分条件对产量的影响。在这种实验中，水分是可以进行人为控制的确定变量，我们称这种实验为“对照实验”。</s></p><p><s>然而，由于伦理和实际操作上的种种不可行，经济学家是不可能拿整个社会来做实验的。例如不能故意控制某个地方的公共投资高，另一个地方的公共投资低，从而判断政府公共投资对收入的影响。经济学家只能使用既有的现实社会运行数据，通过判断不同公共投资地区的GDP的不同来判断公共投资的影响，经济学家称这种为“自然实验”。 但是，事实上，公共投资却并不是完全的确定性的，它并不是政府主动控制想投入多少就投入多少，其大小毫无疑问是受到地方财政收入的约束的。从这个角度上来说，也就是GDP越高的地方，毫无疑问也就能够投入越多的公共投资。</s></p><p><s><font color="red">那么公共投资与GDP的因果关系就变得非常复杂了，到底公共投资是因？还是GDP是因呢？我们称这种情况为随机解释变量问题：即解释变量无法控制，是具有随机性的。</font></s></p><p>  随机解释变量问题可以分为3种不同的情况：</p><ol><li>随机解释变量$X_i$与随机干扰项$\mu $独立： $cov(X_{i},\mu ) = E(X_{i}\mu )= E(X_{i})*E(\mu )=0$，这种情况，随机解释变量问题对模型的估计不会产生影响。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期无关但是异期相关： $cov(X_{i}, \mu _{i-s}) \neq 0$，这种情况，得到的参数估计量是有偏的，但是却是一致的（可以从OLS估计量的形式中推出来）。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期先关：这种情况得到的参数估计量有偏且非一致。</li></ol><h3>4.1 引起内生性问题的通常理由</h3><ol><li>经济模型中因变量滞后项的引用，通常会造成随机解释变量异期相关。</li><li>存在互为因果的模型，例如上文所述公共投资与GDP。</li></ol><h3>4.2 随机解释变量的解决方法</h3><h4>4.2.1 工具变量</h4><p>工具变量是指该变量与随机解释变量之间存在较高的相关性，而且对随机解释变量的解释能力也非常高（$R^2$比较大），但是该解释变量与模型的随机干扰项不相关，与被解释变量也不相关。即满足：</p><ul><li>工具变量必须外生，即$Cov(z,\mu )=0$。</li><li>工具变量必须与内生变量$x$相关，即$Cov(z,x) \neq 0$。</li></ul><h4>4.2.2 工具变量的估计</h4><p>应该根据常识及经济理论判断$Cov(z,\mu )$是否合理。</p><p>我们可以检验$Cov(z,x )\neq 0$是否成立,即检验在$H_0:\pi_1 = 0$在$x=\pi_0+\pi_1 z+v$,这称作第一阶段回归</p><p>假设简单回归情形$y=\beta_0+\beta_1 x+\mu$，并给定我们假设$Cov(z,y)=\beta_1 Cov(z,x)+Cov(z,\mu )$</p><p>于是解出$\beta_1=\frac{Cov(z,x)}{Cov(z,x)}$，得到$\beta_1$估计量$$\hat{\beta_1}=\frac{\sum_{i=1}^n(z_i-z)(y_i - \bar{y})}{\sum_{i=1}^n(z_i-\bar{z})(x_i - x)}$$</p><p>为了进行推断，我们需要计算统计量和置信区间的标准误。通常的方法是增加一个同方差假设</p><p>$E(\frac{\mu^2}{z})=\sigma2=Var(\mu )$得出，$$Var(\hat{\beta_1})=\frac{\sigma^2}{n\sigma_x^2 \rho_{x,z}^2} \\ se(\hat{\beta_1})=\frac{\hat{\sigma}^2}{ SST_{x}R_{x,z}^2}$$</p><blockquote><p>未完待续 loading…</p></blockquote>]]></content>
    
    <summary type="html">
    
      这篇博文是很久之前总结的，最近正好需要复习计量经济学相关知识，所以把原来的这篇文章回炉重造一番，做一点补充完善工作。
    
    </summary>
    
      <category term="经济学" scheme="http://ulsonhu.cn/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
      <category term="经济学" scheme="http://ulsonhu.cn/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>网站迁移(hexo)</title>
    <link href="http://ulsonhu.cn/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB-hexo.html"/>
    <id>http://ulsonhu.cn/网站迁移-hexo.html</id>
    <published>2018-02-19T16:00:00.000Z</published>
    <updated>2018-03-11T04:38:44.562Z</updated>
    
    <content type="html"><![CDATA[<p>由于wordpress访问速度太慢，懒得折腾XD，把一些博客文章迁移到新博客上。目前使用Github Page + Hexo的方案比较流行，留作日常记录。</p><div align="center">The end</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于wordpress访问速度太慢，懒得折腾XD，把一些博客文章迁移到新博客上。目前使用Github Page + Hexo的方案比较流行，留作日常记录。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;The end&lt;/div&gt;

      
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="hexo" scheme="http://ulsonhu.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>2017年(Lunar Year)读书与看剧</title>
    <link href="http://ulsonhu.cn/Lunar_Year.html"/>
    <id>http://ulsonhu.cn/Lunar_Year.html</id>
    <published>2018-02-14T16:00:00.000Z</published>
    <updated>2018-03-11T04:40:03.247Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3>读书（文学类）</h3><ul><li>加缪. 《鼠疫》</li><li>朱光潜.《西方美学史》 <em>读的慢，忘的快</em></li><li>乔治·奥威尔. 《1984》</li><li>乔治·奥威尔. 《动物农庄》</li><li>艾玛·拉金《在缅甸寻找乔治·奥威尔》</li><li>凯鲁亚克. 《在路上》</li><li>白先勇 《台北人》</li><li>尤瓦尔·赫拉利 《人类简史:从动物到上帝》</li><li>尤瓦尔, 赫拉利. 《未来简史》</li><li>斯蒂芬·茨威格. 《人类群星闪耀时》</li><li>尼古拉斯·斯帕克思. 《分手信》</li><li>卡勒德·胡赛尼. 《群山回唱》</li><li>费孝通. 《乡土中国》</li></ul><h3>读书（自我提高及工具书）</h3><ul><li>李忠秋. 《结构思考力》</li><li>尼尔·布朗《学会提问》</li><li>布鲁克·诺埃尔·摩尔《批判性思维》</li><li>读自我提高类书籍本意在于提升自身逻辑思考能力，上面几本书能够很好的达到目的。</li><li>Johnson. 实用多元统计分析.</li><li>RobertV.Hogg. 数理统计学导论</li><li>张维迎. 博弈论与信息经济学</li><li>Nasrabadi, Nasser M. “Pattern recognition and machine learning.”</li></ul><h3>看剧</h3><ul><li>《怦然心动》- 纯爱类影片，学会从整体审视生活</li><li>《时空恋旅人》 - 看完觉得幸福了一辈子</li><li>《饮食男女》 - 人之大欲，不过饮食男女</li><li>《闻香识女人》 - 善良、正直，是走得多远都不能丢弃的道德品质</li><li>《海边的曼彻斯特》 - 每个人都是一座孤独的岛</li><li>《东京爱情故事》 - 爱情是个很难说的事儿吧，thank you，赤名莉香</li><li>《白色巨塔》- 过程正义与结果正义</li><li>《NANA》 - 主题曲很好听</li><li>《熔炉》 - 不想评论，谢谢</li><li>《聚焦》 - 同上</li><li>《两杆大烟枪》 - 同《低俗小说》《疯狂的石头》，贵在叙事方式</li><li>《傲慢与偏见》、《罗马假日》、《南丁格尔》、《乱世佳人》还说什么，都是经典，无论看几遍，都能品出味道来.</li></ul><div align="center">和子由渑池怀旧 .苏轼<br>人生到处知何似，应似飞鸿踏雪泥。<br>泥上偶然留指爪，鸿飞那复计东西。<br>老僧已死成新塔，坏壁无由见旧题。<br>往日崎岖还知否，路长人困蹇驴嘶。<br></div>]]></content>
    
    <summary type="html">
    
      一个人不总是能让自己的工作有意义，或者同人类的伟大征程发生本质联系。创造出新东西是困难的，命运可能既没有提供资源和天分，也没有提供位置和环境。但反求诸己是可能的，去动手，去克服自己的积习，改造自己的反射，克服不断分泌的多巴胺的诱惑，意识到平庸并不等于无聊和自鸣得意，付出努力去获取知识，获取灵活的身体，理解自己在这个快速变动的世界上的角色，不是为了忍耐，而是为了找到自己的叙事
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="文字" scheme="http://ulsonhu.cn/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
</feed>
