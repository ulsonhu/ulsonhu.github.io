<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sonnet&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://ulsonhu.cn/"/>
  <updated>2018-03-28T11:22:20.487Z</updated>
  <id>http://ulsonhu.cn/</id>
  
  <author>
    <name>Pic by John Lennon</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>概率论（离散空间）杂谈</title>
    <link href="http://ulsonhu.cn/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9D%82%E8%B0%88%E7%AF%87%E4%B8%80.html"/>
    <id>http://ulsonhu.cn/概率论杂谈篇一.html</id>
    <published>2018-03-19T16:00:00.000Z</published>
    <updated>2018-03-28T11:22:20.487Z</updated>
    
    <content type="html"><![CDATA[<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521877258/2018_03_09_01.jpg" height="90%"><p>关于概率论与统计学的不同，相信学过统计学的同学，看过上图后一定能秒懂。</p><blockquote><p>统计学：根据手中信息，猜猜桶里有啥？</p></blockquote><blockquote><p>概率论：根据桶中信息，猜猜手里有啥？</p></blockquote><h2>概率空间</h2><p>所有基本事件组成的集合，其中的每一个基本事件又称做样本点，样本空间用$\boldsymbol {\Omega }$表示，样本点用$\omega$表示,$\Omega=\{\omega \}$</p><ol><li>$\mathcal{\Omega}$－Sample space 样本空间，试验中所有可能结果的集合。（注：每个结果需要互斥，所有可能结果必须被穷举）</li><li>$\mathcal{F}$－Set of events 事件集合，是$\Omega$的一些子集构成的集合，并且它需要满足以下三点特性（也就是必须是$\sigma$－field）：</li></ol><ul><li>$\mathcal{\Phi \in F}$（也就是必须包含不可能事件）</li><li>如果$E\in F,E^C \in \mathcal{F}$。</li><li>如果$E_1,E_2,\cdots ,E_i \in \mathcal{F}$,那么 $U_{i=1}^{\infty}E_i \in \mathcal{F}$</li></ul><ol start="3"><li>$\mathcal{P}$－Probability measure 概率测度（或概率），描述一次随机试验中被包含在 $\mathcal{F}$中的所有事件的可能性。并且它「碰巧」也需要满足三点特性：</li></ol><ul><li>$0\leq P(E_i)\leq 1$（实际限制了总测度为1）</li><li>$P(\Omega)=1$（包含样本空间并且概率为1）</li><li>如果$E_1,E_2,\cdots ,E_i$是互斥事件,那么$P\{U_{i=1}^{\infty} E_i \}=\sum_{i=1}^{\infty} E_i$</li></ul><h2>谈斯特林公式</h2><p>$$n! \sim \sqrt{2\pi }n^{n+\frac{1}{2} }e^{-n} $$</p><p>证明见附录，这是概率论中非常重要的理论，基于此可以得到一些精确的数值估计</p><h3>Stirling与概率问题</h3><p>什么是一个事件（event）的概率？这是概率论最基本也是争议最多的问题【例】：抛一枚硬币，出现正面的概率？</p><p>这是什么意思，通常认为，将这枚硬币独立的抛「很多次」，那么正面出现的次数「大约」占一半。这是在随机事件中很确定的事。所谓的「平均律」(The law of average)或「大数定律」(The law of large numbers)隐约也是在解释这个说法。现在我们从常识出发，来考虑数学表达。</p><p>【问题1】抛 $2n$ 次硬币，正面恰好出现 $n$ 次的概率又多大？根据组合学，抛 $2n$ 次硬币，共有 $2^{2n}$ 种可能，假设每一种发生的结果机会均等，那么 $2n$ 次中有 $n$ 次正面的结果共有$C_{n}^{2n}$种，故得概率为</p><p>$p_{2n} = \frac{C_n^{2n}}{2^{2n}} = \frac{(2n)!}{2^{2n}\cdot n!\cdot n!} \qquad (1)$</p><p>更有趣的是，当$n$趋向$\infty$时，$p_{2n}$会趋近多少？上述常识性的解释似乎是说， $\lim_{n \to \infty } p_{2n} = 1$，这成立吗？这需要对$(1)$式作精确的估计，于是引出下面的问题</p><p>【问题2】当$n$很大时，如何估算？明确地说：当$n$趋向$\infty$时，$n!$的渐进相等式（Asymptotically equal formula）是什么？</p><p>即要找一个${a_n}$使得</p><p>$$\lim_{n \to \infty} \frac{n!}{a_n} = 1,\quad n! \sim a_n$$</p><p>我们希望找到这样的${a_n}$，然后带入$(1)$式中计算极限值 $\lim_{n \to \infty} p_{2n}$，就可以检验上述常识性的说法是否正确。</p><p>$n!$的渐进相等式（Asymptotically equal formula）存在吗？如何找？这时候就需要Stirling公式出场了。</p><h3>初步否定常识性的概率</h3><p>现在我们要利用Stirling 公式来探讨概率之谜(the enigma of probability)。</p><p>首先观察到一个显然的</p><p>【补题】设$\{a_n\},\{b_n\},\{c_n\}$及$\{d_n\}$皆为正项数列且  $\lim_{n \to \infty} \frac{a_n}{b_n} = l$。若 $a_n \sim c_n$且$b_n \sim d_n$，则  $\lim_{n \to \infty} \frac{c_n}{d_n} = l$。接着计算「丢$2n$次硬币，恰好出现$n$次正面的机率$p_{2 n}$在  $n \to \infty$的极限」</p><p>$$\lim_{n \to \infty}p_{2n} = \lim_{n \to \infty} \frac{(2n)!}{2^{2n}n!n!} \\=\lim_{n \to \infty} \frac{\sqrt{2\pi 2n}(2n)^{2n}e^{-2n}}{2^{2n}\cdot 2\pi \cdot  n\cdot n^{2n}\cdot e^{-2n}} \\=\lim_{n \to \infty}\frac{1}{\sqrt{\pi n}}=0$$</p><p>【定理3】  $ \lim_{n \rightarrow \infty} p_{2n} = 0$。因此，当 $n \to \infty$时，$p_{2n}$不但不如原先预计的趋近于1（即必然发生），反而是趋近于0（即不可能发生）。这警告我们，概率的解释与经验有很大出入。</p><p>【常识性的说法】「丢很多次硬币正面大约占一半。」如果将「大约占一半」， 解释为「恰好是一半」的说法，点估计显然是不对的。如何修正呢？自然想到的是改用区间估计的说法。</p><p>为了叙述方便起见，我们引入随机变量(random variable)的概念。对于$k =1, 2, 3, \cdots $，令随机变量</p><p>$$f(n) =\begin{cases}\epsilon_k =  1, &amp; \text{第$K$次硬币得到正面 } \\\epsilon_k =  0, &amp; \text{第$K$次硬币得到反面}\end{cases}$$</p><p>再令$$S_n = \epsilon_1 + \epsilon_2 + \cdots + \epsilon_n$$</p><p>这也是一个随机变数，定义在某个机率空间$\mathcal{(\Omega, F , P )}$上，代表丢$n$次硬币中，正面出现次数之随机变数，它具有二项分布。于是「$S_{2 n} = n$」就表示丢$2n$次正面恰好出现$n$次的事件，其概率记为$P ( S_{2 n} = n )$。</p><p>因此【定理3】是说。  $\lim_{n \rightarrow \infty} P(S_{2n}=n)=0$</p><p>进一步我们猜想：$S_{2n}$落在$n$的附近之概率应该会大起来吧？</p><p>也许这是「正面大约占一半」更贴切的解释。精确的计算是探求隐晦奥秘的不二法门，让我们就来算算看。</p><p>令$a &gt; 0​$唯一个固定数，那么</p><p>$$P(n-a \leq S_{2n} \leq n+a) = \sum_{k=n-a}^{n+a} C_{k}^{2n}\cdot \frac{1}{2^{2n} } \\ \sim \frac{2a}{ \sqrt{\pi n}} \rightarrow 0 ,when \quad  n \rightarrow \infty$$</p><p>因此我们又得到一个不出所料的结果：</p><p>【定理4】：对任意固定数$a &gt; 0$，$$\lim_{b \to \infty} P( \mid S_{2n} - n \mid \leq a ) = 0$$</p><p>换言之，以$n$为中心，左右之长皆为$a$之区间，概率依然为零！另外，将偶数$2n$改成奇数$2 n +1$，【定理4】仍然成立。因为当  $n \to \infty$时，相应项的比值为</p><p>$$\frac{ C_{k}^{2n+1}\cdot \frac{1}{ 2^{2n+1} } }{C_{k}^{2n} \frac{1}{2^{2n}}} = \frac {2n+1}{2n+1-k} \cdot \frac{1}{2} \to \frac{1}{2}$$所以$$P( -a \leq S_{2n+1} - \frac{2n+1}{2} \leq a )  \\ = \sum_{k=-a+ \frac {2n+1}{2}}^{a+ \frac {2n+1}{2}}  C_k^{2n} \frac{1}{2^{2n+1}}\\\sim \frac{1}{2}\sum_{k=-a+ \frac {2n+1}{2}}^{a+ \frac {2n+1}{2}}  C_k^{2n} \frac{1}{2^{2n}} \to 0$$</p><p>所以得到【定理5】：对任意有限正数$a$，恒有$$\lim_{n \to \infty} P(-a \leq S_{2n+1} - \frac{2n+1}{2} \leq a) = 0$$</p><p>将上述【定理4】与【定理5】归结起来就得到：</p><p>【定理6】：对任意有限正数$a$，恒有</p><p>$$\lim_{n \to \infty} P(-a \leq S_n - \frac{n}{2} \leq a) = 0 $$</p><p>这是一个令人惊异的结果，但也令人失望！逻辑的闷棍把常识的观点打得眼冒金星。用任何有限区间$[- a , a\ ]$来网罗住  $S_n - \frac{n}{2}$所散布的概率，当 $n \to \infty$时，根本没有往到任何概率，概率全部流失掉！</p><p>换言之，丢$n$次，出现正面的次数，落在包含$\frac{n}{2}$的任何有限区间的机会，当$n$很大时，微乎其微。</p><p>什么是概率？它仍然是很神秘！</p><blockquote><ol><li>表面来看，Stirling 公式并不漂亮，但却很多用途，它是揭开许多深刻奥秘的钥匙。在研究二项分布的性质时，De Moivre 最先得到这个公式（1718年）；后来James Stirling 在1730年又重新得到它。</li></ol></blockquote><blockquote><ol start="2"><li>$n!$的连续变化就是Gamma函数，内容精彩丰富，这是Euler的贡献。</li></ol></blockquote><h2>附录</h2><blockquote><p>斯特林公式证明，相当于一道考研题目</p></blockquote><p>$$log{n!}=log{1}+log{2}+\cdots+log{n} $$</p><p>因为$\log x$为单调函数，所以</p><p>$$\int_{k-1}^{k} \log{x} dx &lt; \log{n!} &lt; \int_{k}^{k+1}\log{x}dx $$把上式对$k$从$1$到$n$相加得到</p><p>$$\int_{0}^{n}\log{x}dx &lt; \log{n!} &lt; \int_{1}^{n+1}\log{x}dx \qquad(1)$$$$\Leftrightarrow n\log{n}-n &lt; \log{n!} &lt; (n+1)\log{(n+1)}-n \qquad(2)$$这是一个双重不等式，提示我们把$\log {n!}$与两端数的算数平均做比较，即想到$(n+\frac{1}{2})\log{n}-n$$$d_n=\log{n!}-(n+\frac{1}{2})\log{n}+n \qquad (3)$$$$d_n - d_{n+1}=\log{n!}-(n+\frac{1}{2})\log\frac{n+1}{n}-1$$$$\frac{n+1}{n}=\frac{1+\frac{1}{2n+1}}{1-\frac{1}{2n+1}}$$$\boldsymbol{Taylor}$展开得$$d_n - d_{n+1}=\frac{1}{3(2n+1)^2}+\frac{1}{5(2n+1)^4}+\cdots $$把上式与一个公比的几何级数进行比较得$$0 &lt; d_n-d_{n+1} &lt; \frac{1}{3\left [ (2n+1)^2-1 \right ]}=\frac{1}{12n}-\frac{1}{12(n+1)}$$知是${d_n}$下降序列，说明序列${d_n-(12n)^{-1} }$是上升的，因此，极限$\lim d_n = C$存在且有限，但是，由$(3)$知：$d_n \rightarrow C$等价于$$n! \sim e^C \cdot n^{n+\frac{1}{2} } \cdot e^{-n}$$</p><p>这就是斯特林公式的初步证明，其中关于$C$（$e^C=\sqrt{2\pi}$）的证明较复杂，有兴趣可参考相关文章，在此不赘述。</p>]]></content>
    
    <summary type="html">
    
      什么是一个事件（event）的概率？这是概率论最基本也是争议最多的问题。我们是试着从常识出发，来考虑数学表达。
    
    </summary>
    
      <category term="概率论" scheme="http://ulsonhu.cn/categories/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
    
      <category term="Mathematic" scheme="http://ulsonhu.cn/tags/Mathematic/"/>
    
      <category term="概率论" scheme="http://ulsonhu.cn/tags/%E6%A6%82%E7%8E%87%E8%AE%BA/"/>
    
  </entry>
  
  <entry>
    <title>用python做数据分析与科学计算(篇一)</title>
    <link href="http://ulsonhu.cn/%E7%94%A8python%E5%81%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97(%E7%AF%87%E4%B8%80).html"/>
    <id>http://ulsonhu.cn/用python做数据分析与科学计算(篇一).html</id>
    <published>2018-03-17T16:00:00.000Z</published>
    <updated>2018-03-24T15:55:57.498Z</updated>
    
    <content type="html"><![CDATA[<p>用python做数据分析与科学计算主要涉及Numpy, Pandas, Scipy, Scikit-learn, Scipy等库，工作环境为Anaconda，这个IDE集成了大部分常用的包。同时，可以实现本地环境下Python的多版本切换，可参考之前文章,<a href="https://ulsonhu.github.io/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html" target="_blank" rel="noopener">MacOS下使用python的多版本方案</a></p><a id="more"></a><p>  通常做数据分析&amp;挖掘的workflow：拿到数据之后先要做一个数据的预处理(pandas+numpy+scipy)，接着会要对数据包含的特征做一些可视化输出(matplotlib)，之后需要提取特征&amp;建模调参(numpy+scikit-learn)，有了模型与结果，最后归纳整理做presentation &amp; report.</p><h2>Numpy</h2><p>用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多，本身是由C语言开发。这个是很基础的扩展，其余的扩展都是以此为基础。数据结构为ndarray,一般有三种方式来创建。</p><table><thead><tr><th>Function</th><th>Useage</th></tr></thead><tbody><tr><td>array.shape</td><td>查看或改变数组的大小</td></tr><tr><td>array.reshape</td><td>修改数组的尺寸，原数组不变，两个数组共享内存，如果修改值的话这两个数组都会变</td></tr><tr><td>array.size</td><td>数组元素的总个数，等于shape属性中元组元素的乘积</td></tr><tr><td>array.ndim</td><td>数组的维数</td></tr><tr><td>array.dtype</td><td>array的数据规格</td></tr><tr><td>numpy.zeros(dim1,dim2)</td><td>创建dim1*dim2的零矩阵</td></tr><tr><td>numpy.eye(n)</td><td>创建$n*n$单位矩阵</td></tr><tr><td>numpy.identity(n)</td><td>创建$n*n$单位矩阵</td></tr><tr><td>numpy.arange</td><td>类似于list的range函数，通过指定初始值，终值，和步长来生成一维数组</td></tr><tr><td>array.astype(numpy.float64)</td><td>更换矩阵的数据形式</td></tr><tr><td>array * array</td><td>矩阵点乘</td></tr><tr><td>array[a:b]</td><td>切片</td></tr><tr><td>array.copy()</td><td>得到ndarray的副本，而不是视图</td></tr><tr><td>array [a] [b]=array [ a, b ]</td><td>两者等价</td></tr><tr><td>data[[4,3,0,6]]</td><td>索引，将第4,3,0,6行摘取出来，组成新数组</td></tr><tr><td>numpy.reshape(a,b)</td><td>将a<em>b的一维数组排列为a</em>b的形式</td></tr><tr><td>array([a,b,c,d],[d,e,f,g])</td><td>返回一维数组，分别为[a,d],[b,e],[c,f],[d,g]</td></tr><tr><td>array.T</td><td>array的转置</td></tr><tr><td>numpy.random.randn(a,b)</td><td>生成$a*b$的随机数组</td></tr><tr><td>numpy.dot(matrix_1,matrix_2)</td><td>矩阵乘法</td></tr><tr><td>array.transpose( (1,0,2,etc.) )</td><td>对于高维数组，转置需要一个由轴编号组成的元组</td></tr></tbody></table><p>numpy库提供了matrix类，使用matrix类创建的是矩阵对象，它们的加减乘除运算缺省采用矩阵方式计算。但是由于NumPy中同时存在ndarray和matrix对象，因此很容易将两者弄混。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用ones()创建一个2*4的全1矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mat(np.ones((<span class="number">2</span>,<span class="number">4</span>))) </span><br><span class="line">matrix([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">        [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><h2>Pandas</h2><p>基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。最具有统计意味的工具包，某些方面优于R软件。数据结构有一维的Series，二维的DataFrame(类似于Excel或者SQL中的表，如果深入学习，会发现Pandas和SQL相似的地方很多，例如merge函数)，三维的Panel（Pan（el) + da(ta) + s，知道名字的由来了吧）。</p><p>学习Pandas你要掌握的是：</p><ol><li>汇总和计算描述统计，处理缺失数据 ，层次化索引</li><li>清理、转换、合并、重塑、GroupBy技术</li><li>日期和时间数据类型及工具</li></ol><p><a href="http://pandas.pydata.org/pandas-docs/stable/10min.htmlml" target="_blank" rel="noopener">入门理解：</a></p><iframe src="http://nbviewer.jupyter.org/github/ulsonhu/mltest/blob/master/python_backup/Pandas_learn.ipynb" width="95%" height="300"></iframe><h3>使用pandas清洗数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">column_names = [<span class="string">"sex"</span>, <span class="string">"length"</span>, <span class="string">"diameter"</span>, <span class="string">"height"</span>, <span class="string">"whole weight"</span>, <span class="string">"shucked weight"</span>, <span class="string">"viscera weight"</span>, <span class="string">"shell weight"</span>, <span class="string">"rings"</span>]</span><br><span class="line">alone_df = pd.read_csv(<span class="string">'alone.csv'</span>,names=column_names)</span><br><span class="line">alone_df[<span class="string">'sex'</span>] = alone_df[<span class="string">'sex'</span>].map(&#123;<span class="string">'F'</span>:<span class="number">1</span>,<span class="string">'M'</span>:<span class="number">0</span>,<span class="string">'I'</span>:<span class="number">2</span>&#125;)</span><br><span class="line">alone_df[<span class="string">'sex'</span>] = alone_df.rings.map(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">alone_df.head()</span><br></pre></td></tr></table></figure><h2>Matplotlib</h2><p>Python中最著名的绘图系统，很多其他的绘图例如Seaborn（针对pandas绘图而来）也是由其封装而成。其中针对不是很复杂的数据，推荐使用Seaborn，容易上手，图表美观。<a href="http://seaborn.pydata.org/index.html" target="_blank" rel="noopener">Seaborn参考</a></p><p>需要掌握的内容</p><ol><li>散点图，折线图，条形图，直方图，饼状图，箱形图的绘制。</li><li>绘图的三大系统：pyplot，pylab(不推荐)，面向对象</li><li>坐标轴的调整，添加文字注释，区域填充，及特殊图形patches的使用</li><li>金融的同学要注意的是：可以直接调用Yahoo财经数据绘图（很好用）</li></ol><h3>简单的散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902375/2018_03_09_03.png" width="90%" height="90%"><h3>使用子图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment"># （行，列，活跃区）</span></span><br><span class="line">plt.plot(x, np.sin(x), <span class="string">'r'</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">'g'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902375/2018_03_09_02.png" width="90%" height="90%"><p>使用子图只需要一个额外的步骤。即在调用 <code>plot()</code> 函数之前需要先调用<code>subplot()</code>函数。该函数的第一个参数代表子图的总行数，第二个参数代表子图的总列数，第三个参数代表活跃区域.</p><p>标题，标签和图例当需要快速创建图形时，你可能不需要为图形添加标签。但是当构建需要展示的图形时，你就需要添加标题，标签和图例。</p><h3>添加标题，坐标轴标记和图例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">plt.plot(x, np.sin(x), <span class="string">'r-x'</span>, label=<span class="string">'Sin(x)'</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">'g-^'</span>, label=<span class="string">'Cos(x)'</span>)</span><br><span class="line">plt.legend() <span class="comment"># 展示图例</span></span><br><span class="line">plt.xlabel(<span class="string">'Rads'</span>) <span class="comment"># 给 x 轴添加标签</span></span><br><span class="line">plt.ylabel(<span class="string">'Amplitude'</span>) <span class="comment"># 给 y 轴添加标签</span></span><br><span class="line">plt.title(<span class="string">'Sin and Cos Waves'</span>) <span class="comment"># 添加图形标题</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>为了给图形添加图例，我们需要在 <code>plot()</code> 函数中添加命名参数 <code>label</code> 并赋予该参数相应的标签。然后调用 <code>legend()</code> 函数就会在我们的图形中添加图例。</p><p>接下来我们只需要调用函数 <code>title()</code>，<code>xlabel()</code> 和 <code>ylabel()</code> 就可以为图形添加标题和标签。</p><p>你会得到类似于下面这张拥有标题、标签和图例的图形：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902376/2018_03_09_04.png" width="90%" height="90%"><p>参考文献</p><ol><li><a href="http://deeplearning.net/tutorial/" target="_blank" rel="noopener">Deep Learning Tutorials</a></li><li><a href="http://www.scipy-lectures.org/" target="_blank" rel="noopener">Scipy Lecture</a></li><li><a href="https://www.kesci.com/" target="_blank" rel="noopener">KeSci平台</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/10min.html" target="_blank" rel="noopener">10 Minutes to pandas</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;用python做数据分析与科学计算主要涉及Numpy, Pandas, Scipy, Scikit-learn, Scipy等库，工作环境为Anaconda，这个IDE集成了大部分常用的包。同时，可以实现本地环境下Python的多版本切换，可参考之前文章,&lt;a href=&quot;https://ulsonhu.github.io/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;MacOS下使用python的多版本方案&lt;/a&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="Python" scheme="http://ulsonhu.cn/tags/Python/"/>
    
      <category term="Machine Learning" scheme="http://ulsonhu.cn/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>SAS基础学习篇(一)</title>
    <link href="http://ulsonhu.cn/SAS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80).html"/>
    <id>http://ulsonhu.cn/SAS基础学习篇(一).html</id>
    <published>2018-03-13T16:00:00.000Z</published>
    <updated>2018-03-21T02:59:56.496Z</updated>
    
    <content type="html"><![CDATA[<p>参考书籍</p><ol><li>《SAS编程与数据挖掘商业案例》（预热）</li><li>「the Little SAS Book」(推荐)</li><li>「Applied Econometrics Using The SAS System」</li></ol><p>SAS编程主要包括<code>DATA</code>和<code>PROC</code>两部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* create sas data set named toads;</span><br><span class="line">* read the data file ToadJump.dta using list input;</span><br><span class="line">DATA toads;</span><br><span class="line">INFILE &apos;~/desktop/ToadJump.dta&apos;;</span><br><span class="line">INPUT ToadJump $ Weight Jump1 Jump2 Jump3;</span><br><span class="line">RUN;</span><br><span class="line">* print the data to make sure the file was read correctly;</span><br><span class="line">* PROC PRINT DATA = toads;</span><br><span class="line">TITLE &apos;SAS Data Set Toads&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>这样就建立了一个名为<code>toads</code>的临时数据集，然后读入外部文件<code>ToadJump.dat</code>，然后告诉SAS有四个变量，其中第一个是文本型,缺失值用一个点<code>.</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* Create a SAS data set named sales;</span><br><span class="line">* Read the data file OnionRing.dat using column input;</span><br><span class="line">DATA sales;</span><br><span class="line">INFILE ’~/desktop/OnionRing.dat’;</span><br><span class="line">INPUT VisitingTeam $ 1-20 ConcessionSales 21-24 BleacherSales 25-28</span><br><span class="line">OurHits 29-31 TheirHits 32-34 OurRuns 35-37 TheirRuns 38-40;</span><br><span class="line">RUN;</span><br><span class="line">* Print the data to make sure the file was read correctly;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">TITLE ’SAS Data Set Sales’;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h2>基本函数</h2><table><thead><tr><th>SAS文本类函数</th><th></th></tr></thead><tbody><tr><td>ANYALNUM(arg,start)</td><td>返回第一次出现任意数字或字母的位置，可选开始位置start</td></tr><tr><td>ANYALPHA(arg,start)</td><td>返回第一次出现任意字母的位置，可选开始位置start</td></tr><tr><td>ANYDIGIT(arg,start)</td><td>返回第一次出现任意数字的位置，可选开始位置start</td></tr><tr><td>ANYSPACE(arg,start)</td><td>返回第一次出现任意空白的位置，可选开始位置start</td></tr><tr><td>CAT(arg1,arg2,…argn)</td><td>连接字符串，留下头尾空白</td></tr><tr><td>CATS(arg1,arg2,…argn)</td><td>连接字符串，删除头尾空白</td></tr><tr><td>CATX(‘separator-string’, arg-1,…,arg-n)</td><td>连接字符串，删除头尾空白并用指定标点连接</td></tr><tr><td>COMPRESS(arg, ‘char’)</td><td>移除字符串中的空格和可选字符</td></tr><tr><td>INDEX(arg, ‘string’)</td><td>返回指定字符在变量中的位置</td></tr><tr><td>LEFT(arg)</td><td>字符串左对齐</td></tr><tr><td>LENGTH(arg)</td><td>返回字符串长度，不考虑尾部空格</td></tr><tr><td>PROPCASE(arg)</td><td>首字母大写</td></tr><tr><td>SUBSTR(arg,position,n)</td><td>从字符串中提取指定开始位置指定长度字符</td></tr><tr><td>TRANSLATE(source,to1,from1,…ton,fromn)</td><td>替换字符</td></tr><tr><td>TRANWRD(source,from,to)</td><td>替换字符串</td></tr><tr><td>TRIM(arg)</td><td>删除尾部空白</td></tr><tr><td>UPCASE(arg)</td><td>替换成大写</td></tr></tbody></table><table><thead><tr><th>SAS数值函数</th><th></th></tr></thead><tbody><tr><td>INT(arg)</td><td>返回整数</td></tr><tr><td>LOG(arg)</td><td>自然对数</td></tr><tr><td>LOG10(arg)</td><td>$10$为底对数</td></tr><tr><td>MAX(arg1,arg2,…argn)</td><td>最大值</td></tr><tr><td>MEAN(arg1,arg2,…argn)</td><td>均值</td></tr><tr><td>MIN(arg1,arg2,…argn)</td><td>最小值</td></tr><tr><td>N(arg1,arg2,…argn)</td><td>非缺失值个数</td></tr><tr><td>NMISS(arg1,arg2,…argn)</td><td>缺失值个数</td></tr><tr><td>ROUND(arg, roundoffunit)</td><td>保留几位小数</td></tr><tr><td>SUM(arg1,arg2,…argn)</td><td>求和</td></tr></tbody></table><table><thead><tr><th>SAS日期函数</th><th></th></tr></thead><tbody><tr><td>DATEJUL(julian-date)</td><td>标准julian日期到SAS日期</td></tr><tr><td>DAY(date)</td><td>返回「日」</td></tr><tr><td>MDY(month,day,year)</td><td>年月日到SAS日期</td></tr><tr><td>MONTH(date)</td><td>返回「月」</td></tr><tr><td>QTR(date)</td><td>返回季度</td></tr><tr><td>TODAY()</td><td>今日</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几（周日为1）</td></tr><tr><td>YEAR(date)</td><td>返回「年」</td></tr><tr><td>YRDIF(start-date,end- date,’ACTUAL’)</td><td>返回相差年份</td></tr></tbody></table><h2>判断结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* if then structure</span><br><span class="line">if model = &apos;Pink&apos; then make = &apos;Floyd&apos;;</span><br><span class="line"></span><br><span class="line">* 执行多项命令，需要嵌套do；可以用and和or</span><br><span class="line">if Year then Model = &apos;Mac&apos; or Model = &apos;pro&apos; then Make = &apos;Jobs&apos;;</span><br><span class="line">if Model = &apos;iphone5&apos; then do;</span><br><span class="line">Make = &apos;Tim&apos;;</span><br><span class="line">Seats = 2;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">* if else</span><br><span class="line">if Cost = . then CostGroup = &apos;Missing&apos;;</span><br><span class="line">else if Cost else if Cost else CostGroup = high;</span><br><span class="line"></span><br><span class="line">* use if to select sub-set</span><br><span class="line">if sex = &apos;m&apos;;if sex = &apos;m&apos; then detele;</span><br></pre></td></tr></table></figure><h2>数组操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* Change all 9 to missing values;</span><br><span class="line">DATA songs;</span><br><span class="line">INFILE &apos;~/desktop/WBRK.dat&apos;;</span><br><span class="line">INPUT City $ 1-15 Age domk wj hwow simbh kt aomm libm tr filp ttr;</span><br><span class="line">ARRAY song (10) domk wj hwow simbh kt aomm libm tr filp ttr;</span><br><span class="line">DO i = 1 TO 10;</span><br><span class="line">IF song(i) = 9 THEN song(i) = .;</span><br><span class="line">END;</span><br><span class="line">RUN;</span><br><span class="line">PROC PRINT DATA = songs;</span><br><span class="line">TITLE &apos;WBRK Song Survey&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h2>基本模块调用</h2><p>搞定基本的函数之后，开始鼓捣$SAS$里面的模型。也就是说，要开始写<code>PROC</code>了。其实，$SAS$比较像$Stata$（计量经济学主流软件），无论是从输出的样式，还是语法。不习惯没有()的模型调用呀。若是说$SAS$和$Stata$的区别，怕只是$Stata$更侧重于<strong>计量模型</strong>而$SAS$则是服务于大多数<strong>统计模型</strong>吧。</p><h3>PROC的基本内容：CONTENT</h3><p><code>PROC:content</code>，可以显示数据集的主要特性。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBNAME tropical &apos;~/MySASLib&apos;;</span><br><span class="line">PROC CONTENTS DATA = tropical.banana;</span><br></pre></td></tr></table></figure><p>这里主要是两个声明:<code>TITLE</code>和<code>FOOTNOTE</code>。前者输出时候会产生一个标题，后者会产生尾注。用法也是比较直接的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TITLE ”Here’s another title”;</span><br><span class="line">TITLE ’Here’’s another title’;</span><br><span class="line">FOOTNOTE3 ’This is the third footnote’;</span><br></pre></td></tr></table></figure><h3>SAS PROC求子集:WHERE</h3><p>如果要在<code>PROC</code>里面先求子集的话，可以直接调用<code>WHERE</code>。感觉这里和$SQL$的思路比较像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROC PRINT DATA = &apos;～/desktop/MySASLib/style&apos;;</span><br><span class="line">WHERE Genre = &apos;Impressionism&apos;;</span><br><span class="line">TITLE &apos;Major Impressionist Painters&apos;;</span><br><span class="line">FOOTNOTE &apos;F = France N = Netherlands U = US&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h3>SAS PROC 数据进行排序:SORT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA marine;</span><br><span class="line">INFILE &apos;~/desktop/Lengths.dat&apos;;</span><br><span class="line">INPUT Name $ Family $ Length @@;</span><br><span class="line">RUN;</span><br><span class="line">* Sort the data;</span><br><span class="line">PROC SORT DATA = marine OUT = seasort NODUPKEY;</span><br><span class="line">BY Family DESCENDING Length;</span><br><span class="line">PROC PRINT DATA = seasort;</span><br><span class="line">TITLE &apos;Whales and Sharks&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>这样数据就按照<code>Family</code>、<code>Length</code>（递减）排序了。</p><h3>SAS PROC 输出数据:PRINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Candy.dat&apos;;</span><br><span class="line">INPUT Name $ 1-11 Class @15 DateReturned MMDDYY10. CandyType $</span><br><span class="line">Quantity;</span><br><span class="line">Profit = Quantity * 1.25;</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY Class;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">BY Class;</span><br><span class="line">SUM Profit;</span><br><span class="line">VAR Name DateReturned CandyType Profit;</span><br><span class="line">TITLE &apos;Candy Sales for Field Trip by Class&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h3>SAS PROC里面改变输出格式：FORMAT</h3><p>基本就是<code>FORMAT</code>一下就可以了，再就是<code>PUT</code>的时候也可以调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Candy.dat&apos;;</span><br><span class="line">INPUT Name $ 1-11 Class @15 DateReturned MMDDYY10. CandyType $</span><br><span class="line">Quantity;</span><br><span class="line">Profit = Quantity * 1.25;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">VAR Name DateReturned CandyType Profit;</span><br><span class="line">FORMAT DateReturned DATE9. Profit DOLLAR6.2;</span><br><span class="line">TITLE &apos;Candy Sale Data Using Formats&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>常用的格式有：</p><ul><li>文本型：<code>$HEXw.</code>和<code>$w.</code></li><li>日期型：<code>DATEw.</code>（输出为ddmmyy或者ddmmyyyy）、<code>DATETIMEw.d</code>（输出为ddmmyy:hh:mm:ss）、<code>DAYw.</code>（输出为dd）、<code>EURDFDDw.</code> 、<code>JULIANw.</code>、<code>MMDDYYw.</code>（输出为mmddyy或mmddyyyy）、<code>TIMEw.d</code>（输出为hh:mm:ss）、<code>WEEKDATEw.</code>（输出为工作日）、<code>WORDDATEw.</code>(输出为单词)。</li><li>数字型：<code>BESTw.</code>（自动选择）、<code>COMMAw.d</code>（逗号分隔）、<code>DOLLARw.d</code>（货币）、<code>Ew.</code>（科学计数法）、<code>PDw.d</code>、<code>w.d</code>（标准小数）</li></ul><p>输出的样本见下：</p><p>当然<code>FORMAT</code>还可以自定义<code>factor</code>型变量的输出格式，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA carsurvey;</span><br><span class="line">INFILE &apos;~/deskktop/Cars.dat&apos;;</span><br><span class="line">INPUT Age Sex Income Color $;</span><br><span class="line">PROC FORMAT;</span><br><span class="line">VALUE gender 1 = &apos;Male&apos; </span><br><span class="line">2 = &apos;Female&apos;;</span><br><span class="line">VALUE agegroup 13 -&lt; 20 = &apos;Teen&apos;</span><br><span class="line">20 -&lt; 65 = &apos;Adult&apos;</span><br><span class="line">65 - HIGH = &apos;Senior&apos;;</span><br><span class="line">VALUE $col &apos;W&apos; = &apos;Moon White&apos;</span><br><span class="line">&apos;B&apos; = &apos;Sky Blue&apos;</span><br><span class="line">&apos;Y&apos; = &apos;Sunburst Yellow&apos;</span><br><span class="line">&apos;G&apos; = &apos;Rain Cloud Gray&apos;;</span><br><span class="line">* Print data using user-defined and standard (DOLLAR8.) formats;</span><br><span class="line">PROC PRINT DATA = carsurvey;</span><br><span class="line">FORMAT Sex gender. Age agegroup. Color $col. Income DOLLAR8.;</span><br><span class="line">TITLE &apos;Survey Results Printed with User-Defined Formats&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>就可以把数字型的1，2转换为对应的文本<code>male</code>和<code>female</code>等，还可以把变量离散化。</p><h3>SAS总结数据:MEANS</h3><p>$SAS$当然还有类似于$Excel$的数据透视表和$R$的<code>data.table</code>的模块，就是<code>MEANS</code>。可以输出的描述性统计值，包括最大值、最小值、平均值、中位数、余非缺失值个数、缺失值个数、范围、标准差、和等等。此外，还可以使用<code>BY</code>或者<code>CLASS</code>进行分组统计，<code>VAR</code>选择变量等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Flowers.dat&apos;;</span><br><span class="line">INPUT CustomerID $ @9 SaleDate MMDDYY10. Petunia SnapDragon</span><br><span class="line">Marigold;</span><br><span class="line">Month = MONTH(SaleDate);</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY Month;</span><br><span class="line">* Calculate means by Month for flower sales;</span><br><span class="line">PROC MEANS DATA = sales;</span><br><span class="line">BY Month;</span><br><span class="line">VAR Petunia SnapDragon Marigold;</span><br><span class="line">TITLE &apos;Summary of Flower Sales by Month&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Summary of  Flower Sales by Month 1</span><br><span class="line">---------------- Month=5 --------------</span><br><span class="line">The MEANS Procedure</span><br><span class="line">Variable N Mean Std Dev Minimum Maximum</span><br><span class="line">----------------------------------------</span><br><span class="line">Petunia 3 86.6666667 35.1188458 50.0000000 120.0000000</span><br><span class="line">SnapDragon 3 113.3333333 41.6333200 80.0000000 160.0000000</span><br><span class="line">Marigold 3 81.6666667 25.6580072 60.0000000 110.0000000</span><br><span class="line">---------------- Month=6 ---------------</span><br><span class="line">Variable N Mean Std Dev Minimum Maximum</span><br><span class="line">-----------------------------------------</span><br><span class="line">Petunia 4 81.2500000 16.5201897 60.0000000 100.0000000</span><br><span class="line">SnapDragon 4 97.5000000 47.8713554 60.0000000 160.0000000</span><br><span class="line">Marigold 4 83.7500000 19.7378655 60.0000000 100.0000000</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure><p>当然这些统计量也可以直接的写入一个SAS数据表，只需要加上一个<code>OUTPUT</code>就可以了。原数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">756-01 05/04/2008 120 80 110</span><br><span class="line">834-01 05/12/2008 90 160 60</span><br><span class="line">901-02 05/18/2008 50 100 75</span><br><span class="line">834-01 06/01/2008 80 60 100</span><br><span class="line">756-01 06/11/2008 100 160 75</span><br><span class="line">901-02 06/19/2008 60 60 60</span><br><span class="line">756-01 06/25/2008 85 110 100</span><br></pre></td></tr></table></figure><p>SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Flowers.dat&apos;;</span><br><span class="line">INPUT CustomerID $ @9 SaleDate MMDDYY10. Petunia SnapDragon Marigold;</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY CustomerID;</span><br><span class="line">* Calculate means by CustomerID, output sum and mean to new data set;</span><br><span class="line">PROC MEANS NOPRINT DATA = sales;</span><br><span class="line">BY CustomerID;</span><br><span class="line">VAR Petunia SnapDragon Marigold;</span><br><span class="line">OUTPUT OUT = totals MEAN(Petunia SnapDragon Marigold) =</span><br><span class="line">MeanPetunia MeanSnapDragon MeanMarigold</span><br><span class="line">SUM(Petunia SnapDragon Marigold) = Petunia SnapDragon Marigold;</span><br><span class="line">PROC PRINT DATA = totals;</span><br><span class="line">TITLE &apos;Sum of Flower Data over Customer ID&apos;;</span><br><span class="line">FORMAT MeanPetunia MeanSnapDragon MeanMarigold 3.;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终结果为：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_01.png" width="90%" height="90%"></p><h3>SAS PROC统计频率：FREQ</h3><p>计数的话，就要靠SAS里面的<code>FREQ</code>模块了。比如我们有一个数据集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp w cap d cap w kon w ice w kon d esp d kon w ice d esp d</span><br><span class="line">cap w esp d cap d Kon d . d kon w esp d cap w ice w kon w</span><br><span class="line">kon w kon w ice d esp d kon w esp d esp w kon w cap w kon w</span><br></pre></td></tr></table></figure><p>然后可以用<code>FREQ</code>来统计一些基本量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA orders;</span><br><span class="line">INFILE &apos;~/desktop/Coffee.dat&apos;;</span><br><span class="line">INPUT Coffee $ Window $ @@;</span><br><span class="line">* Print tables for Window and Window by Coffee;</span><br><span class="line">PROC FREQ DATA = orders;</span><br><span class="line">TABLES Window Window * Coffee;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终会得到一个$2*5$的表格：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_02.png" width="90%" height="90%"></p><h3>SAS PROC汇报表格：TABULATE</h3><p>基本看到TABULATE就可以想到那个著名的软件Tabular了…不过貌似SAS也自带了一个类似的表格模块。这个东西可以变得非常复杂，不过鉴于一时半会儿还用不到，没有细细看。抄个例子吧。</p><p>原数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Silent Lady Maalea sail sch 75.00</span><br><span class="line">America II Maalea sail yac 32.95</span><br><span class="line">Aloha Anai Lahaina sail cat 62.00</span><br><span class="line">Ocean Spirit Maalea power cat 22.00</span><br><span class="line">Anuenue Maalea sail sch 47.50</span><br><span class="line">Hana Lei Maalea power cat 28.99</span><br><span class="line">Leilani Maalea power yac 19.99</span><br><span class="line">Kalakaua Maalea power cat 29.50</span><br><span class="line">Reef Runner Lahaina power yac 29.95</span><br><span class="line">Blue Dolphin Maalea sail cat 42.95</span><br></pre></td></tr></table></figure><p>SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36;</span><br><span class="line">RUN;</span><br><span class="line">* Tabulations with three dimensions;</span><br><span class="line">PROC TABULATE DATA = boats;</span><br><span class="line">CLASS Port Locomotion Type;</span><br><span class="line">TABLE Port, Locomotion, Type;</span><br><span class="line">TITLE &apos;Number of Boats by Port, Locomotion, and Type&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终结果：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_03.png" width="90%" height="90%"></p><p>类似的，还可以增加统计量（类似于<code>MEANS</code>那里）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36;</span><br><span class="line">RUN;</span><br><span class="line">* PROC TABULATE report with options;</span><br><span class="line">PROC TABULATE DATA = boats FORMAT=DOLLAR9.2;</span><br><span class="line">CLASS Locomotion Type;</span><br><span class="line">VAR Price;</span><br><span class="line">TABLE Locomotion ALL, MEAN*Price*(Type ALL)</span><br><span class="line">/BOX=&apos;Full Day Excursions&apos; MISSTEXT=&apos;none&apos;;</span><br><span class="line">TITLE;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以得到：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_04.png" width="90%" height="90%"></p><p>最后还可以混合<code>FORMAT</code>等等，可以变得相当的复杂。貌似这东西是美国劳工部鼓捣出来的格式…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36 Length 38-40;</span><br><span class="line">RUN;</span><br><span class="line">* Using the FORMAT= option in the TABLE statement;</span><br><span class="line">PROC TABULATE DATA = boats;</span><br><span class="line">CLASS Locomotion Type;</span><br><span class="line">VAR Price Length;</span><br><span class="line">TABLE Locomotion ALL,</span><br><span class="line">MEAN * (Price*FORMAT=DOLLAR6.2 Length*FORMAT=6.0) * (Type ALL);</span><br><span class="line">TITLE &apos;Price and Length by Type of Boat&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>BOSS级汇报表格呈现了…</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_05.png" width="90%" height="90%"><p>我只能感慨，不愧是商业软件啊，用户需求考虑的真的是特别的周到…这种费时费力做汇报表格的事情也被搞定了，强悍。</p><p>SAS里面的报告：REPORT还有一个REPORT，看到有TABULATE的时候我已经不奇怪并略略的有些期待一个做报告的模块出现了。这东西基本就是前面几个的超级混合体，反正你想搞到的汇报模式总是能够搞出来的。</p><p>又是一堆数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17 sci 9 bio 28 fic 50 mys 13 fic 32 fic 67 fic 81 non 38 non</span><br><span class="line">53 non 16 sci 15 bio 61 fic 52 ref 22 mys 76 bio 37 fic 86 fic</span><br><span class="line">49 mys 78 non 45 sci 64 bio 8 fic 11 non 41 fic 46 ref 69 fic</span><br><span class="line">34 fic 26 mys 23 sci 74 ref 15 sci 27 fic 23 mys 63 fic 78 non</span><br><span class="line">40 bio 12 fic 29 fic 54 mys 67 fic 60 fic 38 sci 42 fic 80 fic</span><br></pre></td></tr></table></figure><p>然后一堆SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DATA books;</span><br><span class="line">INFILE &apos;c:\MyRawData\LibraryBooks.dat&apos;;</span><br><span class="line">INPUT Age BookType $ @@;</span><br><span class="line">RUN;</span><br><span class="line">* Define formats to group the data;</span><br><span class="line">PROC FORMAT;</span><br><span class="line">VALUE agegpa</span><br><span class="line">0-18 = &apos;0 to 18&apos;</span><br><span class="line">19-25 = &apos;19 to 25&apos;</span><br><span class="line">26-49 = &apos;26 to 49&apos;</span><br><span class="line">50-HIGH = &apos; 50+ &apos;;</span><br><span class="line">VALUE agegpb</span><br><span class="line">0-25 = &apos;0 to 25&apos;</span><br><span class="line">26-HIGH = &apos; 26+ &apos;;</span><br><span class="line">VALUE $typ</span><br><span class="line">&apos;bio&apos;,&apos;non&apos;,&apos;ref&apos; = &apos;Non-Fiction&apos;</span><br><span class="line">&apos;fic&apos;,&apos;mys&apos;,&apos;sci&apos; = &apos;Fiction&apos;;</span><br><span class="line">RUN;</span><br><span class="line">*Create two way table with Age grouped into four categories;</span><br><span class="line">PROC FREQ DATA = books;</span><br><span class="line">TITLE &apos;Patron Age by Book Type: Four Age Groups&apos;;</span><br><span class="line">TABLES BookType * Age / NOPERCENT NOROW NOCOL;</span><br><span class="line">FORMAT Age agegpa. BookType $typ.;</span><br><span class="line">RUN;</span><br><span class="line">* Create two way table with Age grouped into two categories;</span><br><span class="line">PROC FREQ DATA = books;</span><br><span class="line">TITLE &apos;Patron Age by Book Type: Two Age Groups&apos;;</span><br><span class="line">TABLES BookType * Age / NOPERCENT NOROW NOCOL;</span><br><span class="line">FORMAT Age agegpb. BookType $typ.;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>然后一堆交叉计数的结果就出来了：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_06.png" width="90%" height="90%"></p><p>当然，简单的计算和分类统计也不在话下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA natparks;</span><br><span class="line">INFILE &apos;c:\MyRawData\Parks.dat&apos;;</span><br><span class="line">INPUT Name $ 1-21 Type $ Region $ Museums Camping;</span><br><span class="line">RUN;</span><br><span class="line">*Statistics in COLUMN statement with two group variables;</span><br><span class="line">PROC REPORT DATA = natparks NOWINDOWS HEADLINE;</span><br><span class="line">COLUMN Region Type N (Museums Camping),MEAN;</span><br><span class="line">DEFINE Region / GROUP;</span><br><span class="line">DEFINE Type / GROUP;</span><br><span class="line">TITLE &apos;Statistics with Two Group Variables&apos;;</span><br><span class="line">RUN;</span><br><span class="line">*Statistics in COLUMN statement with group and across variables;</span><br><span class="line">PROC REPORT DATA = natparks NOWINDOWS HEADLINE;</span><br><span class="line">COLUMN Region N Type,(Museums Camping),MEAN;</span><br><span class="line">DEFINE Region / GROUP;</span><br><span class="line">DEFINE Type / ACROSS;</span><br><span class="line">TITLE &apos;Statistics with a Group and Across Variable&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以得到一个看起来很fancy的表格：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_07.png" width="90%" height="90%"></p><h3>SAS数据总结综述</h3><p>我的感觉是，<code>MEANS</code>, <code>TABULATE</code>和<code>REPORT</code>这三个模块各有千秋，基本就是可以替代EXCEL的数据透视表，虽然效率上说不好谁比谁高。</p>]]></content>
    
    <summary type="html">
    
      由于接触到SAS，本人电脑为Macbook，暂时无法安装SAS，所以通过网上收集相关知识，Mark下
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="SAS" scheme="http://ulsonhu.cn/tags/SAS/"/>
    
  </entry>
  
  <entry>
    <title>Excel知识点备忘</title>
    <link href="http://ulsonhu.cn/Excel%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%87%E5%BF%98.html"/>
    <id>http://ulsonhu.cn/Excel知识点备忘.html</id>
    <published>2018-03-11T16:00:00.000Z</published>
    <updated>2018-03-23T15:52:50.368Z</updated>
    
    <content type="html"><![CDATA[<p>Excel系统学习：<a href="http://study.163.com/course/courseMain.htm?courseId=670032" target="_blank" rel="noopener">视频教程</a></p><h2>相对引用与绝对引用</h2><ul><li><code>$A1</code>列绝对引用</li><li><code>A$1</code>行绝对引用</li><li><code>$A$1</code>行列都为绝对引用</li></ul><p>快捷键<code>F4</code></p><h2>条件格式</h2><p>学会使用条件格式，其中与混合应用交叉，可实现相关功能</p><h2>排序</h2><ul><li>一般排序</li><li>多条件排序</li><li>按照特定字段排序</li><li>排序的延伸</li></ul><h2>筛选</h2><h2>一、时间与日期函数</h2><ol><li><code>today()</code>返回日期格式的当前日期,输入日期快捷键<code>Ctrl+;</code></li><li><code>now()</code>,输入日期时间快捷键<code>Ctrl+Shift+;</code></li><li><code>weekday(serial_number,return_type)</code></li><li><code>workday()</code></li><li><code>dateif(start_date,end_date,unit[Y|M|D])</code>返回两个日期之间年/月/日的间隔数</li></ol><p>输入日期快捷键<code>Ctrl+;</code></p><h2>二、统计函数</h2><ol><li><code>count</code></li><li><code>countif(range,criteria)</code>计算区域中满足指定条件的单元格个数</li><li><code>countifs(range1,criteria1,range2,criteria2,...)</code></li><li><code>sumif(range,criteria,sum_range)</code></li><li><code>sumifs(sum_range,criteria_range1,criteria1,criteria_range2,criteria2,...)</code></li></ol><h2>三、查找和引用函数</h2><ol><li><code>vlookup(lookup_value,table_array,col_index_num,range_lookup)</code></li></ol><ul><li><code>lookup_value</code>需要在数据表第一列查找的数值</li><li><code>table_array</code>需要查找的数据区域</li><li><code>col_index_num</code>为待返回的匹配值的列序号</li><li><code>range_lookup</code>精确匹配与模糊匹配</li></ul><h3>关于跨表引用</h3><table><thead><tr><th>产品编号</th><th>系列</th><th>产品名称</th><th>进货单价</th></tr></thead><tbody><tr><td>AP11001</td><td>老婆饼</td><td>老婆饼（花生）</td><td>6.5</td></tr><tr><td>AP11002</td><td>老婆饼</td><td>老婆饼（桂花）</td><td>6.5</td></tr></tbody></table><p>如根据“产品编号”自动返回基本信息表“系列”字段内容<code>vlookup($D2,产品基本信息表!$B$3:$F$38,2,false)</code></p><blockquote><p>跨表查询，工作中常用</p></blockquote><p>注意：</p><ul><li>查找值一定要在第一列</li><li>模糊匹配时第一列一定要升序排列</li></ul><ol start="2"><li><code>index(查找的区域，区域内第几行，区域内第几列)</code>与<code>match(查找指定的值，查找所在区域，查找方式的参数)</code>，两者连用，基本可以替代’Vlookup()'的查找，其中’Vlookup()'只是针对文本内容的查找</li></ol><p>如<code>index(A:A,match(C1,B:B,0))</code></p><ol start="3"><li><blockquote><p>=Lookup（查找的值，值所在的位置，返回相应位置的值）</p></blockquote></li></ol><p><code>lookup()</code>函数弥补了<code>vlookup()</code>函数第三参数的劣势，但其本身也存在缺点，即不能精确匹配使用<code>lookup()</code>函数需要熟悉Excel数组的运算.详见<a href="http://study.163.com/course/courseLearn.htm?courseId=670032#/learn/video?lessonId=823422&amp;courseId=670032" target="_blank" rel="noopener">视频18课时62:00</a></p><ol start="4"><li><p><code>choose(index_num, value1, [value2], ...)</code></p></li><li><p><code>Offset(指定点，偏移多少行，偏移多少列，返回多少行，返回多少列)</code>建立坐标系，以坐标系为原点，返回距离原点的值或者区域。正数代表向下或向右，负数则相反。通过’Offset()'函数可以实现动态图标、动态数据透视表</p></li><li><p><code>Row()</code></p></li></ol><p>返回单元格所在的行</p><ol start="7"><li><code>Column()</code></li></ol><p>返回单元格所在的列</p><h2>四、文本函数</h2><ul><li><code>text(text)</code>设置数字格式并将其转换为文本</li><li><code>concatenate(text1,text2,...)</code>将几个文本项合并为一个文本项</li><li><code>len(text)</code>计算字符串的长度</li><li><code>mod(number,divisor)</code> 返回两数相除的余数。</li><li><code>right(text,num_chars)</code> 返回文本值中最右边的字符</li><li><code>left(text,num_chars)</code>返回文本值中最左边的字符</li><li><code>mid(text,start_num,num_chars))</code>从文本字符串中的指定位置起返回特定个数的字符</li><li><code>trim(text)</code>设置数字格式并将其转换为文本</li></ul><h2>五、数据透视表</h2><p>Excel中十分重要的一项功能，主要功能是将数据聚合，按照各子段进行<code>sum()</code>，<code>count()</code>的运算。应用范围</p><ul><li>包括大量复杂数据的表格，希望快速整理出一份具有实际意义的报表</li><li>希望找出同类数据在不同时期的某种特定关系</li><li>希望对数据进行合理有效的分组</li><li>需要经常查询分析数据的变化趋势</li><li>数据源经常变化，然而有需要经常分析和处理最新的数据源</li></ul><h3>数据分析</h3><p>查找<code>Ctrl+F</code>与替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=if(average(A2:A5)&gt;50,sum(B2:B5),0)</span><br><span class="line">=if(A2=10,&quot;科技处&quot;,if(A2=20,&quot;财务处&quot;,&quot;人事处&quot;))</span><br><span class="line">=sumif(销售记录汇总!$A$2:$A$107,$B5,销售记录汇总!$G$2,$G$107)</span><br><span class="line">=sumif(条件区域,条件值,求和区域)</span><br><span class="line"></span><br><span class="line">=sumifs(求和区域,条件区域,条件值)</span><br><span class="line">=sumif(销售记录汇总!$G$2,$G$107,销售记录汇总!$A$2:$A$107,$B5)</span><br></pre></td></tr></table></figure><p>条件可以是数字、表达式或文本，但是要使用引号</p><h3>数组计算相关</h3><p>计算结果<code>Ctrl+Shift+Enter</code></p><h2>杂类技巧</h2><ol><li>选择性粘贴 $\rightarrow $ 转置</li><li><code>column()``row()</code>返回当前列(行)数</li><li><code>Ctrl+Enter</code>，以当前单元格为始，往下填充数据和函数。</li><li><code>Ctrl+Space</code>，选定整列。<code>Shift+Space</code>，选定整行。</li><li><code>Alt+Enter</code>，换行。</li></ol>]]></content>
    
    <summary type="html">
    
      数据分析需要掌握的一些基本Excel姿势拾遗，后续不断更新
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="Excel" scheme="http://ulsonhu.cn/tags/Excel/"/>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>MySQL语句学习及总结</title>
    <link href="http://ulsonhu.cn/MySQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93.html"/>
    <id>http://ulsonhu.cn/MySQL语句学习及总结.html</id>
    <published>2018-03-05T16:00:00.000Z</published>
    <updated>2018-03-20T12:33:18.001Z</updated>
    
    <content type="html"><![CDATA[<p>  推荐：<a href="http://zh.sqlzoo.net/" target="_blank" rel="noopener">在线SQL编辑网站</a></p><h1>一、数据库基础</h1><ol><li>创建数据库</li></ol><p><code>CREATE DATABASE database_name;</code></p><ol start="2"><li>查询数据库</li></ol><p><code>show create database &lt;database_name&gt;;</code></p><ol start="3"><li>删除数据库</li></ol><p><code>drop database &lt;database_name&gt;;</code></p><ol start="4"><li>修改数据库</li></ol><p><code>alter database &lt;database_name&gt; character set &lt;str_coll&gt; collate &lt;rules&gt;</code></p><p><strong>补充</strong>:</p><ul><li>切换数据库 <code>use db_name;</code> -&gt; 当有多个数据库的情况,需要<code>use db_name;</code> 先切换到要操作的数据库</li><li>查看当前正在使用数据库: <code>select database();</code></li></ul><ol start="5"><li>数据表操作:</li></ol><p>创建数据表</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">   column_1 column_1_type,</span><br><span class="line">   column_2 column_2_type,</span><br><span class="line">   column_3 column_3_type,</span><br><span class="line">   column_4 column_4_type</span><br><span class="line">);</span><br></pre></td></tr></table></figure><h2>1. SQL功能概述</h2><p>SQL（Structured Query Language，结构化查询语言）是用户操作关系数据库的通用语言。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520904956/2018_03_06.png" width="80%" height="80%"></p><h2>基本数据类型</h2><table><thead><tr><th>数据类型</th><th>说明</th><th>存储空间</th></tr></thead><tbody><tr><td>bit</td><td>数据类型是整型，其值只能是0、1或空值。(很省空间的一种数据类型，如果能够满足需求应该尽量多用)</td><td>$1$ byte</td></tr><tr><td>tinyint</td><td>数据类型能存储从$0~255$之间的整数。</td><td>$1$ byte</td></tr><tr><td>smallint</td><td>数据类型可以存储从$-32768~32767$之间的整数。这种数据类型对存储一些常限定在特定范围内的数值型数据非常有用</td><td>$2$ byte</td></tr><tr><td>int</td><td>数据类型可以存储从$-2^{31}-2^{31}$之间的整数。存储到数据库的几乎所有数值型的数据都可以用这种数据类型</td><td>$4$ byte</td></tr><tr><td>numeric(p,s) or decimal(p,s)</td><td>数据类型能用来存储从$-10^{38}-1~10^{38}-1$的固定精度和范围的数值型数据。</td><td>$\leq17$byte</td></tr><tr><td>char(n)</td><td>char数据类型用来存储指定长度的定长非统一编码型的数据,$n$表示字符串的最大长度，取值范围为$1~8000$ （若实际字符串控件小于n,系统自动在后面补空格）</td><td>$n$ byte</td></tr><tr><td>varchar(n)</td><td>可变长度的字符串类型,n表示字符串的最大长度。</td><td>字符数+2字节额外开销</td></tr><tr><td>text</td><td>text 数据类型用来存储大量的非统一编码型字符数据。</td><td>每个字符一个字节</td></tr><tr><td>nchar(n)</td><td>用来存储定长统一编码字符型数据。此数据类型能存储4000种字符，使用的字节空间上增加了一倍.</td><td>$2n$ byte</td></tr><tr><td>nvarchar(n)</td><td>数据类型用作变长的统一编码字符型数据。此数据类型能存储4000种字符，使用的字节空间增加了一倍.</td><td>字符数+2字节额外开销</td></tr><tr><td>ntext</td><td>可存储$2^{30}-1$个字符</td><td>每个字符$2$byte</td></tr></tbody></table><p><a href="http://download.csdn.net/detail/u012792686/9757894" target="_blank" rel="noopener">MySQL5中文参考手册</a> -&gt; 部分不知道的字段可以通过这个文档查询</p><h1>二、SQL数据操作语言</h1><h2>1.数据查询语句</h2><h3>1.1 查询语句的基本结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;目标列名序列&gt;  <span class="comment">--需要哪些列</span></span><br><span class="line">    <span class="keyword">From</span> &lt;表名&gt;      <span class="comment">--来自哪张表</span></span><br><span class="line">    [<span class="keyword">WHERE</span> &lt;行选择条件&gt;]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组依据列&gt;]</span><br><span class="line">    [<span class="keyword">HAVING</span> &lt;组&gt;]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序依据列&gt;]</span><br></pre></td></tr></table></figure><p><code>SELECT</code>子句用于指定输出的字段</p><p><code>FROM</code>子句用于指定数据的来源</p><p><code>WHERE</code>子句用于指定数据的选择条件</p><p><code>GROUP BY</code>子句用于对检索到的记录进行分组</p><p><code>HAVING</code> 子句用于指定组的选择条件</p><p><code>ORDER BY</code> 子句用于对查询的结果进行排序</p><h3>1.2 单表查询</h3><ol><li>选择表中列数据</li></ol><p><code>SELECT &lt;column_name[*]&gt; FROM &lt;table_name&gt;</code></p><p>例子 ：<code>SELECT Sname,year(getdata()) - year(Birthdate) FROM Student</code></p><ol start="2"><li>选择表中的若干元祖</li></ol><ul><li>消除取值相同的行：<code>DISTINCT</code></li></ul><p><code>SELECT DISTINCT &lt;val&gt; FROM &lt;table_name&gt;</code></p><p>例子 ：<code>SELECT DISTINCT Tom FROM Student</code></p><ul><li>查询满足条件的元组</li></ul><table><thead><tr><th>查询条件</th><th>谓 词</th></tr></thead><tbody><tr><td>比较</td><td>=、&gt;、&gt;=、&lt;=、&lt;、&lt;&gt;、!=、!&gt;、!&lt;</td></tr><tr><td>确定范围</td><td>BETWEEN…AND、 NOT BETWEEN…AND</td></tr><tr><td>确定集合</td><td>IN 、NOT IN</td></tr><tr><td>字符匹配</td><td>LIKE 、NOT LIKE</td></tr><tr><td>空值</td><td>IS NULL、IS NOT NULL</td></tr><tr><td>多重条件（逻辑谓词）</td><td>AND、OR</td></tr></tbody></table><ol start="3"><li>对查询结果进行排序:将查询结果按照指定的顺序显示。<code>ASC</code>表示按列值升序排列（从上往下，值从大到小）。<code>DESC</code>表示按列值降序排列（从上往下，值从小到大）。默认为<code>ASC</code>。</li></ol><p><code>ORDER BY &lt;column_name&gt; [ASC|DESC]</code></p><p>例子 ：<code>SELECT Sno,Grade FROM SC ORDER BY Grade DESC</code></p><ol start="4"><li>使用聚合函数统计数据:聚合函数也称为统计函数或集合函数，作用是对一组值进行计算并返回一个统计结果。</li></ol><table><thead><tr><th>聚合函数</th><th>含义</th></tr></thead><tbody><tr><td>COUNT(*)</td><td>统计表中元组的个数</td></tr><tr><td>COUNT([DISTINCT]&lt;column_name&gt;)</td><td>统计本列的非空列值个数</td></tr><tr><td>SUM(&lt;column_name&gt;)</td><td>计算列值的和值（必须是数值型列）</td></tr><tr><td>AVG(&lt;column_name&gt;)</td><td>计算列值的平均值（必须是数值型列）</td></tr><tr><td>MAX(&lt;column_name&gt;)</td><td>计算列值的最大值</td></tr><tr><td>MIN(&lt;column_name&gt;)</td><td>计算列值的最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（统计学生总人数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计“001”学号学生的考试平均成绩）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno = <span class="string">'001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询“C001”号课程考试成绩的最高分和最低分）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(Grade) 最高分,<span class="keyword">MIN</span>(Grade) 最低分 <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br></pre></td></tr></table></figure><p>注意：聚合函数不能出现在WHERE子句中！</p><ol start="5"><li>对数据进行分组统计:需要先对数据进行分组，然后再对每个组进行统计。分组子句<code>GROUP BY</code>。在一个查询语句中，可以用多个列进行分组。分组子句跟在<code>WHERE</code>子句的后面：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY &lt;分组依据列&gt;[,...n]</span><br><span class="line">    [HAVING &lt;组筛选条件&gt;]</span><br></pre></td></tr></table></figure><h3>1.3 多表连接查询</h3><p>若一个查询同时涉及到两张或以上的表，则称为连接查询。</p><ol><li><strong>内连接</strong>:使用内连接时，如果两个表的相关字段满足条件，则从两个表中提取数据组成新的记录。</li></ol><p><code>FROM &lt;table1&gt; [INNER] JOIN &lt;table2&gt; ON &lt;Join Condition&gt;</code></p><p>注意：连接条件中的连接字段必须是可比的，必须是语义相同的列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询学生及选课的详细信息）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.Sno = SC.Sno</span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询计算机系学生的选课情况，列出该学生的名字、所修课程号、成绩）---行选择条件</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname,Cno,Grade <span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计每个系的平均成绩） ---分组的多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> Dept,<span class="keyword">AVG</span>(Grade) <span class="keyword">AS</span> AverageGrade <span class="keyword">FROM</span> Student S <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">Group</span> <span class="keyword">BY</span> Dept</span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计计算机系每个学生的选课门数、平均成绩、最高成绩、最低成绩）--分组和行选择条件的多表连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">COUNT</span>(*),<span class="keyword">AVG</span>(Grade),<span class="keyword">MAX</span>(Grade),<span class="keyword">MIN</span>(Grade) <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span> <span class="keyword">Group</span> <span class="keyword">BY</span> Dept</span><br></pre></td></tr></table></figure><ol start="2"><li><strong>自连接</strong>:自连接是一种特殊的内连接，相互连接的表在物理上是一张表，但在逻辑上可以看做是两张表。</li></ol><p><code>FROM &lt;table1&gt; AS T1 JOIN &lt;table1&gt; AS T2</code></p><p>通过为表取别名的方法，可以让物理上的一张表在逻辑上成为两张表。<font color="blue">（一定要为表取别名！）</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询与刘晨在同一个系学习的学生的姓名、所在系）</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.Sname,S1.Dept <span class="keyword">FROM</span> Student S1 <span class="keyword">JOIN</span> Student S2 </span><br><span class="line"><span class="keyword">ON</span> S1.Dept = S2.Dept   <span class="comment">--同一个系的学生</span></span><br><span class="line"><span class="keyword">WHERE</span> S2.Sname = <span class="string">'刘晨'</span>  <span class="comment">--S2表作为查询条件</span></span><br><span class="line"><span class="keyword">AND</span> S1.Sname != <span class="string">'刘晨'</span>  <span class="comment">--S1表作为结果表，并从中去掉‘刘晨’本人信息</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>外连接</strong>:在内连接操作中，只有满足条件的元祖才能出现在查询结果集中。外连接是只限制一张表中的数据必须满足条件，而另一张表的数据可以不满足条件。</li></ol><p><code>FROM &lt;table1&gt; LEFT|RIGHT [OUTER] JOIN &lt;table2&gt; ON &lt;Join Condition&gt;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEFT [OUTER] JOIN <span class="comment">--称为左外连接，含义是限制表2中的数据必须满足条件，但不管表1中的数据是否满足条件，均输出表1中的数据。 </span></span><br><span class="line">LEFT [OUTER] JOIN <span class="comment">--称为右外连接，含义是限制表1中的数据必须满足条件，但不管表2中的数据是否满足条件，均输出表2中的数据。</span></span><br></pre></td></tr></table></figure><h2>2.数据更改功能</h2><h3>2.1 插入数据</h3><p><code>INSERT INTO &lt;table_name&gt;[(column_name)] VALUES (val)</code></p><p>（1）简单插入语句</p><p>INSERT INTO Student VALUES (‘001’,‘陈东’,‘男’,‘1996/6/23’,‘信息管理系’)</p><p>（2）多行插入语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">VALUES</span>(<span class="string">'001'</span>,<span class="string">'C001'</span>,<span class="number">90</span>),</span><br><span class="line">                     (<span class="string">'001'</span>,<span class="string">'C002'</span>,<span class="number">30</span>),</span><br><span class="line">                     (<span class="string">'001'</span>,<span class="string">'C005'</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>（3）不按表顺序插入语句</p><p>按与表列顺序不同的顺序插入数据<code>INSERT INTO Student(Sno,Sname,Sex,Dept) VALUES ('001','陈东','男','1996/6/23','信息管理系')</code></p><h3>2.2 更新数据</h3><p><code>UPDATE &lt;table_name&gt; SET column_name = val</code></p><p>（1）无条件更新</p><p><code>UPDATE SC SET Grade = Grade+10</code></p><p>（2）有条件更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（将“C001”号课程的学分改成5分）</span></span><br><span class="line"><span class="keyword">UPDATE</span> Course <span class="keyword">SET</span> Grade = <span class="number">5</span> <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（将计算机系全体学生的成绩加5分）</span></span><br><span class="line"><span class="keyword">UPDATE</span> SC <span class="keyword">SET</span> Grade = Grade+<span class="number">5</span> <span class="keyword">FROM</span> SC <span class="keyword">JOIN</span> Student S <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span></span><br></pre></td></tr></table></figure><h3>2.3 删除数据</h3><p><code>DELETE [TOP (expression) [PERCENT]] FROM &lt;table_name&gt;</code></p><p>（1）无条件删除</p><p><code>DELETE FROM Student</code></p><p>（2）有条件删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（删除所有考试成绩不合格的学生的选课记录）</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Grade &lt; <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（删除Student表中2.5%的行数据）</span></span><br><span class="line"><span class="keyword">DELETE</span> TOP (<span class="number">2.5</span>) <span class="keyword">PERCENT</span> <span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><h1>三、高级查询</h1><h2>1. CASE函数</h2><p>CASE函数是一种多分支函数，它可以根据条件列表的值返回多个可能的结果表达式中的一个。</p><h3>1.1 简单CASE函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">    WHEN when_expression THEN result_expression</span><br><span class="line">    [...n]</span><br><span class="line">    [ELSE else_expression]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li><code>input_expression</code>：所计算的表达式，可以是一个变量名、字段名、函数或子查询。</li><li><code>when_expression</code> ：要与input _expression进行比较的简单表达式。简单表达式中不可包含比较运算法，只需给出被比较的表达式或值。</li><li><code>else_expression</code> ： 比较结果均不为TRUE时返回的表达式。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询选了JAVA课程的学生的学号、姓名、所在系、成绩，</span></span><br><span class="line"><span class="comment">--若所在系为“计算机系”，则显示“CS”；若所在系为“信息管理系”，则显示“IM”；若所在系为“通信工程系”，则显示“COM”）</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> Dept</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'计算机系'</span> <span class="keyword">THEN</span> <span class="string">'CS'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'信息管理系'</span> <span class="keyword">THEN</span> <span class="string">'IM'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'通信工程系'</span> <span class="keyword">THEN</span> <span class="string">'COM'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 所在系,Grade 成绩</span><br><span class="line">    <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno </span><br><span class="line">    <span class="keyword">JOIN</span> Course C <span class="keyword">ON</span> C.Cno = SC.Cno</span><br><span class="line">    <span class="keyword">WHERE</span> Cname = <span class="string">'Java'</span></span><br></pre></td></tr></table></figure><h3>1.2 搜索CASE函数</h3><p>简单 CASE函数只能将<code>input_expression</code>与一个单值进行比较，如果需要跟一个范围内的值进行比较，就需要搜索<code>CASE</code>函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">    WHEN Boolean_expression THEN result_expression</span><br><span class="line">    [...n]</span><br><span class="line">    [ELSE else_expression]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><code>Boolean_expression</code> ：比较表达式，可以包含比较运算符，直接将两者进行比较。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上述例子也可以用搜索CASE函数：</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'计算机系'</span> <span class="keyword">THEN</span> <span class="string">'CS'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'信息管理系'</span> <span class="keyword">THEN</span> <span class="string">'IM'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'通信工程系'</span> <span class="keyword">THEN</span> <span class="string">'COM'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 所在系,Grade 成绩</span><br><span class="line">    <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno </span><br><span class="line">    <span class="keyword">JOIN</span> Course C <span class="keyword">ON</span> C.Cno = SC.Cno</span><br><span class="line">    <span class="keyword">WHERE</span> Cname = <span class="string">'Java'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询C001课程的考试情况，列出学号和成绩，然后根据成绩划分等级）</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> Grade &gt;= <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">'优'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">99</span> <span class="keyword">THEN</span> <span class="string">'良'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">79</span> <span class="keyword">THEN</span> <span class="string">'中'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">69</span> <span class="keyword">THEN</span> <span class="string">'及格'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 成绩</span><br><span class="line">    <span class="keyword">FROM</span>  SC <span class="keyword">ON</span> <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br></pre></td></tr></table></figure><h2>2. 子查询</h2><p>如果一个<code>SELECT</code>语句嵌套在另一个<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>语句中，则称为子查询或内层查询；而包含子查询的语句称为主查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> cunstomers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> cust_id </span><br><span class="line">        <span class="keyword">FROM</span> orders </span><br><span class="line">        <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num </span><br><span class="line">                <span class="keyword">FROM</span> orderitems </span><br><span class="line">                <span class="keyword">WHERE</span> prod_id = <span class="string">'TN2'</span>););</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用联结操作简化子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> cunstomers,orders,orderitems <span class="comment">--good</span></span><br><span class="line"><span class="keyword">WHERE</span> cunstomers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'TN2'</span>;</span><br></pre></td></tr></table></figure><p>子查询通常用于满足下列需求之一：</p><ul><li>把一个查询分解成一系列的逻辑步骤</li><li>提供一个列表作为<code>WHERE</code>子句和<code>IN</code>、<code>EXISTS</code>、<code>ANY</code>、<code>ALL</code>的目标对象</li><li>提供由外层查询中每一条记录驱动的查询</li></ul><p>子查询通常有几种形式：</p><ul><li><code>WHERE 列名 [NOT] IN (子查询)</code></li><li><code>WHERE 列名 比较运算符 (子查询)</code></li><li><code>WHERE EXISTS(子查询)</code></li></ul>]]></content>
    
    <summary type="html">
    
      准备面试数据分析岗，学习一下数据库和SQL语言知识，总结如下。
    
    </summary>
    
      <category term="数据分析" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
      <category term="SQL" scheme="http://ulsonhu.cn/tags/SQL/"/>
    
      <category term="数据库" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>VC维理论-统计学习理论基础</title>
    <link href="http://ulsonhu.cn/VC%E7%BB%B4%E7%90%86%E8%AE%BA-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"/>
    <id>http://ulsonhu.cn/VC维理论-统计学习理论基础.html</id>
    <published>2018-03-02T16:00:00.000Z</published>
    <updated>2018-03-12T16:25:46.823Z</updated>
    
    <content type="html"><![CDATA[<p>目录：</p><ul><li>说说历史</li><li>Hoeffding不等式</li><li>Connection to Learning</li><li>学习可行的两个核心条件</li><li>Effective Number of Hypotheses</li><li>Growth Function</li><li>Break Point与Shatter</li><li>VC Bound</li><li>VC dimension</li><li>深度学习与VC维</li><li>小结</li><li>参考文献</li></ul><p>VC维在机器学习领域是一个很基础的概念，它给诸多机器学习方法的可学习性提供了坚实的理论基础，但有时候，对我们而言，SVM，LR，深度学习等可能都已经用到线上了，但却不理解VC维。</p><p>这里，在台湾大学<a style="color: #109eff" href="https://www.coursera.org/course/ntumlone" target="_blank" rel="noopener">机器学习基石</a>课程的基础上，我们简单聊聊“VC维的来龙去脉”。我们将解决以下问题：为什么某机器学习方法是可学习的？为什么会有过拟合？拿什么来衡量机器学习模型的复杂度？深度学习与VC维的关系？</p><h2>说说历史</h2><p>在讲VC维之前，我们不妨来说说VC维的历史。而说起VC维的历史，又不得不提起神经网络，一方面是因为神经网络与VC维的发明过程是交织在一起的，另一方面是由于神经网络乏善可陈的泛化控制方法，深度学习在理论基础上一直被怀疑，甚至神经网络和VC维的代表SVM还一起争风吃醋过好多年。</p><ul><li>1943年，模拟神经网络由麦卡洛可（McCulloch）和皮茨（Pitts)提出，他们分析了理想化的人工神经元网络，并且指出了它们进行简单逻辑运算的机制。</li><li>1957年，康奈尔大学的实验心理学家弗兰克·罗森布拉特(Rosenblatt)在一台IBM–704计算机上模拟实现了一种他发明的叫作“感知机”（Perceptron）的神经网络模型。神经网络与支持向量机都源自于感知机（Perceptron）。</li><li>1962年，罗森布拉特著作：《神经动力学原理：感知机和大脑机制的理论》（Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms）。</li><li>1969年，明斯基和麻省理工学院的另一位教授佩普特合作著作：《感知机：计算几何学》（Perceptrons: An Introduction to Computational Geometry)。在书中，明斯基和佩普特证明单层神经网络不能解决XOR（异或）问题。</li><li>1971年，V. Vapnik and A. Chervonenkis在论文“On the uniform convergence of relative frequencies of events to their probabilities”中提出<strong>VC维</strong>的概念。</li><li>1974年，V. Vapnik提出了结构风险最小化原则。</li><li>1974年，沃波斯（Werbos）的博士论文证明了在神经网络多加一层，并且利用“后向传播”（Back-propagation）学习方法，可以解决XOR问题。那时正是神经网络研究的低谷，文章不合时宜。</li><li>1982年，在加州理工担任生物物理教授的霍普菲尔德，提出了一种新的神经网络，可以解决一大类模式识别问题，还可以给出一类组合优化问题的近似解。这种神经网络模型后被称为霍普菲尔德网络。</li><li>1986年，Rummelhart与McClelland发明了神经网络的学习算法Back Propagation。</li><li>1993年，Corinna Cortes和Vapnik等人提出了支持向量机(support vector machine)。神经网络是多层的非线性模型，支持向量机利用核技巧把非线性问题转换成线性问题。</li><li>1992~2005年，SVM与Neural network之争，但被互联网风潮掩盖住了。</li><li>2006年，Hinton提出神经网络的Deep Learning算法。Deep Learning假设神经网络是多层的，首先用Restricted Boltzmann Machine（非监督学习）学习网络的结构，然后再通过Back Propagation（监督学习）学习网络的权值。</li><li>现在，deep learning的应用越来越广泛，甚至已经有超越SVM的趋势。一方面以Hinton，Lecun为首的深度学习派坚信其有效实用性，另一方面Vapnik等统计机器学习理论专家又坚持着理论阵地，怀疑deep learning的泛化界。</li></ul><h2>Hoeffding不等式</h2><p>Hoeffding不等式是关于一组随机变量均值的概率不等式。 如果$X_1,X_2,\cdots,X_n$为一组独立同分布的参数为$p$的伯努利分布随机变量，$n$为随机变量的个数。定义这组随机变量的均值为：$$\bar{X}=\frac{X_1+X_2+\cdots+X_n}{n}$$</p><p>对于任意$\sigma &gt; 0$, Hoeffding不等式可以表示为</p><p>$$P(|\bar{X}-E(\bar{X})|\geq \sigma) \leq exp(-2{\sigma}^2n^2)$$</p><p>更多请参考:<a style="color: #109eff" href="http://science.scileaf.com/library/2461" target="_blank" rel="noopener">Hoeffding不等式</a>，<a style="color: #109eff" href="http://zh.wikipedia.org/zh-cn/%E9%9B%86%E4%B8%AD%E4%B8%8D%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">集中不等式</a></p><h3>示例:</h3><p>在统计推断中，我们可以利用样本的统计量(statistic)来推断总体的参数(parameter)，譬如使用样本均值来估计总体期望。如下图所示，我们从罐子里抽球，希望估计罐子里红球和绿球的比例。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780790/2018_03_04_01bin_sample.png" alt="bin_sample" width="60%" height="60%">直觉上，如果我们有更多的样本(抽出更多的球)，则样本期望$v$应该越来越接近总体期望$\mu $。事实上，这里可以用hoeffding不等式表示如下：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780789/2018_03_04_02.png" width="50%" height="50%">从hoeffding不等式可以看出，当$n$逐渐变大时，不等式的UpperBound越来越接近0，所以样本期望越来越接近总体期望。</p><h2>Connection to Learning</h2><p>接下来，我们希望可以将机器学习关联到上一节讨论的hoeffding不等式。一个基本的机器学习过程如下图所示。其中的概念定义为：</p><ul><li>$f$ 表示理想的方案(可以是一个函数，也可以是一个分布)</li><li>$H$ 是该机器学习方法的假设空间</li><li>$g$ 表示我们求解的用来预测的假设，$g$属于$H$</li></ul><p><font color="blue">机器学习的过程就是：通过算法$A$，在假设空间$H$中，根据样本集$D$，选择最好的假设作为$g$。选择标准是$g$近似于$f$。</font><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780789/2018_03_04_03.png" width="80%" height="80%"></p><p>拿<a style="color: #109eff" href="http://zh.wikipedia.org/zh/%E6%84%9F%E7%9F%A5%E5%99%A8" target="_blank" rel="noopener">感知机(perceptron)</a>来举例。</p><p>感知机（perceptron）是一个线性分类器(linear classifiers）。 线性分类器的几何表示：直线、平面、超平面。</p><p>perceptron的假设空间，用公式描述，如下所示：$$h(x)=sign((\sum_{i=1}^{n})-threshod)$$</p><p>感知器的优化目标如下式所示，$w_g$就是我们要求的最好的假设。$$W_g\rightarrow argmin\sum_{n=1}^{N}\left [y_n \neq sign(W^Tx_n)  \right ]$$</p><p>设定两个变量，如下图所示，图中 $f(x)$表示理想目标函数，$h(x)$是我们预估得到的某一个目标函数，$h(x)$是假设空间$H$中的一个假设。<strong>$E_{out}(h)$</strong>，可以理解为在理想情况下(已知f)，总体(out-of-sample)的损失(这里是0–1 loss)的期望，称作expected loss。<strong>$E_{in}(h)$</strong>，可以理解为在训练样本上(in-of-sample)，损失的期望，称作expirical loss。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781757/2018_03_05learning_hoeffding.png" width="80%" height="80%"><p>当训练样本量$N$足够大，且样本是独立同分布的，类比于上面“抽球”的例子，可以通过样本集上的expirical loss $E_{in}(h)$ 推测总体的expected loss $E_{out}(h)$。基于Hoeffding不等式，我们得到下面式子：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781760/2018_03_05_02.png" width="80%" height="80%">根据上面不等式，我们可以推断，当$N$足够大时，expected loss和expirical loss将非常接近。注意在上面推导中，我们是针对某一个特定的解$h(x)$。在我们的假设空间$H$中，往往有很多个假设函数(甚至于无穷多个)，这里我们先假定$H$中有$M$个假设函数。那么对于整个假设空间，也就是这M个假设函数，可以推导出下面不等式：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781758/2018_03_05hoeffding_12.png" width="80%" height="80%"></p><p>上面式子的含义是：在假设空间$H$中，设定一个较小的$\epsilon$值，任意一个假设$h$，它的$E_{in}(h)$与$E_{out}(h)$的差由该值$2\cdot M\cdot exp{-2\epsilon^2\cdot N}$所约束住。注意这个bound值与 “样本数$N$和假设数$M$” 密切相关。</p><h2>学习可行的两个核心条件</h2><p>在往下继续推导前，先看一下<strong>什么情况下Learning是可行的</strong>?</p><p>如果假设空间$H$的size M是有限的，当$N$足够大时，那么对假设空间中任意一个$g$，$E_{out}(g)$约等于$E_{in}(g)$；利用算法A从假设空间$H$中，挑选出一个$g$，使得$E_{in}(g)$接近于0，那么<a style="color: #109eff" href="http://en.wikipedia.org/wiki/Probably_approximately_correct_learning" target="_blank" rel="noopener">probably approximately correct</a>而言，$E_{out}(g)$也接近为0；</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781759/2018_03_05x.png" width="80%" height="80%">上面这两个核心条件，也正好对应着test和train这两个过程。train过程希望损失期望(即$E_{in}(g)$)尽可能小；test过程希望在真实环境中的损失期望也尽可能小，即$E_{in}(g)$接近于$E_{out}(g)$。<p>但往往我们更多在关心，如何基于模型的假设空间，利用最优化算法，找到$E_{in}$最小的解$g$。但容易忽视test这个过程，如果让学习可行，不仅仅是要在训练集表现好，在真实环境里也要表现好。从上述推导出来的不等式，我们看到假设数$M$在这两个核心条件中有着重要作用。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781760/2018_03_05.png" width="80%" height="80%"></p><p>$M$太小，当$N$足够大时，$E_{in}和$E_{out}$比较接近，但如果候选假设集太小，不容易在其中找到一个$g$，使得$E_{in}(g)$约等于0，第二项不能满足。而如果$M$太大，这时候选集多了，相对容易在其中找到一个$g$，使得$E_{in}(g)$约等于0，但第一项就不能满足了。所以假设空间$H$的大小$M$很关键。</p><p>对于一个假设空间，$M$可能是无穷大的。要能够继续推导下去，那么有一个直观的思路，能否找到一个有限的因子$m_H$来替代不等式bound中的$M$。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_06.png" width="80%" height="80%"><p>虽说假设空间很大，上述推导里，我们用到了$P(h_1,h_2,\cdots ,h_m) \leq P(h_1) + P(h_2) + \cdots + P(h_m)$。但事实上，多个$h$之间并不是完全独立的，他们是有很大的重叠的，也就是在$M$个假设中，可能有一些假设可以归为同一类。</p><p>下面我们以二维假设空间为例，来解释一下该空间下各假设在确定的训练样本上的重叠性。</p><p>举例来说，如果我们的算法要在平面上(二维空间)挑选一条直线方程作为$g$，用来划分一个点$x_1$。假设空间$H$是所有的直线，它的size M是无限多的。但是实际上可以将这些直线分为两类，一类是把$x_1$判断为正例的，另一类是把$x_1$判断为负例的。如下图所示：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_07.png" width="50%" height="50%"></p><p>那如果在平面上有两个数据点$x_1,x_2$，这样的话，假设空间$H$中的无数条直线可以分为4类。那依次类推，3个数据点情况下，$H$中最多有8类直线。4个数据点，$H$中最多有14类直线<font color="blue">(注意：为什么不是16类直线)</font>。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_08.png" width="60%" height="60%">从上面在二维假设空间中的分析，我们可以推测到一个结论，假设空间size M是很大，但在样本集$D$上，有效的假设函数数目是有限的。接下来我们将继续推导这个有效的假设函数值。</p><h2>Effective Number of Hypotheses</h2><p>对于这个有效的假设函数值，我们尝试用一个数学定义来说明：从$H$中任意选择一个方程$h$，让这个$h$对样本集合$D$进行二元分类，输出一个结果向量。例如在平面里用一条直线对2个点进行二元分类，输出可能为${1,–1}，{–1,1}，{1,1}，{–1,–1}$，这样每个输出向量我们称为一个dichotomy。</p><p>下面是hypotheses与dichotomies的概念对比：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782701/2018_03_05_09.png" width="80%" height="80%">注意到，如果对平面上的4个点来分类，根据前面分析，输出的结果向量只有14种可能，即有14个dichotomies。如果有$N$个样本数据，那么有效的假设个数定义为： $effective(N) = H$作用于样本集$D$“最多”能产生多少不同的dichotomy。所以有一个直观思路，能否用$effective(N)$来替换Hoeffding不等式中的M。接下来我们来分析下$effective(N)$。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_10.png" width="80%" height="80%"><h2>Growth Function</h2><p>$H$作用于$D$“最多”能产生多少种不同的dichotomies？</p><p>这个数量与假设空间$H$有关，跟数据量$N$也有关。将$H$作用于$D$“最多”能产生的dichotomies数量(即effective(N) )表示为数学符号：$max_H(x_1,x_2,\cdots,x_N)$</p><p>这个式子又称为“成长函数”(growth function)。在$H$确定的情况下，growth function是一个与$N$相关的函数。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782701/2018_03_05_11.png" width="80%" height="80%"></p><p>下图举4个例子，分别计算其growth function：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783290/2018_03_05_12.png" width="80%" height="80%">对于第一个例子，positive ray，相当于是正向的射线。该假设空间，作用于1个样本点，可以产生2种dichotomies：(–1)，(+1)。作用于2个样本点，可以产生3种dichotomies：(–1,+1)，(–1,–1)，(+1,+1)。作用于3个样本点，可以产生4种dichotomies。依次类推，可以推导出其成长函数 $m_H(N)=N+1$；求解出$m_H(N)$后，那是不是可以考虑用$m_H(N)$替换$M$? 如下所示：$$P[|E_{in}(g)-E_{out}(g)|>\epsilon]\leq 2\cdot m_H(N)\cdot N $$<h2>Break Point与Shatter</h2><p>在进一步推导前，再看两个概念：<font color="blue">shatter，break point。</font></p><p><strong>Shatter的概念</strong>：当假设空间H作用于$N$个input的样本集时，产生的dichotomies数量等于这$N$个点总的组合数$2N$是，就称：这$N$个inputs被$H$给shatter掉了。</p><p>要注意到 shatter 的原意是“打碎”，在此指“$N$个点的所有(碎片般的)可能情形都被H产生了”。所以$m_{H}=2N$的情形是即为“shatter”。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520784111/2018_03_05_13.png"><p>对于给定的成长函数$m_H(N)$，从$N=1$出发，$N$慢慢变大，当增大到$k$时，出现$m_{H}(N)&lt;2k$的情形，则我们说k是该成长函数的<strong>break point</strong>。对于任何$N&lt; k$个inputs而言，$H$都没有办法再shatter他们了。</p><p>举例来说，对于上面的positive ray的例子，因为$m_H(N)=N+1$，当$N=2$时，$m_H(2)&lt;2^2$， 所以它的break point就是2。</p><h2>VC Bound</h2><p>说完break point的概念后，再回到成长函数。我们将成长函数的上界，设为$B(N,k)$，意为：maximum possible $m_H(N)$ when $break point = k$。</p><p>那么我们做一些简单的推导：</p><ul><li>$B(2,2)=3$。因为break point=2，任意两个点都不能被shatter，$m_H(2)$肯定小于$2^2$，所以$B(2,2)=3$。</li><li>$B(3,2)=4$。因为任意两个点都不能被shatter，那么3个点产生的dichotomies不能超过4，所以$B(3,2)=4$。</li><li>$B(N,1)=1$。</li><li>$B(N,k)=2^N \quad for \quad N &lt; k$;$\qquad B(N,k)=2^{N–1} \quad for \quad N=k$；</li><li>$B(4,3)=？$去掉其中的一个数据点$x_4$后，考虑到break point=3，余下数据$(x1,x2,x3)$的dichotomies数目不能超过$B(3,3)$。当扩展为$(x1,x2,x3,x4)$时，$(x1,x2,x3)$上的dichotomies只有部分被重复复制了，设被复制的dichotomies数量为$a$，未被复制的数量为$b$。于是有$B(3,3) = a+b; B(4,3) = 2a + b$。因为$a$被复制了，表示$x_4$有两个取值，那么$(x1,x2,x3)$上的$a$应该小于等于$B(3,2)$。所以推导出$B(4,3) = 2a + b \leq B(3,3) + B(3,2)$。对于任意$N&gt;k$，类推可以得到，$B(N,k) \leq B(N−1,k)+B(N−1,k−1)$</li></ul><p>最后利用数学归纳法，可以证明得到下面的bounding function($N&gt;k$)：$$m_H{N}\leq \sum_{i=0}^{k-1}\binom{N}{i}$$</p><p>这个式子显然是多项式的，多项式的最高幂次项为：$N^{k–1}$。</p><p>所以我们得到结论：如果break point存在（有限的正整数），生长函数$m_{H}(N)$是多项式的。</p><p>再重复一遍，$H$作用于数据量为$N$的样本集$D$，方程的数量看上去是无穷的，但真正有效(effective)的方程的数量却是有限的，这个数量为$m_H(N)$。$H$中每一个$h$作用于$D$都能算出一个$E_{in}$来，一共有$m_H(N)$个不同的$E_{in}$。</p><p>OK，到目前为止，关于$m_H(N)$的推导结束。回到growth function小节提出的问题，能否用<strong>$m_H(N)$直接替换M?</strong></p><p>既然得到了$m_H(N)$的多项式上界，我们希望对之前的不等式中$M$进行替换，用$m_H(N)$来替换$M$。这样替换后，当break point存在时，$N$足够大时，该上界是有限的。$$P[h\in H\quad s.t \quad |E_{in}(h)-E_{out}(h)|&gt;\epsilon]\leq 2 \\m_{H}N\cdot exp(-2\cdot {\epsilon}^2\cdot N)$$</p><p>然而直接替换是存在问题的，主要问题是：$E_{in}$的可能取值是有限个的，但$E_{out}$的可能取值是无限的。可以通过将$E_{out}$ 替换为验证集(verification set) 的$E_{in}$来解决这个问题。</p><p>下面是推导过程：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783670/2018_03_05_14.png" width="80%" height="80%"></p><p>最后我们得到下面的VC bound:<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_15.png" width="80%" height="80%"></p><p>关于这个公式的数学推导，我们可以暂且不去深究。我们先看一下这个式子的意义，如果假设空间存在有限的break point，那么$m_H(2N)$会被最高幂次为$k–1$的多项式上界给约束住。随着$N$的逐渐增大，指数式的下降会比多项式的增长更快，所以此时VC Bound是有限的。更深的意义在于，$N$足够大时，对$H$中的任意一个假设$h，E_{in}(h)$都将接近于$E_{out}(h)$，这表示学习可行的第一个条件是有可能成立的。</p><h2>VC dimension</h2><p>说了这么多，VC维终于露出庐山真面目了。此概念由Vladimir Vapnik与Alexey Chervonenkis提出。一个假设空间$H$的<strong>VC dimension</strong>，是这个$H$最多能够shatter掉的点的数量，记为$d_{vc}(H)$。如果不管多少个点$H$都能shatter它们，则$d_{vc}=\infty$。还可以理解为：$vc-dim$就是$argmax\quad x_n\quad {growth function=2^n}$。</p><p>根据定义，可以得到一个明显的结论：$$k = d_{vc}(H) + 1$$</p><p>根据前面的推导，我们知道VC维的大小：与学习算法$A$无关，与输入变量$X$的分布也无关，与我们求解的目标函数$f$ 无关。<font color="blue">它只与模型和假设空间有关。</font></p><p>我们已经分析了，对于2维的perceptron，它不能shatter 4个样本点，所以它的VC维是3。此时，我们可以分析下2维的perceptron，如果样本集是线性可分的，perceptron learning algorithm可以在假设空间里找到一条直线，使$E_{in}(g)=0$；另外由于其VC维=3，当$N$足够大的时候，可以推断出：$E_{out}(g)$约等于$E_{in}(g)$。这样学习可行的两个条件都满足了，也就证明了2维感知器是可学习的。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783663/2018_03_05_16.png" width="80%" height="80%"></p><p>总结回顾一下，要想让机器学到东西，并且学得好，有2个条件：</p><ul><li>$H$的$d_{vc}$是有限的，这样VC bound才存在。(good H)；$N$足够大(对于特定的$d_{vc}$而言)，这样才能保证VC bound不等式的bound不会太大。(good D)</li><li>算法A有办法在$H$中顺利的挑选一个使得$E_{in}最小的$g$。(good A)</li></ul><p>回到最开始提出的学习可行的两个核心条件，尝试用VC维来解释：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_17.png" width="80%" height="80%"></p><p>从上图可以看出，当VC维很小时，条件1容易满足，但因为假设空间较小，可能不容易找到合适的$g$,使得$E_{in}(g)$约等于0。当VC维很大时，条件2容易满足，但条件1不容易满足，因为VC bound很大。</p><p>VC维反映了假设空间$H$的强大程度(powerfulness)，VC 维越大，$H$也越强，因为它可以打散(shatter)更多的点。</p><p>定义模型自由度是，模型当中可以自由变动的参数的个数，即我们的机器需要通过学习来决定模型参数的个数。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_18.png" width="80%" height="80%"><p>一个实践规律：VC 维与假设参数$w$的自由变量数目大约相等。$d_{VC} \approx  free parameters$。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783663/2018_03_05_19.png" width="80%" height="80%"><p>上面式子中的第3项表示模型复杂度。模型越复杂，VC维大，$E_{out}$可能距离$E_{in}$ 越远。如下图所示，随着$d_{vc}$的上升，$E_{in}$不断降低，而模型复杂度不断上升。</p><p>它们的上升与下降的速度在每个阶段都是不同的，因此我们能够寻找一个二者兼顾的，比较合适的$d_{vc}$，用来决定应该使用多复杂的模型。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785729/2018_03_05_20.png" width="80%" height="80%"></p><p>模型较复杂时($d_{vc}$ 较大)，需要更多的训练数据。 理论上，数据规模$N$约等于 $10000*d_{vc}$（称为采样复杂性，sample complexity）；然而，实际经验是，只需要 $N = 10*d_{vc}$。</p><p>造成理论值与实际值之差如此之大的最大原因是，VC Bound 过于宽松了，我们得到的是一个比实际大得多的上界。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785731/2018_03_05_21.png" height="80%"></p><p>注意在前述讨论中，理想的目标函数为$f(x)$，error measure用的是“0–1 loss”。如果在unknown target上引入噪声(+noise)，或者用不同的error measure方法，VC theory还有效吗？这里只给出结论，VC theory对于绝大部分假设空间(or 加入噪声)和error度量方法，都是有效的。</p><p>除此外，我们为了避免overfit，一般都会加正则项。那加了正则项后，新的假设空间会得到一些限制，此时新假设空间的VC维将变小，也就是同样训练数据条件下，$E_{in}$更有可能等于$E_{out}$，所以泛化能力更强。这里从VC维的角度解释了正则项的作用。</p><h2>深度学习与VC维</h2><p>对于神经网络，其VC维的公式为：$d_{VC} = O(V\cdot D)$，其中$V$表示神经网络中神经元的个数，$D$表示weight的个数，也就是神经元之间连接的数目。(注意：此式是一个较粗略的估计，深度神经网络目前没有明确的VC bound)<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785730/2018_03_05_22.png"></p><p>举例来说，一个普通的三层全连接神经网络：input layer是1000维，hidden layer有1000个nodes，output layer为1个node，则它的VC维大约为$O(1000*1000*1000)$。</p><p>可以看到，神经网络的VC维相对较高，因而它的表达能力非常强，可以用来处理任何复杂的分类问题。根据上一节的结论，要充分训练该神经网络，所需样本量为10倍的VC维。如此大的训练数据量，是不可能达到的。所以在20世纪，复杂神经网络模型在out of sample的表现不是很好，容易overfit。</p><p>但现在为什么深度学习的表现越来越好。原因是多方面的，主要体现在：</p><ul><li>通过修改神经网络模型的结构，以及提出新的regularization方法，使得神经网络模型的VC维相对减小了。例如卷积神经网络，通过修改模型结构(局部感受野和权值共享)，减少了参数个数，降低了VC维。2012年的AlexNet，8层网络，参数个数只有60M；而2014年的<a style="color: #109eff" href="http://www.cs.unc.edu/~wliu/papers/GoogLeNet.pdf" target="_blank" rel="noopener">GoogLeNet</a>，22层网络，参数个数只有7M。</li><li>dropout，drop connect，denosing等regularization方法的提出，也一定程度上增加了神经网络的泛化能力。</li><li>训练数据变多了。随着互联网的越来越普及，相比于以前，训练数据的获取容易程度以及量和质都大大提升了。训练数据越多，$E_{in}$越容易接近于$E_{out}$。而且目前训练神经网络，还会用到很多data augmentation方法，例如在图像上，剪裁，平移，旋转，调亮度，调饱和度，调对比度等都使用上了。</li><li>除此外，pre-training方法的提出，GPU的利用，都促进了深度学习。</li></ul><p>但即便这样，深度学习的VC dimension和VC Bound依旧很大，其泛化控制方法依然没有强理论支撑。但是实践又一次次证明，深度学习是好用的。所以VC维对深度学习的指导意义，目前不好表述，有一种思想建议，深度学习应该抛弃对VC维之类概念的迷信，尝试从其他方面来解释其可学习型，例如使用泛函空间（如<a style="color: #109eff" href="http://en.wikipedia.org/wiki/Banach_space" target="_blank" rel="noopener">Banach Space</a>）中的概率论。</p><p>更多细节请参考下面链接：</p><ol><li><a style="color: #109eff" href="http://ttic.uchicago.edu/~tewari/lectures/lecture12.pdf" target="_blank" rel="noopener">VC Dimension of Multilayer Neural Networks</a>，该文章给出了多层神经网络的VC bound的相关证明。</li><li><a style="color: #109eff" href="http://www.kdnuggets.com/2014/02/exclusive-yann-lecun-deep-learning-facebook-ai-lab.html" target="_blank" rel="noopener">Lecun: What is the relationship between Deep Learning and Support Vector Machines / Statistical Learning Theory?</a>Vapnik really believes in his bounds. He worried that neural nets didn’t have similarly good ways to do capacity control (although neural nets do have generalization bounds, since they have finite VC dimension).Lecun’s counter argument was that the ability to do capacity control was somewhat secondary to the ability to compute highly complex function with a limited amount of computation.</li></ol><h2>小结</h2><p>上面仔细分析了VC维的来龙去脉，讲述了VC维在机器学习理论中的指导意义。考虑到VC维在机器学习领域虽是基础，却也是大坑，难免有理解不深或不当之处，敬请谅解。若希望获得更深理解，请参考下面的参考文献。</p><h2>参考文献</h2><ol><li><a style="color: #109eff" href="http://www.autonlab.org/tutorials/vcdim.html" target="_blank" rel="noopener">VC dimension Tutorial Slides by Andrew Moore</a></li><li><a style="color: #109eff" href="https://www.coursera.org/course/ntumlone" target="_blank" rel="noopener">机器学习基石</a> x(上文的截图均出自于该课程的讲义)</li><li><a style="color: #109eff" href="http://www.svms.org/vc-dimension/" target="_blank" rel="noopener">vc-dimension in svms</a></li><li><a style="color: #109eff" href="http://www.36dsj.com/archives/21236" target="_blank" rel="noopener">机器学习简史</a></li><li><a style="color: #109eff" href="http://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory" target="_blank" rel="noopener">Vapnik–Chervonenkis theory</a></li><li><a style="color: #109eff" href="http://www.cs.nyu.edu/~yann/talks/lecun-ranzato-icml2013.pdf" target="_blank" rel="noopener">Deep Learning Tutorial</a></li><li><a style="color: #109eff" href="http://www.zhihu.com/question/27434103" target="_blank" rel="noopener">深度学习的研究领域是否有被过度夸大</a></li><li><a style="color: #109eff" href="http://freemind.pluskid.org/slt/vc-theory-vapnik-chervonenkis-dimension" target="_blank" rel="noopener">VC Theory: Vapnik–Chervonenkis Dimension</a></li></ol>]]></content>
    
    <summary type="html">
    
      VC维在机器学习领域是一个很基础的概念，它给诸多机器学习方法的可学习性提供了坚实的理论基础，但有时候，对我们而言，SVM，LR，深度学习等可能都已经用到线上了，但却不理解VC维。
    
    </summary>
    
      <category term="机器学习相关" scheme="http://ulsonhu.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="Machine Learning" scheme="http://ulsonhu.cn/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Lasso回归算法</title>
    <link href="http://ulsonhu.cn/LASSO%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95.html"/>
    <id>http://ulsonhu.cn/LASSO回归算法.html</id>
    <published>2018-02-28T16:00:00.000Z</published>
    <updated>2018-03-24T14:49:32.426Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://rokia.org/?tag=p_value" target="_blank" rel="noopener">关于P值滥用的简要介绍</a></p><p>计量模型中关于变量选择，很多同学可能第一个想到的是：前进法，后退法，向前向后逐步回归。但是，这些方法存在一些固有的缺陷,它们会导致某些可能为最优的变量组合无法共同进入模型。</p><p>我们抛开传统的统计学教材，把眼光瞄向统计学习理论，就会发现，其实有大量的模型可供我们选择。今天，先介绍最基础的方法：lasso。</p><h2>一、The lasso的提出</h2><p>Lasso,即Lesat absolute shrinkage and seletion operator.改方法由统计学习领域的执牛耳者<a href="http://statweb.stanford.edu/~tibs/lasso/lasso.pdf" target="_blank" rel="noopener">Robert Tibshirani于1996年开创</a>。至今为止，这篇文章被引用次数已达14000多次。据说，在学术领域，被引用次数能达到几十次已经可以引以为傲。经过将近20年的发展，这个方法养活了一大群人，同时也发展出了很多更为成熟的理论，如Adaptive lasso，The Grouped lasso,SCAD。</p><h2>二、The lasso的原理</h2><p>lasso的思想其实很简单，就是在传统的最小二乘估计上对模型的系数施加一个$L_1$惩罚。模型形式如下。$$\widehat{\beta}^{lasso} =\quad  argmin_{\beta}\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 \\ \qquad s. t\sum_{j = 1}^{p}|\beta_j|\leq t.$$</p><p>上式等价于</p><p>$$\widehat{\beta}^{lasso} = argmin_{\beta}{\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 + \lambda\sum_{j = 1}^{p}|\beta_j|}$$</p><p>看到这个表达式，有没有一种熟悉的感觉？看！</p><p>$$\widehat{\beta}^{ridge} = argmin_{\beta} {\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 + \lambda\sum_{j = 1}^{p}\beta_{j}^2}$$</p><p>没错！它其实跟我们在回归分析教材中介绍的岭回归(ridge regression)非常相似，只是将$L_2$惩罚换成了$L_1$惩罚。Zou and Hastie在2005年，提出了一种在ridge regression和the lasso之间折衷的方法：the <strong>elastic net</strong> penalty,思想也非常简单，但是却很有影响力。</p><p>回头看下，lasso为何如此流行。这么做的好处是一举多得的：</p><ul><li>可以解决岭回归能够解决的问题：多重共线性问题,过拟合问题等；</li><li>还可以解决岭回归不能解决的问题：将一部分变量的系数压缩至0，即实现变量选择。</li></ul><p>我们可以从一张图看出来。<br><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764085/2018_03_04p1.png" width="70%" height="70%"></p><p>这幅图可以这样理解蓝色的区域是$\beta$的可行域。由于the lasso的约束是$L_1$约束，必然是方形区域，区域的大小取决于$t$的大小；而ridge regression是$L_2$约束，所以可行域呈圆形。</p><p>$$Z = \sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2$$</p><p>从上面的式子可以看出，（如果我的空间解析几何没记错的话，）函数$Z(\beta_1,\beta_2)$描述的是一个椭圆抛物面的形状。而椭圆抛物面在$(\beta_1,\beta_2)$平面上的投影就是类似上图红色圆圈所表述的形状，每一圈代表着不同的$Z$值。而中间的黑点，自然就是最小的$Z$，即没有约束下，普通最小二乘得到的解。我们可以想象，当蓝色的圆圈足够大，以至于涵盖了中间的小黑点时，约束没有起到作用，取到的解就是中间的小黑点，此时等价于普通最小二乘；当约束比较紧，取到的解靠近0，为两个区域相切的点。</p><p>我们可以直观地看到，the lasso更容易取到角点解，即：使得某些变量的系数压缩至零。如果你还是不相信自己的眼睛，我们待会还可以从一个示例中看出这一特点。</p><p>一些爱思考的同学可能会继续追问：“它能够保证留下来的变量都是对因变量有着更大影响的吗？”这一点稍微思考一下，应该是可以保证的。但是，如果存在一组高度相关的变量时，Lasso倾向于选择其中的一个变量，而忽视其他所有的变量。这样可能会导致结果的不稳定性。要解决这个问题，可以去探究一下 <strong>elastic net</strong> penalty。</p><h2>三、lasso的R实现</h2><p>lasso的实现可以采用glmnet包。glmnet包作者是Friedman, Hastie, and Tibshirani这三位统计学习领域的大牛，可信度无可置疑。这个包采用的算法是循环坐标下降法（cyclical coordinate descent），能够处理的模型包括 linear regression,logistic and multinomial regression models, poisson regression 和 the Cox model，用到的正则化方法就是$l1$范数（lasso）、$l2$范数（岭回归）和它们的混合 （elastic net）。</p><p>这里，给出一个实现lasso的示例。</p><p>数据来源于ISLR包中的Hitters数据集，该数据集描述了美国1986年和1987年的棒球运动员相关数据。我们来探究一下对运动员薪水起主要作用的因素有哪些。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ISLR)</span><br><span class="line">str(Hitters)&lt;/code&gt;&lt;/pre&gt;</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 'data.frame':    322 obs. of  20 variables:</span></span><br><span class="line"><span class="comment">##  $ AtBat    : int  293 315 479 496 321 594 185 298 323 401 ...</span></span><br><span class="line"><span class="comment">##  $ Hits     : int  66 81 130 141 87 169 37 73 81 92 ...</span></span><br><span class="line"><span class="comment">##  $ HmRun    : int  1 7 18 20 10 4 1 0 6 17 ...</span></span><br><span class="line"><span class="comment">##  $ Runs     : int  30 24 66 65 39 74 23 24 26 49 ...</span></span><br><span class="line"><span class="comment">##  $ RBI      : int  29 38 72 78 42 51 8 24 32 66 ...</span></span><br><span class="line"><span class="comment">##  $ Walks    : int  14 39 76 37 30 35 21 7 8 65 ...</span></span><br><span class="line"><span class="comment">##  $ Years    : int  1 14 3 11 2 11 2 3 2 13 ...</span></span><br><span class="line"><span class="comment">##  $ CAtBat   : int  293 3449 1624 5628 396 4408 214 509 341 5206 ...</span></span><br><span class="line"><span class="comment">##  $ CHits    : int  66 835 457 1575 101 1133 42 108 86 1332 ...</span></span><br><span class="line"><span class="comment">##  $ CHmRun   : int  1 69 63 225 12 19 1 0 6 253 ...</span></span><br><span class="line"><span class="comment">##  $ CRuns    : int  30 321 224 828 48 501 30 41 32 784 ...</span></span><br><span class="line"><span class="comment">##  $ CRBI     : int  29 414 266 838 46 336 9 37 34 890 ...</span></span><br><span class="line"><span class="comment">##  $ CWalks   : int  14 375 263 354 33 194 24 12 8 866 ...</span></span><br><span class="line"><span class="comment">##  $ League   : Factor w/ 2 levels &amp;quot;A&amp;quot;,&amp;quot;N&amp;quot;: 1 2 1 2 2 1 2 1 2 1 ...</span></span><br><span class="line"><span class="comment">##  $ Division : Factor w/ 2 levels &amp;quot;E&amp;quot;,&amp;quot;W&amp;quot;: 1 2 2 1 1 2 1 2 2 1 ...</span></span><br><span class="line"><span class="comment">##  $ PutOuts  : int  446 632 880 200 805 282 76 121 143 0 ...</span></span><br><span class="line"><span class="comment">##  $ Assists  : int  33 43 82 11 40 421 127 283 290 0 ...</span></span><br><span class="line"><span class="comment">##  $ Errors   : int  20 10 14 3 4 25 7 9 19 0 ...</span></span><br><span class="line"><span class="comment">##  $ Salary   : num  NA 475 480 500 91.5 750 70 100 75 1100 ...</span></span><br><span class="line"><span class="comment">##  $ NewLeague: Factor w/ 2 levels &amp;quot;A&amp;quot;,&amp;quot;N&amp;quot;: 1 2 1 2 2 1 1 1 2 1 ...&lt;/code&gt;&lt;</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Hitters&lt;-na.omit(Hitters)</span><br><span class="line"><span class="comment">## sampling</span></span><br><span class="line">x&amp;lt;-model.matrix(Salary~.,Hitters)[,-<span class="number">1</span>]</span><br><span class="line">y&amp;lt;-Hitters$Salary</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">train&amp;lt;-sample(<span class="number">1</span>:nrow(x),nrow(x)/<span class="number">2</span>)</span><br><span class="line">test&amp;lt;-(-train)</span><br><span class="line">y.test&amp;lt;-y[test]</span><br><span class="line"></span><br><span class="line"><span class="comment">## ridge regression</span></span><br><span class="line"><span class="keyword">library</span>(glmnet)</span><br><span class="line">grid&amp;lt;-<span class="number">10</span>^seq(<span class="number">10</span>,-<span class="number">2</span>,length = <span class="number">100</span>)</span><br><span class="line">ridge.mod&amp;lt;-glmnet(x,y,alpha = <span class="number">0</span>,lambda = grid)</span><br><span class="line">plot(ridge.mod, main = &amp;quot;The ridge&amp;quot;)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018.03_04lasso01.png" width="70%" height="70%"><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## the lasso</span></span><br><span class="line">lasso.mod&amp;lt;-glmnet(x[train,],y[train],alpha = <span class="number">1</span>,lambda = grid)</span><br><span class="line">plot(lasso.mod, main = &amp;quot;The lasso&amp;quot;)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018_03_04lasso02.png" width="70%" height="70%"><p>从上面两幅图对比可知，the lasso相比起ridge regression，在压缩变量方便表现更出色。当然，你还可以使用这个包内部的交叉验证函数对<span class="math inline">(\lambda)</span>进行参数优化，使得模型更具有稳健性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## cross-validation</span><br><span class="line">set.seed(1)</span><br><span class="line">cv.out&amp;lt;-cv.glmnet(x[train,],y[train],alpha = 1)</span><br><span class="line">plot(cv.out)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018_03_04_lasso03.png" width="70%" height="70%"><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bestlam&amp;lt;-cv.out$lambda.min</span><br><span class="line">lasso.pred&amp;lt;-predict(lasso.mod,s = bestlam,newx = x[test,])</span><br><span class="line">mean((lasso.pred - y.test)^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## [1] 100743.4</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out&amp;lt;-glmnet(x,y,alpha = <span class="number">1</span>,lambda = grid)</span><br><span class="line">lasso.coef&amp;lt;-predict(out,type = &amp;quot;coefficients&amp;quot;,s = bestlam)[<span class="number">1</span>:<span class="number">20</span>,]</span><br><span class="line">lasso.coef</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  (Intercept)        AtBat         Hits        HmRun         Runs </span></span><br><span class="line"><span class="comment">##   18.5394844    0.0000000    1.8735390    0.0000000    0.0000000 </span></span><br><span class="line"><span class="comment">##          RBI        Walks        Years       CAtBat        CHits </span></span><br><span class="line"><span class="comment">##    0.0000000    2.2178444    0.0000000    0.0000000    0.0000000 </span></span><br><span class="line"><span class="comment">##       CHmRun        CRuns         CRBI       CWalks      LeagueN </span></span><br><span class="line"><span class="comment">##    0.0000000    0.2071252    0.4130132    0.0000000    3.2666677 </span></span><br><span class="line"><span class="comment">##    DivisionW      PutOuts      Assists       Errors   NewLeagueN </span></span><br><span class="line"><span class="comment">## -103.4845458    0.2204284    0.0000000    0.0000000    0.0000000</span></span><br></pre></td></tr></table></figure><p>可见，很多变量的系数确实被压缩至零。</p><h2>四、lasso的优缺点分析</h2><ul><li>相比较于其他变量选择方法，如：best subset，Partial Least Squares(偏最小二乘)，Principal components regression(主成分回归)，the lasso和ridge regression对参数的调整是连续的，并不是一刀切的。</li><li>the lasso相比于ridge regression的优势在于压缩变量表现更出色。</li><li>但是，正如前面所说，lasso还是会有一些潜在的问题，有时候，elastic net等其他的一些lasso的变形会是更好的选择。</li></ul><h2>五、参考文献</h2><ol><li>The Elements of Statistical Learning: Data Mining, Inference and Prediction. Second edition</li><li>An Introduction to Statistical Learning with R</li><li><a href="http://site.douban.com/182577/widget/notes/10567212/note/288551448/" target="_blank" rel="noopener">线性回归建模–变量选择和正则化（1）：R包glmnet</a></li></ol>]]></content>
    
    <summary type="html">
    
      很多人在做变量选择时，眼光依然局限于$R^2$或者$Adjusted-R^2$,以及$P-Value$之中。计量经济学中，对于模型选择，学术界其实更倾向于采用$AIC$和$BIC$等标准来做判断。而对于$P-Value$的滥用与批判，其实已经到了水深火热的地步。抛开背景知识不谈，在变量选择，可以倚靠哪些神奇的准则和方法？
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>因果推断：工具变量（Instrumental Variable）</title>
    <link href="http://ulsonhu.cn/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%98%E9%87%8F%EF%BC%88Instrumental%20Variable%EF%BC%89.html"/>
    <id>http://ulsonhu.cn/因果推断：工具变量（Instrumental Variable）.html</id>
    <published>2018-02-27T16:00:00.000Z</published>
    <updated>2018-03-11T10:55:23.905Z</updated>
    
    <content type="html"><![CDATA[<h2>一、线性回归和最小二乘法</h2><p>线性模型和最小二乘的理论起源于高斯的天文学研究，“回归”（regression）这个名字则是 Francis Galton 在研究优生学的时候提出来的。为了描述的方便，我们假定回归的自变量只有一维，比如个体$i$是否接受某种处理（吸烟与否；参加某个工作；等等），记为$D_i$。 回归的因变量也是一维，表示我们关心的结果（是否有肺癌；是否找到工作培训与否；等等），记为$Y_i$。假定我们的研究中有 $n$ 个个体，下面的线性模型用于描述$D$和$Y$之间的“关系”：</p><p>$$Y_i = \alpha + \beta D_i + \varepsilon_i, i=1, \cdots, n. \quad \quad (1)$$</p><p>一般情形下，我们假定个体间是独立的。模型虽简单，我们还是有必要做一些解释。首先，我们这里的讨论都假定$D_i$是随机变量，对应统计学中的随机设计 （random design）的情形；这和传统统计学中偏好的固定设计（fixed design）有点不同—那里假定$D_i$总是固定的。（统计学源于实验设计，那里的解释变量都是可以控制的，因此统计学教科书有假定固定设计的传统。）假定$D_i$是随机的，既符合很多社会科学和流行病学的背景，又会简化后面的讨论。另外一个问题是 $\varepsilon_i$，它到底是什么含义？Rubin 曾经嘲笑计量经济学家的$\varepsilon_i$道：为了使得线性模型的等式成立，计量经济学家必须加的一项，就叫$\varepsilon_i$。批评的存在并不影响这个线性模型的应用；关键的问题在于，我们在这个$\varepsilon_i$上加了什么假定呢？最根本的假定是：</p><p>$$E(\varepsilon_i) = 0, \text{ and }  \text{cov}(D_i, \varepsilon_i) = 0. \quad \quad (2)$$</p><p>不同的教科书稍有不同，比如 Wooldridge 的书上假定$E(\varepsilon_i\mid D_i ) =0$，很显然，这蕴含着上面两个假定。零均值的假定并不强，因为 $\alpha$“吸收”了$\varepsilon_i$的均值；关键在第二个协方差为零的假定—它通常被称为“外生性”（exogeneity）假定。在这个假定下，我们在 (1) 的两边关于$D_i$取协方差，便可以得到：</p><p>$$\text{cov}(Y_i, D_i )= \beta \text{var}(D_i),$$</p><p>因此，$\beta = \text{cov}(Y_i, D_i) / \text{var}(D_i)$，我们立刻得到了矩估计：</p><p>$$\widehat{\beta}_{OLS}=\frac{\sum_{i=1}^n(Y_i-\bar{Y})(D_i-\bar{D})}{\sum_{i=1}^n(D_i-\bar{D})^2}$$</p><p>上面的估计式也是通常的最小二乘解，这里只是换了一个推导方式。如果将 (1) 看成一个数据生成的机制，在假定 (2) 下我们的确可以估计出因果作用$\beta$.</p><h2>二、内生性和工具变量</h2><p>问题的关键是假定 (2) 很多时候并不成立（$\text{cov}(D_i, \varepsilon_i)\neq 0$），比如，吸烟的人群和不吸烟的人群本身很不相同，参加工作培训的人可能比不参加工作培训的人有更强的找工作动机，等等。因此，包含个体$i$其他所有隐藏信息的变量$\varepsilon_i$不再与$D_i$不相关了—这被称为“内生性”（endogeneity）。这个时候，最小二乘估计收敛到$\beta + \text{cov}(D,\varepsilon)/\text{var}(D)$, 因而在$\text{cov}(D,\varepsilon)\neq 0$时不再是$\beta$的相合估计。</p><p>前面几次因果推断的介绍中提到，完全的随机化实验，可以给我们有效的因果推断。但是很多问题中，强制性的随机化实验是不现实或者不符合伦理的。比如，我们不能强制某些人吸烟，或者不吸烟。但是，“鼓励性实验”依然可行。我们可以随机地给吸烟的人以某种金钱的奖励，如果他们放弃吸烟，则获得某种经济上的优惠。将这个“鼓励性”的变量记为$Z_i$，它定义为是否被鼓励的示性变量，取值 0-1。由于我们的鼓励是完全随机的，有理由假定$\text{cov}(Z_i, \varepsilon_i)=0$。</p><p>以上的各个假定，可以用下面的一个图来形象的描述。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520746493/2018_03_03iv.png" alt="iv" width="70%" height="70%"><p>如图所示，由于$D$和$Y$之间存在一个混杂因素$U$，两者之间的因果作用是不可以用线性回归相合估计的。工具变量$Z$的存在，使得$D$到$Y$的因果作用的识别成为了可能。这里的工具变量$Z$满足如下的条件: $Z\perp U, Z\not \perp D$，并且$Z\perp Y|(D,U)$。第三个条件，可以理解成为“无 $Z$到$Y$的直接作用”。</p><p>此时，我们在线性模型 (1) 两边关于$Z_i$取协方差，得到</p><p>$$\text{cov}(Z_i, Y_i) = \beta \text{cov} (Z_i, D_i),$$</p><p>因此，$\beta = \frac{  \text{cov}(Z_i, Y_i)} {\text{cov} (Z_i, D_i) } $，我们立刻得到如下的矩估计：</p><p>$$\widehat{\beta}_{OLS} = \frac{\sum_{i=1}^n (Y_i – \bar{Y}) (D_i – \bar{D})}{\sum_{i=1}^n (D_i – \bar{D})^2}$$</p><p>根据大数定律，这个“工具变量估计”是$\beta$的相合估计量。上面的式子对一般的$Z_i$都是成立的；当$Z_i$是 0-1 变量时，上面的式子可化简成：</p><p>$$\widehat{\beta}_{IV} = \frac{  \bar{Y}_1 – \bar{Y}_0 } { \bar{D}_1 – \bar{D}_0 },$$</p><p>其中$\bar{Y}_1$表示$Z_i=1$组的平均结果，$\bar{Y}_0$表示$Z_i=0$组的平均结果，关于$D$的定义类似。上面的估计量，很多时候被称为 Wald 估计量（它的直观含义是什么呢？） 需要注意的是，(3) 要求$\text{cov}(Z_i,D_i)\neq 0$，即“鼓励”对于改变人的吸烟行为是有效的；否则上面的工具变量估计量在大样本下趋于无穷大。</p><h2>三、潜在结果视角下的因果作用</h2><p>工具变量估计量在文献中存在已有很多年了，一直到了 Angrist, Imbens and Rubin (1996) 年的文章出现，才将它和潜在结果视角下的因果推断联系起来。关于 Neyman 引进的潜在结果，需要回顾这一系列的第二篇文章。</p><p>一般地， $Z$表示一个 0-1 的变量，表示随机化的变量（1 表示随机化分到非鼓励组；0 表示随机化分到鼓励组）；$D$ 表示最终接受处理与否（1 表示接受处理；0 表示接受对照）；$Y$ 是结果变量。为了定义因果作用，我们引进如下的潜在结果：$(Y_i(1), Y_i(0))$表示个体$i$接受处理和对照下$Y$的潜在结果；$(D_i(1), D_i(0))$表示个体$i$非鼓励组和鼓励组下$D$的潜在结果。由于随机化，下面的假定自然的成立：</p><p>（随机化）$Z_i \perp { D_i(1), D_i(0), Y_i(1), Y_i(0) }.$</p><p>根据鼓励性实验的机制，个体在受到鼓励的时候，更加不可能吸烟，因为下面的单调性也是很合理的：</p><p>（单调性）$D_i(1) \leq D_i(0).$</p><p>由于个体的结果$Y$直接受到所受的处理$D$的影响，而不会受到是否受鼓励$Z$的影响，下面的排除约束（exclusion restriction）的假定，很多时候也是合理的：</p><p>（排除约束）$D_i(1) = D_i(0) $ 蕴含着 $Y_i(1) = Y_i(0)$.</p><p>上面的假定表明，当随机化的“鼓励”$Z$不会影响是否接受处理$D$时，随机化的“鼓励” $Z$也不会影响结果变量$Y$。也可以理解成，随机化的“鼓励” $Z$ 仅仅通过影响是否接受处理$D$来影响结果$Y$，或者说，随机化“鼓励” $Z$本身对与结果变量$Y$没有“直接作用”。</p><p>以上三个假定下，我们得到：</p><p>$$ ACE(Z \rightarrow Y) \\ E{Y_i(1)} -E{Y_i(0)} \\ P{ D_i(1)=1, D_i(0)=0} E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=0 }\\ + P{ D_i(1)=0, D_i(0)=0} E{Y_i(1)-Y_i(0)\mid D_i(1)=0, D_i(0)=0 }\\+P{ D_i(1)=1, D_i(0)=1} E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=1 }\\ P{ D_i(1)=1, D_i(0)=0} E{Y_i(1) -Y_i(0)\mid D_i(1)=1, D_i(0)=0 }.$$</p><p>单调使得 $D$ 的潜在结果的组合只有三种；排除约束假定使得上面分解的后两个式子为$0$。由于对于 $(D_i(1)=0, D_i(0)=0)$ 和 $(D_i(1)=1, D_i(0)=1)$两类人，随机化的“鼓励”对于$D$的作用为$0$，$(D_i(1)=1, D_i(0)=0)$一类人的比例就是$Z$对$D$平均因果作用：$ACE(Z\rightarrow D) = P{ D_i(1)=1, D_i(0)=0} $. 因此，</p><p>$$<br>CACE= E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=0 } = \frac{ ACE(Z \rightarrow Y) }{ ACE(Z\rightarrow D) }.<br>$$</p><p>上面的式子被定义为$CACE$是有理由的。它表示的是子总体$(D_i(1)=1, D_i(0)=0)$中，随机化对于结果的因果作用；由于这类人中随机化和接受的处理是相同的，它也表示处理对结果的因果作用。这类人接受处理与否完全由于是否接受鼓励而定，他们被成为“依从者”（complier），因为这类人群中的平均因果作用又被成为“依从者平均因果作用”（CACE：complier average causal effect）;计量经济学家称它为“局部处理作用”（LATE：local average treatment effect）。</p><p>由于$Z$是随机化的，它对于$D$和$Y$的平均因果作用都是显而易见可以得到的。因为$\widehat{ACE}(Z\rightarrow D) = \bar{D}_1 – \bar{D}_0, \widehat{ACE}(Z\rightarrow Y) = \bar{Y}_1 – \bar{Y}_0$，CACE 的一个矩估计便是</p><p>$$ \frac{\widehat{ACE}(Z\rightarrow Y)  } {  \widehat{ACE}(Z\rightarrow D)   } = \widehat{\beta}_{IV}.$$</p><p>由此可见工具变量估计量的因果含义。上面的讨论既显示了工具变量对于识别因果作用的有效性，也揭示了它的局限性：我们只能识别某个子总体的平均因果作用；而通常情况下，我们并不知道某个个体具体属于哪个子总体。</p><h2>四、实例</h2><p>这部分给出具体的例子来说明上理论的应用，具体计算用到了第五部分的一个函数（其中包括用delta方法算的抽样方差）。这里用到的数据来自一篇政治学的文章 Green et al. (2003) “Getting Out the Vote in Local Elections: Results from Six Door-to-Door Canvassing Experiments”，<a href="http://dvn.iq.harvard.edu/dvn/faces/study/StudyPage.xhtml?globalId=hdl:1902.1/21729&amp;studyListingIndex=5_c49f1060ddaa41a23e5759168940" target="_blank" rel="noopener">数据点击此处可以在此下载</a>。</p><p>文章目的是研究某个社会实验是否能够提到投票率，实验是随机化的，但是并非所有的实验组的人都依从。因此这里的变量 $Z$ 表示随机化的实验，$D$ 表示依从与否，$Y$ 是投票与否的示性变量。具体的数据描述，可参加前面提到的文章。</p><p>原始数据总结如下：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520746493/2018_03_03table1.png" width="70%" height="70%">根据下一个部分的函数，我们得到如下的结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CACE.IV(Y, D, Z)</span><br><span class="line">$CACE</span><br><span class="line">[1] 0.07914375</span><br><span class="line"></span><br><span class="line">$se.CACE</span><br><span class="line">           [,1]</span><br><span class="line">[1,] 0.02273439</span><br><span class="line"></span><br><span class="line">$p.value</span><br><span class="line">             [,1]</span><br><span class="line">[1,] 0.0004991073</span><br><span class="line"></span><br><span class="line">$prob.complier</span><br><span class="line">[1] 0.2925123</span><br><span class="line"></span><br><span class="line">$se.complier</span><br><span class="line">[1] 0.004871619</span><br></pre></td></tr></table></figure><p>由此可见，这个实验对于提高投票率，有显著的作用。</p><h2>五、R code</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## function for complier average causal effect</span></span><br><span class="line">CACE.IV = <span class="keyword">function</span>(outcome, treatment, instrument)</span><br><span class="line">&#123;</span><br><span class="line">Y = outcome</span><br><span class="line">D = treatment</span><br><span class="line">Z = instrument</span><br><span class="line">N = length(Y)</span><br><span class="line"></span><br><span class="line">Y1 = Y[Z == <span class="number">1</span>]</span><br><span class="line">Y0 = Y[Z == <span class="number">0</span>]</span><br><span class="line">D1 = D[Z == <span class="number">1</span>]</span><br><span class="line">D0 = D[Z == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">mean.Y1 = mean(Y1)</span><br><span class="line">mean.Y0 = mean(Y0)</span><br><span class="line">mean.D1 = mean(D1)</span><br><span class="line">mean.D0 = mean(D0)</span><br><span class="line"></span><br><span class="line">prob.complier = mean.D1 - mean.D0</span><br><span class="line">var.complier  = var(D1)/length(D1) + var(D0)/length(D0)</span><br><span class="line">se.complier   = var.complier^<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">CACE = (mean.Y1 - mean.Y0)/(mean.D1 - mean.D0)</span><br><span class="line"></span><br><span class="line"><span class="comment">## COV</span></span><br><span class="line">pi1 = mean(Z)</span><br><span class="line">pi0 = <span class="number">1</span> - pi1</span><br><span class="line"></span><br><span class="line">Omega = c( var(Y1)/pi1, cov(Y1, D1)/pi1, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">           cov(Y1, D1)/pi1, var(D1)/pi1, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>, <span class="number">0</span>, var(Y0)/pi0, cov(Y0, D0)/pi0,</span><br><span class="line">           <span class="number">0</span>, <span class="number">0</span>, cov(Y0, D0)/pi0, var(D0)/pi0 )</span><br><span class="line">Omega = matrix(Omega, byrow = <span class="literal">TRUE</span>, nrow = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Gradient</span></span><br><span class="line">Grad = c(<span class="number">1</span>, -CACE, -<span class="number">1</span>, CACE)/(mean.D1 - mean.D0)</span><br><span class="line"></span><br><span class="line">COV.CACE = t(Grad)%*%Omega%*%Grad/N</span><br><span class="line"></span><br><span class="line">se.CACE = COV.CACE^<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">p.value = <span class="number">2</span>*pnorm(abs(CACE/se.CACE), <span class="number">0</span>, <span class="number">1</span>, lower.tail = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##results</span></span><br><span class="line">res = list(CACE          = CACE,</span><br><span class="line">           se.CACE       = se.CACE,</span><br><span class="line">           p.value       = p.value,</span><br><span class="line">           prob.complier = prob.complier,</span><br><span class="line">           se.complier   = se.complier)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      为了介绍工具变量，我们首先要从线性模型出发。毫无疑问，线性模型是理论和应用统计（包括计量经济学和流行病学等）最重要的工具；对线性模型的深刻理解，可以说就是对一大半统计理论的理解。下面的第一部分先对线性模型，尤其是线性模型背后的假设做一个回顾。
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>广义矩估计(GMM)方法</title>
    <link href="http://ulsonhu.cn/%E5%B9%BF%E4%B9%89%E7%9F%A9%E4%BC%B0%E8%AE%A1(GMM)%E6%96%B9%E6%B3%95.html"/>
    <id>http://ulsonhu.cn/广义矩估计(GMM)方法.html</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-03-31T15:51:25.498Z</updated>
    
    <content type="html"><![CDATA[<p>首先广义矩估计($GMM$)很容易使我们联想到统计学中参数估计方法之一的矩估计。</p><h2>矩估计</h2><p>矩估计是什么呢？简单的说，就是用样本矩代替总体矩进行统计推断的方法。</p><p>一个最基础的例子是正态总体的参数估计问题。如果$x_i \sim N(\mu,{\sigma}^2)$，如何估计$\mu$和$\sigma$呢？本科的统计学一般会介绍两种方法：极大似然估计和矩估计。其中矩估计是我们今天的主角。观察到：</p><p>$$E(x_i)=\mu,\quad E(x_{i}^2)={\mu}^2+{\sigma}^2$$而根据大数定理，在一定的条件下，我们有：$$\bar{x_i}-\mu=O_p(1),\quad \bar{x_{i}^2}={\mu}^2+{\sigma}^2+O_p(1)$$</p><p>也就是说，当样本量足够大的时候，样本矩与总体矩只差了一个无穷小量，那么我们是不是可以<font color="blue">用样本矩代替总体矩得到参数的估计呢？</font></p><p>按照上面的思路，我们把$O_p(1)$去掉，同时把未知的总体参数写成其估计值，也就是$\hat{x}$的形式，我们得到了：$$\hat{\mu}=\bar{x_i},\quad \hat{\sigma^2}=\bar{x_{i}^2}+\bar{x_i}^2$$</p><p>如此，我们得到了两个总体矩的点估计。<font color="blue">在这个简单的例子里面，你只要把上面的大数定理的结论带到上面两个式子里面，很容易的就可以证明出两个点估计是一致的估计量。当然，值得注意的是，即便我使用的是矩条件，$\sigma$的估计也不是无偏的。一般而言，除了特殊情况，不管是$MLE$还是$MM$还是$GMM$，都不一定可以得到无偏的估计量。特别是在比较复杂的应用里面，一致就很不错了，无偏性的讨论真的繁琐。</font></p><h2>广义矩估计</h2><p>在上面的例子中，我们只使用了<strong>两个矩条件</strong>。然而我们知道，正态分布的矩是有无穷多个可以用的，那么我们是不是可以使用更多的矩条件呢？</p><p>但是有个问题不好解决。在这个例子里面，我们有两个未知参数，如果只使用一阶矩，那么只有一个方程解两个未知数，显然是不可能的。像上面一样，我们用两个矩条件解两个未知数，就解出来了。然而，当我们用一到三阶矩，总共三个方程求解的时候，三个方程求解两个未知数，可能无解。</p><p>方程数多了，反而没有解了，为什么呢？其实很简单，用三个方程中的任意两个方程，都可以求出一组解，那么三个方程我们就可以求出三组解。所以应该如何把这些矩条件都用上呢？到这里我们不妨引入一些记号。还是使用上面的例子，我们把上面的三个矩条件写到一个向量里面去，记：</p><p>$$g(x_i,\theta)=[x_i-\mu,{x_i}^2-\mu^2-\sigma^2,{x_i}^3-\mu^3-3\cdot \mu \sigma^2],\theta={\mu,\sigma^2}$$我们可以得到一个$3*1$的列向量，并且：</p><p>$$Eg(x_i,\theta)=0$$</p><p>上面就是我们要用的矩条件。而根据上面的思路，用其样本矩代替总体矩：</p><p>$$\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})=0$$解这个方程应该就可以得到参数$\theta$的估计。但是正如上面所说的，三个方程两个未知数，并不能确保这个方程有解，所以必须想一些其他办法。一个比较自然的想法是，上面的矩条件等于0，虽然我不太可能保证三个方程同时等于0，但是仿照$OLS$，我们可以让他们的平方和最小，也就是：</p><p>$$\underset{\hat{\theta} }{min}{ [ \frac{1}{N}\sum_{i}g(x_i,\hat{\theta}) ]}’[\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})]$$这样我们就能保证三个矩条件的样本矩都足够贴近于0，当然不可能同时为0。这样不就综合使用了三个矩条件的信息么？</p><p>更一般的，由于上面的$g$函数是一个$3*1$的列向量，我们可以使用一个权重矩阵$W$来赋予每个矩条件以不同的权重：</p><p>$$\underset{\hat{\theta} }{min}{ [ \frac{1}{N}\sum_{i}g(x_i,\hat{\theta}) ]}'W[\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})]$$</p><p>只要这个$W$是一个正定矩阵，那么仍然可以保证每个样本矩都足够贴近于0。那么问题来了，既然对$W$的要求只要求正定矩阵，那么使用不同的权重矩阵就有可能得到不同的结果。</p><p>问题是，有没有一个最优的权重矩阵呢？当然是有的。可以证明，最优的权重矩阵应该是：使用这个权重矩阵，就得到了最有效的估计。</p><blockquote><p>$GMM$估计相当于给不同的矩条件赋予了不同的权重，然后才能这个权重得到最小化条件，不同的权重阵其实就对不同的估计量，“OLS, IV, 2SLS, GLS, RE, FE, SUR, 3SLS, Pooled OLS…全是它的特殊情况”</p></blockquote><h2>GMM延伸</h2><p>计量经济学的很多问题基本都可以归结为$GMM$的问题。从最简单的$OLS、2SLS$到稍微复杂一点的面板数据、动态面板等等，本质上都是在找矩条件。比如工具变量的$2SLS$，可以发现矩条件不过就是：</p><p>$$E[(y_i-{x_i}’\beta)*z_i]=0$$</p><p>套一下上面的公式，最优权重矩阵(的逆)为：</p><p>$$E[(y_i-{x_i}’\beta_0)*z_i*{z_i}’*(y_i-{x_i}’\beta_0)’]=E[e_i^2z_i{z_i}’]=\sigma^2Ez_i{z_i}’$$</p><p>带入到目标函数中，就得到了$2SLS$。甚至，一些其他的估计量，比如$MLE、M-estimator$等，在一定的条件下也可以转化为$GMM$，因为这些估计量的一阶条件可以看成是矩条件。所以$GMM$也就变成了一个统一的框架。为什么$GMM$这么受欢迎呢？因为$GMM$把复杂的统计过程抽象化成为一个（看似）简单的过程：找矩条件。只要你能找到矩条件，你就能估计。$GMM$把估计的繁琐细节全都抽象了，面对一个模型，你所需要做的所有事情就是找到矩条件，证明这个模型是可以识别的，然后什么也不用管，一股脑儿塞进去，结果就出来了。</p><p>所以呢如果你去看一些稍微复杂的模型，基本都可以归结为矩条件。</p><h2>参考</h2><ol><li><a href="https://www.zhihu.com/question/41312883/answer/91484566" target="_blank" rel="noopener">如何用简单的例子解释什么是 Generalized Method of Moments (GMM)?</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89%E7%9F%A9%E4%BC%B0%E8%AE%A1" target="_blank" rel="noopener">广义矩估计</a></li></ol>]]></content>
    
    <summary type="html">
    
      简单的$GMM$快速入门介绍虽然听起来高大上，但背后统计学思想并不复杂。如果你有本科的统计知识，看懂下文是不成问题的。$GMM$的全名是$\text{Generalized Method of Moments}$，也就是广义矩估计。
    
    </summary>
    
      <category term="数理统计" scheme="http://ulsonhu.cn/categories/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>JUMP少年周刊-最全漫画排行榜</title>
    <link href="http://ulsonhu.cn/JUMP%E5%B0%91%E5%B9%B4%E5%91%A8%E5%88%8A-%E6%9C%80%E5%85%A8%E6%BC%AB%E7%94%BB%E6%8E%92%E8%A1%8C%E6%A6%9C.html"/>
    <id>http://ulsonhu.cn/JUMP少年周刊-最全漫画排行榜.html</id>
    <published>2018-02-23T16:00:00.000Z</published>
    <updated>2018-03-23T04:14:21.695Z</updated>
    
    <content type="html"><![CDATA[<p>其中，一些台词我们仍记忆犹新诸如</p><p>龟–派--汽–功  $\quad \Rightarrow $ 七龙珠<br>你已经死了      $\quad \Rightarrow $北斗神拳<br>教练我想打篮球！ $\quad \Rightarrow $灌篮高手<br>燃烧吧，小宇宙   $\quad \Rightarrow $圣斗士星矢<br>我可是要当海贼王的男人 $\quad \Rightarrow $One Peice<br></p><p>JUMP的连载原则：把在十话内没有得到读者青睐的漫画统统砍掉，并要求高人气作品不准完结，要不顾剧情发展的连载下去。虽然，这样的的条款压抑了创作者空间，但是作为一个企业来说，JUMP以这样的原则给我们呈现了数不清的优秀作品，也获得了巨大的商业成功，稳居日本漫画龙头地位。</p><table><thead><tr><th style="text-align:center">排行</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>香蕉时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>奇异果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>芒果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">No.1</td><td style="text-align:center"><strong>破廉耻学园</strong></td><td style="text-align:center">永井 豪</td><td style="text-align:center">1968-1972</td><td style="text-align:center"><strong>七龙珠</strong></td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1984-1995</td><td style="text-align:center"><strong>海贼王</strong></td><td style="text-align:center">尾田荣一郎</td><td style="text-align:center">2000-2013</td></tr><tr><td style="text-align:center">No.2</td><td style="text-align:center">根性青蛙</td><td style="text-align:center">吉泽保美</td><td style="text-align:center">1970-1976</td><td style="text-align:center">筋肉人</td><td style="text-align:center">蚵仔煎</td><td style="text-align:center">1979-1987</td><td style="text-align:center"><strong>全职猎人</strong></td><td style="text-align:center">富坚 义博</td><td style="text-align:center">1998-</td></tr><tr><td style="text-align:center">No.3</td><td style="text-align:center"><strong>乌龙派出所</strong></td><td style="text-align:center">秋本 治</td><td style="text-align:center">1976-2016</td><td style="text-align:center"><strong>灌篮高手</strong></td><td style="text-align:center">井上 雄彦</td><td style="text-align:center">1990-1996</td><td style="text-align:center"><strong>火影忍者</strong></td><td style="text-align:center">岸本 齐史</td><td style="text-align:center">1999-2013</td></tr><tr><td style="text-align:center">No.4</td><td style="text-align:center">魔投手</td><td style="text-align:center">梶原一骑</td><td style="text-align:center">1971-1974</td><td style="text-align:center"><strong>北斗神拳</strong></td><td style="text-align:center">武论尊</td><td style="text-align:center">1983-1988</td><td style="text-align:center"><strong>美食的俘虏</strong></td><td style="text-align:center">岛袋 光年</td><td style="text-align:center">2008-2016</td></tr><tr><td style="text-align:center">No.5</td><td style="text-align:center"><strong>男儿当大将</strong></td><td style="text-align:center">本宫</td><td style="text-align:center">1968-1973</td><td style="text-align:center">城市猎人</td><td style="text-align:center">北条司</td><td style="text-align:center">1985-1991</td><td style="text-align:center">死神</td><td style="text-align:center">久保 带人</td><td style="text-align:center">2001-2016</td></tr><tr><td style="text-align:center">No.6</td><td style="text-align:center">阿拉蕾</td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1980-1984</td><td style="text-align:center"><strong>足球小将</strong></td><td style="text-align:center">高桥 阳一</td><td style="text-align:center">1981-1988</td><td style="text-align:center"><strong>棋魂</strong></td><td style="text-align:center">堀田由美</td><td style="text-align:center">1999-2003</td></tr><tr><td style="text-align:center">No.7</td><td style="text-align:center">魔神z</td><td style="text-align:center">永井 豪</td><td style="text-align:center">1972-1973</td><td style="text-align:center">High School！奇面组</td><td style="text-align:center">新泽基荣</td><td style="text-align:center">1982-1987</td><td style="text-align:center">游戏王</td><td style="text-align:center">高桥和希</td><td style="text-align:center">1996-2004</td></tr><tr><td style="text-align:center">No.8</td><td style="text-align:center">Play Ball</td><td style="text-align:center">千叶昭雄</td><td style="text-align:center">1973-1978</td><td style="text-align:center"><strong>Jo-Jo奇妙冒险</strong></td><td style="text-align:center">荒木飞吕彦</td><td style="text-align:center">1987-2004</td><td style="text-align:center">银魂</td><td style="text-align:center">空知 英秋</td><td style="text-align:center">2004-至今</td></tr><tr><td style="text-align:center">No.9</td><td style="text-align:center"><strong>猫眼三姐妹</strong></td><td style="text-align:center">北条司</td><td style="text-align:center">1981-1984</td><td style="text-align:center">橙路</td><td style="text-align:center">松本泉</td><td style="text-align:center">1984-1987</td><td style="text-align:center">黑子的篮球</td><td style="text-align:center">藤卷忠俊</td><td style="text-align:center">2009-2014</td></tr><tr><td style="text-align:center">No.10</td><td style="text-align:center">赛道之狼</td><td style="text-align:center"></td><td style="text-align:center">1975-1979</td><td style="text-align:center"><strong>幽游白书</strong></td><td style="text-align:center">富坚义博</td><td style="text-align:center">1990-1993</td><td style="text-align:center"><strong>网球王子</strong></td><td style="text-align:center">许斐刚</td><td style="text-align:center">1999-2008</td></tr><tr><td style="text-align:center">No.11</td><td style="text-align:center"><strong>料理人味平</strong></td><td style="text-align:center">牛次郎</td><td style="text-align:center">1973-1977</td><td style="text-align:center"><strong>浪客剑心</strong></td><td style="text-align:center">和月 伸宏</td><td style="text-align:center">1994-1999</td><td style="text-align:center">死亡笔记</td><td style="text-align:center">大场</td><td style="text-align:center">2004-2006</td></tr><tr><td style="text-align:center">No.12</td><td style="text-align:center">东大一直线</td><td style="text-align:center">小林</td><td style="text-align:center">1976-1979</td><td style="text-align:center"><strong>圣斗士星矢</strong></td><td style="text-align:center">车田 正美</td><td style="text-align:center">1986-1990</td><td style="text-align:center">暗杀教室</td><td style="text-align:center">松井 优征</td><td style="text-align:center">2012</td></tr><tr><td style="text-align:center">No.13</td><td style="text-align:center">天际球团</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">铁拳对钢拳</td><td style="text-align:center">森田真法</td><td style="text-align:center">1988-1997</td><td style="text-align:center">家庭教师HITMAN REBORN</td><td style="text-align:center">天野明</td><td style="text-align:center">2004-1012</td></tr><tr><td style="text-align:center">No.14</td><td style="text-align:center">厕所博士</td><td style="text-align:center"></td><td style="text-align:center">1970-1977</td><td style="text-align:center">魁！！男塾</td><td style="text-align:center">宫下亚喜罗</td><td style="text-align:center">1985-1991</td><td style="text-align:center"><strong>通灵王</strong></td><td style="text-align:center">武井 宏之</td><td style="text-align:center">1998-2004</td></tr><tr><td style="text-align:center">No.15</td><td style="text-align:center">眼睛蛇</td><td style="text-align:center">寺泽 武一</td><td style="text-align:center">1978-1984</td><td style="text-align:center">电影少女</td><td style="text-align:center">桂 正和</td><td style="text-align:center">1989-1992</td><td style="text-align:center">Bobobo-bo Bo-bobo</td><td style="text-align:center">泽井 磐夫</td><td style="text-align:center">2001-2007</td></tr><tr><td style="text-align:center">No.16</td><td style="text-align:center">杜宾刑警</td><td style="text-align:center">武论尊</td><td style="text-align:center">1975-1979</td><td style="text-align:center">幻法小魔星</td><td style="text-align:center">江川 达也</td><td style="text-align:center">1988-1992</td><td style="text-align:center"><strong>草莓100%</strong></td><td style="text-align:center">河下 水希</td><td style="text-align:center">2002-2005</td></tr><tr><td style="text-align:center">No.17</td><td style="text-align:center">停止！！云雀</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1981-1983</td><td style="text-align:center">秀逗泰山</td><td style="text-align:center">德弘正也</td><td style="text-align:center">1988-1995</td><td style="text-align:center">出包王女</td><td style="text-align:center">矢吹 健太郎</td><td style="text-align:center">2006-2009</td></tr><tr><td style="text-align:center">No.18</td><td style="text-align:center">热拳本色</td><td style="text-align:center">车田 正美</td><td style="text-align:center">1977-1981</td><td style="text-align:center">灵异教师神眉</td><td style="text-align:center"></td><td style="text-align:center">1993-1999</td><td style="text-align:center">ROOKIES</td><td style="text-align:center">森田</td><td style="text-align:center">1998-2003</td></tr><tr><td style="text-align:center">No.19</td><td style="text-align:center">赤脚的元</td><td style="text-align:center">中泽 磐治</td><td style="text-align:center">1973-1974</td><td style="text-align:center">银牙</td><td style="text-align:center">高桥义广</td><td style="text-align:center">1983-1987</td><td style="text-align:center">光速蒙面侠21</td><td style="text-align:center">村田雄介</td><td style="text-align:center">2002-2009</td></tr><tr><td style="text-align:center">No.20</td><td style="text-align:center">前进！！海盗</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1997-1980</td><td style="text-align:center">顺带着稀里糊涂</td><td style="text-align:center"></td><td style="text-align:center">1985-1989</td><td style="text-align:center">搞怪吹笛手</td><td style="text-align:center">臼田京介</td><td style="text-align:center">2000-2010</td></tr></tbody></table><blockquote><p>表格注：JUMP于2012年连载的人气漫画诸如：<strong>排球少年、食戟之灵</strong>等优秀作品暂未列入排行榜。</p></blockquote><p>2000年代以来，JUMP三台柱就分别是“死神、火影、海贼王”，但是死神和火影的正式完结，人气却弄的相当低迷，海贼王目前也可以看到，尾田休刊次数也增加不少。目前JUMP少年周刊可以说迎来了一个低迷时期。</p><p>于2008年连载的《美食俘虏》，JUMP虽有意提拔其为台柱，甚至把主角请到《海贼王》中客串，但目前看来依然扶不起。目前连载中算是老油条的《银魂》，也是准备暖身进入最终章了。</p><p>2014年人气漫画，《黑子的篮球》完结。2016年，三台柱中《死神》、《火影忍者》完结，超人气作品《暗杀教室》完结，《食戟之灵》进入新篇章后人气也随之下滑。</p><p>目前，发展看好的有优秀运动向排球漫画《排球少年》，于2014年连载的《我的英雄学院》也一直维持着相当高的人气。</p><p>说了这么多还是希望，海贼王不要烂尾 $$Thanks \\ ShonenJump.$$</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521696877/jum.jpg" width="90%" height="90%">]]></content>
    
    <summary type="html">
    
      关于JUMP少年周刊的一份漫画排行榜。1968年8月6日JUMP少年周刊正式创刊，不是作为日本少年的我们，可能无法对周刊少年JUMP的历史感同身受，但是其中很多作品，一定有自童年或直到现在依然被你喜爱的作品。
    
    </summary>
    
      <category term="漫画兴趣" scheme="http://ulsonhu.cn/categories/%E6%BC%AB%E7%94%BB%E5%85%B4%E8%B6%A3/"/>
    
    
      <category term="JUMP周刊" scheme="http://ulsonhu.cn/tags/JUMP%E5%91%A8%E5%88%8A/"/>
    
      <category term="漫画" scheme="http://ulsonhu.cn/tags/%E6%BC%AB%E7%94%BB/"/>
    
  </entry>
  
  <entry>
    <title>本科计量经济学之回炉重造篇</title>
    <link href="http://ulsonhu.cn/%E6%9C%AC%E7%A7%91%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B9%8B%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%E7%AF%87.html"/>
    <id>http://ulsonhu.cn/本科计量经济学之回炉重造篇.html</id>
    <published>2018-02-21T16:00:00.000Z</published>
    <updated>2018-03-11T04:38:51.612Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于本科的计量经济学课程，主要涉及宏微观、高等数学、线性代数、统计学相关知识。<br>学完我们需要掌握的主要内容包括计量经济学中基本假设及违背基本假设的处理；横截面、面板数据的分析与处理；基础时间序列分析与预测</p><p>参考书籍为</p><ul><li><a href="https://book.douban.com/subject/4717098/" target="_blank" rel="noopener">李子奈.计量经济学</a></li><li><a href="https://book.douban.com/subject/5068097/" target="_blank" rel="noopener">伍德里奇.计量经济学导论</a></li></ul><h2>1 基本假设篇</h2><p>通常在实际研究的计量经济学问题中，完全满足回归的基本假设的情况并不多见。不满足基本假定的情况。称为<strong>违背基本假定</strong>，其情况主要包括:</p><ol><li>随机干扰项存在异方差</li><li>随机干扰项的序列相关（或称自相关）</li><li>解释变量之间的多重共线</li><li>解释变量为随机变量，存在内生性</li></ol><h3>1.1 异方差性</h3><p>线性模型的基本假设中有$Var(\mu|x_1,x_2,\cdots,x_k)=d$，即<strong>随机干扰项的方差不因自变量的不同而不同</strong>。表现在现实的经济生活中，以消费水平受到收入水平的影响为例。$C = b_0 + b_1 * Y + \mu$,对于收入水平Y较低的群众而言，消费情况的变化是比较小的，但是对于收入水平较大的群体而言，其消费水平的变化差异可能就非常大了。用公式表示，即为$var(\mu|x_1,x_2,\cdots,x_k) = f(x_i,d)$</p><h3>1.2 数据异方差性的后果</h3><ol><li>导致参数估计无效，在估计的有效性中，利用了$Ε（\mu '\mu）= d^2I$这条同方差的假设,但是现在d与X是相关的，不能直接拿出来</li><li>参数显著性检验失去意义（显著性检验中，是要用到随机干扰项的误差的，由于异方差性，使用最小二乘法得出来的参数的方差并不是其真实方差了）</li><li>模型预测失效。（模型预测也是要用到随机干扰项的方差的）</li></ol><h3>1.3 检验异方差</h3><ol><li><p><strong>图示检验</strong>（使用Y-X散点图，或者$e^2~X$散点图进行判断，如果呈现一条水平线则是不存在异方差，否则，可能存在），这种方法的问题是：判断并不准确，是否算是水平线还是复杂性的异方差无法判断</p></li><li><p><strong>帕克（Park）检验与戈里瑟检验</strong>。 对样本残差平方$e_i^2$与X之间进行检验。设定模型$e_i^2\sim f(X)+\mu $,如果$e_i^2$与X之间存在显著的相关性，则原模型存在异方差性。<strong>该检验存在的问题</strong>：模型$e_i^2\sim f(X)+\mu $的函数形式和变量选择存在不确定性，而且，该模型本身自己也可能存在异方差性</p></li><li><p><strong>G-Q（Goldfeld-Quandt）检验</strong>:</p></li></ol><ul><li>a.按照某一个被认为可能存在异方差性的变量将样本进行从小到大的排序；</li><li>b.将样本分成两个部分，一个部分自变量大，一个部分自变量小；</li><li>c.对这两个样本分别进行回归，得到各自的残差平方和，在同方差的假设下，这两个残差平方和的大小应当是差异不大的；</li><li>使用上面得出的残差平方和构建F统计量。</li></ul><p><strong>方法的问题</strong>:只能检验单调递增还是单调递减型方差，并且可能需要对各个解释变量进行轮流实验。</p><ol start="4"><li><strong>怀特检验进行辅助回归</strong>：$e_i^2 \sim b_0 + b_1x_1 + b_2x_2 + b_3x_1x_2 + b_4x_1^2 + b_5x_2^2 + \mu $，可以证明，在同方差的假设下，从该辅助回归得到的$R^2$与样本容量的积，渐近服从自由度为辅助回归方程中解释变量个数的卡方分布 $nR^2 \sim \chi^2(k)$ 。WLS加权最小二乘法思想就是将不稳定的方差转换为稳定的方差乘以一个不稳定的函数。通过变换，使得模型变为同方差的情况。</li></ol><p>  假设我们已经知道了随机误差项的方差和自变量之间的关系:$var(\mu_i)=E(\mu_i^2)=d_i^2=f(X_{i,j}) \cdot q^2$(而不是在无异方差的情况下的 $var(\mu |X)=q^2$ )。那么，我们可以使用$\sqrt{f(X_{ij})}$去除以原模型，使得变化后的模型称为无异方差的情况。注：公式中$j$为变量的标号, $i$为样本的标号。 变化后的模型如下：</p><p>$$ Y_i / \sqrt{f(X_{ij})} = b_0 / \sqrt{f(X_{ij})} + b_1x_1 / \sqrt{f(X_{ij})} + \cdots + b_k  x_k / \sqrt{f(X_{ij})} + u_i/\sqrt(f(X_{ij}))$$</p><p>注意到这里，每个变量$X_{ij}$除以的都是其相对应的$f(X_{ij})$. 上面模型，异方差就是不存在的了，便可以用加权后的模型对参数进行估计。现在的问题是，如何对权重$f(x_{ij})$进行估计呢？</p><p>观察可以发现，等式左边可以用样本残差$e_i^2$来代替，等式左边$f(X_{ij})$中有$j$个参数，$q^2$为另一个参数。两边取对数，能够将等式转换为线性模型进行估计。接着就是使用帕克检验的方法，进行各种形式的尝试。从而估计出$f(X_{ij})$的形式 。</p><h3>1.4 异方差稳健标准误法</h3><p><strong>加权最小二乘法</strong>的关键是要寻找模型中随机扰动项$\mu $的方差与解释变量间的适当的函数形式，而这并非一件容易的事。</p><p>如果很难找到的话，可以用异方差的稳健标准误方法，进行替代。 <font color="red">在有异方差的情况下，参数估计仍然是无偏的，但是参数估计的方差和标准差会与传统的有所区别，从而无法保证估计的有效性，但并不影响估计的无偏性和一致性。</font>那么我们仍然采用普通的最小二乘估计量，但是在进行参数检验的时候使用修正后的相应方差。（至于参数的有效性无法满足的问题，并不关注）</p><ol><li>在无异方差下，参数估计的方差为$var(b|X) = d^2 (x’x)^{-1}$，在有异方差下，则为 $var(b) =　(x’x)^{-1}x’D(x’x)^{-1}x’$,这里$D$为$n*1$的向量。使用普通最小二乘法估计的残差平方$e_i^2$形成的向量$e’e$作为向量D的代表。怀特证明了这种做法是对$var(b) =　(x’x)^{-1} * x’ * D * (x’x)^{-1} * x’$的一致估计。</li><li>当存在异方差时，异方差稳健标准误法虽然不能得到有效的参数估计，但是由于得到了普通最小二乘估计量的正确的方差估计，使得以估计量方差为基础的各项检验不再失效，是消除异方差性不良后果的主要手段。</li></ol><h2>2 序列相关性</h2><h3>2.1 序列相关的含义</h3><p>  在经典的线性模型假设中，有<font color="red">随机干扰项独立，即互不相关的假设。</font>这个假设的意思是说，对于造成结果而言，不能由自变量解释到的那部分随机干扰项是独立的。<font color="blue">例如</font>，有两块相邻的水田，其各自产量与施肥量，日照量等有关。但两块水田产量的随机因素之间是不存在关系的，不会因为这块水田随机因素大，那块也大。</p><p>用公式描述，就是：$Cov(\mu _i, \mu _j)=0$， i和j是观测样本。序列相关则意味着样本之间随机因素是具有相关性的，上面例子中，有些无法观测到的对水田产量的因素，例如土壤肥力如果是随机干扰项的话，那么毫无疑问相邻两块土地之间的随机干扰项是具有相关性的。</p><p>通常，由于样本中有$n$个随机干扰项，如果仅存在$E（\mu _i,\mu _{i+1}）\neq 0$，那么称之为一阶自相关，一阶自相关是比较常见的序列相关问题。<font color="blue">例如</font>：一个人的素质可能与他的朋友的素质是相关的，但是与其朋友的朋友的素质之间，相关性就可以忽略了；或者我们可以理解为，一个人素质与其朋友的朋友之间的关系，事实上是通过其朋友来传导的。那么，这样我们就可以将多阶自相关的问题，通过一阶自相关来理解了。</p><p>因此，为了能够便于理解和进行计算，我们通常都进行一阶自相关的研究。我们将一阶自相关用公式表述为：$\mu _i = p*\mu <em>{i+1} + e</em>{i -1}  &lt; p$</p><p>一般经验而言，对于采用时间序列数据作样本的计量经济学问题，由于在不同样本点上解释变量以外的其它因素（随机干扰项）在时间上的连续性，或者说惯性，往往会导致序列相关性。</p><h3>2.2 序列相关性的后果</h3><ol><li><p><strong>参数估计非有效</strong>：在有效性的证明中利用了 $E(uu’) = d^2I$, 但是现在这个条件是无法满足了。所以有效性便不再满足。</p></li><li><p><strong>变量的显著性检验失去意义：</strong>随机干扰项向量的协方差矩阵不再是 $d^2I$，因此原本的参数分布和显著性t检验也不再满足。</p></li><li><p><strong>模型的预测失效：</strong>原因同变量显著性检验失去意义。</p></li></ol><h3>2.3 检验序列相关</h3><ol><li><p><strong>图示法</strong>： 使用OLS的样本残差作为随机干扰项的估计，画出$e_t$和$e_{t-1}$之间的散点图，看二者之间是否存在明显的相关性。该方法存在主观性和不确定性。</p></li><li><p><strong>回归检验法</strong>： 对$e_t$和$e_{t-1}$进行回归检验，看二者之间是否存在显著的关系。</p></li><li><p><strong>DW检验</strong>：构造一个统计量，服从DW分布，然后再使用DW准则进行检验。（用的较少，局限性很大）</p></li><li><p><strong>拉格朗日乘数（LM）检验</strong>：将模型转换为受约束的回归方程即$Y_i=b_0+b_1*x_{i1}+b_2*x_{i2}+\cdots+b_k*x_{ik}+p_1*u_{i-1}+p_2*u_{i-2}+\cdots+p_k*u_{i-k}+e_k$。检验约束条件$H_0：p_1=p_2=\cdots =p_k=0$(k可以自行决定)，再使用检验模型约束条件的LM统计量检验该约束条件即可。</p></li></ol><h3>2.4 如何补救序列相关</h3><p>补救序列相关与补救异方差一样,存在两种思路:</p><ul><li>一就是变换原模型为不存在序列相关的模型,再用OLS来进行估计,即为广义最小二乘法(GLS)和广义差分法（GDM）;</li><li>另一条途径是仍然采用OLS的估计参数，但是对参数估计量的方差或者标准差进行修正。</li></ul><h4>2.4.1 广义最小二乘法</h4><p>  广义最小二乘，是具有普遍意义的最小二乘，普通最小二乘和加权最小二乘是它的特例。<font color="red">广义最小二乘是不需要同方差性和无序列相关的假设的。</font>它将随机变量的协方差矩阵不再表示为 $d^2I$这样的形式， 而是用$cov(u,u’) = p^2 * W$来表示。其中 $W = DD’$.进一步的，变换模型为 $D^{-1}*Y = D^{-1} * X_b + D^{-1}*u$, 该模型便不再有异方差和序列相关，可以对其使用OLS进行估计。（李子奈《计量经济学》pp.127）</p><p>  广义最小二乘法真正的难题是如何去估计协方差矩阵$W$，在序列自相关的情况下，若只有$n$个样本点，要对$\frac{n*(n-1)}{2} + k +2$ 个参数进行估计是几乎不可能的。因此，只能是说对随机干扰项自相关的结构事先给出必要的假设。一般而言，我们假设随机干扰项是一阶自相关的：即$\mu _t = p\mu _{t-1} + e$，对该模型进行估计，便可以得到协方差矩阵W以及权重矩阵D 。</p><h4>2.4.2 广义差分法</h4><p>  广义差分法实质上就是广义最小二乘法，不过是损失了部分样本观测值，具体可见《计量经济学》（李子奈）pp.129。</p><p>随机干扰项相关系数的估计：无论是使用广义最小二乘法还是广义差分法，都需要知道不同样本点之间随机干扰项的相关系数$r_1,r_2\cdots r_p$等，必须对其进行估计，即对$u_t = r_1 * u_{t-1} + r_2 * u_{t-2} + …+ r_p * u_{t-p} + e_t$进行估计。但是事实上$\mu <em>{t}$是无法观测到的，我们只能使用$e</em>{t}$来对其进行近似的估计。</p><p>具体方法为，先使用OLS对原始模型进行估计，对$e_{t},e_{t-1}\cdots e_{t-p}$之间进行线性估计得出随机干扰项的相关系数。再将其带入到广义差分法或者广义最小二乘法中，得到新的$e_{t},e_{t-1}\cdots e_{t-p}$,再次进行估计，得出他们的相关系数，重复上述步骤，直到$e_{t},e_{t-1}\cdots e_{t-p}$的值趋于稳定。我们称该方法为<strong>科克伦-奥科特（Cochrane-Orcutt）迭代法</strong>。</p><p><strong>序列相关稳健标准误法</strong>存在序列相关时，OLS估计的无偏性和一致性仍然是有的，但是有效性无法保证，因此，我们可以对随机干扰项的协方差进行修正，在进行显著性检验时使用改修正的稳健标准误。具体公式过于冗长，可参考《计量经济学》（李子奈）pp.130</p><h3>2.5 虚假序列相关问题</h3><p>  若模型设定中遗漏了重要的解释变量，从而导致了序列相关的出现，我们称之为<strong>虚假序列相关</strong>。我们在处理序列相关问题时，应当要将虚假序列相关的可能性先排除掉，即排除掉遗漏变量的可能。如何避免出现模型设定的偏误问题呢？那就是在开始时建立一个“一般”的模型，然后逐渐剔除缺失不显著的变量。</p><h2>3 多重共线性</h2><p>共线性是指自变量之间存在较大的相关性，导致$|X’X| \neq 0$，从而$(X’X)^{-1}$对角线上的元素较大，随机干扰项的协方差矩阵$d^2(X’X)^{-1}$对角线上的元素也较大，导致一系列的不良后果。主要包括：</p><ol><li>完全共线性下，估计量不存在，完全共线性下$|X’X|=0$，$X’X$没有逆，OLS没法得出参数估计量。</li><li>普通最小二乘法方差变大，导致通过样本计算出来的t值比较小$(X’X）^{-1}$在t统计量的分母中，导致t统计量较小），由于样本本身的共线性问题，导致了t检验的不可靠。同时，也会使得因变量区间预测的“区间”变大，使得预测失去意义，模型不能进行外推。</li><li>参数估计量的经济含义不合理。若$X_1，X_2$之间存在共线性，那么二者其中一个可以由另一个表征出来。他们各自的参数估计量不再代表本身的经济意义，而是代表二者对被解释变量的共同影响。<strong>经验告诉我们，在多元线性回归模型的估计中，如果出现了参数估计值的经济意义明显不合理的情况，应该首先怀疑是否存在多重共线性</strong>。</li></ol><h3>3.1 造成多重共线性的原因</h3><ol><li>经济变量相关的共同趋势。这在时间序列样本中情况比较多。</li><li>滞后变量的引入。例如,居民消费$C$受到总收入以及前期的消费$C_{t-1}$的影响，但是毫无疑问的，前期的消费$C_{t-1}$会影响到当期的收入$Y_{t}$。所以模型中毫无疑问会出现共线性的问题。在这样一种情况下，$Y_{t}$的参数$b_{1}$就不再代表收入对消费的影响了，而是$Y_{t}$与$C_{t-1}$对$C_{t}$的共同影响，二者的参数经济意义不明了。所以可能会出现不合常理的参数估计值。</li><li>样本资料的限制。由于社会科学采用的数据是“社会实验”得出，而并非是控制实验得出，所以自变量样本是不受控制的，某些变量之间可能总是会存在一些共线性。例如时间序列样本就算是这种情况。</li></ol><h3>3.2 多重共线性的检验</h3><p><strong>对两个解释变量</strong>：可以通过解释变量的样本协方差矩阵，发现解释变量之间的两两相关性，对于相关性非常高的两个解释变量，可能存在共线性的问题。</p><p><strong>对多个解释变量之间的相关性</strong>：所谓多个解释变量相关就是如$x_1 = x_2 + x_3 + x_4$这种。使用综合统计检验，如果在OLS下，模型的$R^2$与$F$值较大，但是各参数检验的$t$值较小，说明各解释变量对$Y$的联合线性作用显著。但从较小的$t$值，我们可以估计到，可能存在共线性，从而使得解释变量对$Y$的独立作用不能分辨，故$t$检验不显著。</p><h3>3.3 判别多重共线性的范围</h3><p>知道模型有多重共线性，进一步的，我们希望能够将引起多重共线性的变量找出来，以进一步地对模型进行调整。</p><p>具体的方法有判定系数检验法和逐步回归法。</p><ol><li><p>判定系数检验法：使模型中每个解释变量分别以其余解释变量为解释变量进行回归计算,即 $X_{i} \sim x_{1} + x_{2}+\cdots +x_{i-1} + x_{i+1}+\cdots +x_{k}$。如果发现该模型的判定系数$R^2$较大，则说明该解释变量$x_{i}$能够用其它解释变量表征出来。至于如何判定$R^2$是否足够大，我们可以做$F$检验。</p></li><li><p>逐步回归法：</p></li></ol><ul><li>先做$Y$与各$X_i$分别一元线性回归，找出$R^2$最大的那个$X_i$，以该一元线性回归为基础；</li><li>逐个引入解释变量，观察拟合优度（修正后的拟合优度）的变化（也可以使用AIC准侧），如果拟合优度变化显著，则说明该变量是一个独立解释变量，如果拟合优度变化不显著，说明该解释变量可以用其它变量的线性组合替代，也就是说它与其它变量之间存在共线性关系。</li></ul><h3>3.4 克服多重共线性的办法</h3><ol><li><p><strong>排除引起共线性的变量</strong>：这种方法可能存在的问题是，某变量本来是应当存在于模型当中的，只是由于样本的问题，使得该变量显示出共线性。剔除掉该变量将会导致回归模型在进行预测时的准确性下降。如果换一组样本，可能共线性的情况就不再存在了。因此，是否真的应当剔除掉变量应当还要进行实际经济模型或者实际意义进行考虑。如果某个变量是具有非常明显的经济意义的，那么即使该变量存在共线性，也不能轻易剔除掉。</p></li><li><p><strong>差分法</strong>：常用于时间序列数据中，使用自变量和因变量的增量作为回归的变量。这是由于变量增量的相关性毫无疑问肯定是要比变量本身的相关性弱的。</p></li><li><p><strong>岭回归与LASSO</strong>：可参见<a href="http://www.cnblogs.com/pingzeng/p/5040911.html" target="_blank" rel="noopener">多重共线性的解决方法之——岭回归与LASSO</a></p></li></ol><h2>4 随机解释变量问题 （内生性问题）</h2><p>  计量经济假设中，我们是假设自变量是确定变量，是非随机的。<s>所谓是确定变量，我们可以用科学实验中的对照实验来进行说明，<font color="blue">例如</font>：判断不同的水分条件对粮食产量的影响时，我们将控制其它对产量有影响的变量，如光照，土壤，种子等，仅仅使得水分条件不一样，进而判断水分条件对产量的影响。在这种实验中，水分是可以进行人为控制的确定变量，我们称这种实验为“对照实验”。</s></p><p><s>然而，由于伦理和实际操作上的种种不可行，经济学家是不可能拿整个社会来做实验的。例如不能故意控制某个地方的公共投资高，另一个地方的公共投资低，从而判断政府公共投资对收入的影响。经济学家只能使用既有的现实社会运行数据，通过判断不同公共投资地区的GDP的不同来判断公共投资的影响，经济学家称这种为“自然实验”。 但是，事实上，公共投资却并不是完全的确定性的，它并不是政府主动控制想投入多少就投入多少，其大小毫无疑问是受到地方财政收入的约束的。从这个角度上来说，也就是GDP越高的地方，毫无疑问也就能够投入越多的公共投资。</s></p><p><s><font color="red">那么公共投资与GDP的因果关系就变得非常复杂了，到底公共投资是因？还是GDP是因呢？我们称这种情况为随机解释变量问题：即解释变量无法控制，是具有随机性的。</font></s></p><p>  随机解释变量问题可以分为3种不同的情况：</p><ol><li>随机解释变量$X_i$与随机干扰项$\mu $独立： $cov(X_{i},\mu ) = E(X_{i}\mu )= E(X_{i})*E(\mu )=0$，这种情况，随机解释变量问题对模型的估计不会产生影响。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期无关但是异期相关： $cov(X_{i}, \mu _{i-s}) \neq 0$，这种情况，得到的参数估计量是有偏的，但是却是一致的（可以从OLS估计量的形式中推出来）。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期先关：这种情况得到的参数估计量有偏且非一致。</li></ol><h3>4.1 引起内生性问题的通常理由</h3><ol><li>经济模型中因变量滞后项的引用，通常会造成随机解释变量异期相关。</li><li>存在互为因果的模型，例如上文所述公共投资与GDP。</li></ol><h3>4.2 随机解释变量的解决方法</h3><h4>4.2.1 工具变量</h4><p>工具变量是指该变量与随机解释变量之间存在较高的相关性，而且对随机解释变量的解释能力也非常高（$R^2$比较大），但是该解释变量与模型的随机干扰项不相关，与被解释变量也不相关。即满足：</p><ul><li>工具变量必须外生，即$Cov(z,\mu )=0$。</li><li>工具变量必须与内生变量$x$相关，即$Cov(z,x) \neq 0$。</li></ul><h4>4.2.2 工具变量的估计</h4><p>应该根据常识及经济理论判断$Cov(z,\mu )$是否合理。</p><p>我们可以检验$Cov(z,x )\neq 0$是否成立,即检验在$H_0:\pi_1 = 0$在$x=\pi_0+\pi_1 z+v$,这称作第一阶段回归</p><p>假设简单回归情形$y=\beta_0+\beta_1 x+\mu$，并给定我们假设$Cov(z,y)=\beta_1 Cov(z,x)+Cov(z,\mu )$</p><p>于是解出$\beta_1=\frac{Cov(z,x)}{Cov(z,x)}$，得到$\beta_1$估计量$$\hat{\beta_1}=\frac{\sum_{i=1}^n(z_i-z)(y_i - \bar{y})}{\sum_{i=1}^n(z_i-\bar{z})(x_i - x)}$$</p><p>为了进行推断，我们需要计算统计量和置信区间的标准误。通常的方法是增加一个同方差假设</p><p>$E(\frac{\mu^2}{z})=\sigma2=Var(\mu )$得出，$$Var(\hat{\beta_1})=\frac{\sigma^2}{n\sigma_x^2 \rho_{x,z}^2} \\ se(\hat{\beta_1})=\frac{\hat{\sigma}^2}{ SST_{x}R_{x,z}^2}$$</p><blockquote><p>未完待续 loading…</p></blockquote>]]></content>
    
    <summary type="html">
    
      这篇博文是很久之前总结的，最近正好需要复习计量经济学相关知识，所以把原来的这篇文章回炉重造一番，做一点补充完善工作。
    
    </summary>
    
      <category term="经济学" scheme="http://ulsonhu.cn/categories/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
    
      <category term="数量经济学" scheme="http://ulsonhu.cn/tags/%E6%95%B0%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
      <category term="经济学" scheme="http://ulsonhu.cn/tags/%E7%BB%8F%E6%B5%8E%E5%AD%A6/"/>
    
  </entry>
  
  <entry>
    <title>网站迁移(hexo)</title>
    <link href="http://ulsonhu.cn/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB-hexo.html"/>
    <id>http://ulsonhu.cn/网站迁移-hexo.html</id>
    <published>2018-02-19T16:00:00.000Z</published>
    <updated>2018-03-11T04:38:44.562Z</updated>
    
    <content type="html"><![CDATA[<p>由于wordpress访问速度太慢，懒得折腾XD，把一些博客文章迁移到新博客上。目前使用Github Page + Hexo的方案比较流行，留作日常记录。</p><div align="center">The end</div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;由于wordpress访问速度太慢，懒得折腾XD，把一些博客文章迁移到新博客上。目前使用Github Page + Hexo的方案比较流行，留作日常记录。&lt;/p&gt;
&lt;div align=&quot;center&quot;&gt;The end&lt;/div&gt;

      
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="hexo" scheme="http://ulsonhu.cn/tags/hexo/"/>
    
  </entry>
  
  <entry>
    <title>2017年(Lunar Year)读书与看剧</title>
    <link href="http://ulsonhu.cn/Lunar_Year.html"/>
    <id>http://ulsonhu.cn/Lunar_Year.html</id>
    <published>2018-02-14T16:00:00.000Z</published>
    <updated>2018-03-11T04:40:03.247Z</updated>
    
    <content type="html"><![CDATA[<a id="more"></a><h3>读书（文学类）</h3><ul><li>加缪. 《鼠疫》</li><li>朱光潜.《西方美学史》 <em>读的慢，忘的快</em></li><li>乔治·奥威尔. 《1984》</li><li>乔治·奥威尔. 《动物农庄》</li><li>艾玛·拉金《在缅甸寻找乔治·奥威尔》</li><li>凯鲁亚克. 《在路上》</li><li>白先勇 《台北人》</li><li>尤瓦尔·赫拉利 《人类简史:从动物到上帝》</li><li>尤瓦尔, 赫拉利. 《未来简史》</li><li>斯蒂芬·茨威格. 《人类群星闪耀时》</li><li>尼古拉斯·斯帕克思. 《分手信》</li><li>卡勒德·胡赛尼. 《群山回唱》</li><li>费孝通. 《乡土中国》</li></ul><h3>读书（自我提高及工具书）</h3><ul><li>李忠秋. 《结构思考力》</li><li>尼尔·布朗《学会提问》</li><li>布鲁克·诺埃尔·摩尔《批判性思维》</li><li>读自我提高类书籍本意在于提升自身逻辑思考能力，上面几本书能够很好的达到目的。</li><li>Johnson. 实用多元统计分析.</li><li>RobertV.Hogg. 数理统计学导论</li><li>张维迎. 博弈论与信息经济学</li><li>Nasrabadi, Nasser M. “Pattern recognition and machine learning.”</li></ul><h3>看剧</h3><ul><li>《怦然心动》- 纯爱类影片，学会从整体审视生活</li><li>《时空恋旅人》 - 看完觉得幸福了一辈子</li><li>《饮食男女》 - 人之大欲，不过饮食男女</li><li>《闻香识女人》 - 善良、正直，是走得多远都不能丢弃的道德品质</li><li>《海边的曼彻斯特》 - 每个人都是一座孤独的岛</li><li>《东京爱情故事》 - 爱情是个很难说的事儿吧，thank you，赤名莉香</li><li>《白色巨塔》- 过程正义与结果正义</li><li>《NANA》 - 主题曲很好听</li><li>《熔炉》 - 不想评论，谢谢</li><li>《聚焦》 - 同上</li><li>《两杆大烟枪》 - 同《低俗小说》《疯狂的石头》，贵在叙事方式</li><li>《傲慢与偏见》、《罗马假日》、《南丁格尔》、《乱世佳人》还说什么，都是经典，无论看几遍，都能品出味道来.</li></ul><div align="center">和子由渑池怀旧 .苏轼<br>人生到处知何似，应似飞鸿踏雪泥。<br>泥上偶然留指爪，鸿飞那复计东西。<br>老僧已死成新塔，坏壁无由见旧题。<br>往日崎岖还知否，路长人困蹇驴嘶。<br></div>]]></content>
    
    <summary type="html">
    
      一个人不总是能让自己的工作有意义，或者同人类的伟大征程发生本质联系。创造出新东西是困难的，命运可能既没有提供资源和天分，也没有提供位置和环境。但反求诸己是可能的，去动手，去克服自己的积习，改造自己的反射，克服不断分泌的多巴胺的诱惑，意识到平庸并不等于无聊和自鸣得意，付出努力去获取知识，获取灵活的身体，理解自己在这个快速变动的世界上的角色，不是为了忍耐，而是为了找到自己的叙事
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="文字" scheme="http://ulsonhu.cn/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>MacOS下使用python的多版本方案</title>
    <link href="http://ulsonhu.cn/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html"/>
    <id>http://ulsonhu.cn/MacOS下使用python的多版本方案.html</id>
    <published>2017-12-31T16:00:00.000Z</published>
    <updated>2018-03-11T04:40:02.559Z</updated>
    
    <content type="html"><![CDATA[<h2>背景</h2><p>MacOS系统本身自带python，但是版本仍然停留在python2.7。私以为python2与python3语言差别比较大，python3额外一些新特性如**“通配符**，字典可排序，统一的Unicode编码”**等，都值得去尝试。为此，保证电脑上两个版本都能共存是很必要的。</p><h2>方案一：使用pyenv兼容多版本</h2><p>pyenv 是轻量的Python版本管理器，帮助你在电脑上建立多个版本的python环境，并提供方便的切换方法。pyenv-virtualenv 是 pyenv的扩展工具（类Unix系统上），可以搭建虚拟且独立的python环境，可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。</p><h3>1. 使用Mac OSX的 Homebrew 安装</h3><p>Homebrew作为OS X上强大的包管理器，为系统软件提供了非常方便的安装方式，独特式的解决了包的依赖问题，并不再需要烦人的sudo，一键式编译，无参数困扰，安装Homebrew：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>安装完成后，根据提示将如下语句加入到 <code>～/.bash_profile</code> 或<code>~/.bashrc</code> 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot; # 这句可以不加</span><br></pre></td></tr></table></figure><h3>2. pyenv 常用命令</h3><p>使用 <code>pyenv commands</code> 显示所有可用命令</p><h4>python 安装与卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv install 2.7.3   # 安装python</span><br><span class="line">~$ pyenv uninstall 2.7.3 # 卸载python</span><br></pre></td></tr></table></figure><h4>python切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv global 2.7.3  # 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span><br><span class="line">~$ pyenv local 2.7.3 # 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</span><br></pre></td></tr></table></figure><h4>python优先级</h4><p><strong>shell &gt; local &gt; global</strong></p><p>pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv shell <span class="number">2.7</span><span class="number">.3</span> <span class="comment"># 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。</span></span><br><span class="line"><span class="comment"># 这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。</span></span><br><span class="line">~$ pyenv shell --unset</span><br><span class="line">~$ pyenv rehash  <span class="comment"># 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</span></span><br></pre></td></tr></table></figure><h2>方案二：使用Anaconda包管理多版本python</h2><p>Anaconda 是 Python 的一个发行版，如果把 Python 比作 Linux，那么 Anancoda 就是 CentOS 或者 Ubuntu。它解决了Python开发者的两大痛点。</p><ul><li>提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。</li><li>提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题。###1. 下载 Anaconda直接在官网下载最新版本的 <a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">https://www.continuum.io/downloads</a> 安装包， 选择对应Python版本的安装包，下载完成后直接安装，安装过程选择默认配置即可，大约需要1.8G的磁盘空间。</li></ul><p>conda 是 Anaconda 下用于包管理和环境管理的命令行工具，是 pip 和 vitualenv 的组合。安装成功后 conda 会默认加入到环境变量中，因此可直接在命令行窗口运行 <code>conda</code> 命令，命令帮助可通过<code>conda -h</code>查看。如果你熟悉 virtualenv，那么上手 conda 非常容易，不熟悉 virtulenv 的也没关系，它提供的命令就几个，非常简单。我们可以利用 conda 的虚拟环境管理功能在 Python2 和 Python3 之间自由切换。</p><h3>2. 多版本切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 基于 python2.7 创建一个名为py2_env 的环境</span><br><span class="line">conda create --name py2_env python=2.7</span><br><span class="line"></span><br><span class="line"># 基于 python3.6 创建一个名为py3_env 的环境</span><br><span class="line">conda create --name py3_env python=3.6 </span><br><span class="line"></span><br><span class="line"># 激活python环境</span><br><span class="line">activate py3_env  # windows</span><br><span class="line">source activate py3_env # linux/mac</span><br><span class="line"></span><br><span class="line"># 切换到python3</span><br><span class="line">activate py3_env</span><br></pre></td></tr></table></figure><h3>3. 包管理</h3><p>conda 的包管理功能是对 pip 的一种补充，如果当前已经激活了某个Python环境，那么就可以在当前环境开始安装第三方包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装 numpy </span><br><span class="line">conda install numpy</span><br><span class="line"># 查看已安装的包</span><br><span class="line">conda list </span><br><span class="line"># 包更新</span><br><span class="line">conda update numpy</span><br><span class="line"># 删除包</span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      解决Python 2.x与Python 3.x版本共存的方案
    
    </summary>
    
      <category term="机器学习相关" scheme="http://ulsonhu.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Mac" scheme="http://ulsonhu.cn/tags/Mac/"/>
    
      <category term="Python" scheme="http://ulsonhu.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Python字符串处理拾掇</title>
    <link href="http://ulsonhu.cn/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%8B%BE%E6%8E%87.html"/>
    <id>http://ulsonhu.cn/Python字符串处理拾掇.html</id>
    <published>2017-04-19T16:00:00.000Z</published>
    <updated>2018-03-11T04:40:01.145Z</updated>
    
    <content type="html"><![CDATA[<p>Python 字符串操作（string替换、删除、截取、复制、连接、比较、查找、包含、大小写转换）</p><p>一、去空格及特殊符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.strip().lstrip().rstrip(<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p>二、复制字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strcpy(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strcpy'</span></span><br><span class="line">sStr2 = sStr1</span><br><span class="line">sStr1 = <span class="string">'strcpy2'</span></span><br><span class="line">print(sStr2)</span><br></pre></td></tr></table></figure><p>三、连接字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strcat(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strcat'</span></span><br><span class="line">sStr2 = <span class="string">'append'</span></span><br><span class="line">sStr1 += sStr2</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>四、查找字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strchr(sStr1,sStr2)</span></span><br><span class="line"><span class="comment"># &lt; 0 为未找到</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'s'</span></span><br><span class="line">nPos = sStr1.index(sStr2)</span><br><span class="line">print(nPos)</span><br></pre></td></tr></table></figure><p>五、比较字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strcmp(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'strch'</span></span><br><span class="line">print(cmp(sStr1,sStr2))</span><br></pre></td></tr></table></figure><p>六、扫描字符串是否包含指定的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strspn(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'12345678'</span></span><br><span class="line">sStr2 = <span class="string">'456'</span></span><br><span class="line"><span class="comment">#sStr1 and chars both in sStr1 and sStr2</span></span><br><span class="line">print(len(sStr1 <span class="keyword">and</span> sStr2))</span><br></pre></td></tr></table></figure><p>七、字符串长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlen(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'strlen'</span></span><br><span class="line">print(len(sStr1))</span><br></pre></td></tr></table></figure><p>八、将字符串中的大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlwr(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'JCstrlwr'</span></span><br><span class="line">sStr1 = sStr1.upper()</span><br><span class="line"><span class="comment">#sStr1 = sStr1.lower()</span></span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>九、追加指定长度的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncat(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">sStr2 = <span class="string">'abcdef'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 += sStr2[<span class="number">0</span>:n]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十、字符串指定长度比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncmp(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">sStr2 = <span class="string">'123bc'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">print( cmp(sStr1[<span class="number">0</span>:n],sStr2[<span class="number">0</span>:n]))</span><br></pre></td></tr></table></figure><p>十一、复制指定长度的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncpy(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">''</span></span><br><span class="line">sStr2 = <span class="string">'12345'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 = sStr2[<span class="number">0</span>:n]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十二、将字符串前n个字符替换为指定的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strnset(sStr1,ch,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">ch = <span class="string">'r'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 = n * ch + sStr1[<span class="number">3</span>:]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十三、扫描字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strpbrk(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'cekjgdklab'</span></span><br><span class="line">sStr2 = <span class="string">'gka'</span></span><br><span class="line">nPos = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> sStr1:</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">in</span> sStr2:</span><br><span class="line">        nPos = sStr1.index(c)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print( nPos)</span><br></pre></td></tr></table></figure><p>十四、翻转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strrev(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr1 = sStr1[::<span class="number">-1</span>]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十五、查找字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strstr(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr2 = <span class="string">'cde'</span></span><br><span class="line">print(sStr1.find(sStr2))</span><br></pre></td></tr></table></figure><p>十六、分割字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strtok(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">sStr2 = <span class="string">','</span></span><br><span class="line">sStr1 = sStr1[sStr1.find(sStr2) + <span class="number">1</span>:]</span><br><span class="line">print(sStr1)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">s = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">print(s.split(<span class="string">','</span>))</span><br></pre></td></tr></table></figure><p>十七、连接字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter = <span class="string">','</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line">print(delimiter.join(mylist))</span><br><span class="line">PHP 中 addslashes 的实现</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addslashes</span><span class="params">(s)</span>:</span></span><br><span class="line">    d = &#123;<span class="string">'"'</span>:<span class="string">'\\"'</span>, <span class="string">"'"</span>:<span class="string">"\\'"</span>, <span class="string">"\0"</span>:<span class="string">"\\\0"</span>, <span class="string">"\\"</span>:<span class="string">"\\\\"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s) </span><br><span class="line">s = <span class="string">"John 'Johny' Doe (a.k.a. \"Super Joe\")\\\0"</span></span><br><span class="line">print(s)</span><br><span class="line">print( addslashes(s))</span><br></pre></td></tr></table></figure><p>十八、只显示字母与数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnlyCharNum</span><span class="params">(s,oth=<span class="string">''</span>)</span>:</span></span><br><span class="line">    s2 = s.lower();</span><br><span class="line">    fomart = <span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">in</span> fomart:</span><br><span class="line">            s = s.replace(c,<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line">print(OnlyStr(<span class="string">"a000 aa-b"</span>))</span><br></pre></td></tr></table></figure><p>十九、截取字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str = ’<span class="number">0123456789</span>′</span><br><span class="line"><span class="keyword">print</span> str[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#截取第一位到第三位的字符</span></span><br><span class="line"><span class="keyword">print</span> str[:] <span class="comment">#截取字符串的全部字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">6</span>:] <span class="comment">#截取第七个字符到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-3</span>] <span class="comment">#截取从头开始到倒数第三个字符之前</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>] <span class="comment">#截取第三个字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-1</span>] <span class="comment">#截取倒数第一个字符</span></span><br><span class="line"><span class="keyword">print</span> str[::<span class="number">-1</span>] <span class="comment">#创造一个与原字符串顺序相反的字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment">#截取倒数第三位与倒数第一位之前的字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:] <span class="comment">#截取倒数第三位到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取，具体啥意思没搞明白？</span></span><br></pre></td></tr></table></figure><p>二十、直接贴过来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"Hello My friend"</span></span><br><span class="line"><span class="comment"># 字符串是一个整体。如果你想直接修改字符串的某一部分，是不可能的。</span></span><br><span class="line"><span class="comment"># 但我们能够读出字符串的某一部分。</span></span><br><span class="line"><span class="comment"># 子字符串的提取</span></span><br><span class="line">str[:<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 字符串包含判断操作符：in，not in</span></span><br><span class="line"><span class="string">"He"</span> <span class="keyword">in</span> str</span><br><span class="line"><span class="string">"she"</span> <span class="keyword">not</span> <span class="keyword">in</span> str</span><br><span class="line"></span><br><span class="line"><span class="comment"># string模块，还提供了很多方法，如</span></span><br><span class="line">S.find(substring, [start [,end]]) <span class="comment">#可指范围查找子串，返回索引值，否则返回-1</span></span><br><span class="line">S.rfind(substring,[start [,end]]) <span class="comment">#反向查找</span></span><br><span class="line">S.index(substring,[start [,end]]) <span class="comment">#同find，只是找不到产生ValueError异常</span></span><br><span class="line">S.rindex(substring,[start [,end]])<span class="comment">#同上反向查找</span></span><br><span class="line">S.count(substring,[start [,end]]) <span class="comment">#返回找到子串的个数</span></span><br><span class="line"></span><br><span class="line">S.lowercase()</span><br><span class="line">S.capitalize()      <span class="comment">#首字母大写</span></span><br><span class="line">S.lower()           <span class="comment">#转小写</span></span><br><span class="line">S.upper()           <span class="comment">#转大写</span></span><br><span class="line">S.swapcase()        <span class="comment">#大小写互换</span></span><br><span class="line"></span><br><span class="line">S.split(str, <span class="string">' '</span>)   <span class="comment">#将string转list，以空格切分</span></span><br><span class="line">S.join(list, <span class="string">' '</span>)   <span class="comment">#将list转string，以空格连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理字符串的内置函数</span></span><br><span class="line">len(str)                <span class="comment">#串长度</span></span><br><span class="line">cmp(<span class="string">"my friend"</span>, str)   <span class="comment">#字符串比较。第一个大，返回1</span></span><br><span class="line">max(<span class="string">'abcxyz'</span>)           <span class="comment">#寻找字符串中最大的字符</span></span><br><span class="line">min(<span class="string">'abcxyz'</span>)           <span class="comment">#寻找字符串中最小的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># string的转换</span></span><br><span class="line">            </span><br><span class="line">float(str) <span class="comment">#变成浮点数，float("1e-1")  结果为0.1</span></span><br><span class="line">int(str)        <span class="comment">#变成整型，  int("12")  结果为12</span></span><br><span class="line">int(str,base)   <span class="comment">#变成base进制整型数，int("11",2) 结果为2</span></span><br><span class="line">long(str)       <span class="comment">#变成长整型，</span></span><br><span class="line">long(str,base)  <span class="comment">#变成base进制长整型，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的格式化（注意其转义字符，大多如C语言的，略）</span></span><br><span class="line">str_format % (参数列表) <span class="comment">#参数列表是以tuple的形式定义的，即不可运行中改变</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> <span class="string">""</span>%s<span class="string">'s height is %dcm" % ("My brother", 180)</span></span><br><span class="line"><span class="string">          #结果显示为 My brother'</span>s height <span class="keyword">is</span> <span class="number">180</span>cm</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      python中有些常用的字符串处理函数,特别是用python处理自然语言时，字符串处理用的十分频繁。下面总结一下常用的字符串处理的相关函数：
    
    </summary>
    
      <category term="机器学习相关" scheme="http://ulsonhu.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Python" scheme="http://ulsonhu.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>写在大三下学期</title>
    <link href="http://ulsonhu.cn/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%B8%89%E4%B8%8B%E5%AD%A6%E6%9C%9F.html"/>
    <id>http://ulsonhu.cn/写在大三下学期.html</id>
    <published>2017-03-22T05:20:09.000Z</published>
    <updated>2018-03-11T04:38:52.339Z</updated>
    
    <content type="html"><![CDATA[<p>  大学时光经不起回味，一眨眼的时间，大学生生活已经步入尾声，随之而来的就该是毕业季的伤感了。步入大三的同学们，都在为步入”社会“摩拳擦掌，该考研的考研，该工作的工作。即使是平时班上最不爱学习的，也时不时开始向人打听起公务员考试的相关事宜了 :blush: :blush:</p><a id="more"></a><h2>时代的浪潮已经拍到了我们这代人的脚下</h2><p>  每每看到知乎上“大三了，考研还来得及吗？”，“大三了，学计算机还来得及吗？”诸如此类的问题，总也庆幸自己两年多的时间做了一些事读了一些书，但我知道自己做的还远远远远不够看。大三的生活，伴着毕业的步伐，来的匆匆。自己的学年论文加上向老师申请的论文，学的懵懂的专业课，还得挤出时间来为考研蓄力，冷不丁还夹带点感情的纠结。Flag ～</p><p>时光总是匆匆的催人老，情爱总是让人烦恼。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=394467&auto=0&height=66"></iframe><h2>写博客的初衷</h2><p>  大脑的存储空间是有限的，为了让新知识进来，你就得把暂时用不上旧知识遗忘掉。但是，自己当时花了那么多宝贵时间，一步一步摸索着过来所接触到的总结过的知识点，就这样被遗忘，或者被藏在某本笔记本的角落是在太可惜。当你怀着一颗热忱的心去进入一个领域，你只有从宏观上清楚了行业整体，从微观上把握住各个知识点原理，才算得上入门选手。</p><p>  为此，记录下来并且可查可复习非常重要，这也就是Blog能为我提供的。</p><p><em>性格决定你做怎样的选择，你的选择决定你怎样的人生。生命只有一次，而且它正在以不可逆转的姿态向前推进。你可以去旅行，可以朝九晚五地上班，还可以不顾一切地去创业。只是，千万不要选择平庸的人生。</em></p><blockquote><p>黄色的树林里分出两条路，可惜我不能同时去涉足，我在那路口久久伫立，我向着一条路极目望去，直到它消失在丛林深处。</p></blockquote><blockquote><p>但我选了另外一条路，它荒草萋萋，十分幽寂，显得更诱人，更美丽；虽然在这条小路上，很少留下旅人的足迹。</p></blockquote><blockquote><p>那天清晨落叶满地，两条路都未经脚印污染。啊，留下一条路等改日再见！但我知道路径延绵无尽头，恐怕我难以再回返。</p></blockquote><blockquote><p>也许多少年后在某个地方，我将轻声叹息将往事回顾：一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。——罗伯特·弗罗斯特《未选择的路》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;  大学时光经不起回味，一眨眼的时间，大学生生活已经步入尾声，随之而来的就该是毕业季的伤感了。步入大三的同学们，都在为步入”社会“摩拳擦掌，该考研的考研，该工作的工作。即使是平时班上最不爱学习的，也时不时开始向人打听起公务员考试的相关事宜了 :blush: :blush:&lt;/p&gt;
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="文字" scheme="http://ulsonhu.cn/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>「如何高效的学习」读书笔记</title>
    <link href="http://ulsonhu.cn/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0.html"/>
    <id>http://ulsonhu.cn/如何高效学习.html</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2018-03-11T04:38:58.626Z</updated>
    
    <content type="html"><![CDATA[<p>《如何高效学习》从学习的战略上指导学习知识的策略抛出整体性学习的概念，以及结构、模型、高速公路的观点;详细分析了学习的顺序和信息的分类。以战术的方式分解学习的各种战术，如快速阅读、笔记流、比喻法、内在化、联想法、图表法、挂钩法、信息压缩、知识应用、模型纠错等。下面是我阅读时写下的感想，比较少的书摘。</p><a id="more"></a><h3>1. 类比</h3><p>首先，类比是一个推理方法。<br>其次，类比是把两个具有相似或者相同特征的对象进行推理它们具有其他相似或相同特征的方法。</p><h3>2. 概括</h3><p>   读书，将核心用词语总结概括，是最好的学习习惯，只有这样，知识才真正理解，被你加工，通过联想、概括出自己的观点和想法，知识才被刚刚固化，为了知识更加牢固，还需要将知识进行实践运用，知识最好的实践方式就是传播，传播有时候会收到很多不同意见。相互碰撞，如果你能简单轻松的让他们理解并认可你的观点，说明你基本吃透这个知识点。他们当中的不同声音会让你更加容易固化你的知识点，尝试让他们也信服你如果你是正确的。</p><h3>3. 知识纵向拓展</h3><p>   知识纵向拓展，寻根究底。如学习企业管理知识，企业管理包含了财务、人事等管理，那么财务管理是怎样的，人事管理又是怎样的?再深入财务和人事管理里面的各种细节。结合自己所在公司，思考为什么要这样管理，自己公司是这样管理的吗?别人公司是怎样管理的，自己公司和别的公司管理上有什么差别，如何改进?这就是深度拓展，不断深挖细节。</p><h3>4. 知识横向拓展</h3><p>   知识横向拓展，昨天在印象笔记整理文章的时候，正好看到营销这个词，于是就把各类营销词汇整理了一番，方便以后学习归档，如病毒营销、邮件营销、关系营销、内容营销、事件营销等等，可能里面多个营销方式有很多共同点，分别找出来，也有不同点把它们区别开，这些营销方式适合什么场景下使用，适合企业的什么阶段使用，需要哪些辅助工作才能完成，成本多少?这就是横向拓展，通过知识与知识的联系发现他们共同点和不同点，找出他们的差异化，其实横向拓展和纵向拓展是不会绝对分开，当你开始比较的时候，大脑其实就进入了深度拓展和横向拓展，多思考多关联多实践多PK。</p><h3>5. 结构：理解就是结构高度发达完善的结果。</h3><p>   理解的重要性，一个人看书是否学到东西，看他的笔记和读后感就知道，如果这个人笔记和读后感总结都是勾画的原作者的文字，这是较少理解，不够深入，最差的理解是读书笔记和读后感都没有的，也是最差的学习方式，刚刚说的这些话都是错误的!<br>   真正理解，是可以通过结构化思维表达出来。理解帮忙我们把知识结构化，总感觉这里翻译的有问题，只有理解后的知识才便于储存，便于在大脑里结构化。怎么来理解呢?举个例子<br>   当我们阅读&quot;理解就是结构高度发达完善的结果&quot;的时候，如果很快就弄懂了这句话，这句话可能就相当于电脑内存中的一行数据，当我们阅过这句话，看到下段文字的时候这句话已经从内存中消失。但恰巧我读到时候，有意识觉得这里可以写点什么，就反复读了几遍，理解是结构发达的结果，理解是名词，结构发达是短语，结果是名词是产出物，正确说法是因为〖怎么样〗所以〖造成这个结果〗，那么就应该是因为理解所以造成结构发达的结果。修改后：结构高度发达完善就是理解的结果。<br>   有点咬文嚼字，扯远了，当我开始纠结这句话，大脑其实在高速运转，调动了我大脑磁盘里的相关信息来帮助我理解这句话，并做出推断。然后这句话就会固化在我的大脑磁盘里，不是一闪而过的内存数据，同时我刚刚调用过的知识再次被激活得以运用，知识就是越来应用的，不用就不属于你的知识。<br>   我不敢说解释得很明白，希望你们能够看到我对一字一句的理解，以及我狭小硬盘储存的不是特别完善的知识结构是如何被调用的。<br>   我在这里有意的写笔记是为了培养以后习惯性的思考。</p><h3>6. 模型：模型就像是结构的种子，是一座建筑的地基和框架，是知识最核心的概念，在此基础上将引伸出全部的知识。</h3><p>   先回顾，整体性学习的三个重要概念：结构，模型，高速公路。<br>   当我读完模型这一小节，我的脑子里浮现出类似原子的东西，在黑色的空间里自由漂浮，每个原子并不孤立，它们之间有一条耀眼的类似光线的&quot;脐带&quot;互相交错连接，这条连接线经常是一团亮斑从原子这头快速移动到另一头，所以看整体非常耀眼，其实这就是知识的传递与连接。<br>   现在看来，模型就是知识的最小结构，知识的结构由无数的模型和连接组成，我不知道我理解的连接是不是笔者的高速路公路，带着问题继续往下读，等待犹如开奖的那一惊心动魄。</p><h3>7. 高速公路：结构与结构之间的联系。</h3><p>   高速公路的比喻用得非常精准，这是城际之间的快速通道，是连接结构与结构之间的线路。这条线路传递和连接的知识(不是知识点，模型才是知识点)将以光速进行传递，也就是我们常说的一念之间。<br>   结构是模型的集合，模型与模型之间相互交错连接，结构与结构之间交错连接。知识点互相关联，知识互相连接交错。完美的一幅图画，黑暗的空间，一个个大型的分子，分子是若干原子的集合，是原子的仓库，不断有新的原子增加或者删除，我能清晰的透过分子的透薄如水的墙壁看到原子瞬间增加和破灭的过程，每个原子其中的若干连接线突然断裂，它在瞬间被孤立最后立即消亡，这是一个正常情况无法看到感知到的过程。分子的存亡和原子的存活方式完全不一样，只要有一个原子存在，依靠这类原子组成的分子就不会死亡。</p><h3>8. 结构分类</h3><p>   成熟结构、感知结构、生活经验、关系结构、基础数学结构</p><h3>9. 学习顺序</h3><p>   获取、理解、拓展、纠错、应用，测试伴随以上每一步，总结自省伴随以上每一步。</p><h3>10. 信息获取</h3><p>   信息获取，信息大爆炸的今天我们随时都能接触到海量信息，信息获取渠道非常丰富，百度、百科、知道、知乎、各类APP、新闻网站、社交媒体、自媒体等等，所以我们要提高信息获取的手段和筛选方法。<br></p><ul><li>订阅，订阅自己关注的内容或则话题</li><li>筛选，使用印象笔记或有道云笔记以及剪藏功能，把自己粗读有价值的信息收集整理，记得设置标签，方便以后索引。</li><li>(3) 定时整理笔记工具里的内容，整理成文章总结，将信息进行归类。总结的时候可以根据内容进行发散联想，拓展更广的话题，写下来整理成文章，这就是你的学习所得。</li></ul><h3>11. 信息获取方法</h3><p>   精简信息、增加信息获取的数量和信息来源、提高阅读速度效率</p><h3>12. 信息拓展方法</h3><p>   深度拓展、纵向拓展、横向拓展</p><h3>13.信息获取小结</h3><p>   一句话概括，通过不同手段获取知识，不断理解深入研究，拓展和联想相关知识，不断纠错判断，沉淀正确的知识并实践应用。<br>   拓展知识有三个方法，深度拓展、横向拓展、纵向拓展，深度拓展又可以理解为背景拓展，主要了解知识形成的背景、原因和过程，深度拓展和纵向理解容易造成误会，所以固化背景拓展最佳。<br>   关于信息获取每一步的测试单独说下：</p><ul><li>获取——是否看过听过，如果看过比较了解可以略过，进入初期筛选</li><li>理解——真的明白了知识点的含义了吗?是否可以用最简单的语言和比喻解释清楚</li><li>拓展——知识背景如何，相关知识有哪些，存在什么关系</li><li>纠错——哪些知识点、观点是错误的，正确的是什么?为什么它是错的</li><li>运用——这些知识如何运用到现实生活?有什么意义和价值?</li></ul><h3>14. 信息分类</h3><p>   随意信息、观点信息、过程信息、具体信息、抽象信息</p><h3>15. 挂钩法</h3><p>   刚刚我做了一个关于挂钩法有趣的小实验，用了大概二十秒钟记住8件东西，缺了两样，但是我觉得挂钩法依然非常有效。<br>   这几样东西分别是：</p><table><thead><tr><th style="text-align:center">培根</th></tr></thead><tbody><tr><td style="text-align:center">鸡蛋</td></tr><tr><td style="text-align:center">葡萄酒</td></tr><tr><td style="text-align:center">电池</td></tr><tr><td style="text-align:center">泡泡糖</td></tr><tr><td style="text-align:center">牛奶</td></tr><tr><td style="text-align:center">信封</td></tr><tr><td style="text-align:center">菠菜</td></tr><tr><td style="text-align:center">咖啡</td></tr><tr><td style="text-align:center">番茄</td></tr></tbody></table><p>   然后在一边分别把他们列出来。我是这样记忆的，时不时我上班会去早餐店买一份叫培根煎饼的早餐，里面有培根、鸡蛋、生菜、沙拉酱或者番茄酱或则辣椒酱，我就把生菜巧妙替换成菠菜，煎饼比较干那么肯定得来杯牛奶，营养又健康，和牛奶一样的饮品(联想法)有我平时最爱喝的咖啡，最近我还在学习做牛扒，家里一直缺红酒，红酒也是装逼利器哟，吃完早餐喝完咖啡，心里还想着牛扒红酒高逼格的美食，也该进入工作状态(继续挂钩)，打开邮件(映射信封)，查看有没有工作方面的事情，一边嚼着同事给的口香糖，其实我从不买泡泡糖那种口香糖，太甜越嚼越没味道，回到家吃了这么多好吃的肯定担心自己胖了没就需要称称，恰好，电子称没电了，一直拖着没去买电池。   写了好长时间了啊，实际上就是脑子里一瞬间的联想和挂钩。</p><h3>16. 内在化</h3><p>   通过将信息转化为更容易想象的形式，你可以为知识建立广泛的联系</p><h3>17. 内化与内在化</h3><p>   本文用词稍微不太严谨，前面提到的是内在化，这里提的是内化。</p><ul><li>知识内化，是企业管理的重要组成部分，按字面意思理解就是知识的内部消化吸收再创新。</li><li>知识内在化，我又只有闭眼冥想我那黑暗的知识空间，存在无数的知识分子和原子，当我获得新的知识点(原子)的时候就会通过光速连接(本书中的高速公路)找到适合该原子归类的仓库(分子)，如果这不是简单的知识点本身可以独立成新的知识，会自动产生一个分子并包含最少一个原子，这个分子与刚刚通过的光速连接那端的分子自动连接建立索引，便于以后快速搜索及时反馈。继续扩展下内化的过程是不是和搜索引擎很像，检索新的网页(信息收集)然后通过算法判断是否索引或者更新快照(理解、纠错)，蜘蛛沿着网页入口进行纵向和横向爬行(拓展)然后重复算法的判断，合格的网页进行存储并排序展示给用户(应用)。</li></ul><h3>18. 学习的战略战术</h3><p>   简单说战略指导思想，战术指导方法。学习知识的战略指导你把知识融会贯通，运用到现实生活和工作中，学习知识的战术指导你如何去学习。</p><ul><li>获取知识：快速阅读、笔记流</li><li>联系观点：比喻法、内在化、图表法</li><li>随意信息处理：联想法、挂钩法、信息压缩</li><li>知识拓展：知识应用、模型纠错、以项目为基础学习</li></ul><h3>19. 笔记流</h3><p>   &quot;一次学会&quot;表示你在学习时要全神贯注地听老师讲课，而不是忙着做细致漂亮的笔记，等到课下再学。工作中，尤其是会议，用关键词记录，会议后整理，效率高。<br>   一旦你写下了一个观点，下一步就是在这个观点和其他观点之间画上一些箭头呈现出相互关联的关系，形成一张观点网络。</p><h3>20. 读书笔记</h3><p>   写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</p><h3>21. 费曼技巧</h3><ul><li>选择要学习的内容</li><li>以老师的身份学习</li><li>疑惑时返回学习</li><li>用简单直白和比喻去解释知识点</li></ul><h3>22. 提高效率</h3><ul><li>健康身心</li><li>聪明学习</li><li>不拖延</li><li>批处理碎片信息</li><li>坚持做清单、写日子</li></ul><h3>23. 自我教育</h3><ul><li>养成阅读习惯</li><li>设定学习目标写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《如何高效学习》从学习的战略上指导学习知识的策略抛出整体性学习的概念，以及结构、模型、高速公路的观点;详细分析了学习的顺序和信息的分类。以战术的方式分解学习的各种战术，如快速阅读、笔记流、比喻法、内在化、联想法、图表法、挂钩法、信息压缩、知识应用、模型纠错等。下面是我阅读时写下的感想，比较少的书摘。&lt;/p&gt;
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="文字" scheme="http://ulsonhu.cn/tags/%E6%96%87%E5%AD%97/"/>
    
      <category term="阅读" scheme="http://ulsonhu.cn/tags/%E9%98%85%E8%AF%BB/"/>
    
  </entry>
  
  <entry>
    <title>SVM支持向量机</title>
    <link href="http://ulsonhu.cn/SVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html"/>
    <id>http://ulsonhu.cn/SVM支持向量机.html</id>
    <published>2017-02-26T16:00:00.000Z</published>
    <updated>2018-03-11T04:39:59.811Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通俗来讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p></blockquote><a id="more"></a><h2>从线性回归讲起</h2><p>SVM主要是用来做分类工作，诸如文本分类，图像分类，生物序列分析和生 物数据挖掘， 手写字符识别等领域都有很多的应用。</p><p>对分类最简单的即线性分类器用X表示数据点，Y表示类别（二分类中，y取1或-1），一个线性分类器的目标是在数据空间中找到一个分隔平面,这个分隔平面方程可以表示为：$$\omega^{T}x+b=0$$为使目标函数值在-1到1之间，我们使用Logistic函数作为假设函数。</p><p>假设函数：</p><p>$$h_\theta(x)=g(\theta^{T}x)=\frac{1}{1+e^(-\theta^{T}x)}, \quad h_\theta(x)\in(0,1)$$</p><p>其中，x是n维特征向量，所以假设函数就是y=1的概率：</p><p>$$P(y=1|x;\theta)=h_\theta(x) \ P(y=0|x;\theta)=1-h_\theta(x)$$</p><p>从而，有$h_\theta(x)&gt;0.5$就是y=1的类，反之属于y=0的类。接下来，将结果中y = 0 和 y = 1 替换为 y =-1，y = 1，然后将$\theta^Tx= \theta_0x_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$中的$x_0$替换 为 b，最后将后面的$\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$替换为$\omega^Tx$，也就是说除了 y 由 y = 0 变为 y =1 外，线性分类函数跟 Logistic 回归的形式化表示$h_\theta(x)=g(\theta^Tx)=g(\omega^Tx+b)$没区别。<img src="http://img.blog.csdn.net/20170226133437427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3>函数间隔与几何间隔</h3><p>在超平面 $\omega^{T} x + b = 0$ 确定的情况下，$|\omega^{T} x + b|$ 能够表示点 x 到距离超平面的远近 ，而通过观察 $\omega^{T} x + b$的符号与类标记 y 的符号是否一致可判断分类是否正确，所以，可以用 $y(\omega^{T} x + b)$ 的正负性来判定或表示分类的正确性。</p><p>给定的训练数据集T和超平面w,b)，定义超平面(w,b)关于样本点(xi,yi)的函数间隔为：$$\hat{\gamma}=y(\omega^{T}x+b)=y(f(x))$$但这样定义的函数间隔有问题，即如果成比例的改变 w 和 b（如将它们改成 2w 和 2b），则函数间隔的值 f(x) 却变成了原来的 2 倍（虽然此时超平面没有改变），所以只 有函数间隔还远远不够。</p><p>平面法向单位化的函数间隔，即几何间隔$$\gamma=\frac{\omega^{T}x+b}{||\omega||}=\frac{f((x)}{||\omega||}$$假定对于一个点 x ，令其垂直投影到超平面上的对应点为 $x_0$ ，w 是垂直于超平面 的一个向量， 为样本 x 到分类间隔的距离，如图所示。<img src="http://img.blog.csdn.net/20170226134808933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log"></p><p>从上述的定义可以看出：几何间隔就是函数间隔除以 $∥\omega∥$，而且函 数间隔 $y(w ^T x + b) = yf(x)$ 实际上就是 $|f(x)|$，只是人为定义的一个间隔度量，而几何 间隔 $|f(x)|/∥\omega∥$ 才是直观上的点到超平面的距离。</p><h2>最大间隔分类器</h2><p>对一个数据点进行分类， SVM的思想是当超平面离数据点的“间隔”越大， 分类的确信度 （conﬁdence）也越大。<img src="http://img.blog.csdn.net/20170226135127419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>定义目标函数：<img src="http://img.blog.csdn.net/20170226135744814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>回顾一下几何间隔的定义 $\tilde{\gamma}=y\gamma = \frac{hat{\gamma}}{∥\omega∥}$ 可知， 如果令函数间隔 $\hat{\gamma}$等于 1， 则有$\tilde{\gamma}=\frac{1}{∥w∥}$ 且 $y_i (\omega ^T x_i + b) \geq1; \quad i = 1; \cdots; n$</p><p>从而上述目标函数转化成了：</p><p>$$ max\quad \frac{1}{||w||} ;\ s.t. y_i (w^{T} x_i + b)\geq1;\quad i = 1, \cdots,n$$</p><p>这个目标函数便是在相应的约束条件$y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$条件下，最大化这个 $\frac{1}{||w||}$ 值，而 $\frac{1}{||w||}$便是几何间隔$\tilde{\gamma}$。</p><h2>拉格朗日乘子法</h2><p>由于求 $\frac{1}{||w||}$ 的最大值相当于求 $\frac{1}{2}||w||^2$ 的最小值，所以上述目标函数等价于</p><p>$$ min\quad \frac{1}{2}||w||^2 ; \ s.t. y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$$</p><p>因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。这个问题可以用现成的 QP (Quadratic Programming) 优化包进行求解。一言以蔽之：在一定的约束条件下，目标最优，损失最小。</p><p>此外，由于这个问题的特殊结构，还可以通过拉格朗日对偶性（Lagrange Duality） 变换到对偶变量 (dual variable) 的优化问题， 即通过求解与原问题等价的对偶问题 （dual problem）得到原始问题的最优解，这就是线性可分条件下支持向量机的对偶算 法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数， 进而推广到非线性分类问题。</p><p>那什么是拉格朗日对偶性呢？简单来讲，通过给每一个约束条件加上一个拉格朗日乘子（Lagrange multiplier），定义拉格朗日函数</p><p>$$L(\omega,b,\alpha)= \frac{1}{2}||w||^2-\sum_{i=1}^{n}\alpha_i(y_i(w_i^Tx_i+b)-1)$$</p><p>原问题是极小极大问题:$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)$$</p><p>原始问题的对偶问题，是极大极小问题:$$\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p>将拉格朗日函数$L(w,b,\alpha)$分别对w，b求偏导并令其为0,</p><p><img src="http://img.blog.csdn.net/20170226142614206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log00"></p><p>将上式带入拉格朗日函数$L(w,b,\alpha)$中，得到：</p><p><img src="http://img.blog.csdn.net/20170226142712754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"></p><p>继续求$\underset{w,b}{min}L(w,b,\alpha)$对$\alpha$的极大值:</p><p><img src="http://img.blog.csdn.net/20170226142934391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>整理目标函数，求解出最优的$\alpha^{*}$<img src="http://img.blog.csdn.net/20170226172322298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>上式为一般的含不等式约束问题，存在最优化解法的必要和充分条件即KKT条件（详情可查看<a href="http://blog.csdn.net/touristman5/article/details/57418552" target="_blank" rel="noopener">等式约束与不等式约束问题</a>）：为方便理解，我们把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$$L(a,b,x)=f(x)+a∗g(x)+b∗h(x)$$</p><p>KKT条件是说最优值必须满足以下条件：</p><ol><li>$\frac{\partial{L}}{\partial{x_i}}=0$对x求导为零；</li><li>$h(x) =0;$</li><li>$a*g(x) = 0;$</li></ol><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为$g(x)&lt;=0$，如果要满足这个等式，必须$\alpha=0$或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><p>所谓 支撑向量Supporting Vector 也在这里显示出来——事实上，所有非 Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上 只要针对少量的“支持向量”而不是所有的训练数据即可。</p><h3>核函数</h3><p>对于线性不可分的情况，可以使用核函数，将输入空间映射到特征空间（通俗说来是从低维空间映射到高维空间），从而使得原本线性不可分的样本可以在特征空间可分。</p><p><img src="http://img.blog.csdn.net/20170226174650918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log04"></p><p>在实际应用中，往往依赖先验领域知识才能选择有效的核函数####常见的核函数有</p><ul><li>多项式核函数：$$K(x_1,x_2)=(\left \langle x_1,x_2  \right \rangle)^d$$</li><li>高斯核函数：$$K(x_1,x_2)=exp^ { \frac{||x_1-x_2||}{2\sigma^2} } $$</li></ul><p>参考链接：</p><ol><li>统计学习方法，李航著，清华大学出版社，2012年</li><li><a href="http://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7624837</a></li><li><a href="http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html" target="_blank" rel="noopener">http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通俗来讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="机器学习相关" scheme="http://ulsonhu.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="统计学" scheme="http://ulsonhu.cn/tags/%E7%BB%9F%E8%AE%A1%E5%AD%A6/"/>
    
      <category term="Machine Learning" scheme="http://ulsonhu.cn/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>用Tensorflow写简单的神经网络</title>
    <link href="http://ulsonhu.cn/%E7%94%A8Tensorflow%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html"/>
    <id>http://ulsonhu.cn/用Tensorflow写简单的神经网络.html</id>
    <published>2017-02-24T17:40:33.000Z</published>
    <updated>2018-03-18T03:33:56.215Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。</p><a id="more"></a><p><img src="http://tensorfly.cn/images/tensors_flowing.gif" alt="log00"></p><p>根据上图，可以看出一个简单神经网络所具有的模块结构，首先输入层(Input Layer)，接受相关的结构化化数据；其次是隐藏层(Hidden Layer)，隐藏层主要加权运算，通过激活函数达到拟合线性非线性函数的目的；最后有输出层(Output Layer)，其结果成为下一次迭代的初始值。</p><p>一个的单层神经网络如下：<img src="http://hahack.com/images/ann2/w4eQd.png" alt="log01"></p><p>就此，我们用Tensorflow实现一个单层神经网络，参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs,in_size,out_size,activation_function=None)</span>:</span></span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_size,out_size]))</span><br><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>,out_size])+<span class="number">0.1</span>)</span><br><span class="line">    Wx_plus_b = tf.matmul(inputs,Weights)+biases</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x_d = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">300</span>)[:,np.newaxis]</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>,<span class="number">0.05</span>,x_d.shape)</span><br><span class="line">y_d = np.square(x_d) - <span class="number">0.5</span> + noise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义placeholder，可以更方便</span></span><br><span class="line">xs = tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">1</span>])</span><br><span class="line">ys = tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加隐藏层</span></span><br><span class="line">layer1 = add_layer(xs,<span class="number">1</span>,<span class="number">10</span>,activation_function = tf.nn.relu)</span><br><span class="line">predict = add_layer(layer1,<span class="number">10</span>,<span class="number">1</span>,activation_function = <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - predict),reduction_indices=[<span class="number">1</span>]))</span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.3</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="comment"># init = tf.initialize_all_variables() no long valid from</span></span><br><span class="line"><span class="comment"># 2017-03-02 if using tensorflow &gt;= 0.12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int((tf.__version__).split(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span>:</span><br><span class="line">    init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_d, ys: y_d&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># to see the step improvement</span></span><br><span class="line">        print(sess.run(loss, feed_dict=&#123;xs: x_d, ys: y_d&#125;))</span><br></pre></td></tr></table></figure><p>单机运行结果如下：<img src="http://img.blog.csdn.net/20170225020607154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log2"></p><blockquote><p>[1]参考链接：<a href="https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13" target="_blank" rel="noopener">https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习相关" scheme="http://ulsonhu.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E7%9B%B8%E5%85%B3/"/>
    
    
      <category term="Python" scheme="http://ulsonhu.cn/tags/Python/"/>
    
      <category term="Machine Learning" scheme="http://ulsonhu.cn/tags/Machine-Learning/"/>
    
      <category term="TensorFlow" scheme="http://ulsonhu.cn/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>唐璜节选</title>
    <link href="http://ulsonhu.cn/%E5%94%90%E7%92%9C%E8%8A%82%E9%80%89.html"/>
    <id>http://ulsonhu.cn/唐璜节选.html</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2018-03-11T04:38:57.869Z</updated>
    
    <content type="html"><![CDATA[<p>   诗歌能做到以更简练、更摄人心魄的精准语言与我们的灵魂直接沟通。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生命激荡着青葱的希望</span><br><span class="line">爱意伴随着激情的火焰</span><br><span class="line">美食、酒神，都是爱情的风帆</span><br><span class="line">——唐璜-「七」岩穴奇情</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生命的美好不能束缚他，死亡的狰狞也不能毁灭它</span><br><span class="line">来自他的母亲—摩尔人赋予她刚强的性格</span><br><span class="line">他将彻底面对世界</span><br><span class="line">乐园和荒漠，没有第三条路</span><br><span class="line"></span><br><span class="line">希腊的少女曾用哀歌，咏叹海黛的爱</span><br><span class="line">迁居的岛民，也曾在漫漫长夜将这一切讲述</span><br><span class="line">夜色大海静，传说流万古</span><br><span class="line">孤岛痴女情，唯有诗人知</span><br><span class="line">——唐璜-「十六」伤逝</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">爱情犹如鸦片，不用太多</span><br><span class="line">一口便让人迷醉</span><br><span class="line">除了泪水情人的眼睛什么都能汲取</span><br><span class="line">尤其是生命的泉水</span><br><span class="line"></span><br><span class="line">这已经足够，爱情虚无飘渺</span><br><span class="line">它因自私而起，又因自私结束</span><br><span class="line">还有一种爱情只是一时的热忱</span><br><span class="line">把自己的脆弱与孤独的美相结合</span><br><span class="line">点缀那一颗疯狂的无法遏制的心</span><br><span class="line">如果没有这种美，热情也就消失</span><br><span class="line">——唐璜-「三十二」女皇的恩宠</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;   诗歌能做到以更简练、更摄人心魄的精准语言与我们的灵魂直接沟通。&lt;/p&gt;
    
    </summary>
    
      <category term="读书思考" scheme="http://ulsonhu.cn/categories/%E8%AF%BB%E4%B9%A6%E6%80%9D%E8%80%83/"/>
    
    
      <category term="文字" scheme="http://ulsonhu.cn/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
</feed>
