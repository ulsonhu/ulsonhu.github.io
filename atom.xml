<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Sonnet&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-02-23T07:32:46.204Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ulson</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用AngularJS写框架</title>
    <link href="http://yoursite.com/2018/02/23/%E7%94%A8AngularJS%E5%86%99%E6%A1%86%E6%9E%B6/"/>
    <id>http://yoursite.com/2018/02/23/用AngularJS写框架/</id>
    <published>2018-02-22T17:08:29.000Z</published>
    <updated>2018-02-23T07:32:46.204Z</updated>
    
    <content type="html"><![CDATA[<h2>1. 模块的定义和加载</h2><h3>1.1 模块的定义</h3><p>一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。</p><a id="more"></a><p>先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？</p><p>我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。</p><p>考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。</p><p>JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？</p><p>在很多传统高级语言里，变量作用域的边界是大括号，在{}里面定义的变量，作用域不会传到外面去，但我们的JavaScript大人不是这样的，他的边界是function。所以我们这段代码，i仍然能打出值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure><p>那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。</p><p>我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过： C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！” Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！” C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！</p><p>啊，我们发现了什么，既然无法避免全局的作用域，那与其让100个function都全局，不如只让一个来全局，其他的都由它管理。</p><p>本来我们打算自己当上帝的，现在只好改行先当个工商局长。你想开店吗？先来注册，不然封杀你！于是良民们纷纷来注册。店名叫什么，从哪进货，卖什么的，一一登记在案，为了方便下面的讨论，我们连进货的过程都让工商局管理起来。</p><p>店名，指的就是这里的模块名，从哪里进货，代表它依赖什么其他模块，卖什么，表示它对外提供一些什么特性。</p><p>好了，考虑到我们的这个注册管理机构是个全局作用域，我们还得把它挂在window上作为属性，然后再用一个function隔离出来，要不然，别人也定义一个同名的，就把我们覆盖掉了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//register a module</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这个module方法内部，应当怎么去实现呢？我们的module应当有一个地方存储，但存储是要在工商局内部的，不是随便什么人都可以看到的，所以，这个存储结构也放在工商局同样的作用域里。</p><p>用什么结构去存储呢？工商局备案的时候，店名不能跟已有的重复，所以我们发现这是用map的很好场景，考虑到JavaScript语言层面没有map，我们弄个Object来存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">window</span>.thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!moduleMap[name]) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    dependencies: dependencies,</span><br><span class="line">                    factory: factory</span><br><span class="line">                &#125;;</span><br><span class="line">                moduleMap[name] = <span class="built_in">module</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> moduleMap[name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在，模块的存储结构就搞好了。</p><h3>1.2 模块的使用</h3><p>存的部分搞好了，我们来看看怎么取。现在来了一个商家，卖木器的，他需要从一个卖钉子的那边进货，卖钉子的已经来注册过了，现在要让这个木器厂能买到钉子。现在的问题是，两个商家处于不同的作用域，也就是说，它们互相不可见，那通过什么方式，我们才能让他们产生调用关系呢？</p><p>个人解决不了的问题还是得靠政府，有困难要坚决克服，没有困难就制造困难来克服。现在困难有了，该克服了。商家说，我能不能给你我的进货名单，你帮我查一下它们在哪家店，然后告诉我？这么简单的要求当然一口答应下来，但是采用什么方式传递给你呢？这可犯难了。</p><p>我们参考AngularJS框架，写了一个类似的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"A"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module A</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"B"</span>, [<span class="string">"A"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module B</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看这段代码特别在哪里呢？模块A的定义，毫无特别之处，主要看模块B。它在依赖关系里写了一个字符串的A，然后在工厂方法的形参写了一个真真切切的A类型。嗯？这个有些奇怪啊，你的A类型要怎么传递过来呢？其实是很简单的，因为我们声明了依赖项的数组，所以可以从依赖项，挨个得到对应的工厂方法，然后创建实例，传进来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = moduleMap[name];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">module</span>.entity) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">module</span>.dependencies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (moduleMap[<span class="built_in">module</span>.dependencies[i]].entity) &#123;</span><br><span class="line">                args.push(moduleMap[<span class="built_in">module</span>.dependencies[i]].entity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                args.push(<span class="keyword">this</span>.use(<span class="built_in">module</span>.dependencies[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">module</span>.entity = <span class="built_in">module</span>.factory.apply(noop, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里面递归获取了依赖项，然后当作参数，用这个模块的工厂方法来实例化了一下。这里我们多做了一个判断，如果模块工厂已经执行过，就缓存在entity属性上，不需要每次都创建。以此类推，假如一个模块有多个依赖项，也可以用类似的方式写，毫无压力：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thin.define(&quot;D&quot;, [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;], function(A, B, C) &#123;</span><br><span class="line">    //module D</span><br><span class="line">    var a = new A();</span><br><span class="line">    var b = new B();</span><br><span class="line">    var c = new C();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意了，D模块的工厂，实参的名称未必就要是跟依赖项一致，比如，以后我们代码较多，可以给依赖项和模块名称加命名空间，可能变成这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thin.define(&quot;foo.D&quot;, [&quot;foo.A&quot;, &quot;foo.B&quot;, &quot;foo.C&quot;], function(A, B, C) &#123;</span><br><span class="line">    //module D</span><br><span class="line">    var a = new A();</span><br><span class="line">    var b = new B();</span><br><span class="line">    var c = new C();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码仍然可以正常运行。我们来做另外一个测试，改变形参的顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"A"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"a"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"B"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"C"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"D"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">B, A, C</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> B + A + C;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> D = thin.use(<span class="string">"D"</span>);</span><br><span class="line">alert(D);</span><br></pre></td></tr></table></figure><p>试试看，我们的D打出什么结果呢？结果是&quot;abc&quot;，所以说，模块工厂的实参只跟依赖项的定义有关，跟形参的顺序无关。我们看到，在AngularJS里面，并非如此，实参的顺序是跟形参一致的，这是怎么做到的呢？</p><p>我们先离开代码，思考这么一个问题：如何得知函数的形参名数组？对，我们是可以用func.length得到形参个数，但无法得到每个形参的变量名，那怎么办呢？</p><p>AngularJS使用了一种比较极端的办法，分析了函数的字面量。众所周知，在JavaScript中，任何对象都隐含了toString方法，对于一个函数来说，它的toString就是自己的实现代码，包含函数签名和注释。下面我贴一下AngularJS里面的这部分代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FN_ARGS = <span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</span><br><span class="line"><span class="keyword">var</span> FN_ARG_SPLIT = <span class="regexp">/,/</span>;</span><br><span class="line"><span class="keyword">var</span> FN_ARG = <span class="regexp">/^\s*(_?)(\S+?)\1\s*$/</span>;</span><br><span class="line"><span class="keyword">var</span> STRIP_COMMENTS = <span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">annotate</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $inject,</span><br><span class="line">      fnText,</span><br><span class="line">      argDecl,</span><br><span class="line">      last;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn == <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!($inject = fn.$inject)) &#123;</span><br><span class="line">      $inject = [];</span><br><span class="line">      fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>);</span><br><span class="line">      argDecl = fnText.match(FN_ARGS);</span><br><span class="line">      forEach(argDecl[<span class="number">1</span>].split(FN_ARG_SPLIT), <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        arg.replace(FN_ARG, <span class="function"><span class="keyword">function</span>(<span class="params">all, underscore, name</span>)</span>&#123;</span><br><span class="line">          $inject.push(name);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      fn.$inject = $inject;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(fn)) &#123;</span><br><span class="line">    last = fn.length - <span class="number">1</span>;</span><br><span class="line">    assertArgFn(fn[last], <span class="string">'fn'</span>);</span><br><span class="line">    $inject = fn.slice(<span class="number">0</span>, last);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertArgFn(fn, <span class="string">'fn'</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $inject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个代码也不长，重点是类型为function的那段，首先去除了注释，然后获取了形参列表字符串，这段正则能获取到两个结果，第一个是全函数的实现，第二个才是真正的形参列表，取第二个出来split，就得到了形参的字符串列表了，然后按照这个顺序再去加载依赖模块，就可以让形参列表不对应于依赖项数组了。</p><p>AngularJS的这段代码很强大，但是要损耗一些性能，考虑到我们的框架首要原则是简单，甚至可以为此牺牲一些灵活性，我们不做这么复杂的事情了。</p><h3>1.3 模块的加载</h3><p>到目前为止，我们可以把多个模块都定义在一个文件中，然后手动引入这个js文件，但是如果一个页面要引用很多个模块，引入工作就变得比较麻烦，比如说，单页应用程序（SPA）一般比较复杂，往往包含数以万计行数的js代码，这些代码至少分布在几十个甚至成百上千的模块中，如果我们也在主界面就加载它们，载入时间会非常难以接受。但我们可以这样看：主界面加载的时候，并不是用到了所有这些功能，能否先加载那些必须的，而把剩下的放在需要用的时候再去加载？</p><p>所以我们可以考虑<strong>万能的AJAX</strong>，从服务端获取一个js的内容，然后……，怎么办，你当然说不能eval了，因为据说eval很evil啦，但是它evil在哪里呢？主要是破坏全局作用域啦，怎么怎么，但是如果这些文件里面都是按照我们规定的模块格式写，好像也没有什么在全局作用域的……，好吧。</p><p>算了，我们还是用最简单的方式了，就是**动态创建script标签，然后设置src，添加到document.head里，然后监听它们的完成事件，做后续操作。**真的很简单，因为我们的框架不需要考虑那么多种情况，不需要AMD，不需要require那么麻烦，用这框架的人必须按照这里的原则写。</p><p>所以，说真的我们这里没那么复杂啦，要是你们想看更详细原理的不如去看这个，解释得比我好哎：<a href="http://coolshell.cn/articles/9749.html#jtss-tsina" target="_blank" rel="noopener">JavaScript装载与执行</a></p><p>[补一段，@Franky 大神指出了这篇文章中一些不符合现状的地方，我把它也贴在这里，供读者参考]</p><blockquote><p>很多观点都是 史蒂夫那本老书上的观点. 和那时候同期产生的一些数据和资料…所以显得不少东西说的太想当然了… 譬如script标签的加载和执行会阻塞后面资源的加载和执行之类的.说的过于肯定了. 比如chrome7+就开始逐渐改进的 预加载机制 就分 head 里的资源, body里的资源 .两个资源是否跨界三种情形. 不提这些浏览器. 我们看看ie10也同样改进了 死循环10秒 这后面的图片能被提前加载. 就更不用说其他A级浏览器的丰富的优化策略了. 所以还是建议博主, 别拿几年前的老资料作为依据.尤其这些数据是用来说明更新速度像在赛跑一样的各个浏览器了.</p><p>关于 defer , 似乎史蒂夫的老书上是这么说的么? 显然没有测试全非ie浏览器的各个版本.或者是他测试数据的时候ff某大版本的几个beta子版本还没出现?</p><p>其次是就你的加载器提到的预加载策略. 你有测过所有浏览器用object预加载可能涉及到的问题么(比如chrome,8,9的预加载的会话级别的资源类型缓存bug). 抛开这个问题不谈,假设你预加载到一半,用户再次触发了加载.你觉得这种情况如果频繁发生.是否合适? 你的预加载策略连script.onload状态都无法测知,进一步优化的可能性就消失了. 考虑下为什么seajs 的 umd要设计成那个样子?</p><p>最后吐槽下你的代码. 有注意到你用 document.body.appendChild 来向DOM中插入脚本. 我的建议是 永远不要这样做.除非你可以无视ie6用户.以及ie7缺失某些补丁的子版本.</p><p>你可以选择body 可以.但请用insertBefore. 但在某些极端情况下.这仍然会发生问题. 最佳实践是 head.insertBefore 向其第一个子节点插入.(你甚至无需检测是否存在子节点. 这个api会在没有子节点的时候,行为同appendChild). 而更加稳妥的情况是. 如果注入script. 发现document.head还没有被构建时. 可以自己造一个. 这才是一个通用加载器要做到的程度…</p></blockquote><p>我也偷懒了，只是贴一下代码，顺便解释一下，界面把所依赖的js文件路径放在数组里，然后挨个创建script标签，src设置为路径，添加到head中，监听它们的完成事件。在这个完成时间里，我们要做这么一些事情：在fileMap里记录当前js文件的路径，防止以后重复加载，检查列表中所有文件，看看是否全部加载完了，如果全加载好了，就执行回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>: <span class="function"><span class="keyword">function</span> (<span class="params">pathArr, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> path = pathArr[i];</span><br><span class="line">        <span class="keyword">if</span> (!fileMap[path]) &#123;</span><br><span class="line">            <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">            node.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">            node.async = <span class="string">'true'</span>;</span><br><span class="line">            node.src = path + <span class="string">'.js'</span>;</span><br><span class="line">            node.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fileMap[path] = <span class="literal">true</span>;</span><br><span class="line">                head.removeChild(node);</span><br><span class="line">                checkAllFiles();</span><br><span class="line">            &#125;;</span><br><span class="line">            head.appendChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkAllFiles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allLoaded = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fileMap[pathArr[i]]) &#123;</span><br><span class="line">                allLoaded = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allLoaded) &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>1.4 小结</h3><p>到此为止，我们的简易框架的模块定义系统就完成了。完整的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fileMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!moduleMap[name]) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    dependencies: dependencies,</span><br><span class="line">                    factory: factory</span><br><span class="line">                &#125;;</span><br><span class="line">                moduleMap[name] = <span class="built_in">module</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> moduleMap[name];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        use: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">module</span> = moduleMap[name];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">module</span>.entity) &#123;</span><br><span class="line">                <span class="keyword">var</span> args = [];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">module</span>.dependencies.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (moduleMap[<span class="built_in">module</span>.dependencies[i]].entity) &#123;</span><br><span class="line">                        args.push(moduleMap[<span class="built_in">module</span>.dependencies[i]].entity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        args.push(<span class="keyword">this</span>.use(<span class="built_in">module</span>.dependencies[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">module</span>.entity = <span class="built_in">module</span>.factory.apply(noop, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.entity;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>: <span class="function"><span class="keyword">function</span> (<span class="params">pathArr, callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> path = pathArr[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!fileMap[path]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">                    node.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">                    node.async = <span class="string">'true'</span>;</span><br><span class="line">                    node.src = path + <span class="string">'.js'</span>;</span><br><span class="line">                    node.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        fileMap[path] = <span class="literal">true</span>;</span><br><span class="line">                        head.removeChild(node);</span><br><span class="line">                        checkAllFiles();</span><br><span class="line">                    &#125;;</span><br><span class="line">                    head.appendChild(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">checkAllFiles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> allLoaded = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fileMap[pathArr[i]]) &#123;</span><br><span class="line">                        allLoaded = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (allLoaded) &#123;</span><br><span class="line">                    callback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.thin = thin;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"constant.PI"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"shape.Circle"</span>, [<span class="string">"constant.PI"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">pi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Circle.prototype = &#123;</span><br><span class="line">        area : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pi * <span class="keyword">this</span>.r * <span class="keyword">this</span>.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"shape.Rectangle"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.l = l;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Rectangle.prototype = &#123;</span><br><span class="line">        area: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.l * <span class="keyword">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Rectangle;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"ShapeTypes"</span>, [<span class="string">"shape.Circle"</span>, <span class="string">"shape.Rectangle"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">Circle, Rectangle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        CIRCLE: Circle,</span><br><span class="line">        RECTANGLE: Rectangle</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"ShapeFactory"</span>, [<span class="string">"ShapeTypes"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">ShapeTypes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getShape: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> shape;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"CIRCLE"</span>: &#123;</span><br><span class="line">                    shape = <span class="keyword">new</span> ShapeTypes[type](<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"RECTANGLE"</span>:  &#123;</span><br><span class="line">                    shape = <span class="keyword">new</span> ShapeTypes[type](<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ShapeFactory = thin.use(<span class="string">"ShapeFactory"</span>);</span><br><span class="line">alert(ShapeFactory.getShape(<span class="string">"CIRCLE"</span>, <span class="number">5</span>).area());</span><br><span class="line">alert(ShapeFactory.getShape(<span class="string">"RECTANGLE"</span>, <span class="number">3</span>, <span class="number">4</span>).area());</span><br></pre></td></tr></table></figure><p>在这个例子里定义了四个模块，每个模块只需要定义自己所直接依赖的模块，其他的可以不必定义。也可以来这里看测试链接：<a href="http://xufei.github.io/thin/demo/demo.0.1.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/demo.0.1.html</a></p><h2>2. 数据绑定</h2><h3>2.1 数据绑定的原理</h3><p>数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。</p><p>在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。</p><p>先看数据到界面上的的绑定，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input vm-value=&quot;name&quot;/&gt;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Tom&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们给name重新赋值，<a href="http://person.name" target="_blank" rel="noopener">person.name</a> = “Jerry”，怎么才能让界面得到变更？</p><p>从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    setName: function(newName) &#123;</span><br><span class="line">        this.name = newName;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Tom&quot;,</span><br><span class="line">    gender: 5</span><br><span class="line">    set: function(key, value) &#123;</span><br><span class="line">        this[key] = value;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者合并两个方法，只判断是否传了参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = function(value) &#123;</span><br><span class="line">    if (arguments.length == 0) &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;</span><br><span class="line">    else &#123;</span><br><span class="line">        this._name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<a href="http://xn--person-op0jjj079gsvv8ray18m049c.name" target="_blank" rel="noopener">赋值的时候就是person.name</a>(“Tom”)，取值的时候就是var name = <a href="http://person.name" target="_blank" rel="noopener">person.name</a>()了。</p><p>有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。</p><p>在C#等一些语言里，有一种东西叫做存取器，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private string name;</span><br><span class="line"></span><br><span class="line">    public string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候，<a href="http://person.Name" target="_blank" rel="noopener">person.Name</a> = “Jerry”，就会调用到set里，相当于是个方法。</p><p>这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">var person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">// Add an accessor property to the object.</span><br><span class="line">Object.defineProperty(person, &quot;name&quot;, &#123;</span><br><span class="line">    set: function (value) &#123;</span><br><span class="line">        this._name = value;</span><br><span class="line">        //do something</span><br><span class="line">    &#125;,</span><br><span class="line">    get: function () &#123;</span><br><span class="line">        return this._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: true,</span><br><span class="line">    configurable: true</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>赋值的时候，<a href="http://person.name" target="_blank" rel="noopener">person.name</a> = “Tom”，取值的时候，var name = <a href="http://person.name" target="_blank" rel="noopener">person.name</a>，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。</p><p>现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。</p><p>再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。</p><h3>2.2 数据绑定的实现</h3><p>我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function parseElement(element) &#123;</span><br><span class="line">    for (var i=0; i&lt;element.attributes.length; i++) &#123;</span><br><span class="line">        parseAttribute(element.attributes[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var i=0; i&lt;element.children.length; i++) &#123;</span><br><span class="line">        parseElement(element.children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？</p><p>我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。</p><p>因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">this.define(&quot;Person&quot;, [], function() &#123;</span><br><span class="line">    function Person() &#123;</span><br><span class="line">        this.name = &quot;Tom&quot;;</span><br><span class="line">        this.age = 5;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype = &#123;</span><br><span class="line">        growUp: function() &#123;</span><br><span class="line">            this.age++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    return Person;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>模型方面都准备好了，现在来看界面：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div vm-model=&quot;Person&quot;&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; vm-value=&quot;name&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;text&quot; vm-value=&quot;age&quot;/&gt;</span><br><span class="line">    &lt;input type=&quot;button&quot; vm-click=&quot;growUp&quot; value=&quot;Grow Up&quot;/&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure><p>为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。</p><p>好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？</p><p>当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function parseElement(element, vm) &#123;</span><br><span class="line">    var model = vm;</span><br><span class="line"></span><br><span class="line">    if (element.getAttribute(&quot;vm-model&quot;)) &#123;</span><br><span class="line">        model = bindModel(element.getAttribute(&quot;vm-model&quot;));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var i=0; i&lt;element.attributes.length; i++) &#123;</span><br><span class="line">        parseAttribute(element, element.attributes[i], model);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (var i=0; i&lt;element.children.length; i++) &#123;</span><br><span class="line">        parseElement(element.children[i], model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function bindModel(modelName) &#123;</span><br><span class="line">    thin.log(&quot;model&quot; + modelName);</span><br><span class="line"></span><br><span class="line">    var model = thin.use(modelName, true);</span><br><span class="line">    var instance = new model();</span><br><span class="line"></span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的：</p><ul><li>init，用于绑定初始化方法</li><li>click，用于绑定点击</li><li>value，绑定变量</li><li>enable和disable，绑定可用状态</li><li>visible和invisible，绑定可见状态</li></ul><p>然后就可以实现我们parseAttribute函数了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">function parseAttribute(element, attr, model) &#123;</span><br><span class="line">    if (attr.name.indexOf(&quot;vm-&quot;) == 0) &#123;</span><br><span class="line">        var type = attr.name.slice(3);</span><br><span class="line"></span><br><span class="line">        switch (type) &#123;</span><br><span class="line">            case &quot;init&quot;:</span><br><span class="line">                bindInit(element, attr.value, model);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;value&quot;:</span><br><span class="line">                bindValue(element, attr.value, model);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;click&quot;:</span><br><span class="line">                bindClick(element, attr.value, model);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;enable&quot;:</span><br><span class="line">                bindEnable(element, attr.value, model, true);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;disable&quot;:</span><br><span class="line">                bindEnable(element, attr.value, model, false);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;visible&quot;:</span><br><span class="line">                bindVisible(element, attr.value, model, true);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;invisible&quot;:</span><br><span class="line">                bindVisible(element, attr.value, model, false);</span><br><span class="line">                break;</span><br><span class="line">            case &quot;element&quot;:</span><br><span class="line">                model[attr.value] = element;</span><br><span class="line">                break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。</p><p>这么多绑定，不打算都讲，用bindValue函数来说明一下吧：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function bindValue(element, key, vm) &#123;</span><br><span class="line">    thin.log(&quot;binding value: &quot; + key);</span><br><span class="line"></span><br><span class="line">    vm.$watch(key, function (value, oldValue) &#123;</span><br><span class="line">        element.value = value || &quot;&quot;;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    element.onkeyup = function () &#123;</span><br><span class="line">        vm[key] = element.value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    element.onpaste = function () &#123;</span><br><span class="line">        vm[key] = element.value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。</p><p>在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。</p><p>接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。</p><p>然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var Binder = &#123;</span><br><span class="line">    $watch: function (key, watcher) &#123;</span><br><span class="line">        if (!this.$watchers[key]) &#123;</span><br><span class="line">            this.$watchers[key] = &#123;</span><br><span class="line">                value: this[key],</span><br><span class="line">                list: []</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            Object.defineProperty(this, key, &#123;</span><br><span class="line">                set: function (val) &#123;</span><br><span class="line">                    var oldValue = this.$watchers[key].value;</span><br><span class="line">                    this.$watchers[key].value = val;</span><br><span class="line"></span><br><span class="line">                    for (var i = 0; i &lt; this.$watchers[key].list.length; i++) &#123;</span><br><span class="line">                        this.$watchers[key].list[i](val, oldValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                get: function () &#123;</span><br><span class="line">                    return this.$watchers[key].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        this.$watchers[key].list.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function bindModel(name) &#123;</span><br><span class="line">    thin.log(&quot;binding model: &quot; + name);</span><br><span class="line"></span><br><span class="line">    var model = thin.use(name, true);</span><br><span class="line">    var instance = new model().extend(Binder);</span><br><span class="line">    instance.$watchers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    return instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？</p><p>先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。</p><p>同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。</p><p>嗯，我们是不是可以试一下了？来写个代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Simple binding demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"binding"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"xu.fei@outlook.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../js/thin.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"test.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"test.Person"</span> <span class="attr">vm-init</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    thin.define(<span class="string">"test.Person"</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.name = <span class="string">"Tom"</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.age = <span class="number">5</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        Person.prototype = &#123;</span></span><br><span class="line"><span class="javascript">            init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.name = <span class="string">"Jerry"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.age = <span class="number">3</span>;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            growUp: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.age++;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> Person;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者访问这里：<a href="http://xufei.github.io/thin/demo/simple-binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/simple-binding.html</a></p><p>以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。</p><p>我们还有一个更实际一点的例子，结合了另外一个系列里面写的简单DataGrid控件，做了一个很基础的人员管理界面：<a href="http://xufei.github.io/thin/demo/binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/binding.html</a></p><h3>2.3 小结</h3><p>到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。</p><p>注意Object.defineProperty仅在Chrome等浏览器中可用，IE需要9以上才比较正常。在司徒正美的avalon框架中，巧妙使用VBScript绕过这一限制，利用vbs的property和两种语言的互通，实现了低版本IE的兼容。我们这个框架的目标不是兼容，而是为了说明原理，所以感兴趣的朋友可以去看看avalon的源码。</p>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;1. 模块的定义和加载&lt;/h2&gt;
&lt;h3&gt;1.1 模块的定义&lt;/h3&gt;
&lt;p&gt;一个框架想要能支撑较大的应用，首先要考虑怎么做模块化。有了内核和模块加载系统，外围的模块就可以一个一个增加。不同的JavaScript框架，实现模块化方式各有不同，我们来选择一种比较优雅的方式作个讲解。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>网站迁移(hexo)</title>
    <link href="http://yoursite.com/2018/02/23/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB-hexo/"/>
    <id>http://yoursite.com/2018/02/23/网站迁移-hexo/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2018-02-23T07:34:16.345Z</updated>
    
    <content type="html"><![CDATA[<p>显示摘要显示摘要显示摘要</p><a id="more"></a><p>显示摘要</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;显示摘要
显示摘要
显示摘要&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>理解回调函数</title>
    <link href="http://yoursite.com/2018/02/23/%E7%90%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
    <id>http://yoursite.com/2018/02/23/理解回调函数/</id>
    <published>2018-02-22T16:00:00.000Z</published>
    <updated>2018-02-23T07:33:54.173Z</updated>
    
    <content type="html"><![CDATA[<p>主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。</p><a id="more"></a><p>函数是第一类对象，这是javascript中的一个重要的概念。意味着函数可以像对象一样按照第一类管理被使用，所以在javaScript中的函数：</p><p>**☑ **  能“存储”在变量中</p><p>** ☑**   能作为函数的实参被传递</p><p>**☑ **  能在函数中被创建</p><p>** ☑**   能从函数中返回</p><p><strong>百科里面是这么解释的：</strong></p><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应。</p><p>因此从上面可以看出来，回调本质上是一种设计原则，并且jQuery的设计原则遵循了这个模式。</p><p>在后端的编程语言中，传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入和一个输出。简单的理解函数本质上就<strong>是输入和输出之间实现过程的映射</strong>。</p><p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用。</p><p><strong>jQuery中遍地都是回调的设计：</strong></p><p><strong>异步回调：</strong></p><p>事件句柄回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(callback);</span><br><span class="line">$(document).on(‘click’,callback)</span><br></pre></td></tr></table></figure><p>Ajax异步请求成功失败回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;aaron.html&quot;,</span><br><span class="line">  context: document</span><br><span class="line">&#125;).done(function() &#123; </span><br><span class="line">        //成功执行</span><br><span class="line">&#125;).fail(function() &#123;</span><br><span class="line">        //失败执行</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>动画执行完毕回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#clickme&apos;).click(function() &#123;</span><br><span class="line">    $(&apos;#book&apos;).animate(&#123;</span><br><span class="line">        opacity: 0.25,</span><br><span class="line">        left: &apos;+=50&apos;,</span><br><span class="line">        height: &apos;toggle&apos;</span><br><span class="line">    &#125;, 5000, function() &#123;</span><br><span class="line">        // Animation complete.</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上都是jQuery的回调直接运用，运用基本都是将匿名函数作为参数传递给了另一个函数或方法。而且以上都有一个特点，执行的代码都是异步的。</p><p><strong>同步回调：</strong></p><p>当然回调不仅仅只是处理异步，一般同步(很耗时的任务)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p><p>一个同步(阻塞)中使用回调的例子，目的是在test1代码执行完成后执行回调callback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var test1 = function(callback) &#123;</span><br><span class="line">    //执行长时间操作</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line">test1(function() &#123;</span><br><span class="line">    //执行回调中的方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>所以理解回调函数最重要的2点：</strong></p><p>1、一个回调函数作为参数传递给另一个函数是，我们仅仅传递了函数定义。我们并没有在参数中执行函数。我们并不传递像我们平时执行函数一样带有一对执行小括号()的函数</p><p>2、回调函数并不会马上被执行，它会在包含它的函数内的某个特定时间点被“回调”。</p><h2>回调的灵活运用</h2><p>我们经常会这样使用函数回调：</p><p><strong>☑</strong>  事件触发通知</p><p><strong>☑</strong>  资源加载通知</p><p><strong>☑</strong>  定时器延时</p><p><strong>☑</strong>  ajax、动画通知等等。</p><p>以上都是很单一的事件监听回调的处理方式，但是jQuery把回调函数的用法设计成一个更高的抽像，用于解耦与分离变化。</p><p>如何理解这个设计？我们看下面的例子。</p><p><strong>例子一：</strong></p><p>jQuery针对Dom的处理提供了append、prepend、before、after等方法的处理，这几个方法的特征：</p><p>1、参数的传递可以是HTML字符串、DOM元素、元素数组或者jQuery对象</p><p>2、为了优化性能针对节点的处理需要生成文档碎片</p><p>可见几个方法都是需要实现这2个特性的，那么我们应该如何处理？</p><p><strong>高层接口：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">before: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">after: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>.nextSibling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>底层实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">domManip: <span class="function"><span class="keyword">function</span>(<span class="params">args, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Flatten any nested arrays</span></span><br><span class="line">    args = concat.apply([], args);</span><br><span class="line">    <span class="comment">// We can't cloneNode fragments that contain checked, in WebKit</span></span><br><span class="line">    <span class="keyword">if</span> (isFunction ||</span><br><span class="line">        <span class="comment">//多参数处理</span></span><br><span class="line">        self.domManip(args, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l) &#123;</span><br><span class="line">        <span class="comment">//生成文档碎片</span></span><br><span class="line">        fragment = jQuery.buildFragment(args, <span class="keyword">this</span>[<span class="number">0</span>].ownerDocument, <span class="literal">false</span>, <span class="keyword">this</span>);</span><br><span class="line">        callback.call(<span class="keyword">this</span>[i], node, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察下jQuery的实现，通过抽象出一个domManip方法，然后在这个方法中处理共性，合并多个参数的处理与生成文档碎片的处理，然后最终把结果通过回调函数返回给每一个调用者。</p><p><strong>例子二：</strong></p><p>在很多时候需要控制一系列的函数顺序执行。那么一般就需要一个队列函数来处理这个问题。</p><p>我们看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Ulson(List, callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        var task;</span><br><span class="line">        if (task = List.shift()) &#123;</span><br><span class="line">            task(); //执行函数</span><br><span class="line">        &#125;</span><br><span class="line">        if (List.length &gt; 0) &#123; //递归分解</span><br><span class="line">            arguments.callee(List)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 25)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">Ulson([</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;a&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;b&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;c&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">], function() &#123;</span><br><span class="line">    alert(&apos;callback&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 分别弹出 ‘a’ , ‘b’ ,&apos;c&apos;,’callback</span><br></pre></td></tr></table></figure><p>传入一组函数参数，靠递归解析，分个执行，其实就是靠setTimeout可以把函数加入到队列末尾才执行的原理，这样的写法就有点就事论事了，聚合对象完全是一个整体，无法再次细分出来，所以我们需要一种方案，用来管理分离每一个独立的对象。</p><p><strong>我们换成jQuery提供的方式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;a&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;b&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.fire(); //输出结果: &apos;a&apos; &apos;b&apos;</span><br></pre></td></tr></table></figure><p>是不是便捷很多了，代码又很清晰，所以Callbacks它是一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。</p><p>那么我们使用回调函数，总的来说<strong>弱化耦合</strong>，让调用者与被调用者分开，调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件的被调用函数。</p><h2>理解观察者模式</h2><p>讲解jQuery回调对象之前，我们有必要先理解其背后的设计思想 - “观察者模式”。</p><p>观察者模式 (pub/sub) 的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。观察者也被叫作订阅者（Subscriber），它指向被观察的对象，既被观察者（Publisher 或 subject)。当事件发生时，被观察者（Publisher）就会通知观察者（subscriber）。</p><p><strong>观察者的使用场合</strong></p><p>观察者的使用场合就是：<strong>当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式</strong>。先看官网的demo这个例子，涉及到了 add 与 fire方法，熟悉设计模式的童鞋呢，一眼就能看出，其实又是基于发布订阅（Publish/Subscribe）的观察者模式的设计。</p><p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统，将 $.Callbacks 作为一个队列。</p><p><strong>我们来模拟常规下最简单的实现：</strong></p><p>JS里对观察者模式的实现是通过回调来实现的，我们来先定义一个Observable对象，其内部包含了2个方法：订阅add方法与发布fire方法，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用add开始订阅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(1)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用fire开始发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.fire(); // 1, 2</span><br></pre></td></tr></table></figure><p><strong>设计的原理：</strong></p><p>开始构建一个存放回调的数组，如<code>this.callbacks= []</code>添加回调时，将回调push进this.callbacks，执行则遍历this.callbacks执行回调，也弹出1跟2了。当然这只是简洁的设计，便于理解，整体来说设计的思路代码都是挺简单的，那么我们从简单的设计深度挖掘下这种模式的优势。</p><p>注意：如果没有做过复杂交互设计，或者大型应用的开发者，可能一开始无法理解这模式的好处，就简单的设计而言用模式来处理问题，有点把简单的问题复杂化。我们不是为了使用模式而使用的。</p><p><strong>组件开发为了保证组件可以在不同的项目中都适用，其必须是对其常用功能抽象出来加以实现，绝不会包含具体的业务逻辑而某一特定的项目使用者在其业务场景中使用组件时不可避免的要加入不同场景的业务逻辑。</strong></p><h2>模式的实际运用</h2><p>在进行组件开发中，为了保证组件可以在不同的类似项目场景中都能适用，那么就必须是对其常用功能抽象出来加以实现。</p><p>我们来看看具体的实际用处：</p><p>假设一段ajax的请求，成功后通过done返回结果数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"test.html"</span>,</span><br><span class="line">  context: <span class="built_in">document</span>.body</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//data数据的处理</span></span><br><span class="line">  $(<span class="string">'aaron1'</span>).html(data.a)</span><br><span class="line">  $(<span class="string">'aaron2'</span>).html(data.b)</span><br><span class="line">  $(<span class="string">'aaron3'</span>).html(data.c)</span><br><span class="line">  <span class="comment">//其余处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>咋一看好像都挺好，没什么问题，但是仔细观察我们会发现所有的逻辑是不是都写在done方法里面，这样确实是无可厚非的，但是问题就是逻辑太复杂了。Done里面有数据处理、html渲染、还可能有其它不同场景的业务逻辑。这样如果是换做不同的人去维护代码，增加功能就会显得很混乱而且没有扩展性。那么观察者模式能很好的解决了这个的问题。</p><p>我们优化下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">    pocessData()</span><br><span class="line">    pocessHtml()</span><br><span class="line">    pocessOther()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessData() &#123;</span><br><span class="line">    //处理数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessHtml() &#123;</span><br><span class="line">    $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">    $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">    $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessOther() &#123;</span><br><span class="line">    //处理其他逻辑</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处是，分离出各种的业务函数，从而降低了代码之间的耦合度，但是这样代码写法几乎就是“就事论事”的处理，达不到<strong>抽象复用</strong>。</p><p>那么我们用之前的观察者模式加工一下上面的代码：（这只是伪代码，用于理解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessData</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">  $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">  $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessOther</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">  Observable.fire(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>设计该模式背后的主要动力是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称为观察者，而被观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者并且可能经常以事件对象的形式传递消息。</p><p>总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;fn(data);&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    arg.successful(arg.data+ <span class="string">',返回获取到后台的数据'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用add开始订阅：</span></span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_one: '</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_two: '</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一段ajax请求，成功后处理</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  data:<span class="string">'Hello'</span>,</span><br><span class="line">  successful:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    Observable.fire(data); <span class="comment">//触发动作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2>jQuery回调对象</h2><p>jQuery.Callbacks一般开发者接触的很少，虽然jQuery向开发者提供了外部接口调用，但是$.Callbacks()模块的开发目的是为了给内部$.ajax() 和 $.Deferred()模块提供统一的基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p><p>jQuery.Callbacks是jquery在1.7版本之后加入的，是从1.6版中的_Deferred对象中抽离的，主要用来进行函数队列的add、remove、fire、lock等操作，并提供once、memory、unique、stopOnFalse四个option进行一些特殊的控制。</p><p>这个函数常见的应用场景是事件触发机制，也就是设计模式中的观察者模式的发布、订阅机制，目前Callbacks对象用于queue、ajax、Deferred对象中，本小节主要是一些简单的例子去理解的使用。</p><p>我们看官网提供的demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将上述两个方法作为回调函数，并添加到 $.Callbacks 列表中，并按下面的顺序调用它们:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line"><span class="comment">// outputs: foo!</span></span><br><span class="line">callbacks.fire(<span class="string">"foo!"</span>);</span><br><span class="line">callbacks.add(fn2);</span><br><span class="line"><span class="comment">// outputs: bar!, fn2 says: bar!</span></span><br><span class="line">callbacks.fire(<span class="string">"bar!"</span>)</span><br></pre></td></tr></table></figure><p>这样做的结果是，当构造复杂的回调函数列表时，将会变更很简单。可以根据需要，很方面的就可以向这些回调函数中传入所需的参数。</p><p>上面的例子中，我们使用了 $.Callbacks() 的两个方法: .add() 和 .fire()。 .add() 和 .fire() .add() 支持添加新的回调列表, 而.fire() 提供了一种用于处理在同一列表中的回调方法的途径。</p><p>另一种方法是$.Callbacks 的.remove()方法，用于从回调列表中删除一个特定的回调。下面是.remove()使用的一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">// outputs: foo!</span><br><span class="line">callbacks.fire( &quot;foo!&quot; );</span><br><span class="line">callbacks.add( fn2 );</span><br><span class="line">// outputs: bar!, fn2 says: bar!</span><br><span class="line">callbacks.fire( &quot;bar!&quot; );</span><br><span class="line">callbacks.remove( fn2 );</span><br><span class="line">// only outputs foobar, as fn2 has been removed.</span><br><span class="line">callbacks.fire( &quot;foobar&quot; );</span><br></pre></td></tr></table></figure><p>这个运用内部就是观察者模式的一种设计实现，只是相对比较复杂。我们看看jQuery的回调函数到底为哪些模块服务？</p><p>异步队列模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deferred: function(func) &#123;</span><br><span class="line">  var tuples = [</span><br><span class="line">    // action, add listener, listener list, final state</span><br><span class="line">    [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">    [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">    [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">  ]，………….</span><br></pre></td></tr></table></figure><p>队列模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_queueHooks: function(elem, type) &#123;</span><br><span class="line">  var key = type + &quot;queueHooks&quot;;</span><br><span class="line">  return data_priv.get(elem, key) || data_priv.access(elem, key, &#123;</span><br><span class="line">    empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() &#123;</span><br><span class="line">      data_priv.remove(elem, [type + &quot;queue&quot;, key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ajax模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax: function(url, options) &#123;</span><br><span class="line">  //省略代码</span><br><span class="line">  deferred = jQuery.Deferred(),</span><br><span class="line">  completeDeferred = jQuery.Callbacks(&quot;once memory&quot;)</span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现jQuery.Callbacks还提供“once memory”等参数用来处理：</p><p>☑  once: 确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)。</p><p>☑  memory: 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p><p>☑  unique: 确保一次只能添加一个回调(所以在列表中没有重复的回调)。</p><p>☑  stopOnFalse: 当一个回调返回false 时中断调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks(<span class="string">'once'</span>);</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'a'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'b'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.fire(); <span class="comment">//输出结果: 'a' 'b'</span></span><br><span class="line">callbacks.fire(); <span class="comment">//未执行</span></span><br></pre></td></tr></table></figure><p>once的作用是使callback队列只执行一次。</p><p>最后，我们大概知道这个是干嘛用的了，可以开始上正菜了。</p><h2>jQuery回调模块结构</h2><p>整个$.Callbacks的源码很少，它是一个工厂函数，使用函数调用（非new，它不是一个类）创建对象，它有一个可选参数flags用来设置回调函数的行为，对外的接口也就是self的返回。</p><p>jQuery.Callbacks()的API列表如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callbacks.add()        ：回调列表中添加一个回调或回调的集合。</span><br><span class="line">callbacks.disable()    ：禁用回调列表中的回调。</span><br><span class="line">callbacks.disabled()   ：确定回调列表是否已被禁用。 </span><br><span class="line">callbacks.empty()      ：从列表中删除所有的回调。</span><br><span class="line">callbacks.fire()       ：用给定的参数调用所有的回调。</span><br><span class="line">callbacks.fired()      ：访问给定的上下文和参数列表中的所有回调。 </span><br><span class="line">callbacks.fireWith()   ：访问给定的上下文和参数列表中的所有回调。</span><br><span class="line">callbacks.has()        ：确定列表中是否提供一个回调。</span><br><span class="line">callbacks.lock()       ：锁定当前状态的回调列表。</span><br><span class="line">callbacks.locked()     ：确定回调列表是否已被锁定。</span><br><span class="line">callbacks.remove()     ：从回调列表中的删除一个回调或回调集合。</span><br></pre></td></tr></table></figure><p>源码结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.Callbacks = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?</span><br><span class="line">        (optionsCache[options] || createOptions(options)) :</span><br><span class="line">        jQuery.extend(&#123;&#125;, options);</span><br><span class="line">    <span class="comment">//实现代码</span></span><br><span class="line">    fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    self = &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        has: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;&#125;,</span><br><span class="line">        empty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disable: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disabled: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        lock: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        locked: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fireWith: <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;&#125;,</span><br><span class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fired: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个结构要分三部分：</p><p>☑   Options参数缓存</p><p>☑   内部fire触发器的设计</p><p>☑   外部</p><p><strong>参数的缓存设计</strong></p><p>Callbacks是可以是接受的字符串的组合传参数，可以使用空格分割，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var opts = &apos;unique memory&apos;;</span><br><span class="line">var object = &#123;&#125;</span><br><span class="line">jQuery.each(opts.match(/\S+/g) || [], function(_, flag) &#123;</span><br><span class="line">  object[flag] = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的操作其实是不需要重复的，所以我们可以设计一个缓存池，用来储存重复的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var optionsCache = &#123;&#125;;</span><br><span class="line">function createOptions(options) &#123;</span><br><span class="line">  var object = optionsCache[options] = &#123;&#125;;</span><br><span class="line">  jQuery.each(options.match(rnotwhite) || [], function(_, flag) &#123;</span><br><span class="line">    object[flag] = true;</span><br><span class="line">  &#125;);</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们传递参数的时候，如果参数是字符串，我们可以直接从optionsCache缓存中去查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = typeof options === &quot;string&quot; ?</span><br><span class="line">        ( optionsCache[ options ] || createOptions( options ) ) :</span><br><span class="line">        jQuery.extend( &#123;&#125;, options );</span><br></pre></td></tr></table></figure><p><strong>接口的设计：</strong></p><p>通过学习了观察者模式的思路，我们知道callback需要在内部维护着一个list的队列数组，用于保存订阅的对象数据。同时也需要提供了add、remove、fire等订阅、发布、删除类似的接口。</p><p>那么我们代码是不是很简单是就是把订阅对象给push给内部list列表？</p><p>实现思路就是: 构建一个存放回调的数组，如<code>var list = []</code>，通过闭包使这条回调数组保持存在。添加回调时，将回调push进list，执行则遍历list执行回调。</p><p>后面几节我们会通过简单的模拟实现去剖析设计的思路。</p><h2>默认回调对象设计</h2><p>不传入任何参数，调用add的时候将函数add到内部的list中，调用fire的时候顺序触发list中的回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says:&apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks();</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">console.log(&apos;........&apos;)</span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;)</span><br></pre></td></tr></table></figure><p>结果就是按照顺序叠加触发，如下列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn1 says:foo </span><br><span class="line">………………………</span><br><span class="line">fn1 says:bar </span><br><span class="line">fn2 says bar</span><br></pre></td></tr></table></figure><p>这种就是最简单的处理了，可以直接模拟，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks() &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      list.forEach(function(fn) &#123;</span><br><span class="line">        fn(args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>once的设计</h2><p>这一小节我们来讲一下once。</p><p>once的作用确保回调列表只执行（.fire()）一次(像一个递延 Deferred)，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val)&#123;</span><br><span class="line">    console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br></pre></td></tr></table></figure><p>结果你会发现cbs.fire(‘foo’)只执行了一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo  //只显示一次</span><br></pre></td></tr></table></figure><p>once定义是很明确的，确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)，所以针对这种once的处理可以有多种不同的途径实现。</p><p>1、add的时候抛弃</p><p>2、在fire的时候抛弃多个。</p><p>但是jQuery是在执行第一个fire的时候直接给清空list列表了，然后在add的地方给判断下list是否存在，从而达到这样的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        list.forEach(function(fn) &#123;</span><br><span class="line">          fn(args);</span><br><span class="line">        &#125;)</span><br><span class="line">        if (options === &apos;once&apos;) &#123;</span><br><span class="line">          list = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在fire之后，判断参数是否为once，直接把list给清理掉，所以之后的所有fire都被抛弃掉了，而从达到了once的效果。</p><p><strong>jQuery.Callbacks的处理</strong></p><p>在fire中调用了 self.disable(); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 禁用回调列表中的回调。</span><br><span class="line">disable: function() &#123;</span><br><span class="line">    list = stack = memory = undefined;</span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>memory的设计</h2><p>memory：保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p><p>回调函数是从异步队列Deferred分离出来的，所以很多的接口设计都是为了契合Deferred接口，memory用的很多，这个缓存的设计这里提及一下</p><p>主要是用来实现deferred的异步收集与pipe管道风格的数据传递的，具体在Deferred有详解，这里大概了解下作用范围。</p><p>memory这个有点不好理解，我们还是通过列子说明下，看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var cbs = Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn3(val) &#123;</span><br><span class="line">  console.log(&apos;fn3 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cbs = $.Callbacks(&apos;memory&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line"></span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line">cbs.add(fn3);</span><br><span class="line">cbs.fire(&apos;aaron&apos;);</span><br></pre></td></tr></table></figure><p>结果可以看出，我们在执行cbs.add(fn2);的时候，此时除了把fn2添加到了回调队列之外而且还立刻执行了这个方法，唯一的区别就是，参数是用的之前的。所以解释就叫“<strong>保持以前的值</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo </span><br><span class="line">.......... </span><br><span class="line">fn2 says foo </span><br><span class="line">fn1 says bar </span><br><span class="line">fn2 says bar </span><br><span class="line">.......... </span><br><span class="line">fn3 says bar </span><br><span class="line">fn1 says aaron </span><br><span class="line">fn2 says aaron </span><br><span class="line">fn3 says aaron</span><br></pre></td></tr></table></figure><p>所以这个<code>memory</code>设计需要解决的问题就是：</p><p>1：如何取到上一个参数</p><p>2：add后如何执行</p><p>看看我们实现的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callbacks</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = [];</span><br><span class="line">  <span class="keyword">var</span> self;</span><br><span class="line">  <span class="keyword">var</span> firingStart;</span><br><span class="line">  <span class="keyword">var</span> memory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fire</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    memory = options === <span class="string">'memory'</span> &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || <span class="number">0</span>;</span><br><span class="line">    firingStart = <span class="number">0</span>;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    <span class="keyword">for</span> (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> start = list.length;</span><br><span class="line">      list.push(fn)</span><br><span class="line">      <span class="keyword">if</span> (memory) &#123;</span><br><span class="line">        firingStart = start; <span class="comment">//获取最后一值</span></span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   fire: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先add之后要能触发fire的动作，所以我们把fire作为内部的一个私有方法实现_fire，比较合逻辑，这样外部的fire只是一个门面方法的调用。</p><p>私有变量memory缓存这上一个参数的属性，我们靠firingStart用来定位最后通过add增加的回调数据的索引。在遍历的时候直接通过firingStart的起始索引定位，然后传递memory的参数，而且实现这种“保持以前的值”的设计。</p><h2>unique的设计</h2><p>Unique：确保一次只能添加一个回调(所以在列表中没有重复的回调)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var callbacks = $.Callbacks( &quot;unique&quot; );</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.add( fn1 ); // repeat addition</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.fire( &quot;foo&quot; );</span><br></pre></td></tr></table></figure><p>结果：过滤了相同的add操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo</span><br></pre></td></tr></table></figure><p>过滤重复的比较简单，因为是数组的保存方式，我们可以在入口处通过indexOf判断即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>stopOnFalse</h2><p>stopOnFalse: 当一个回调返回false 时中断调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var callbacks = $.Callbacks(&quot;stopOnFalse&quot;);</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line">callbacks.fire(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">callbacks.add(fn2);</span><br><span class="line">callbacks.fire(&quot;bar&quot;);</span><br></pre></td></tr></table></figure><p>结果虽然fn1被添加到了回调列表，但是因为fn1返回了false，那么意思之后的回调都不会被调用了。如果还有fn3，在f2上返回false，fn3也将不会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p></p><p>这个设计我们只要控制好函数返回的处理的布尔值，通过这个值用来判断是否需要下一个遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex =</span><br><span class="line">      firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是几种单独的处理情况的用法，我们可以看到jQuery都是组合使用的，最常见的就是</p><p>jQuery.Callbacks(“once memory”)的组合了，其实以上的思路都讲解过了，无非就是组合起来的时候要考虑一些判断了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>2017年(Lunar Year)读书与看剧</title>
    <link href="http://yoursite.com/2018/02/15/Lunar_Year/"/>
    <id>http://yoursite.com/2018/02/15/Lunar_Year/</id>
    <published>2018-02-14T16:00:00.000Z</published>
    <updated>2018-02-23T07:34:30.872Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>小确幸：一个人不总是能让自己的工作有意义，或者同人类的伟大征程发生本质联系。创造出新东西是困难的，命运可能既没有提供资源和天分，也没有提供位置和环境。但反求诸己是可能的，去动手，去克服自己的积习，改造自己的反射，克服不断分泌的多巴胺的诱惑，意识到平庸并不等于无聊和自鸣得意，付出努力去获取知识，获取灵活的身体，理解自己在这个快速变动的世界上的角色，不是为了忍耐，而是为了——如淡豹所说的那样——找到自己的叙事。</p></blockquote><a id="more"></a><h3>读书（文学类）</h3><p>加缪. 《鼠疫》朱光潜.《西方美学史》 <em>读的慢，忘的快</em>乔治·奥威尔. 《1984》乔治·奥威尔. 《动物农庄》艾玛·拉金《在缅甸寻找乔治·奥威尔》凯鲁亚克. 《在路上》白先勇 《台北人》尤瓦尔·赫拉利 《人类简史:从动物到上帝》尤瓦尔, 赫拉利. 《未来简史》斯蒂芬·茨威格. 《人类群星闪耀时》尼古拉斯·斯帕克思. 《分手信》卡勒德·胡赛尼. 《群山回唱》费孝通. 《乡土中国》</p><h3>读书（自我提高及工具书）</h3><p>李忠秋. 《结构思考力》尼尔·布朗《学会提问》布鲁克·诺埃尔·摩尔《批判性思维》读自我提高类书籍本意在于提升自身逻辑思考能力，上面几本书能够很好的达到目的。Johnson. 实用多元统计分析.RobertV.Hogg. 数理统计学导论张维迎. 博弈论与信息经济学Nasrabadi, Nasser M. “Pattern recognition and machine learning.”</p><h3>看剧</h3><p>《怦然心动》- 纯爱类影片，学会从整体审视生活《时空恋旅人》 - 看完觉得幸福了一辈子《饮食男女》 - 人之大欲，不过饮食男女《闻香识女人》 - 善良、正直，是走得多远都不能丢弃的道德品质《海边的曼彻斯特》 - 每个人都是一座孤独的岛《东京爱情故事》 - 爱情是个很难说的事儿吧，thank you，赤名莉香《白色巨塔》- 过程正义与结果正义《NANA》 - 主题曲很好听《熔炉》 - 不想评论，谢谢《聚焦》 - 同上《两杆大烟枪》 - 同《低俗小说》《疯狂的石头》，贵在叙事方式《傲慢与偏见》、《罗马假日》、《南丁格尔》、《乱世佳人》还说什么，都是经典，无论看几遍，都能品出味道来.</p><blockquote><p>和子由渑池怀旧 <em>苏轼</em>人生到处知何似，应似飞鸿踏雪泥。泥上偶然留指爪，鸿飞那复计东西。老僧已死成新塔，坏壁无由见旧题。往日崎岖还知否，路长人困蹇驴嘶。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;小确幸：一个人不总是能让自己的工作有意义，或者同人类的伟大征程发生本质联系。创造出新东西是困难的，命运可能既没有提供资源和天分，也没有提供位置和环境。但反求诸己是可能的，去动手，去克服自己的积习，改造自己的反射，克服不断分泌的多巴胺的诱惑，意识到平庸并不等于无聊和自鸣得意，付出努力去获取知识，获取灵活的身体，理解自己在这个快速变动的世界上的角色，不是为了忍耐，而是为了——如淡豹所说的那样——找到自己的叙事。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="文字" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>优化算法篇之牛顿法</title>
    <link href="http://yoursite.com/2018/01/14/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
    <id>http://yoursite.com/2018/01/14/优化算法篇之牛顿法/</id>
    <published>2018-01-13T16:00:00.000Z</published>
    <updated>2018-02-23T07:35:12.343Z</updated>
    
    <content type="html"><![CDATA[<p>我们在接触具体的机器学习算法前，其实很有必要对优化问题进行一些介绍。随着学习的深入，笔者越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。</p><a id="more"></a><p>最常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度方向法等。在大学课程中，数值分析是计算机或数学相关专业一门比较重要的一门课程，笔者也在大学时自学过相关课程，其介绍的诸多对理论的计算机实现方法，对现在的学习依然发挥着很大的作用。当然优化算法只是数值分析课程中涉及一部分内容，这一节主要介绍和回顾牛顿法。</p><h2>牛顿法</h2><p>上节介绍的梯度下降法（最速下降法）只用到了目标函数的一阶导数，牛顿法是一种二阶优化算法，相对于梯度下降算法收敛速度更快。首先，选择一个接近函数$f(x)$零点的$x_0$，计算相应的$f(x_0)$ 和切线斜率$f ’ (x_0)$。然后我们计算穿过点$(x_0,  f(x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $X$轴的交点的$x$坐标，也就是求如下方程的解：$f(x_0)+f’(x_0)*(x-x_0)=0$我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x) = 0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示：</p><p>$$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$牛顿法是基于当前位置的切线来确定下一次的位置，所以牛顿法又被很形象地称为是&quot;切线法&quot;。牛顿法的搜索路径（二维情况）如下图所示：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif?_=4751804" alt="newton"></p><h4>缺点</h4><p>牛顿法也有很大的缺点，就是每次计算都需要计算Hessian矩阵的逆，因此计算量较大。</p><h3>拟牛顿法</h3><p>拟牛顿法在一定程度上解决了牛顿法计算量大的问题。其本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它<strong>使用正定矩阵来近似Hessian矩阵的逆</strong>，从而简化了运算的复杂度。（在多变量的情况下，如果目标矩阵的Hessain矩阵非正定，牛顿法确定的搜索方向并不一定是目标函数下降的方向）拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><h4>拟牛顿法的Matlab实现：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#函数名：quasi_Newton(f,x0,error), </span><br><span class="line">#参数：f:待求梯度函数   x0:初始点   error：允许误差 </span><br><span class="line">#主程序： </span><br><span class="line">function A=quasi_Newton(f,x0,error) </span><br><span class="line">     [a,b]=size(x0); </span><br><span class="line">     G0=eye(b); </span><br><span class="line">     initial_gradient=gradient_my(f,x0,b); </span><br><span class="line">     norm0=0; </span><br><span class="line">     norm0=initial_gradient*initial_gradient&apos;; </span><br><span class="line">     syms step_zzh; </span><br><span class="line">     A=[x0]; </span><br><span class="line">     search_direction=-initial_gradient; </span><br><span class="line">     x=x0+step_zzh*search_direction; </span><br><span class="line">     f_step=subs(f,findsym(f),x); </span><br><span class="line">     best_step=golden_search(f_step,-15,15); </span><br><span class="line">     x_1=x0+best_step*search_direction; </span><br><span class="line">     A=[A;x_1]; </span><br><span class="line">     k=1; </span><br><span class="line">while norm0&gt;error </span><br><span class="line">     ox=x_1-x0; </span><br><span class="line">     og=gradient_my(f,x_1,b)-initial_gradient; </span><br><span class="line">     G1=G0+(ox&apos;*ox)/(ox*og&apos;)-(G0*og&apos;*og*G0)/(og*G0*og&apos;); </span><br><span class="line">     if  k+1==b </span><br><span class="line">         new_direction=-gradient_my(f,x_1,b); </span><br><span class="line">     else </span><br><span class="line">         new_direction=-(G1*(gradient_my(f,x_1,b))&apos;)&apos;; </span><br><span class="line">     end </span><br><span class="line">     x=x_1+step_zzh*new_direction; </span><br><span class="line">     f_step=subs(f,findsym(f),x); </span><br><span class="line">     best_step=golden_search(f_step,-15,15) </span><br><span class="line">     x_2=x_1+best_step*new_direction </span><br><span class="line">     A=[A;x_2]; </span><br><span class="line">     initial_gradient=gradient_my(f,x_1,b); </span><br><span class="line">     norm0=initial_gradient*initial_gradient&apos;; </span><br><span class="line">     x0=x_1;x_1=x_2; </span><br><span class="line">     G0=G1; </span><br><span class="line">     k=k+1; </span><br><span class="line">end</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我们在接触具体的机器学习算法前，其实很有必要对优化问题进行一些介绍。
随着学习的深入，笔者越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mathematic" scheme="http://yoursite.com/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>写在大三下学期</title>
    <link href="http://yoursite.com/2017/03/22/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%B8%89%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
    <id>http://yoursite.com/2017/03/22/写在大三下学期/</id>
    <published>2017-03-22T05:20:09.000Z</published>
    <updated>2018-02-23T07:34:04.921Z</updated>
    
    <content type="html"><![CDATA[<p>大学时光经不起回味，一眨眼的时间，大学生生活已经步入尾声，随之而来的就该是毕业季的伤感了。步入大三的同学们，都在为步入”社会“摩拳擦掌，该考研的考研，该工作的工作。即使是平时班上最不爱学习的，也时不时开始向人打听起公务员考试的相关事宜了 :blush::blush:</p><a id="more"></a><h2>时代的浪潮已经拍到了我们这代人的脚下</h2><p>每每看到知乎上“大三了，考研还来得及吗？”，“大三了，学计算机还来得及吗？”诸如此类的问题，总也庆幸自己两年多的时间做了一些事读了一些书，但我知道自己做的还远远远远不够看。大三的生活，伴着毕业的步伐，来的匆匆。自己的学年论文加上向老师申请的论文，学的懵懂的专业课，还得挤出时间来为考研蓄力，冷不丁还夹带点感情的纠结。Flag ～</p><blockquote><p>时光总是匆匆的催人老，情爱总是让人烦恼。</p></blockquote><h2>写博客的初衷</h2><p>大脑的存储空间是有限的，为了让新知识进来，你就得把暂时用不上旧知识遗忘掉。但是，自己当时花了那么多宝贵时间，一步一步摸索着过来所接触到的总结过的知识点，就这样被遗忘，或者被藏在某本笔记本的角落是在太可惜。当你怀着一颗热忱的心去进入一个领域，你只有从宏观上清楚了行业整体，从微观上把握住各个知识点原理，才算得上入门选手。</p><p>为此，记录下来并且可查可复习非常重要，这也就是Blog能为我提供的。</p><p><em>性格决定你做怎样的选择，你的选择决定你怎样的人生。生命只有一次，而且它正在以不可逆转的姿态向前推进。你可以去旅行，可以朝九晚五地上班，还可以不顾一切地去创业。只是，千万不要选择平庸的人生。</em></p><blockquote><p>黄色的树林里分出两条路，可惜我不能同时去涉足，我在那路口久久伫立，我向着一条路极目望去，直到它消失在丛林深处。</p></blockquote><blockquote><p>但我选了另外一条路，它荒草萋萋，十分幽寂，显得更诱人，更美丽；虽然在这条小路上，很少留下旅人的足迹。</p></blockquote><blockquote><p>那天清晨落叶满地，两条路都未经脚印污染。啊，留下一条路等改日再见！但我知道路径延绵无尽头，恐怕我难以再回返。</p></blockquote><blockquote><p>也许多少年后在某个地方，我将轻声叹息将往事回顾：一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。——罗伯特·弗罗斯特《未选择的路》</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;大学时光经不起回味，一眨眼的时间，大学生生活已经步入尾声，随之而来的就该是毕业季的伤感了。
步入大三的同学们，都在为步入”社会“摩拳擦掌，该考研的考研，该工作的工作。即使是平时班上最不爱学习的，也时不时开始向人打听起公务员考试的相关事宜了 :blush::blush:&lt;/p&gt;
    
    </summary>
    
    
      <category term="文字" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>「如何高效的学习」读书笔记</title>
    <link href="http://yoursite.com/2017/03/22/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2017/03/22/如何高效学习/</id>
    <published>2017-03-21T16:00:00.000Z</published>
    <updated>2018-02-23T07:35:03.509Z</updated>
    
    <content type="html"><![CDATA[<p>《如何高效学习》从学习的战略上指导学习知识的策略抛出整体性学习的概念，以及结构、模型、高速公路的观点;详细分析了学习的顺序和信息的分类。以战术的方式分解学习的各种战术，如快速阅读、笔记流、比喻法、内在化、联想法、图表法、挂钩法、信息压缩、知识应用、模型纠错等。下面是我阅读时写下的感想，比较少的书摘。</p><a id="more"></a><h3>1. 类比</h3><p>首先，类比是一个推理方法。其次，类比是把两个具有相似或者相同特征的对象进行推理它们具有其他相似或相同特征的方法。</p><h3>2. 概括</h3><p>读书，将核心用词语总结概括，是最好的学习习惯，只有这样，知识才真正理解，被你加工，通过联想、概括出自己的观点和想法，知识才被刚刚固化，为了知识更加牢固，还需要将知识进行实践运用，知识最好的实践方式就是传播，传播有时候会收到很多不同意见。相互碰撞，如果你能简单轻松的让他们理解并认可你的观点，说明你基本吃透这个知识点。他们当中的不同声音会让你更加容易固化你的知识点，尝试让他们也信服你如果你是正确的。</p><h3>3. 知识纵向拓展</h3><p>知识纵向拓展，寻根究底。如学习企业管理知识，企业管理包含了财务、人事等管理，那么财务管理是怎样的，人事管理又是怎样的?再深入财务和人事管理里面的各种细节。结合自己所在公司，思考为什么要这样管理，自己公司是这样管理的吗?别人公司是怎样管理的，自己公司和别的公司管理上有什么差别，如何改进?这就是深度拓展，不断深挖细节。</p><h3>4. 知识横向拓展</h3><p>知识横向拓展，昨天在印象笔记整理文章的时候，正好看到营销这个词，于是就把各类营销词汇整理了一番，方便以后学习归档，如病毒营销、邮件营销、关系营销、内容营销、事件营销等等，可能里面多个营销方式有很多共同点，分别找出来，也有不同点把它们区别开，这些营销方式适合什么场景下使用，适合企业的什么阶段使用，需要哪些辅助工作才能完成，成本多少?这就是横向拓展，通过知识与知识的联系发现他们共同点和不同点，找出他们的差异化，其实横向拓展和纵向拓展是不会绝对分开，当你开始比较的时候，大脑其实就进入了深度拓展和横向拓展，多思考多关联多实践多PK。</p><h3>5. 结构：理解就是结构高度发达完善的结果。</h3><p>理解的重要性，一个人看书是否学到东西，看他的笔记和读后感就知道，如果这个人笔记和读后感总结都是勾画的原作者的文字，这是较少理解，不够深入，最差的理解是读书笔记和读后感都没有的，也是最差的学习方式，刚刚说的这些话都是错误的!　　真正理解，是可以通过结构化思维表达出来。理解帮忙我们把知识结构化，总感觉这里翻译的有问题，只有理解后的知识才便于储存，便于在大脑里结构化。怎么来理解呢?举个例子　　当我们阅读&quot;理解就是结构高度发达完善的结果&quot;的时候，如果很快就弄懂了这句话，这句话可能就相当于电脑内存中的一行数据，当我们阅过这句话，看到下段文字的时候这句话已经从内存中消失。但恰巧我读到时候，有意识觉得这里可以写点什么，就反复读了几遍，理解是结构发达的结果，理解是名词，结构发达是短语，结果是名词是产出物，正确说法是因为〖怎么样〗所以〖造成这个结果〗，那么就应该是因为理解所以造成结构发达的结果。修改后：结构高度发达完善就是理解的结果。　　有点咬文嚼字，扯远了，当我开始纠结这句话，大脑其实在高速运转，调动了我大脑磁盘里的相关信息来帮助我理解这句话，并做出推断。然后这句话就会固化在我的大脑磁盘里，不是一闪而过的内存数据，同时我刚刚调用过的知识再次被激活得以运用，知识就是越来应用的，不用就不属于你的知识。　　我不敢说解释得很明白，希望你们能够看到我对一字一句的理解，以及我狭小硬盘储存的不是特别完善的知识结构是如何被调用的。　　我在这里有意的写笔记是为了培养以后习惯性的思考。</p><h3>6. 模型：模型就像是结构的种子，是一座建筑的地基和框架，是知识最核心的概念，在此基础上将引伸出全部的知识。</h3><p>先回顾，整体性学习的三个重要概念：结构，模型，高速公路。当我读完模型这一小节，我的脑子里浮现出类似原子的东西，在黑色的空间里自由漂浮，每个原子并不孤立，它们之间有一条耀眼的类似光线的&quot;脐带&quot;互相交错连接，这条连接线经常是一团亮斑从原子这头快速移动到另一头，所以看整体非常耀眼，其实这就是知识的传递与连接。　　现在看来，模型就是知识的最小结构，知识的结构由无数的模型和连接组成，我不知道我理解的连接是不是笔者的高速路公路，带着问题继续往下读，等待犹如开奖的那一惊心动魄。</p><h3>7. 高速公路：结构与结构之间的联系。</h3><p>高速公路的比喻用得非常精准，这是城际之间的快速通道，是连接结构与结构之间的线路。这条线路传递和连接的知识(不是知识点，模型才是知识点)将以光速进行传递，也就是我们常说的一念之间。结构是模型的集合，模型与模型之间相互交错连接，结构与结构之间交错连接。知识点互相关联，知识互相连接交错。完美的一幅图画，黑暗的空间，一个个大型的分子，分子是若干原子的集合，是原子的仓库，不断有新的原子增加或者删除，我能清晰的透过分子的透薄如水的墙壁看到原子瞬间增加和破灭的过程，每个原子其中的若干连接线突然断裂，它在瞬间被孤立最后立即消亡，这是一个正常情况无法看到感知到的过程。分子的存亡和原子的存活方式完全不一样，只要有一个原子存在，依靠这类原子组成的分子就不会死亡。</p><h3>8. 结构分类</h3><p>成熟结构、感知结构、生活经验、关系结构、基础数学结构</p><h3>9. 学习顺序</h3><p>获取、理解、拓展、纠错、应用，测试伴随以上每一步，总结自省伴随以上每一步。</p><h3>10. 信息获取</h3><p>信息获取，信息大爆炸的今天我们随时都能接触到海量信息，信息获取渠道非常丰富，百度、百科、知道、知乎、各类APP、新闻网站、社交媒体、自媒体等等，所以我们要提高信息获取的手段和筛选方法。</p><ul><li>订阅，订阅自己关注的内容或则话题</li><li>筛选，使用印象笔记或有道云笔记以及剪藏功能，把自己粗读有价值的信息收集整理，记得设置标签，方便以后索引。</li><li>(3) 定时整理笔记工具里的内容，整理成文章总结，将信息进行归类。总结的时候可以根据内容进行发散联想，拓展更广的话题，写下来整理成文章，这就是你的学习所得。</li></ul><h3>11. 信息获取方法</h3><p>精简信息、增加信息获取的数量和信息来源、提高阅读速度效率</p><h3>12. 信息拓展方法</h3><p>深度拓展、纵向拓展、横向拓展</p><h3>13.信息获取小结</h3><p>一句话概括，通过不同手段获取知识，不断理解深入研究，拓展和联想相关知识，不断纠错判断，沉淀正确的知识并实践应用。　　拓展知识有三个方法，深度拓展、横向拓展、纵向拓展，深度拓展又可以理解为背景拓展，主要了解知识形成的背景、原因和过程，深度拓展和纵向理解容易造成误会，所以固化背景拓展最佳。　　关于信息获取每一步的测试单独说下：</p><ul><li>获取——是否看过听过，如果看过比较了解可以略过，进入初期筛选</li><li>理解——真的明白了知识点的含义了吗?是否可以用最简单的语言和比喻解释清楚</li><li>拓展——知识背景如何，相关知识有哪些，存在什么关系</li><li>纠错——哪些知识点、观点是错误的，正确的是什么?为什么它是错的</li><li>运用——这些知识如何运用到现实生活?有什么意义和价值?</li></ul><h3>14. 信息分类</h3><p>随意信息、观点信息、过程信息、具体信息、抽象信息</p><h3>15. 挂钩法</h3><p>刚刚我做了一个关于挂钩法有趣的小实验，用了大概二十秒钟记住8件东西，缺了两样，但是我觉得挂钩法依然非常有效。　　这几样东西分别是：</p><table><thead><tr><th style="text-align:center">培根</th></tr></thead><tbody><tr><td style="text-align:center">鸡蛋</td></tr><tr><td style="text-align:center">葡萄酒</td></tr><tr><td style="text-align:center">电池</td></tr><tr><td style="text-align:center">泡泡糖</td></tr><tr><td style="text-align:center">牛奶</td></tr><tr><td style="text-align:center">信封</td></tr><tr><td style="text-align:center">菠菜</td></tr><tr><td style="text-align:center">咖啡</td></tr><tr><td style="text-align:center">番茄</td></tr></tbody></table><p>然后在一边分别把他们列出来。我是这样记忆的，时不时我上班会去早餐店买一份叫培根煎饼的早餐，里面有培根、鸡蛋、生菜、沙拉酱或者番茄酱或则辣椒酱，我就把生菜巧妙替换成菠菜，煎饼比较干那么肯定得来杯牛奶，营养又健康，和牛奶一样的饮品(联想法)有我平时最爱喝的咖啡，最近我还在学习做牛扒，家里一直缺红酒，红酒也是装逼利器哟，吃完早餐喝完咖啡，心里还想着牛扒红酒高逼格的美食，也该进入工作状态(继续挂钩)，打开邮件(映射信封)，查看有没有工作方面的事情，一边嚼着同事给的口香糖，其实我从不买泡泡糖那种口香糖，太甜越嚼越没味道，回到家吃了这么多好吃的肯定担心自己胖了没就需要称称，恰好，电子称没电了，一直拖着没去买电池。　　写了好长时间了啊，实际上就是脑子里一瞬间的联想和挂钩。</p><h3>16. 内在化</h3><p>通过将信息转化为更容易想象的形式，你可以为知识建立广泛的联系</p><h3>17. 内化与内在化</h3><p>本文用词稍微不太严谨，前面提到的是内在化，这里提的是内化。</p><ul><li>知识内化，是企业管理的重要组成部分，按字面意思理解就是知识的内部消化吸收再创新。</li><li>知识内在化，我又只有闭眼冥想我那黑暗的知识空间，存在无数的知识分子和原子，当我获得新的知识点(原子)的时候就会通过光速连接(本书中的高速公路)找到适合该原子归类的仓库(分子)，如果这不是简单的知识点本身可以独立成新的知识，会自动产生一个分子并包含最少一个原子，这个分子与刚刚通过的光速连接那端的分子自动连接建立索引，便于以后快速搜索及时反馈。继续扩展下内化的过程是不是和搜索引擎很像，检索新的网页(信息收集)然后通过算法判断是否索引或者更新快照(理解、纠错)，蜘蛛沿着网页入口进行纵向和横向爬行(拓展)然后重复算法的判断，合格的网页进行存储并排序展示给用户(应用)。</li></ul><h3>18. 学习的战略战术</h3><p>简单说战略指导思想，战术指导方法。学习知识的战略指导你把知识融会贯通，运用到现实生活和工作中，学习知识的战术指导你如何去学习。</p><ul><li>获取知识：快速阅读、笔记流</li><li>联系观点：比喻法、内在化、图表法</li><li>随意信息处理：联想法、挂钩法、信息压缩</li><li>知识拓展：知识应用、模型纠错、以项目为基础学习</li></ul><h3>19. 笔记流</h3><p>&quot;一次学会&quot;表示你在学习时要全神贯注地听老师讲课，而不是忙着做细致漂亮的笔记，等到课下再学。工作中，尤其是会议，用关键词记录，会议后整理，效率高。一旦你写下了一个观点，下一步就是在这个观点和其他观点之间画上一些箭头呈现出相互关联的关系，形成一张观点网络。</p><h3>20. 读书笔记</h3><p>写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</p><h3>21. 费曼技巧</h3><ul><li>选择要学习的内容</li><li>以老师的身份学习</li><li>疑惑时返回学习</li><li>用简单直白和比喻去解释知识点</li></ul><h3>22. 提高效率</h3><ul><li>健康身心</li><li>聪明学习</li><li>不拖延</li><li>批处理碎片信息</li><li>坚持做清单、写日子</li></ul><h3>23. 自我教育</h3><ul><li>养成阅读习惯</li><li>设定学习目标写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;《如何高效学习》从学习的战略上指导学习知识的策略抛出整体性学习的概念，以及结构、模型、高速公路的观点;详细分析了学习的顺序和信息的分类。以战术的方式分解学习的各种战术，如快速阅读、笔记流、比喻法、内在化、联想法、图表法、挂钩法、信息压缩、知识应用、模型纠错等。下面是我阅读时写下的感想，比较少的书摘。&lt;/p&gt;
    
    </summary>
    
    
      <category term="文字" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>SVM支持向量机</title>
    <link href="http://yoursite.com/2017/02/27/SVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://yoursite.com/2017/02/27/SVM支持向量机/</id>
    <published>2017-02-26T16:00:00.000Z</published>
    <updated>2018-02-23T07:34:37.816Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通俗来讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p></blockquote><a id="more"></a><h2>从线性回归讲起</h2><p>SVM主要是用来做分类工作，诸如文本分类，图像分类，生物序列分析和生 物数据挖掘， 手写字符识别等领域都有很多的应用。</p><p>对分类最简单的即线性分类器用X表示数据点，Y表示类别（二分类中，y取1或-1），一个线性分类器的目标是在数据空间中找到一个分隔平面,这个分隔平面方程可以表示为：$$\omega^{T}x+b=0$$为使目标函数值在-1到1之间，我们使用Logistic函数作为假设函数。</p><p>假设函数：</p><p>$$h_\theta(x)=g(\theta^{T}x)=\frac{1}{1+e^(-\theta^{T}x)}, \quad h_\theta(x)\in(0,1)$$</p><p>其中，x是n维特征向量，所以假设函数就是y=1的概率：</p><p>$$P(y=1|x;\theta)=h_\theta(x) \ P(y=0|x;\theta)=1-h_\theta(x)$$</p><p>从而，有$h_\theta(x)&gt;0.5$就是y=1的类，反之属于y=0的类。接下来，将结果中y = 0 和 y = 1 替换为 y =-1，y = 1，然后将$\theta^Tx= \theta_0x_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$中的$x_0$替换 为 b，最后将后面的$\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$替换为$\omega^Tx$，也就是说除了 y 由 y = 0 变为 y =1 外，线性分类函数跟 Logistic 回归的形式化表示$h_\theta(x)=g(\theta^Tx)=g(\omega^Tx+b)$没区别。<img src="http://img.blog.csdn.net/20170226133437427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3>函数间隔与几何间隔</h3><p>在超平面 $\omega^{T} x + b = 0$ 确定的情况下，$|\omega^{T} x + b|$ 能够表示点 x 到距离超平面的远近 ，而通过观察 $\omega^{T} x + b$的符号与类标记 y 的符号是否一致可判断分类是否正确，所以，可以用 $y(\omega^{T} x + b)$ 的正负性来判定或表示分类的正确性。</p><p>给定的训练数据集T和超平面w,b)，定义超平面(w,b)关于样本点(xi,yi)的函数间隔为：$$\hat{\gamma}=y(\omega^{T}x+b)=y(f(x))$$但这样定义的函数间隔有问题，即如果成比例的改变 w 和 b（如将它们改成 2w 和 2b），则函数间隔的值 f(x) 却变成了原来的 2 倍（虽然此时超平面没有改变），所以只 有函数间隔还远远不够。</p><p>平面法向单位化的函数间隔，即几何间隔$$\gamma=\frac{\omega^{T}x+b}{||\omega||}=\frac{f((x)}{||\omega||}$$假定对于一个点 x ，令其垂直投影到超平面上的对应点为 $x_0$ ，w 是垂直于超平面 的一个向量， 为样本 x 到分类间隔的距离，如图所示。<img src="http://img.blog.csdn.net/20170226134808933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log"></p><p>从上述的定义可以看出：几何间隔就是函数间隔除以 $∥\omega∥$，而且函 数间隔 $y(w ^T x + b) = yf(x)$ 实际上就是 $|f(x)|$，只是人为定义的一个间隔度量，而几何 间隔 $|f(x)|/∥\omega∥$ 才是直观上的点到超平面的距离。</p><h2>最大间隔分类器</h2><p>对一个数据点进行分类， SVM的思想是当超平面离数据点的“间隔”越大， 分类的确信度 （conﬁdence）也越大。<img src="http://img.blog.csdn.net/20170226135127419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>定义目标函数：<img src="http://img.blog.csdn.net/20170226135744814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>回顾一下几何间隔的定义 $\tilde{\gamma}=y\gamma = \frac{hat{\gamma}}{∥\omega∥}$ 可知， 如果令函数间隔 $hat{\gamma}$等于 1， 则有$\tilde{\gamma}=\frac{1}{∥w∥}$ 且 $y_i (\omega ^T x_i + b) \geq1; \quad i = 1; \cdots; n$</p><p>从而上述目标函数转化成了：</p><p>$$ max\quad \frac{1}{∥w∥} ; \quad s.t. y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$$</p><p>这个目标函数便是在相应的约束条件$y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$条件下，最大化这个 $\frac{1}{∥w∥}$ 值，而 $\frac{1}{∥w∥}$便是几何间隔$\tilde{\gamma}$。</p><h2>拉格朗日乘子法</h2><p>由于求 $\frac{1}{∥w∥}$ 的最大值相当于求 $\frac{1}{2}∥w∥^2$ 的最小值，所以上述目标函数等价于</p><p>$$ min\quad \frac{1}{2}||w||^2 ; \quad s.t. y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$$</p><p>因为现在的目标函数是二次的， 约束条件是线性的， 所以它是一个凸二次规划问题。这个问题可以用现成的 QP (Quadratic Programming) 优化包进行求解。一言以蔽之：在一定的约束条件下，目标最优，损失最小。</p><p>此外，由于这个问题的特殊结构，还可以通过拉格朗日对偶性（Lagrange Duality） 变换到对偶变量 (dual variable) 的优化问题， 即通过求解与原问题等价的对偶问题 （dual problem）得到原始问题的最优解，这就是线性可分条件下支持向量机的对偶算 法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数， 进而推广到非线性分类问题。</p><p>那什么是拉格朗日对偶性呢？简单来讲，通过给每一个约束条件加上一个拉格朗日乘子（Lagrange multiplier），定义拉格朗日函数</p><p>$$L(\omega,b,\alpha)= \frac{1}{2}||w||^2-\sum_{i=1}^{n}\alpha_i(y_i(w_i^Tx_i+b)-1)$$</p><p>原问题是极小极大问题$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)$$</p><p>原始问题的对偶问题，是极大极小问题$$\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p>将拉格朗日函数L(w,b,α)分别对w，b求偏导并令其为0,</p><p><img src="http://img.blog.csdn.net/20170226142614206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log00"></p><p>将上式带入拉格朗日函数$L(w,b,\alpha)$中，得到：</p><p><img src="http://img.blog.csdn.net/20170226142712754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"></p><p>继续求$\underset{w,b}{min}L(w,b,α)$对α的极大:<img src="http://img.blog.csdn.net/20170226142934391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>整理目标函数，求解出最优的$\alpha^<em>$<img src="http://img.blog.csdn.net/20170226172322298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">上式为一般的含不等式约束问题，存在最优化解法的必要和充分条件即KKT条件（详情可查看<a href="http://blog.csdn.net/touristman5/article/details/57418552" target="_blank" rel="noopener">等式约束与不等式约束问题</a>）：为方便理解，我们把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$L(a,b,x)=f(x)+a∗g(x)+b∗h(x)$KKT条件是说最优值必须满足以下条件：1）$\frac{\partial{L}}{\partial{x_i}}=0$对x求导为零；2）$h(x) =0;$3）$a</em>g(x) = 0;$</p><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为g(x)&lt;=0，如果要满足这个等式，必须$\alpha=0$或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><p>所谓 支撑向量Supporting Vector 也在这里显示出来——事实上，所有非 Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上 只要针对少量的“支持向量”而不是所有的训练数据即可。</p><h3>核函数</h3><p>对于线性不可分的情况，可以使用核函数，将输入空间映射到特征空间（通俗说来是从低维空间映射到高维空间），从而使得原本线性不可分的样本可以在特征空间可分。</p><p><img src="http://img.blog.csdn.net/20170226174650918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>在实际应用中，往往依赖先验领域知识才能选择有效的核函数常见的核函数有多项式核函数：$$K(x_1,x_2)=(\left \langle x_1,x_2  \right \rangle)^d$$高斯核函数：$$K(x_1,x_2)=exp\left { -\frac{||x_1-x_2||}{2\sigma^2}\right}$$</p><p>参考链接：[1].统计学习方法，李航著，清华大学出版社，2012年[2].<a href="http://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7624837</a><a href="http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html" target="_blank" rel="noopener">http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;通俗来讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="Machine Learning" scheme="http://yoursite.com/tags/Machine-Learning/"/>
    
  </entry>
  
  <entry>
    <title>用Tensflow写简单的神经网络</title>
    <link href="http://yoursite.com/2017/02/25/%E7%94%A8Tensflow%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2017/02/25/用Tensflow写简单的神经网络/</id>
    <published>2017-02-24T17:40:33.000Z</published>
    <updated>2018-02-23T07:34:20.701Z</updated>
    
    <content type="html"><![CDATA[<p>TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。</p><a id="more"></a><p><img src="http://tensorfly.cn/images/tensors_flowing.gif" alt="这里写图片描述"></p><p>根据上图，可以看出一个简单神经网络所具有的模块结构，首先输入层(Input Layer)，接受相关的结构化化数据；其次是隐藏层(Hidden Layer)，隐藏层主要加权运算，通过激活函数达到拟合线性非线性函数的目的；最后有输出层(Output Layer)，其结果成为下一次迭代的初始值。</p><p>一个的单层神经网络如下：<img src="http://hahack.com/images/ann2/w4eQd.png" alt="这里写图片描述"></p><p>就此，我们用Tensorflow实现一个单层神经网络，参考代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/python  </span><br><span class="line"># -*- coding: utf-8 -*-  </span><br><span class="line">from __future__ import print_function</span><br><span class="line">import tensorflow as tf</span><br><span class="line">import numpy as np</span><br><span class="line"></span><br><span class="line"># 定义神经网络层</span><br><span class="line">def add_layer(inputs,in_size,out_size,activation_function=None):</span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_size,out_size]))</span><br><span class="line">    biases = tf.Variable(tf.zeros([1,out_size])+0.1)</span><br><span class="line">    Wx_plus_b = tf.matmul(inputs,Weights)+biases</span><br><span class="line">    </span><br><span class="line">    if activation_function is None:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    else:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    return outputs</span><br><span class="line"></span><br><span class="line"># 定义数据</span><br><span class="line">x_d = np.linspace(-1,1,300)[:,np.newaxis]</span><br><span class="line">noise = np.random.normal(0,0.05,x_d.shape)</span><br><span class="line">y_d = np.square(x_d) - 0.5 + noise</span><br><span class="line"></span><br><span class="line"># 定义placeholder，可以更方便</span><br><span class="line">xs = tf.placeholder(tf.float32,[None,1])</span><br><span class="line">ys = tf.placeholder(tf.float32,[None,1])</span><br><span class="line"></span><br><span class="line"># 添加隐藏层</span><br><span class="line">layer1 = add_layer(xs,1,10,activation_function = tf.nn.relu)</span><br><span class="line">predict = add_layer(layer1,10,1,activation_function = None)</span><br><span class="line"></span><br><span class="line"># 定义损失函数</span><br><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - predict),reduction_indices=[1]))</span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(0.3).minimize(loss)</span><br><span class="line"></span><br><span class="line"># 初始化</span><br><span class="line"># init = tf.initialize_all_variables() no long valid from</span><br><span class="line"># 2017-03-02 if using tensorflow &gt;= 0.12</span><br><span class="line"></span><br><span class="line">if int((tf.__version__).split(&apos;.&apos;)[1]) &lt; 12:</span><br><span class="line">    init = tf.initialize_all_variables()</span><br><span class="line">else:</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"># 输出结果</span><br><span class="line">for i in range(1000):</span><br><span class="line">    # 训练</span><br><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_d, ys: y_d&#125;)</span><br><span class="line">    if i % 50 == 0:</span><br><span class="line">        # to see the step improvement</span><br><span class="line">        print(sess.run(loss, feed_dict=&#123;xs: x_d, ys: y_d&#125;))</span><br></pre></td></tr></table></figure><p>单机运行结果如下：<img src="http://img.blog.csdn.net/20170225020607154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>[1]参考链接：<a href="https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13" target="_blank" rel="noopener">https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="MachineLearning" scheme="http://yoursite.com/tags/MachineLearning/"/>
    
  </entry>
  
  <entry>
    <title>唐璜节选</title>
    <link href="http://yoursite.com/2017/02/23/%E5%94%90%E7%92%9C%E8%8A%82%E9%80%89/"/>
    <id>http://yoursite.com/2017/02/23/唐璜节选/</id>
    <published>2017-02-22T16:00:00.000Z</published>
    <updated>2018-02-23T07:34:02.423Z</updated>
    
    <content type="html"><![CDATA[<p><em>诗歌能做到以更简练、更摄人心魄的精准语言与我们的灵魂直接沟通。</em></p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生命激荡着青葱的希望</span><br><span class="line">爱意伴随着激情的火焰</span><br><span class="line">美食、酒神，都是爱情的风帆</span><br><span class="line">——唐璜-「七」岩穴奇情</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生命的美好不能束缚他，死亡的狰狞也不能毁灭它</span><br><span class="line">来自他的母亲—摩尔人赋予她刚强的性格</span><br><span class="line">他将彻底面对世界</span><br><span class="line">乐园和荒漠，没有第三条路</span><br><span class="line"></span><br><span class="line">希腊的少女曾用哀歌，咏叹海黛的爱</span><br><span class="line">迁居的岛民，也曾在漫漫长夜将这一切讲述</span><br><span class="line">夜色大海静，传说流万古</span><br><span class="line">孤岛痴女情，唯有诗人知</span><br><span class="line">——唐璜-「十六」伤逝</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">爱情犹如鸦片，不用太多</span><br><span class="line">一口便让人迷醉</span><br><span class="line">除了泪水情人的眼睛什么都能汲取</span><br><span class="line">尤其是生命的泉水</span><br><span class="line"></span><br><span class="line">这已经足够，爱情虚无飘渺</span><br><span class="line">它因自私而起，又因自私结束</span><br><span class="line">还有一种爱情只是一时的热忱</span><br><span class="line">把自己的脆弱与孤独的美相结合</span><br><span class="line">点缀那一颗疯狂的无法遏制的心</span><br><span class="line">如果没有这种美，热情也就消失</span><br><span class="line">——唐璜-「三十二」女皇的恩宠</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;em&gt;诗歌能做到以更简练、更摄人心魄的精准语言与我们的灵魂直接沟通。&lt;/em&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="文字" scheme="http://yoursite.com/tags/%E6%96%87%E5%AD%97/"/>
    
  </entry>
  
  <entry>
    <title>等式约束与不等式约束问题</title>
    <link href="http://yoursite.com/2017/01/26/%E7%AD%89%E5%BC%8F%E7%BA%A6%E6%9D%9F%E4%B8%8E%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2017/01/26/等式约束与不等式约束问题/</id>
    <published>2017-01-25T16:00:00.000Z</published>
    <updated>2018-02-23T07:35:20.410Z</updated>
    
    <content type="html"><![CDATA[<p>针对特殊约束条件下的优化问题，有着不同类别适应不同条件的求解算法。包括梯度法、求解线性等式约束问题的投影梯度法、适用于含有等式约束规划和含有不等式规划的拉格朗日乘子法、针对不等式约束的KKT条件法、罚函数法等。</p><a id="more"></a><h2>等式约束问题</h2><p>设目标函数为f(x)，约束条件为$h_k(x)$，形如<font color="red" size="5">$$min \quad f(x) \  s.t. \quad h_k(x)=0 \quad k=1,2,\cdots k$$</font>则解决方法是消元法或者拉格朗日法。消元法不再多说，拉格朗日法这里在提一下，因为后面提到的KKT条件是对拉格朗日乘子法的一种泛化。</p><p>$$L(x,\lambda)=f(x)+\sum_{k=1}^{l}\lambda_kh_k(x)$$其中$λ_k$是各个约束条件的待定系数。然后解偏导方程组：<font color="red" size="5">$$\frac{\partial F }{\partial x_i}=0 \quad  \frac{\partial F }{\partial \lambda_k}=0 \ \cdots$$</font></p><p>至于为什么这么做可以求解最优化？维基百科上给出了一个比较好的直观解释。</p><p>举个二维最优化的例子：</p><p><font size="5">$$min f(x,y)   \s.t. g(x,y) = c$$</font></p><p>这里画出$z=f(x,y)$的等高线：<img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1364139753,865873880&amp;fm=27&amp;gp=0.jpg" alt="这里写图片描述"></p><p>绿线标出的是约束$g(x,y)=c$的点的轨迹。蓝线是$f(x,y)$的等高线。箭头表示斜率，和等高线的法线平行。从梯度的方向上来看，显然有$d1&gt;d2$。绿色的线是约束，也就是说，只要正好落在这条绿线上的点才可能是满足要求的点。如果没有这条约束，$f(x,y)$的最小值应该会落在最小那圈等高线内部的某一点上。<font color="red">而现在加上了约束，最小值点应该在哪里呢？</font>显然应该是在f(x,y)的等高线正好和约束线相切的位置，因为如果只是相交意味着肯定还存在其它的等高线在该条等高线的内部或者外部，使得新的等高线与目标函数的交点的值更大或者更小，<font color="red">只有到等高线与目标函数的曲线相切的时候，可能取得最优值。</font></p><p>如果我们对约束也求梯度$∇g(x,y)$，则其梯度如图中绿色箭头所示。很容易看出来，要想让目标函数$f(x,y)$的等高线和约束相切，则他们切点的梯度一定在一条直线上。即：$∇f(x,y)=λ（∇g(x,y)-C) $其中λ可以是任何非0实数。</p><p>一旦求出$\lambda$的值，将其带入下式，易求在无约束极值和极值所对应的点。</p><p><font size="5">$$F(x,y)=f(x,y)+\lambda(g(x,y)-c)$$</font></p><p>这就是拉格朗日函数的由来。</p><h2>不等式约束问题</h2><p>考虑一般形式的优化问题：<font size="5">$$Min\quad f(x) \ s.t. \quad h(x)=0 \ \quad g(x) \geq 0$$</font></p><p>由上式，对于一个不等式约束$g_j(x)\leqslant 0$，如果在$x^<em>$处$g_j(x)= 0$，那么称该不等式约束是$x^</em>$处的起作用约束；如果在$x^*$处$g_j(x)\geq 0$，那么称该约束是处的不起作用约束。按惯例，把等式约束$h_i(x)=0$当作总是起作用的约束。</p><p>由此，定义不等式约束下的拉格朗日函数L，则L表达式为：<font size="5">$$L(X,\lambda,\mu)=f(X)+\sum_{j==1}^{p}\lambda_jh_j(X)+\sum_{k=1}^{q}\mu_kg_k(X)$$</font></p><p>其中f(x)是原目标函数，$h_j(x)$是第j个等式约束条件，$λ_j$是对应的约束系数，$g_k$是不等式约束，$\mu_k$是对应的约束系数。</p><p>常用的方法是KKT条件，同样地，把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$L(a, b, x)= f(x) + a<em>g(x)+b</em>h(x)$</p><p>KKT条件是说最优值必须满足以下条件：</p><p>1）$\frac{\partial L }{\partial x_i}=0$对x求导为零；</p><p>2）h(x) =0;</p><p>3）a*g(x) = 0;</p><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为g(x)&lt;=0，如果要满足这个等式，必须a=0或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><h3>KKT的推导：</h3><p>首先不加证明的给出对偶问题结论：$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)=\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p><img src="http://images2015.cnblogs.com/blog/520787/201509/520787-20150901140604513-1723209246.jpg" alt="这里写图片描述"></p><p>参考资料：[1].Edwin K.P.Chong  and Stanisslaw H.Zak 最优化导论（第四版）[2].<a href="http://blog.csdn.net/xianlingmao/article/details/7919597" target="_blank" rel="noopener">http://blog.csdn.net/xianlingmao/article/details/7919597</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;针对特殊约束条件下的优化问题，有着不同类别适应不同条件的求解算法。包括梯度法、求解线性等式约束问题的投影梯度法、适用于含有等式约束规划和含有不等式规划的拉格朗日乘子法、针对不等式约束的KKT条件法、罚函数法等。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mathematic" scheme="http://yoursite.com/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>MCMC与Gibbs采样</title>
    <link href="http://yoursite.com/2017/01/25/MCMC%E4%B8%8EGibbs%E9%87%87%E6%A0%B7/"/>
    <id>http://yoursite.com/2017/01/25/MCMC与Gibbs采样/</id>
    <published>2017-01-24T16:00:00.000Z</published>
    <updated>2018-02-23T07:35:34.520Z</updated>
    
    <content type="html"><![CDATA[<h2>1.1 随机模拟</h2><p>随机模拟(或者统计模拟)方法有一个很酷的别名是蒙特卡罗方法(Monte Carlo Simulation)。这个方法的发展始于20世纪40年代，和原子弹制造的曼哈顿计划密切相关，当时的几个大牛，包括乌拉姆、冯.诺依曼、费米、费曼、Nicholas Metropolis， 在美国洛斯阿拉莫斯国家实验室研究裂变物质的中子连锁反应的时候，开始使用统计模拟的方法,并在最早的计算机上进行编程实现。</p><a id="more"></a><p><img src="https://cos.name/wp-content/uploads/2013/01/simulation.jpg" alt="随机模拟与计算机">simulation随机模拟与计算机</p><p>现代的统计模拟方法最早由数学家乌拉姆提出，被Metropolis命名为蒙特卡罗方法，蒙特卡罗是著名的赌场，赌博总是和统计密切关联的，所以这个命名风趣而贴切，很快被大家广泛接受。被不过据说费米之前就已经在实验中使用了，但是没有发表。说起蒙特卡罗方法的源头，可以追溯到18世纪，布丰当年用于计算ππ的著名的投针实验就是蒙特卡罗模拟实验。统计采样的方法其实数学家们很早就知道，但是在计算机出现以前，随机数生成的成本很高，所以该方法也没有实用价值。随着计算机技术在二十世纪后半叶的迅猛发展，随机模拟技术很快进入实用阶段。对那些用确定算法不可行或不可能解决的问题，蒙特卡罗方法常常为人们带来希望。<img src="https://cos.name/wp-content/uploads/2013/01/monte-carlo-simulation.jpg" alt="">monte-carlo-simulation蒙特卡罗方法</p><p>统计模拟中有一个重要的问题就是给定一个概率分布$p(x)$，我们如何在计算机中生成它的样本。一般而言均匀分布 $Uniform(0,1)$的样本是相对容易生成的。 通过线性同余发生器可以生成伪随机数，我们用确定性算法生成[0,1]之间的伪随机数序列后，这些序列的各种统计指标和均匀分布 $Uniform(0,1)$ 的理论计算结果非常接近。这样的伪随机序列就有比较好的统计性质，可以被当成真实的随机数使用。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/sampling.png" alt="">生成一个概率分布的样本</p><p>而我们常见的概率分布，无论是连续的还是离散的分布，都可以基于$Uniform(0,1)$的样本生成。例如正态分布可以通过著名的 Box-Muller 变换得到</p><p>**[Box-Muller 变换]  **如果随机变量 $U1,U2$独立且$U1,U2\sim Uniform[0,1]$</p><p><font size="4">$Z_0 = \sqrt{-2\ln U_1} cos(2\pi U_2) \ Z_1 = \sqrt{-2\ln U_1} sin(2\pi U_2)$</font>则 $Z_0,Z_1$独立且服从标准正态分布。</p><p>其它几个著名的连续分布，包括<strong>指数分布、Gamma 分布、t 分布、F 分布、Beta 分布、Dirichlet 分布</strong>等等,也都可以通过类似的数学变换得到；离散的分布通过均匀分布更加容易生成。更多的统计分布如何通过均匀分布的变换生成出来，大家可以参考统计计算的书，其中 Sheldon M. Ross 的《统计模拟》是写得非常通俗易懂的一本。</p><p>不过我们并不是总是这么幸运的，当p(x)的形式很复杂，或者p(x) 是个高维的分布的时候，样本的生成就可能很困难了。 譬如有如下的情况<font size="5">$p(x)=\frac{\tilde{p}(x)}{\int\tilde{p}(x)}dx $</font>,而$\tilde{p}(x)$我们是可以计算的，但是底下的积分式无法显式计算。$p(x,y)$是一个二维的分布函数，这个函数本身计算很困难，但是条件分布 $p(x|y),p(y|x)$的计算相对简单;如果 $p(x)$是高维的，这种情形就更加明显。此时就需要使用一些更加复杂的随机模拟的方法来生成样本。而本节中将要重点介绍的 MCMC(Markov Chain Monte Carlo) 和 Gibbs Sampling算法就是最常用的一种，这两个方法在现代贝叶斯分析中被广泛使用。要了解这两个算法，我们首先要对马氏链的平稳分布的性质有基本的认识。</p><h2>1.2 马氏链及其平稳分布</h2><p>马氏链的数学定义很简单</p><p>$P(X_{t+1}=x|X_t, X_{t-1}, \cdots) =P(X_{t+1}=x|X_t)$</p><p>也就是状态转移的概率只依赖于前一个状态。</p><p>我们先来看马氏链的一个具体的例子。社会学家经常把人按其经济状况分成3类：下层(lower-class)、中层(middle-class)、上层(upper-class)，我们用1,2,3 分别代表这三个阶层。社会学家们发现决定一个人的收入阶层的最重要的因素就是其父母的收入阶层。如果一个人的收入属于下层类别，那么他的孩子属于下层收入的概率是 0.65, 属于中层收入的概率是 0.28, 属于上层收入的概率是 0.07。事实上，从父代到子代，收入阶层的变化的转移概率如下</p><p><img src="https://cos.name/wp-content/uploads/2013/01/table-1.jpg" alt=""></p><p>使用矩阵的表示方式，转移概率矩阵记为$P = \begin{bmatrix} 0.65 &amp; 0.28 &amp; 0.07 \ 0.15 &amp; 0.67 &amp; 0.18 \ 0.12 &amp; 0.36 &amp; 0.52 \ \end{bmatrix}$</p><p>假设当前这一代人处在下层、中层、上层的人的比例是概率分布向量 $\pi_0=[\pi_0(1), \pi_0(2), \pi_0(3)]$那么他们的子女的分布比例将是 $\pi <em>1=\pi_0P$, 他们的孙子代的分布比例将是 $\pi_2 = \pi_1P=\pi_0P^2$第n代子孙的收入分布比例将是$\pi_n = \pi</em>{n-1}P = \pi_0P^n$假设初始概率分布为$\pi _0=[0.21,0.68,0.11]$,则我们可以计算前n代人的分布状况如下<img src="https://cos.name/wp-content/uploads/2013/01/table-2.jpg" alt="">我们发现从第7代人开始，这个分布就稳定不变了，这个是偶然的吗？我们换一个初始概率分布$\pi _0=[0.75,0.15,0.1]$试试看，继续计算前n代人的分布状况如下<img src="https://cos.name/wp-content/uploads/2013/01/table-3.jpg" alt="">我们发现，到第9代人的时候, 分布又收敛了。最为奇特的是，两次给定不同的初始概率分布，最终都收敛到概率分布 $\pi=[0.286,0.489,0.225]$，也就是说收敛的行为和初始概率分布 $\pi_0$ 无关。这说明这个收敛行为主要是由概率转移矩阵P决定的。我们计算一下 $P_n$$P^{20} = P^{21} = \cdots = P^{100} = \cdots = \begin{bmatrix} 0.286 &amp; 0.489 &amp; 0.225 \ 0.286 &amp; 0.489 &amp; 0.225 \ 0.286 &amp; 0.489 &amp; 0.225 \ \end{bmatrix}$我们发现，当 n 足够大的时候，这个$P_n$矩阵的每一行都是稳定地收敛到$\pi=[0.286,0.489,0.225]$这个概率分布。自然的，这个收敛现象并非是我们这个马氏链独有的，而是绝大多数马氏链的共同行为，关于马氏链的收敛我们有如下漂亮的定理：</p><p>马氏链定理： 如果一个非周期马氏链具有转移概率矩阵PP,且它的任何两个状态是连通的，那么$\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n$存在且与i无关，记$\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n = \pi(j)$, 我们有</p><p>1.$\displaystyle \lim_{n \rightarrow \infty} P^n =\begin{bmatrix} \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \ \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \ \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \ \end{bmatrix}$</p><p>2.$\displaystyle \pi(j) = \sum_{i=0}^{\infty}\pi(i)P_{ij}$3.$\pi$是方程$\pi P=\pi $的唯一非负解其中,$\pi = [\pi(1), \pi(2), \cdots, \pi(j),\cdots ], \quad \sum_{i=0}^{\infty} \pi_i = 1$</p><p>$\pi$称为马氏链的平稳分布。</p><p>这个马氏链的收敛定理非常重要，所有的 MCMC(Markov Chain Monte Carlo) 方法都是以这个定理作为理论基础的。 定理的证明相对复杂，一般的随机过程课本中也不给证明，所以我们就不用纠结它的证明了，直接用这个定理的结论就好了。我们对这个定理的内容做一些解释说明：</p><p>该定理中马氏链的状态不要求有限，可以是有无穷多个的；定理中的“非周期“这个概念我们不打算解释了，因为我们遇到的绝大多数马氏链都是非周期的；两个状态i,j是连通并非指i可以直接一步转移到$j(P_{i,j}&gt;0)$,而是指 i 可以通过有限的n步转移到达$j(P_{ij&gt;}^n&gt;0)$。马氏链的任何两个状态是连通的含义是指存在一个n, 使得矩阵$P_n$ 中的任何一个元素的数值都大于零。我们用 $X_i$ 表示在马氏链上跳转第ii步后所处的状态，如果 $\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n = \pi(j)$存在，很容易证明以上定理的第二个结论。由于<font size="4">$P(X_{n+1}=j)= \sum_{i=0}^\infty P(X_n=i) P(X_{n+1}=j|X_n=i) \  = \sum_{i=0}^\infty P(X_n=i) P_{ij} $</font></p><p>上式两边取极限就得到$\displaystyle \pi(j) = \sum_{i=0}^{\infty}\pi(i)P_{ij}$</p><p>从初始概率分布$\pi_0$出发，我们在马氏链上做状态转移，记$x_i$的概率分布为$\pi_i$, 则有</p><p><font size="4">$X_0 \sim \pi_0(x) \ X_i \sim \pi_i(x), \quad\quad \pi_i(x) = \pi_{i-1}(x)P = \pi_0(x)P^n$</font></p><p>由马氏链收敛的定理, 概率分布$\pi_i(x)$将收敛到平稳分布$\pi(x)$。假设到第n步的时候马氏链收敛，则有</p><p><font size="4">$ X_0 \sim \pi_0(x) \ X_1 \sim \pi_1(x) \ \cdots \ X_n \sim \pi_n(x)=\pi(x) \ X_{n+1} \sim \pi(x) \ X_{n+2} \sim \pi(x) \ \cdots $</font></p><p>所以 $X_n,X_{n+1},X_{n+2},\cdots \sim \pi(x)$都是同分布的随机变量，当然他们并不独立。如果我们从一个具体的初始状态 $x_0$开始,沿着马氏链按照概率转移矩阵做跳转，那么我们得到一个转移序列 $x_0,x_1,x_2,\cdots,x_n,x_{n+1},\cdots,$ 由于马氏链的收敛行为， $x_n,x_{n+1},\cdots$都将是平稳分布$\pi(x)$的样本。</p><h2>1.3 Markov Chain Monte Carlo</h2><p>对于给定的概率分布p(x),我们希望能有便捷的方式生成它对应的样本。由于马氏链能收敛到平稳分布， 于是一个很的漂亮想法是：如果我们能构造一个转移矩阵为PP的马氏链，使得该马氏链的平稳分布恰好是p(x), 那么我们从任何一个初始状态x0x0出发沿着马氏链转移, 得到一个转移序列 $x_0,x_1,x_2,\cdots x_n,x_{n+1},\cdots,$， 如果马氏链在第n步已经收敛了，于是我们就得到了 $\pi(x)$的样本$x_n,x_{n+1},\cdots,x_n,x_{n+1},\cdots$。</p><p>这个绝妙的想法在1953年被 Metropolis想到了，为了研究粒子系统的平稳性质， Metropolis 考虑了物理学中常见的波尔兹曼分布的采样问题，首次提出了基于马氏链的蒙特卡罗方法，即Metropolis算法，并在最早的计算机上编程实现。Metropolis 算法是首个普适的采样方法，并启发了一系列 MCMC方法，所以人们把它视为随机模拟技术腾飞的起点。 Metropolis的这篇论文被收录在《统计学中的重大突破》中， Metropolis算法也被遴选为二十世纪的十个最重要的算法之一。</p><p>我们接下来介绍的MCMC 算法是 Metropolis 算法的一个改进变种，即常用的 Metropolis-Hastings 算法。由上一节的例子和定理我们看到了，马氏链的收敛性质主要由转移矩阵P决定, 所以基于马氏链做采样的关键问题是如何构造转移矩阵P,使得平稳分布恰好是我们要的分布$p(x)$。如何能做到这一点呢？我们主要使用如下的定理。</p><p>**定理：[细致平稳条件]**如果非周期马氏链的转移矩阵P和分布$\pi(x)$满足<font size="4">$ \pi(i)P_{ij} = \pi(j)P_{ji} \quad\quad \text{for all} \quad i,j$</font></p><p>则 $\pi(x)$ 是马氏链的平稳分布，上式被称为细致平稳条件(detailed balance condition)。</p><p>其实这个定理是显而易见的，因为细致平稳条件的物理含义就是<strong>对于任何两个状态i,j从 i 转移出去到j 而丢失的概率质量，恰好会被从 j 转移回i 的概率质量补充回来，所以状态i上的概率质量$\pi(i)$是稳定的，从而$\pi(x)$是马氏链的平稳分布</strong>。数学上的证明也很简单，由细致平稳条件可得</p><p><font size="5">$\sum_{i=1}^\infty \pi(i)P_{ij} =\sum_{i=1}^\infty \pi(j)P_{ji} = \pi(j) \sum_{i=1}^\infty P_{ji} = \pi(j) \ \Rightarrow \pi P = \pi$</font></p><p>由于$\pi$是方程 $\pi P=\pi $的解，所以$\pi $是平稳分布。</p><p>假设我们已经有一个转移矩阵为Q马氏链$q(i,j)$表示从状态 i转移到状态j的概率，也可以写为 $q(j|i)$ 显然，通常情况下</p><p>$p(i) q(i,j) \neq p(j) q(j,i)$</p><p>也就是细致平稳条件不成立，所以$p(x)$不太可能是这个马氏链的平稳分布。我们可否对马氏链做一个改造，使得细致平稳条件成立呢？譬如，我们引入一个 $\alpha(i,j)$, 我们希望</p><p><font size="4">$p(i) q(i,j)\alpha(i,j) = p(j) q(j,i)\alpha(j,i)  \quad (*) $</font></p><p><font size="4">$\alpha(i,j)= p(j) q(j,i),\quad \alpha(j,i) = p(i) q(i,j)$</font></p><p>于是(*)式就成立了。所以有</p><p>$p(i) \underbrace{q(i,j)\alpha(i,j)}<em>{Q’(i,j)} = p(j)\underbrace{q(j,i)\alpha(j,i)}</em>{Q’(j,i)}  \quad (**) $</p><p>于是我们把原来具有转移矩阵$Q$的一个很普通的马氏链，改造为了具有转移矩阵$Q’$的马氏链，而$Q’$恰好满足细致平稳条件，由此马氏链$Q’$的平稳分布就是$p(x)$！</p><p>在改造 Q 的过程中引入的 $\alpha(i,j)$称为接受率，物理意义可以理解为在原来的马氏链上**，从状态 i 以$q(i,j)$ 的概率转跳转到状态j 的时候，我们以$\alpha (i,j)$的概率接受这个转移，于是得到新的马氏链Q′的转移概率为$q(i,j)\alpha(i,j)$。**</p><p><img src="https://cos.name/wp-content/uploads/2013/01/mcmc-transition.jpg" alt=""></p><p>假设我们已经有一个转移矩阵$Q$(对应元素为$q(i,j)$, 把以上的过程整理一下，我们就得到了如下的用于采样概率分布$p(x)$的算法。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/mcmc-algo-1.jpg" alt="">上述过程中 $p(x),q(x|y)$ 说的都是离散的情形，事实上即便这两个分布是连续的，以上算法仍然是有效，于是就得到更一般的连续概率分布 $p(x)$的采样算法，而 $q(x|y)$ 就是任意一个连续二元概率分布对应的条件分布。</p><p>以上的 MCMC 采样算法已经能很漂亮的工作了，不过它有一个小的问题：马氏链Q在转移的过程中的接受率 $\alpha(i,j)$ 可能偏小，这样采样过程中马氏链容易原地踏步，拒绝大量的跳转，这使得马氏链遍历所有的状态空间要花费太长的时间，收敛到平稳分布$p(x)$的速度太慢。有没有办法提升一些接受率呢?</p><p>假设 $\alpha(i,j)=0.1,\alpha(j,i)=0.2$, 此时满足细致平稳条件，于是</p><p>$p(i)q(i,j)\times 0.1 = p(j)q(j,i) \times 0.2$</p><p>上式两边扩大5倍，我们改写为$p(i)q(i,j) \times 0.5 = p(j)q(j,i) \times 1$</p><p>看，我们提高了接受率，而细致平稳条件并没有打破！这启发我们可以把细致平稳条件(**) 式中的$\alpha(i,j),\alpha(j,i)$同比例放大，使得两数中最大的一个放大到1，这样我们就提高了采样中的跳转接受率。所以我们可以取</p><p>$\alpha(i,j) = \min\left{\frac{p(j)q(j,i)}{p(i)q(i,j)},1\right}$</p><p>于是，经过对上述MCMC 采样算法中接受率的微小改造，我们就得到了如下教科书中最常见的 Metropolis-Hastings 算法。<img src="https://cos.name/wp-content/uploads/2013/01/mcmc-algo-2.jpg" alt="">对于分布 $p(x)$,我们构造转移矩阵 Q′ 使其满足细致平稳条件</p><p>$p(x) Q’(x\rightarrow y) = p(y) Q’(y\rightarrow x)$</p><p>此处 x 并不要求是一维的，对于高维空间的$p(x)$，如果满足细致平稳条件</p><p>$p(\mathbf{x}) Q’(\mathbf{x}\rightarrow \mathbf{y}) = p(\mathbf{y}) Q’(\mathbf{y}\rightarrow \mathbf{x})$那么以上的 Metropolis-Hastings 算法一样有效。</p><h2>1.4 Gibbs Sampling</h2><p>对于高维的情形，由于接受率$\alpha$的存在(通常$\alpha&lt;1$), 以上 Metropolis-Hastings 算法的效率不够高。能否找到一个转移矩阵$Q$使得接受率$\alpha=1$呢？我们先看看二维的情形，假设有一个概率分布 $p(x,y)$, 考察x坐标相同的两个点$A(x1,y1),B(x1,y2)$，我们发现$p(x_1,y_1)p(y_2|x_1) = p(x_1)p(y_1|x_1)p(y_2|x_1) \ p(x_1,y_2)p(y_1|x_1) = p(x_1)p(y_2|x_1)p(y_1|x_1)$</p><p>所以得到$ p(x_1,y_1)p(y_2|x_1) = p(x_1,y_2)p(y_1|x_1)  \quad (***) $即$p(A)p(y_2|x_1) = p(B)p(y_1|x_1)$</p><p><img src="https://cos.name/wp-content/uploads/2013/01/gibbs-transition.png" alt="">平面上马氏链转移矩阵的构造</p><p>$Q(A\rightarrow B) = p(y_B|x_1) \quad \text{if} \quad x_A=x_B=x_1 \ Q(A\rightarrow C) = p(x_C|y_1) \quad \text{if} \quad y_A=y_C=y_1 \ Q(A\rightarrow D) = 0 \quad ,\text{others}$</p><p>有了如上的转移矩阵$Q$, 我们很容易验证对平面上任意两点$X,Y$ 满足细致平稳条件</p><p>$p(X)Q(X\rightarrow Y) = p(Y) Q(Y\rightarrow X)$</p><p>于是这个二维空间上的马氏链将收敛到平稳分布 p(x,y)p(x,y)。而这个算法就称为 Gibbs Sampling 算法,是 Stuart Geman 和Donald Geman 这两兄弟于1984年提出来的，之所以叫做Gibbs Sampling 是因为他们研究了Gibbs random field, 这个算法在现代贝叶斯分析中占据重要位置。<img src="https://cos.name/wp-content/uploads/2013/01/gibbs-algo-1.jpg" alt=""><img src="https://cos.name/wp-content/uploads/2013/01/two-stage-gibbs.png" alt=""></p><h3>1.4.1 Gibbs Sampling 算法中的马氏链转移</h3><p>以上采样过程中，如图所示，马氏链的转移只是轮换的沿着坐标轴 xx轴和yy轴做转移，于是得到样本$(x_0,y_0), (x_0,y_1), (x_1,y_1), (x_1,y_2),(x_2,y_2), \cdots$马氏链收敛后，最终得到的样本就是 p(x,y)的样本，而收敛之前的阶段称为 burn-in period。额外说明一下，我们看到教科书上的 Gibbs Sampling 算法大都是坐标轴轮换采样的，但是这其实是不强制要求的。最一般的情形可以是，在t时刻，可以在x轴和y轴之间随机的选一个坐标轴，然后按条件概率做转移，马氏链也是一样收敛的。轮换两个坐标轴只是一种方便的形式。</p><p>以上的过程我们很容易推广到高维的情形，对于(***) 式，如果$x_1$ 变为多维情形$x_1$，可以看出推导过程不变，所以细致平稳条件同样是成立的</p><p>$ p(\mathbf{x_1},y_1)p(y_2|\mathbf{x_1}) = p(\mathbf{x_1},y_2)p(y_1|\mathbf{x_1}) $此时转移矩阵 Q 由条件分布 $p(y|x_1)$定义。上式只是说明了一根坐标轴的情形，和二维情形类似，很容易验证对所有坐标轴都有类似的结论。所以n维空间中对于概率分布$ p(x1,x2,\cdots ,xn)$ 可以如下定义转移矩阵</p><p>1.如果当前状态为$(x_1,x_2,\cdots ,x_n)$，马氏链转移的过程中，只能沿着坐标轴做转移。沿着 $x_i$这根坐标轴做转移的时候，转移概率由条件概率 $p(x_i|x_1, \cdots, x_{i-1}, x_{i+1}, \cdots, x_n)$定义；2.其它无法沿着单根坐标轴进行的跳转，转移概率都设置为 0。</p><p>于是我们可以把Gibbs Smapling 算法从采样二维的$p(x,y)$推广到采样n 维的 $p(x_1,x_2,\cdots,x_n)$</p><p><img src="https://cos.name/wp-content/uploads/2013/01/gibbs-algo-2.jpg" alt=""></p><p>以上算法收敛后，得到的就是概率分布$p(x_1,x_2,\cdots ,x_n)$的样本，当然这些样本并不独立，但是我们此处要求的是采样得到的样本符合给定的概率分布，并不要求独立。同样的，在以上算法中，坐标轴轮换采样不是必须的，可以在坐标轴轮换中引入随机性，这时候转移矩阵 Q 中任何两个点的转移概率中就会包含坐标轴选择的概率，而在通常的 Gibbs Sampling 算法中，坐标轴轮换是一个确定性的过程，也就是在给定时刻tt，在一根固定的坐标轴上转移的概率是1。</p><blockquote><p>转载自<a href="https://cos.name/2013/01/lda-math-mcmc-and-gibbs-sampling/" target="_blank" rel="noopener">统计之都</a></p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;1.1 随机模拟&lt;/h2&gt;
&lt;p&gt;随机模拟(或者统计模拟)方法有一个很酷的别名是蒙特卡罗方法(Monte Carlo Simulation)。这个方法的发展始于20世纪40年代，和原子弹制造的曼哈顿计划密切相关，当时的几个大牛，包括乌拉姆、冯.诺依曼、费米、费曼、Nicholas Metropolis， 在美国洛斯阿拉莫斯国家实验室研究裂变物质的中子连锁反应的时候，开始使用统计模拟的方法,并在最早的计算机上进行编程实现。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mathematic" scheme="http://yoursite.com/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>指数分布族</title>
    <link href="http://yoursite.com/2017/01/23/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E6%97%8F/"/>
    <id>http://yoursite.com/2017/01/23/指数分布族/</id>
    <published>2017-01-22T16:00:00.000Z</published>
    <updated>2018-02-23T07:33:51.287Z</updated>
    
    <content type="html"><![CDATA[<p>指数分布族是指可以表示为指数分布的概率分布。指数分布形式如下：$$P(y;\eta)=b(y)exp(\eta^{T}T(y)-\alpha(\eta))$$其中，$\eta$成为分布的自然参数；T(y)是充分统计量，通常$T(y)=y$。当a、b、T参数都固定的时候，就定义了一个以$\eta$为参数的指数函数族。</p><a id="more"></a><p>实际上，大多数概率分布都可以表示成上面公式给出的形式：</p><p>1）伯努利分布：对0、1问题进行建模2）多项式分布：对K个离散结果的事件建模3）泊松分布：对计数过程进行建模4）伽马分布与指数分布：对间隔的正数进行建模5）Beta分布：对小数进行建模6）Dirichlet分布：对小数进行建模7）Wishart分布：对协方差进行建模8）高斯分布</p><h2>示例</h2><p>我们将高斯分布与伯努利分布表示成指数分布族的形式。</p><h3>伯努利分布</h3><p>伯努利分布是对0、1问题进行建模，特可以表示成如下形式：</p><p>$$P(y;\varphi)=\varphi^y(1-\varphi)^{1-y} \quad y\in{0,1}$$</p><p><img src="http://img.blog.csdn.net/20170226102110215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"></p><p>将伯努利分布表示成如下形式，对比指数族分布公示</p><p><img src="http://img.blog.csdn.net/20170226102145230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>其中可以看到，$\eta$的形式为logisic函数，这是因为logistic模型对问题的先验概率估计是伯努利分布的缘故。</p><h3>高斯分布</h3><p>高斯分布可以推导出线性模型，由线性模型的假设函数可知，高斯分布的方差与假设函数无关，因而为简便计算，我们将方差设为1，即使不这样做，最后的结果也是作为一个系数而已，高斯分布转换为指数分布形式的推导过程如下：</p><p><img src="http://img.blog.csdn.net/20170226102549656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>我们最终一样可以把高斯分布以指数分布族函数的形式表示。</p><h2>后记</h2><p><strong>1) 这里说明指数分布族的目的，是为了说明关于线性模型(Generalized Linear Model).</strong><strong>2) 凡是符合指数分布族的随机变量，都可以用广义线性模型(GLM)进行分析。</strong></p><h3>备注</h3><p>指数分布族的<strong>无记忆性</strong>，教科书上所说的无记忆性（Memoryless Property，又称遗失记忆性）。这表示如果一个随机变量呈指数分布，它的条件概率遵循：$$P(T&gt;s+t;T&gt;t)=P(T&gt;s), \quad for\quad all,\quad s.t&gt;0 $$有兴趣的同学可以深入理解一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;指数分布族是指可以表示为指数分布的概率分布。指数分布形式如下：
$$P(y;\eta)=b(y)exp(\eta^{T}T(y)-\alpha(\eta))$$
其中，$\eta$成为分布的自然参数；T(y)是充分统计量，通常$T(y)=y$。当a、b、T参数都固定的时候，就定义了一个以$\eta$为参数的指数函数族。&lt;/p&gt;
    
    </summary>
    
    
      <category term="Mathematic" scheme="http://yoursite.com/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>优化算法篇之梯度法</title>
    <link href="http://yoursite.com/2017/01/15/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AF%87%E4%B9%8B%E6%A2%AF%E5%BA%A6%E6%B3%95/"/>
    <id>http://yoursite.com/2017/01/15/优化算法篇之梯度法/</id>
    <published>2017-01-14T17:41:05.000Z</published>
    <updated>2018-02-23T07:32:24.492Z</updated>
    
    <content type="html"><![CDATA[<p>我们在接触到具体的机器学习算法前，其实很有必要对优化问题进行一些了解。随着学习的深入，越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。</p><a id="more"></a><p>最常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度方向法等。在大学课程中，数值分析是计算机或数学相关专业一门比较重要的一门课程，笔者也在大学时自学过相关课程，其介绍的诸多对理论的计算机实现方法，对现在的学习依然发挥着很大的作用。</p><p>当然优化算法只是数值分析课程中涉及一部分内容，这一节主要介绍和回顾梯度下降法</p><h2>梯度下降法</h2><p>梯度下降法是最为常见的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。在一般情况下，其解不能保证是全局最优解，梯度下降法的速度也未必是最快的。</p><p>假设$f(x)$是$R^n$上具有一阶连续偏导数的函数，需要求解的无约束最优化问题是：</p><p>$${min}_{x\in R^n}：\quad f(x)$$</p><p>梯度下降法是一种迭代算法，选取适当的初值$x_0$,反复迭代，更新$x_{i}$的值，进行目标函数的极小化，直至收敛。<img src="http://img.my.csdn.net/uploads/201302/13/1360748597_8621.jpg" alt="梯度方向"></p><p>由于我们都知道梯度方向$∇f(x)$是函数增长最快的方向，那么自然而然的想到负梯度方向就是函数值下降最快的方向了。因此，我们以负梯度方向作为极小化的下降方向，在迭代的每一步，以负梯度方向来更新$x$的值，从而达到减小函数值目的，这种方法就是梯度下降法。</p><p>由于$f(x)$具有一阶连续偏导数，若第k次迭代值为$x_k$，则可将$f(x)$在$x_k$处进行一阶泰勒展开：$$f(x)=f(x^{(k)})+g_k^T(x−x^{(k)})$$这里，(方便推广，使用矩阵形式）$$g_k=g(x^{(k)})=∇f(x^{(k)})g_k=g(x^{(k)})=∇f(x^{(k)})$$为$f(x)$在$x_K$的梯度。第$K+1$次迭代值$x_{k+1}$：即$$x_{k+1}=x_{k}+λ_k*p_k$$其中，$p_k$是搜索方向，梯度法中$p_k=-∇f(x)$，取负梯度方向$p_k=−∇f(x^{(k)}),{\lambda_k}$是步长，有时候我们也叫学习率，这个值可以由一维搜索确定，目的在于得到最合适的步长，即${\lambda _k}$使得</p><p>$$Min:\quad \varphi(\lambda)=f(x^{(k)}+λ_kp^{(k)})$$</p><h3>算法过程：</h3><p>1）确定当前位置的损失函数的梯度，对于$(\theta_i)$,其梯度表达式如下：</p><p>$$(\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n))$$</p><p>2）用步长乘以损失函数的梯度，得到当前位置下降的距离，即$(\alpha\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n))$对应于前面登山例子中的某一步。</p><p>3）确定是否所有的$(\theta_i)$,梯度下降的距离都小于$\varepsilon$，如果小于$\varepsilon$则算法终止，当前所有的$\theta_i,(i=0,1,…n)$即为最终结果。否则进入步骤4.</p><p>4）更新所有的$\theta$，对于$\theta_i$，其更新表达式如下。更新完毕后继续转入步骤1.</p><p>$\theta_i = \theta_i – \alpha\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n)$</p><h3>举例</h3><p>下面用线性回归的例子来具体描述梯度下降。假设我们的样本是$(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_n)$,损失函数如前面先决条件所述：</p><p>$$f(\theta_0, \theta_1…, \theta_n) = \sum\limits_{i=0}^{m}(h_\theta(x_0, x_1, …x_n) – y_i)^2$$。</p><p>则在算法过程步骤1中对于$\theta_i$ 的偏导数计算如下：</p><p>$$\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n)= \frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) – y_j)x_i^{j}$$</p><p>由于样本中没有$x_0$上式中令所有的$x_0^{j}$为1.</p><p>步骤4中$\theta_i$的更新表达式如下：</p><p>$$\theta_i = \theta_i – \alpha\frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) – y_j)x_i^{j}$$</p><p>从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加$\frac{1}{m}$ 是为了好理解。由于步长也为常数，他们的乘机也为常数，所以这里$\alpha\frac{1}{m}$可以用一个常数表示。</p><p>梯度下降法的搜索迭代示意图如下图所示:<img src="http://images2015.cnblogs.com/blog/743682/201511/743682-20151108163643227-650396065.png" alt="梯度下降法的搜索迭代示意图如下图所示"></p><p>参考书籍：An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</p>]]></content>
    
    <summary type="html">
    
      support
    
    </summary>
    
    
      <category term="Mathematic" scheme="http://yoursite.com/tags/Mathematic/"/>
    
  </entry>
  
  <entry>
    <title>理解异步</title>
    <link href="http://yoursite.com/2016/12/20/%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2016/12/20/理解异步/</id>
    <published>2016-12-19T16:00:00.000Z</published>
    <updated>2018-02-23T07:33:58.317Z</updated>
    
    <content type="html"><![CDATA[<p>JavaScript编程几乎总是伴随着异步操作，传统的异步操作会在操作完成之后，使用回调函数传回结果，而回调函数中则包含了后续的工作。这也是造成异步编程困难的主要原因：</p><a id="more"></a><h2>前述</h2><p><strong>我们一直习惯于“线性”地编写代码逻辑，但是大量异步操作所带来的回调函数，会把我们的算法分解地支离破碎。</strong></p><p>此时我们不能用if来实现逻辑分支，也不能用while/for/do来实现循环，更不用说异步操作之间的组合、错误处理以及取消操作了。因此也就诞生了如jQuery Deferred这样的辅助类库。</p><p>我们常见的异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">定时器setTimeout</span><br><span class="line">postmessage</span><br><span class="line">WebWorkor</span><br><span class="line">CSS3 动画</span><br><span class="line">XMLHttpRequest</span><br><span class="line">HTML5的本地数据</span><br><span class="line">等等…</span><br></pre></td></tr></table></figure><p>JavaScript要求在与服务器进行交互时要用异步通信，如同AJAX一样。因为是异步模型，所以在调用Transaction游览器提供的本地数据接口时候类似AJAX（这里我是假设），浏览器自己有内部的XHR方法异步处理，但是此时的JS代码还是会同步往下执行，其实就是无阻塞的代码。</p><p>**问题：**因为无阻塞，代码在发送AJAX这个请求后会继续执行，那么后续的操作如果依赖这个数据的就会出错了，所以这里就需要等待AJAX返回，才能执行后续操作。</p><p>因为异步而导致流程不正确，或者说我们的应用在某个程度上依赖第三方API的数据，那么就会面临一个共同的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们无法获悉一个API响应的延迟时间，应用程序的其他部分可能会被阻塞，直到它返回结果。Deferreds 的引入对这个问题提供了一个更好的解决方案，它是非阻塞的，并且与代码完全解耦。</span><br></pre></td></tr></table></figure><p>当然异步操作也可以提供一个类似于成功回调，失败回调的通知接口。</p><p>JS是单线程语言，就简单性而言，把每一件事情（包括GUI事件和渲染）都放在一个线程里来处理是一个很好的程序模型，因为这样就无需再考虑线程同步这些复杂问题。</p><p>另一方面，他也暴露了应用开发中的一个严重问题，单线程环境看起来对用户请求响应迅速，但是当线程忙于处理其它事情时，就不能对用户的鼠标点击和键盘操作做出响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器改变流程</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    show(<span class="number">2</span>)&#125;, <span class="number">0</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行异步动画</span></span><br><span class="line"><span class="comment">//因为代码的执行是按照从上至下</span></span><br><span class="line"><span class="comment">//但是由于加入了动画，动画形成了异步，所以实际的改变值必须等动画完成才能得到</span></span><br><span class="line"><span class="comment">//但是同步逻辑3其实已经运行，所以3要等待2结束才可以</span></span><br><span class="line">$(<span class="string">"#go"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> block = $(<span class="string">"#block"</span>);</span><br><span class="line">show(<span class="string">'1.动画流程代码开始,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">block.animate(&#123;</span><br><span class="line">width       : <span class="string">"70%"</span>,</span><br><span class="line">opacity     : <span class="number">0.4</span>,</span><br><span class="line">marginLeft  : <span class="string">"0.6in"</span>,</span><br><span class="line">fontSize    : <span class="string">"3em"</span>,</span><br><span class="line">borderWidth : <span class="string">"10px"</span>,</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">show(<span class="string">'2.动画执行结束束,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">show(<span class="string">'3.动画流程代码结束,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">$(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Deferred</h2><h3>Deferred是什么</h3><p>前端项目的开发，不仅仅涉及到同步的概念，而且还会经常穿插各种异步的处理。一些大的操作，比如远程获取数据，操作一个大数据处理，这时候是不能马上获取到数据的。假设我们发送一个AJAX请求到接受到数据需要10秒钟，那么从发送到接受数据这个时间段中，前端的处理时间其实是空闲，但是对于开发者来说这种时间是不能浪费了，所以我们可以在10秒钟做很多同步的处理，同时等待异步的数据返回。所以我们需要监听这个回调的数据在成功的时候能够获取到，或者设计一个返回后触发处理的机制，当然原生的JavaScript对这个机制几乎是没有的。为了优化这个形成统一的异步处理方案，jQuery就开始设计了一个Deferred异步模型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Deferred 提供了一个抽象的非阻塞的解决方案（如异步请求的响应），它创建一个promise对象，其目的是在未来某个时间点返回一个响应。简单来说就是一个异步/同步回调函数的处理方案。</span><br></pre></td></tr></table></figure><p>$.Deferred在jQuery代码内部有四个模块被使用，分别是“<strong>promise方法”、“DOM ready”、“Ajax模块”及“动画模块</strong>”。</p><p>看看jQuery中的最常用的AJAX处理：</p><p><strong>一：Ajax的改造</strong></p><p>传统的jQuery的AJAX操作的传统写法(1.5版之前)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;aaron.html&quot;,</span><br><span class="line">  success: function()&#123;</span><br><span class="line">     alert(&quot;成功！&quot;);</span><br><span class="line">  &#125;,</span><br><span class="line">  error:function()&#123;</span><br><span class="line">    alert(&quot;失败！&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。</p><p>在1.5版本后通过新的Deferred引入就改成了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&quot;aaron.html&quot;)</span><br><span class="line">.done(function()&#123; alert(&quot;成功&quot;); &#125;)</span><br><span class="line">.fail(function()&#123; alert(&quot;出错&quot;); &#125;);</span><br></pre></td></tr></table></figure><p>把传参的回调，换成了链式的写法，这样可读性更高了。在jquery 1.5版后，通过$.ajax返回的不是XHR对象了，而是经过包装的Deferred对象，所以就具有promise的一些规范。当然这种写法到底是怎么做的，我们在后续的教程中会详细的讲解到。</p><p><strong>二：提供一种方法来执行一个或多个对象的回调函数</strong></p><p>在实际开发中，我们可能要发送多个异步的请求操作，我们需要等所有的异步都处理完毕后，才能继续下一个动作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aaron1"</span>&gt;</span>运行案例一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aaron2"</span>&gt;</span>运行案例二<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//提供一种方法来执行一个或多个对象的回调函数</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//在实际开发中，我们可能要发送多个异步的请求操作，我们需要等所有的异步都处理完毕后，才能继续下一个动作</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//案例一</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task1</span>(<span class="params">name, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    fn(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 500)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task2</span>(<span class="params">name, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    fn(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 1000)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//任务数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> taskNuns = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> num = <span class="number">2</span>; <span class="comment">//2个任务</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">      show(<span class="string">'任务都完成了'</span>,$(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    num--;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#aaron1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//常规处理</span></span></span><br><span class="line"><span class="javascript">  task1(<span class="string">'任务一'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task1'</span>, $(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    taskNuns()</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  task2(<span class="string">'任务二'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task2'</span>, $(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    taskNuns();</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="comment">//========================分割线============================================</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//案例二</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//通过Deferred改进</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task3</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred();</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task3执行完毕'</span>,$(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">    dtd.resolve(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 500)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> dtd;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task4</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred();</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task4执行完毕'</span>,$(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">    dtd.resolve(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 1000)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> dtd;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#aaron2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  $.when(task3(<span class="string">'task1'</span>), task4(<span class="string">'task2'</span>)).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'when处理成功'</span>, $(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data, ele</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  (ele || $(<span class="string">"body"</span>)).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们这里要涉及一个等待的处理。我们自己要做一个计时器，每一个任务执行完毕后，都要触发一次任务的检测。当最后一个调用完毕了，我们就可以执行后面的动作，当前这里的写法也会有些问题，比如错误的时候没有处理。同样的功能，我们换成Deferred就会很简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when($.ajax(&quot;a1.html&quot;), $.ajax(&quot;a2.html&quot;))</span><br><span class="line">　　.done(function()&#123; alert(&apos;2次回调都正确返回了&apos;) &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&apos;出错了&apos;); &#125;);</span><br></pre></td></tr></table></figure><p>这段代码的意思是：先执行两个操作$.ajax(“a1.html”)和$.ajax(“a2.html”)，如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p><p><strong>三：可以混入任意的对象接口中</strong></p><p>jQuery的Deferred最好用的地方，就是模块化程度非常高，可以任意配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function task(name) &#123;</span><br><span class="line">  var dtd = $.Deferred();</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    dtd.resolve(name)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">  return dtd;</span><br><span class="line">&#125;</span><br><span class="line">$.when(task(&apos;任务一&apos;), task(&apos;任务二&apos;)).done(function() &#123;</span><br><span class="line">  alert(&apos;成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>把需要处理的异步操作，用Deferred对象给包装一下，然后通过when方法收集异步的操作，最后再返回出done的成功，这样的处理太赞了！</p><p>所以说，Deferred的引入，为处理事件回调提供了更加强大并且更灵活的编程模型。</p><h3>认识$.Deferred的接口</h3><p>大多情况下，promise作为一个模型，提供了一个在软件工程中描述延时（或将来）概念的解决方案。它背后的思想我们已经介绍过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是执行一个方法，然后阻塞应用程序等待结果返回，而是返回一个promise对象来满足未来值。</span><br></pre></td></tr></table></figure><p>这样看来，Promise/A只是一种规范，Deferred可以看作这种规范的具体实现，旨在提供通用的接口，用来简化异步编程难度，说白了就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个可链式操作的对象，提供多个回调函数的注册，以及回调列队的回调，并转达任何异步操作成功或失败的消息。</span><br></pre></td></tr></table></figure><p>jQuery.Deferred()背后的设计理念来自 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">CommonJS Promises/A</a> , jQuery.Deferred()基于这个理念实现，但并没有完全遵循其设计， 它代表了一种可能会长时间运行而且不一定必须完整的操作的结果，简单的描述下规范中定义的“Promise”。</p><p>promise模式在任何时刻都处于以下三种状态之一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">未完成（unfulfilled）</span><br><span class="line">已完成（resolved）</span><br><span class="line">拒绝（rejected）</span><br></pre></td></tr></table></figure><p>CommonJS Promise/A 标准这样定义的，promise对象上的then方法负责添加针对已完成和拒绝状态下的处理函数。then方法会返回另一个promise对象，这样可以形成“管道”风格。</p><p>看看jQuery的Deferred源码中对动作接口的定义：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ &quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot; ],</span><br><span class="line">[ &quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot; ],</span><br><span class="line">[ &quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;) ]</span><br></pre></td></tr></table></figure><p>Deferred中定义的动作是非常多的，抽象的看其实可以类似一种观察者模式的实现。</p><p>观察者模式中的订阅方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Done (操作完成)</span><br><span class="line">Fail (操作失败)</span><br><span class="line">Progress (操作进行中</span><br></pre></td></tr></table></figure><p>观察中模式中的发布方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve（解决）</span><br><span class="line">reject（拒绝）</span><br><span class="line">notify（通知）</span><br></pre></td></tr></table></figure><p>而且还提供了可以定义运行时的this对象的fire，fireWith，所以扩展了3个可以定义上下文的的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveWith</span><br><span class="line">rejectWith</span><br><span class="line">notifyWith</span><br></pre></td></tr></table></figure><p>所以按照这样的规范，我们的使用就应该是这样：见代码。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;button id=&quot;aaron1&quot;&gt;例一:基本用法&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;aaron2&quot;&gt;例二:过滤器&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;aaron3&quot;&gt;例三:promise方法&lt;/button&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">//例一</span><br><span class="line">$(&quot;#aaron1&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">  // 构建一个deferred对象</span><br><span class="line">  var dtd = $.Deferred();</span><br><span class="line">  // 给deferred注册一个成功后的回调通知</span><br><span class="line">  dtd.done(function() &#123;</span><br><span class="line">    show(&apos;成功&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line">  // 开始执行一段代码</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    dtd.resolve(); // 改变deferred对象的执行状态</span><br><span class="line">  &#125;, 2000);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">//例二：过滤器</span><br><span class="line">var filterResolve = function() &#123;</span><br><span class="line">  var defer = $.Deferred(),</span><br><span class="line">    filtered = defer.then(function(value) &#123;</span><br><span class="line">      return value * 2;</span><br><span class="line">    &#125;);</span><br><span class="line">  defer.resolve(5);</span><br><span class="line">  filtered.done(function(value) &#123;</span><br><span class="line">    show(&quot;Value is ( 2*5 = ) 10: &quot; + value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">$(&quot;#aaron2&quot;).on(&quot;click&quot;, filterResolve)</span><br><span class="line"></span><br><span class="line">//例三：实现promise方法</span><br><span class="line">$(&quot;#aaron3&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">  var obj = &#123;</span><br><span class="line">    hello: function(name) &#123;</span><br><span class="line">      show(&quot;你好 &quot; + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    defer = $.Deferred();</span><br><span class="line">  // 设置一个promise</span><br><span class="line">  defer.promise(obj);</span><br><span class="line">  //解决一个deferred</span><br><span class="line">  defer.resolve(&quot;慕课网&quot;);</span><br><span class="line">  obj.done(function(name) &#123;</span><br><span class="line">    obj.hello(name);</span><br><span class="line">  &#125;).hello(&quot;Aaron&quot;);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">function show(data) &#123;</span><br><span class="line">  $(&quot;body&quot;).append(&apos;&lt;li&gt;&apos; + data + &apos;&lt;/li&gt;&apos;)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3>$.Deferred的设计</h3><p>由于1.7版本后$.Callbacks从Deferred中抽离出去了，目前版本的Deferred.js代码不过150行，而真正$.Deferred的实现只有100行左右，实现的逻辑是相当犀利的。</p><p>因为Callback被剥离出去后，整个Deferred就显得非常的精简，代码直接通过extend扩展到静态接口上，对于extend的继承这个东东，在之前就提及过jQuery如何处理内部jQuery与init相互引用this的问题，所以当jQuery.extend只有一个参数的时候，其实就是对jQuery静态方法的一个扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">   Deferred:function(func)&#123;</span><br><span class="line">        ...省略代码....</span><br><span class="line">        return deferred</span><br><span class="line">   &#125;,</span><br><span class="line">   when:function(func)&#123;</span><br><span class="line">      ...省略代码....</span><br><span class="line">      return deferred.promise();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们来具体看看2个静态方法内部都干了些什么?</p><p>Deferred整体结构：右边代码所示。</p><p>Deferred就是一个简单的工厂方法，有两种方式使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = $.Deferred（）</span><br><span class="line">$.Deferred(function()&#123;&#125;)</span><br></pre></td></tr></table></figure><p>内部其实是严重依赖$.Callbacks对象，Callbacks就是用来储存deferred依赖的数据的。</p><p>因为done、fail、progress就是jQuery.Callbacks(“once memory”)所有对应的处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var list = jQuery.Callbacks(&quot;once memory&quot;)</span><br><span class="line">promise[&apos;done&apos;] = list.add;</span><br></pre></td></tr></table></figure><p>deferred定义了一系列的接口，堪称一绝，100多行的代码，精练的有些过分。</p><p>Deferred方法内部建议了2个对象，一个是deferred外部接口对象，一个是内部promise对象。</p><p>promise对象解释是一个受限的对象, 这就是所谓的受限制的deferred对象，因为相比之前， 返回的deferred不再拥有resolve(With), reject(With), notify(With)这些能改变deferred对象状态并且执行callbacklist的方法了,只能是then、done、fali等方法。</p><p>其内部通过tuples数组，存储了所有的接口API，通过遍历把所有的接口一次都挂到内部promise与deferred对象上。</p><p>其中定义了done、fail以及progress这几个方法，其实就是Callbacks回调函数中的add方法，用与push外部的的数据，保存在队列上。</p><p>我们通过resolve、reject以及notify其实也就是处理Callbacks中的队列列表。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">// jQuery. Deferred主要处理：</span><br><span class="line">//     显而易见Deferred是个工厂类，返回的是内部构建的deferred对象</span><br><span class="line">//     tuples 创建三个$.Callbacks对象，分别表示成功，失败，处理中三种状态</span><br><span class="line">//     创建了一个promise对象，具有state、always、then、primise方法</span><br><span class="line">//     扩展primise对象生成最终的Deferred对象，返回该对象</span><br><span class="line">//     primise对象就是一个受限对象，只读</span><br><span class="line">var Deferred = function(func) &#123;</span><br><span class="line">  var tuples = [</span><br><span class="line">    //1 动作</span><br><span class="line">    //2 侦听器</span><br><span class="line">    //3 最终状态</span><br><span class="line">    //后面的操作将是围绕这些接口处理</span><br><span class="line">    [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">    [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">    [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">  ],</span><br><span class="line">  state = &quot;pending&quot;,</span><br><span class="line">  //扩展的primise对象</span><br><span class="line">  promise = &#123;</span><br><span class="line">    state: function() &#123;&#125;,</span><br><span class="line">    always: function() &#123;&#125;,</span><br><span class="line">    then: function( /* fnDone, fnFail, fnProgress */ ) &#123;&#125;,</span><br><span class="line">    promise: function(obj) &#123;&#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  deferred = &#123;&#125;;</span><br><span class="line">  //定义管道风格的接口pipe</span><br><span class="line">  promise.pipe = promise.then;</span><br><span class="line">  //逐个添加所有的接口到deferred对象上</span><br><span class="line">  jQuery.each(tuples, function(i, tuple) &#123;</span><br><span class="line">    deferred[tuple[0]] = function() &#123;</span><br><span class="line">      deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments);</span><br><span class="line">      return this;</span><br><span class="line">    &#125;;</span><br><span class="line">    deferred[tuple[0] + &quot;With&quot;] = list.fireWith;</span><br><span class="line">  &#125;);</span><br><span class="line">  //转成成promise对象</span><br><span class="line">  promise.promise(deferred);</span><br><span class="line">  //如果传递的参数是函数，直接运行</span><br><span class="line">  if (func) &#123;</span><br><span class="line">    func.call(deferred, deferred);</span><br><span class="line">  &#125;</span><br><span class="line">  return deferred;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//when就是一个合集的处理</span><br><span class="line">//可以收集多个异步操作，合并成功后处理</span><br><span class="line">//同时也可以绑定Promise 对象的其它方法，如 defered.then</span><br><span class="line">//所以when内部必须要创建一个deferred对象</span><br><span class="line">var when = function(subordinate /* , ..., subordinateN */ ) &#123;</span><br><span class="line">  var i = 0,</span><br><span class="line">    resolveValues = slice.call(arguments),</span><br><span class="line">    length = resolveValues.length,</span><br><span class="line">    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</span><br><span class="line">    updateFunc = function(i, contexts, values) &#123;</span><br><span class="line">      return function(value) &#123;&#125;;</span><br><span class="line">    &#125;,</span><br><span class="line">    progressValues, progressContexts, resolveContexts;</span><br><span class="line">  if (length &gt; 1) &#123;</span><br><span class="line">    progressValues = new Array(length);</span><br><span class="line">    progressContexts = new Array(length);</span><br><span class="line">    resolveContexts = new Array(length);</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">      if (resolveValues[i] &amp;&amp; jQuery.isFunction(resolveValues[i].promise)) &#123;</span><br><span class="line">        resolveValues[i].promise()</span><br><span class="line">          .done(updateFunc(i, resolveContexts, resolveValues))</span><br><span class="line">          .fail(deferred.reject)</span><br><span class="line">          .progress(updateFunc(i, progressContexts, progressValues));</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        --remaining;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return deferred.promise();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2>Deferred的执行流程</h2><p>用下面的例子分析（见右侧代码编辑器）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var defer = $.Deferred();</span><br><span class="line">defer.resolve(5);</span><br><span class="line">defer.done(function(value) &#123;&#125;)</span><br><span class="line">var filtered = defer.then(function(value) &#123;</span><br><span class="line">  return value * 2;</span><br><span class="line">&#125;);</span><br><span class="line">filtered.done(function(value) &#123;&#125;);</span><br></pre></td></tr></table></figure><p>这里有几个关键的问题：</p><p>1、defer延时对象通过resolved触发done成功回调，调用在添加done之前，那么靠什么延时处理？</p><p>2、为什么defer.then对象返回的给filtered.done的数据可以类似管道风格的顺序叠加给后面的done处理？</p><p>一般来说，javascript要实现异步的收集，就需要“等待”，比如defer.resolve(5)虽然触发了，但是done的处理还没添加，我们必须要等待done、then等方法先添加了后才能执行了resolve，那么常规的的用法就是在resolve内部用setTimeout 0，image.onerror行成一个异步的等待操作处理。</p><p>但是jQuery很巧妙的绕过了这个收集方式，</p><p>defer.resolve(5)方法实际就是触发了callback回到函数的fireWith方法，这样可以接受一个上下文deferred与参数5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments);</span><br></pre></td></tr></table></figure><p>之前 done | fail | progress方法都是通过jQuery.Callbacks(“once memory”) 或 jQuery.Callbacks(“memory”)生成的。</p><p>实际上在Callback源码fire方法有一句 memory = options.memory &amp;&amp; data;这样就很巧妙的缓存当前参数5的值，提供给下一个使用，这个就是then，pipe链式数据的一个基础了，此刻的操作，我们把memory保存了这个数据的值。</p><p>重点来了，下一个defer.done的操作也是走的add的处理，把done的回调函数加入到list队列中的之后，接着就会触发。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> // With memory, if we&apos;re not firing then</span><br><span class="line"> // we should call right away</span><br><span class="line">&#125; else if (memory) &#123;</span><br><span class="line">  firingStart = start;</span><br><span class="line">  fire(memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为memory在上一个resolve操作的时候，缓存了5了，所以memory的判断显示是为真的，所以立刻就触发了fire(memory)的代码了，所以就算触发的循序与添加的循序不一致，也不会导致错误。 而且jquery很巧妙的避免了异步收集的问题，这样处理更可靠了。可见回调函数模块就是为Deferred模块量身定做的了。</p><p>第二个问题，是关于then，pipe管道风格的处理，这样也是一个很复杂的设计，在后面一章就提到了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var filterResolve = function() &#123;</span><br><span class="line">  var defer = $.Deferred();</span><br><span class="line">  //先执行成功</span><br><span class="line">  defer.resolve(5);</span><br><span class="line">  //后添加</span><br><span class="line">  defer.done(function(value) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&quot;&lt;li&gt;defer.done的值是：&quot; + value + &quot;&lt;/li&gt;&quot;);</span><br><span class="line">  &#125;)</span><br><span class="line">  //实现一个管道方法</span><br><span class="line">  var filtered = defer.then(function(value) &#123;</span><br><span class="line">    return value * 2;</span><br><span class="line">  &#125;);</span><br><span class="line">  //接受上一个值，叠加处理</span><br><span class="line">  filtered.done(function(value) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&quot;&lt;li&gt;filtered.done ( 2*5 = ) 10: &quot; + &quot;&lt;/li&gt;&quot;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;, filterResolve);</span><br></pre></td></tr></table></figure><h2>Deferred源码剖析(上)</h2><p>Deferred对接口的设计别出心裁，不是常规的直接定义的，我们可以看tuples这个数组的定义。</p><p><strong>Deferred</strong><strong>自身则围绕这三组数据进行更高层次的抽象</strong></p><p>☑ 触发回调函数列表执行(函数名)</p><p>☑ 添加回调函数（函数名）</p><p>☑ 回调函数列表（jQuery.Callbacks对象）</p><p>☑ Deferred最终状态（第三组数据除外）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var tuples = [</span><br><span class="line">  // action, add listener, listener list, final state</span><br><span class="line">  [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">  [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">  [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里抽象出2组阵营：</p><p><strong>1</strong>**组：回调方法/事件订阅 **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">done、fail、progress</span><br></pre></td></tr></table></figure><p><strong>2</strong>**组：通知方法/事件发布    **</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">resolve、reject、notify、resolveWith、rejectWith、notifyWith</span><br></pre></td></tr></table></figure><p>Tuples元素集，其实是把相同有共同特性的代码的给合并成一种结构，然后来一次处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(tuples, function(i, tuple) &#123;</span><br><span class="line">  //代码请看右边代码区域</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于Tuples的3条数据集是分2部分处理的：</p><p><strong>第一部分将回调函数存入</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise[ tuple[1] ] = list.add;</span><br></pre></td></tr></table></figure><p>其实就是给promise赋予3个回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.done = $.Callbacks(&quot;once memory&quot;).add</span><br><span class="line">promise.fail = $.Callbacks(&quot;once memory&quot;).add</span><br><span class="line">promise.progressl = $.Callbacks(&quot;memory&quot;).add</span><br></pre></td></tr></table></figure><p>如果存在Deferred最终状态，默认会预先向doneList，failList中的list添加三个回调函数。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (stateString) &#123;</span><br><span class="line">  list.add(function() &#123;</span><br><span class="line">    state = stateString;</span><br><span class="line">  &#125;, tuples[i ^ 1][2].disable, tuples[2][2].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个小技巧：</p><p>i ^ 1 <a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">按位异或运算符</a></p><p>所以实际上第二个传参数是1、0索引对调了，所以取值是failList.disable与doneList.disable。</p><p><strong>通过stateString有值这个条件，预先向doneList,failList中的list添加三个回调函数，分别是:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doneList : [changeState, failList.disable, processList.lock]</span><br><span class="line">failList : [changeState, doneList.disable, processList.lock]</span><br></pre></td></tr></table></figure><p>☑ changeState 改变状态的匿名函数，deferred的状态，分为三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)；</p><p>☑ 不论deferred对象最终是resolve（还是reject），在首先改变对象状态之后，都会disable另一个函数列表failList(或者doneList)；</p><p>☑ 然后lock processList保持其状态，最后执行剩下的之前done（或者fail）进来的回调函数。</p><p>所以第一步最终都是围绕这add方法：</p><p>☑ done/fail/是list.add也就是<a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#add" target="_blank" rel="noopener">callbacks.add</a>，将回调函数存入回调对象中。</p><p><strong>第二部分很简单，给Deferred对象扩充6个方法：</strong></p><p>☑ resolve/reject/notify 是 <a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith" target="_blank" rel="noopener">callbacks.fireWith</a>，执行回调函数；</p><p>☑ resolveWith/rejectWith/notifyWith 是 <a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith" target="_blank" rel="noopener">callbacks.fireWith</a> 队列方法引用。</p><p>最后合并promise到Deferred。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">promise.promise( deferred );</span><br><span class="line">jQuery.extend( obj, promise );</span><br></pre></td></tr></table></figure><p>所以最终通过工厂方法Deferred构建的异步对象带的所有的方法了，return内部的deferred对象了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;button&gt;测试Deferred&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">      </span><br><span class="line">    function Deferred()&#123;</span><br><span class="line">      //内部deferred对象</span><br><span class="line">      var deferred = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      //定义的基本接口</span><br><span class="line">      //Callbacks(once memory)的用法，就是只执行一次，并且保持以前的值</span><br><span class="line">      // 每个元组分别包含一些与当前deferred相关的信息: </span><br><span class="line">      // 分别是：触发回调函数列表执行(函数名)，添加回调函数（函数名），回调函数列表（jQuery.Callbacks对象），deferred最终状态（第三组数据除外）</span><br><span class="line">      // 总体而言，三个元组会有对应的三个callbacklist对应于doneList, failList, processList</span><br><span class="line">      var tuples = [</span><br><span class="line">        [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">        [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">        [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      //deferred的状态，三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)</span><br><span class="line">      //其实就是tuples最后定义的</span><br><span class="line">      var state = &quot;pending&quot;;</span><br><span class="line"></span><br><span class="line">      //内部promise对象,作用：</span><br><span class="line">      //1：通过promise.promise( deferred );混入到deferred中使用</span><br><span class="line">      //2：可以生成一个受限的deferred对象，</span><br><span class="line">      //   不在拥有resolve(With), reject(With), notify(With)这些能改变deferred对象状态并且执行callbacklist的方法了</span><br><span class="line">      //   换句话只能读，不能改变了</span><br><span class="line">      //扩展</span><br><span class="line">      //  done fail pipe process </span><br><span class="line">      var promise = &#123;</span><br><span class="line">        state: function() &#123;&#125;,</span><br><span class="line">        always: function() &#123;&#125;,</span><br><span class="line">        then: function() &#123;&#125;,</span><br><span class="line">        promise: function(obj) &#123;</span><br><span class="line">          return obj != null ? jQuery.extend(obj, promise) : promise;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      //管道接口,API别名</span><br><span class="line">      promise.pipe = promise.then;</span><br><span class="line"></span><br><span class="line">      //遍历tuples</span><br><span class="line">      //把定义的接口混入到deferred中</span><br><span class="line">      jQuery.each(tuples, function(i, tuple) &#123;</span><br><span class="line">        var list = tuple[2],</span><br><span class="line">          stateString = tuple[3];</span><br><span class="line"></span><br><span class="line">          // 给上面的promise对象添加done，fail，process方法</span><br><span class="line">          // 分别引用三个不同 jQuery.Callbacks(&quot;once memory&quot;)对象的add方法，在初始化就构建成了对象</span><br><span class="line">          // 向各自的回调函数列表list（各自闭包中）中添加回调函数，互不干扰</span><br><span class="line">          // promise = &#123;</span><br><span class="line">          //    done:</span><br><span class="line">          //    fail:</span><br><span class="line">          //    process</span><br><span class="line">          // &#125;</span><br><span class="line">          promise[tuple[1]] = list.add;</span><br><span class="line"></span><br><span class="line">        if (stateString) &#123;</span><br><span class="line">          list.add(function() &#123;</span><br><span class="line">            state = stateString;</span><br><span class="line">          &#125;, tuples[i ^ 1][2].disable, tuples[2][2].lock);</span><br><span class="line">        &#125;</span><br><span class="line">        deferred[tuple[0]] = function() &#123;</span><br><span class="line">          deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments);</span><br><span class="line">          return this;</span><br><span class="line">        &#125;;</span><br><span class="line">        deferred[tuple[0] + &quot;With&quot;] = list.fireWith;</span><br><span class="line">      &#125;);</span><br><span class="line">      //混入方法</span><br><span class="line">      promise.promise(deferred);</span><br><span class="line"></span><br><span class="line">      return deferred;</span><br><span class="line">    &#125;</span><br><span class="line">  $(&quot;button&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">    var dtd = Deferred();</span><br><span class="line">    // 给deferred注册一个成功后的回调通知</span><br><span class="line">    dtd.done(function() &#123;</span><br><span class="line">       $(&apos;body&apos;).append(&apos;&lt;li&gt;Deferred成功&lt;/li&gt;&apos;)</span><br><span class="line">    &#125;)</span><br><span class="line">    // 开始执行一段代码</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">      dtd.resolve(); // 改变deferred对象的执行状态</span><br><span class="line">    &#125;, 500);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h2>Deferred源码剖析(下)</h2><p>在上一节中构建了deferred对象，实现了done/fail/process和resolve/reject/notify等方法，但是最重要的then,pipe管道接口我们还没有实现，我们考虑下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var dfd = $.Deferred()</span><br><span class="line">dfd.then(function(preVale) &#123;</span><br><span class="line">  return 2 * preVale   //4</span><br><span class="line">&#125;).then(function(preVale) &#123;</span><br><span class="line">  return 3 * preVale   //12</span><br><span class="line">&#125;)</span><br><span class="line">dfd.resolve(2)</span><br></pre></td></tr></table></figure><p>then就是pipe，我们可以想象是一个管道，可以对回调模式使用瀑布模型。如案例所示，下一个回调都能取到上一个回调的值，这样一直可以叠加往后传递。</p><p>不难看出管道的风格就是链式的操作，每一个链上的结果都会反馈后下一个链，那么这个链式是不是传统的返回自身这个对象this呢？</p><p>常规的办法通过数组处理：右侧代码所示。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function aDeferred(）&#123;</span><br><span class="line">   //代码右侧代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样的结构当然是很简陋的，这里我们最终有一个本质的问题没有解决，jQuery中的then的返回还有可能是另一个新的异步模型对象,如ajax，因此还能实现done，fail,always,then等方法。所以采用简陋的数组的方式保存状态是很肤浅的了。</p><p>这时候jQuery采取了对象保存处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以把每一次的then操作，当做是创建一个新的deferred对象，那么每一个对象都够保存自己的状态与各自的处理方法。通过一个办法把所有的对象操作都串联起来，这就是then或者pipe管道设计的核心思路了。</span><br></pre></td></tr></table></figure><p>看jQuery的<strong>then</strong>结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">then: function( /* fnDone, fnFail, fnProgress */ ) &#123;</span><br><span class="line">         var fns = arguments;</span><br><span class="line">         return jQuery.Deferred(function(newDefer) &#123;</span><br><span class="line">                   jQuery.each(tuples, function(i, tuple) &#123;</span><br><span class="line">                            deferred[tuple[1]](function() &#123;</span><br><span class="line">                         // deferred[ done | fail | progress ]                   </span><br><span class="line">                    &#125;);</span><br><span class="line">               &#125;);</span><br><span class="line">         &#125;).promise()</span><br></pre></td></tr></table></figure><p>其实在内部创建了一个新的Deferred对象，不过这里的不同是通过传递一个回调函数，参数是newDefer，其实Deferred内部就是为了改变下上下文this为deferred，然后传递deferred给这个回调函数了，所以newDefer就指向内部的deferred对象了。</p><p>那么对象之间如何关联？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(tuples, function(i, tuple) &#123;</span><br><span class="line">  //取出参数</span><br><span class="line">  var fn = jQuery.isFunction(fns[i]) &amp;&amp; fns[i];</span><br><span class="line">  // deferred[ done | fail | progress ] for forwarding actions to newDefer</span><br><span class="line">  // 添加done fail progress的处理方法</span><br><span class="line">  // 针对延时对象直接做了处理</span><br><span class="line">  deferred[tuple[1]](function() &#123;</span><br><span class="line">    var returned = fn &amp;&amp; fn.apply(this, arguments);</span><br><span class="line">    if (returned &amp;&amp; jQuery.isFunction(returned.promise)) &#123;</span><br><span class="line">      returned.promise()</span><br><span class="line">        .done(newDefer.resolve)</span><br><span class="line">        .fail(newDefer.reject)</span><br><span class="line">        .progress(newDefer.notify);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      newDefer[tuple[0] + &quot;With&quot;](this === promise ? newDefer.promise() : this, fn ? [returned] : arguments);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把then的方法通过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deferred.done</span><br><span class="line">deferred.fail</span><br><span class="line">deferred.progress</span><br></pre></td></tr></table></figure><p>加入到上一个对象的各自的执行队列中保存了。这样就实现了不同对象之间的关联调用。</p><p>同样如果then返回的是一个promise对象（ajax）的时候：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if (returned &amp;&amp; jQuery.isFunction(returned.promise)) &#123;</span><br><span class="line">  returned.promise()</span><br><span class="line">    .done(newDefer.resolve)</span><br><span class="line">    .fail(newDefer.reject)</span><br><span class="line">    .progress(newDefer.notify);</span><br></pre></td></tr></table></figure><p>也可以直接处理了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;button&gt;模拟的代码测试&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  //使用$.Deferred</span><br><span class="line">  var dfd = $.Deferred()</span><br><span class="line">  dfd.then(function(preVale) &#123;</span><br><span class="line">    return 2 * preVale; </span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    return 3 * preVale </span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&apos;&lt;li&gt;使用$.Deferred代码结果:&apos;+ preVale +&apos;&lt;/li&gt;&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  dfd.resolve(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //简单模拟</span><br><span class="line">  function aDeferred() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    return &#123;</span><br><span class="line">      then: function(fn) &#123;</span><br><span class="line">        arr.push(fn)</span><br><span class="line">        return this;</span><br><span class="line">      &#125;,</span><br><span class="line">      resolve: function(args) &#123;</span><br><span class="line">        var returned;</span><br><span class="line">        arr.forEach(function(fn, i) &#123;</span><br><span class="line">          var o = returned || args;</span><br><span class="line">          returned = fn(o)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">  var d = aDeferred();</span><br><span class="line">  d.then(function(preVale) &#123;</span><br><span class="line">    return 2 * preVale //4</span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    return 3 * preVale //4</span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&apos;&lt;li&gt;模拟代码结果:&apos;+ preVale +&apos;&lt;/li&gt;&apos;)</span><br><span class="line">  &#125;);</span><br><span class="line">  d.resolve(2)</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3>when方法的设计</h3><p>when也是一个非常有用的方法，常用于合并多个异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when(d1,d2,d3,d4......).done(function(v1, v2,v3...) &#123;</span><br><span class="line">    //等待所有异步加载完毕后执行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用法很简单，把所有的异步丢到when中，when会处理所有的结果。当然d1,d2,d3都是有规范的，都是通过Deferred产生的。</p><p>具体的用法见右侧代码编辑器中的代码。</p><p>如果向 <code>jQuery.when()</code> 传入延迟对象，那么会返回它的 Promise 对象(延迟方法的一个子集)。可以继续绑定 Promise 对象的其它方法，例如， <code>defered.then</code> 。当延迟对象已经被解决（resolved）或被拒绝(rejected）（通常是由创建延迟对象的最初代码执行的），那么就会调用适当的回调函数。例如，由 <code>jQuery.ajax()</code> 返回的 jqXHR 对象是一个延迟对象，可以向下面这样使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when($.ajax(&quot;test.aspx&quot;)).then(function(data, textStatus, jqXHR) &#123;</span><br><span class="line">  alert(jqXHR.status); // alerts 200</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过模拟的代码，可以很简单的分析整个流程：</p><p>1. 传递了多个异步对象，然后遍历每个异步对象给每一个对象绑定done、fail、progess方法，无非就是监听每一个异步的状态（成功，失败），如果是完成了自然会激活done方法。</p><p>2. updateFunc是监听方法，通过判断异步对象执行的次数来决定是不是已经完成了所有的处理或者是失败处理</p><p>3. 因为<code>when也要形成异步操作，</code>比如when().done()，<code>所以内部必须新建一个</code>jQuery.Deferred()对象，用来给后面链式调用。</p><p>4. 此刻监听所有异步对象(d1,d2…)的updateFunc的处理都完毕了，会给一个正确的通知给when后面的done方法，因为done是通过第三步jQuery.Deferred()创建的，所以此时就需要发送消息到这个上面，即：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred.resolveWith(contexts, values);</span><br></pre></td></tr></table></figure><p>5. 内部的jQuery.Deferred()因为外部绑定了when().done(),所以done自然就收到了updateFunc给的消息了，可以继续之后的操作了。</p><p>所以整个执行流程就是这样简单，我们通过右边最简单的模拟出这个效果。</p><p>整个when的设计其实最终还是依赖了jQuery.Deferred内部处理的机制，一层套一层。当然jQuery的异步设计逻辑也确实很复杂，需要思维跳转很活跃，某一个时间在这里，下一个片段又要另一个地方去了，不是按照同步代码这样执行的。需要大家有一定的空间跳跃力了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;script src=&quot;http://img.mukewang.com/down/541f6ff70001a0a500000000.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;button&gt;$.when代码测试&lt;/button&gt;</span><br><span class="line">&lt;button&gt;when模拟的代码测试&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">$(&apos;button&apos;).eq(0).click(function() &#123;</span><br><span class="line">  var d1 = new $.Deferred();</span><br><span class="line">  var d2 = new $.Deferred();</span><br><span class="line"></span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    d1.resolve(&quot;$.when代码测试Fish&quot;);</span><br><span class="line">  &#125;,500)</span><br><span class="line"></span><br><span class="line">  setTimeout(function()&#123;</span><br><span class="line">    d2.resolve(&quot;$.when代码测试Pizza&quot;);</span><br><span class="line">  &#125;,1000)</span><br><span class="line"></span><br><span class="line">$.when(d1, d2).done(function(v1, v2) &#123;</span><br><span class="line">  show(v1); // &quot;Fish&quot;</span><br><span class="line">  show(v2); // &quot;Pizza&quot;</span><br><span class="line">&#125;);  </span><br><span class="line">&#125;)</span><br><span class="line">ul</span><br><span class="line">$(&apos;button&apos;).eq(1).click(function() &#123;</span><br><span class="line"></span><br><span class="line">  var d1 = new $.Deferred();</span><br><span class="line">  var d2 = new $.Deferred();</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    d1.resolve(&quot;when模拟:Fish&quot;);</span><br><span class="line">  &#125;, 500)</span><br><span class="line"></span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    d2.resolve(&quot;when模拟:Pizza&quot;);</span><br><span class="line">  &#125;, 1000)</span><br><span class="line"></span><br><span class="line">  function when(d1, d2) &#123;</span><br><span class="line">    var i = 0,</span><br><span class="line">      resolveValues = [].slice.call(arguments),</span><br><span class="line">      length = resolveValues.length;</span><br><span class="line">    var len = length;</span><br><span class="line">    //收集resolve值</span><br><span class="line">    var values = [];</span><br><span class="line">    var deferred = jQuery.Deferred();</span><br><span class="line"></span><br><span class="line">    function updateFunc(value) &#123;</span><br><span class="line">      values.push(value);</span><br><span class="line">      if (len === 1) &#123;</span><br><span class="line">        deferred.resolveWith(&apos;contexts&apos;, values);</span><br><span class="line">      &#125;</span><br><span class="line">      len--</span><br><span class="line">    &#125;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">      resolveValues[i].done(updateFunc)</span><br><span class="line">    &#125;</span><br><span class="line">    return deferred;</span><br><span class="line">  &#125;</span><br><span class="line">  when(d1, d2).done(function(v1, v2) &#123;</span><br><span class="line">    show(v1); // &quot;Fish&quot;</span><br><span class="line">    show(v2); // &quot;Pizza&quot;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;JavaScript编程几乎总是伴随着异步操作，传统的异步操作会在操作完成之后，使用回调函数传回结果，而回调函数中则包含了后续的工作。这也是造成异步编程困难的主要原因：&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>JQuery源码解读 02-对象构建</title>
    <link href="http://yoursite.com/2016/10/28/JQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2002-%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA/"/>
    <id>http://yoursite.com/2016/10/28/JQuery源码解读 02-对象构建/</id>
    <published>2016-10-27T16:00:00.000Z</published>
    <updated>2018-02-23T07:34:25.725Z</updated>
    
    <content type="html"><![CDATA[<h2>对象简介</h2><p>面向对象(OOP)的语言都有一个特点，它们都会有类的这一概念，通过类可以抽象出创建具体相同方法与属性的对象。但是ECMAScript中是没有类的概念的，因此它的对象与基于类的语言如java的定义是有所不同的。</p><a id="more"></a><p>在JavaScript世界中函数作为“一等公民”，它不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值、传参、返回，这样的函数也称之为第一级函数。不仅如此，而且还可以通过操作符new来充当类的构造器。</p><p>函数在充当类的构造器时，原型prototype是一个重要的概念。prototype是构造函数的一个属性, 该属性指向一个对象。而这个对象将作为该构造函数所创建的所有实例的基引用(base reference), 可以把对象的基引用想像成一个自动创建的隐藏属性。 当访问对象的一个属性时, 首先查找对象本身, 找到则返回；若不, 则查找基引用指向的对象的属性(如果还找不到实际上还会沿着原型链向上查找,  直至到根)。 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到。</p><p>类一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ajQuery() &#123;</span><br><span class="line">    this.name = &apos;jQuery&apos;;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">var a = new ajQuery()</span><br><span class="line">var b = new ajQuery()</span><br><span class="line">var c = new ajQuery()</span><br></pre></td></tr></table></figure><p>类二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function ajQuery() &#123;</span><br><span class="line">    this.name = &apos;jQuery&apos;</span><br><span class="line">&#125;</span><br><span class="line">ajQuery.prototype = &#123;</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new ajQuery()</span><br><span class="line">var b = new ajQuery()</span><br><span class="line">var c = new ajQuery()</span><br></pre></td></tr></table></figure><p>类一与类二产生的结构几乎是一样的，而本质区别就是：类二new产生的a、b、c三个实例对象共享了原型的sayName方法，这样的好处节省了内存空间，类一则是要为每一个实例复制sayName方法，每个方法属性都占用一定的内存的空间，所以如果把所有属性方法都声明在构造函数中，就会无形的增大很多开销，这些实例化的对象的属性一模一样，都是对this的引用来处理。除此之外类一的所有方法都是拷贝到当前实例对象上。类二则是要通过scope连接到原型链上查找，这样就无形之中要多一层作用域链的查找了。</p><p>jQuery对象的构建如果在性能上考虑，所以就必须采用原型式的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery = function( selector, context ) &#123;</span><br><span class="line">    return new jQuery.fn.init( selector, context );</span><br><span class="line">&#125;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init：function()&#123;</span><br><span class="line">    return this</span><br><span class="line">&#125;,</span><br><span class="line">    jquery: version,</span><br><span class="line">    constructor: jQuery,</span><br><span class="line">    ………………</span><br><span class="line">&#125;</span><br><span class="line">var a = $() ;</span><br></pre></td></tr></table></figure><p>使用原型结构，性能上是得到了优化，但是ajQuery类这个结构与目标jQuery的结构的还是有很大不一致：</p><p>☑   没有采用new操作符；</p><p>☑   return返回的是一个通过new出来的的对象 。</p><p><a href="https://github.com/JsAaron/jQuery" target="_blank" rel="noopener">所有案例的github下载地址</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ajQuery()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'jQuery'</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.prototype = &#123;</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ajQuery()</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery的写法</span></span><br><span class="line"><span class="keyword">var</span> $jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> $jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$jQuery.fn = $jQuery.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'aaron'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">constructor</span>: $jQuery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var $a = $jQuery();</span><br><span class="line">show('$jQuery的调用')</span><br><span class="line">show($a);</span><br></pre></td></tr></table></figure><h2>分离构造器</h2><p>通过new操作符构建一个对象，一般经过四步：</p><p><strong>A.创建一个新对象</strong></p><p><strong>B.将构造函数的作用域赋给新对象（所以this就指向了这个新对象）</strong></p><p><strong>C.执行构造函数中的代码</strong></p><p><strong>D.返回这个新对象</strong></p><p>最后一点就说明了，我们只要返回一个新对象即可。其实new操作符主要是把原型链跟实例的this关联起来，这才是最关键的一点，所以我们如果需要原型链就必须要new操作符来进行处理。否则this则变成window对象了。</p><p>我们来剖析下jQuery的这个结构,以下是我们常见的类式写法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">//实例化时，返回自身对象,返回后可以调用方法[链式调用]</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">    selectorName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.selector;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">var a = new $$('aaa');  //实例化</span><br><span class="line">a.selectorName() //aaa //得到选择器名字</span><br></pre></td></tr></table></figure><p>首先改造jQuery无new的格式，我们可以通过instanceof判断this是否为当前实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> ajQuery))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ajQuery(selector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意千万不要像下面这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var $$ = ajQuery = function(selector) &#123;</span><br><span class="line">    this.selector = selector;</span><br><span class="line">    return new ajQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line">Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><p>这样会无限递归自己，从而造成死循环并且溢出。</p><p>jQuery为了避免出现这种死循环的问题，采取的手段是把原型上的一个init方法作为构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var $$ = ajQuery = function(selector) &#123;</span><br><span class="line">    //把原型上的init作为构造器</span><br><span class="line">    return new ajQuery.fn.init( selector );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">    name: &apos;aaron&apos;,</span><br><span class="line">    init: function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;,</span><br><span class="line">    constructor: ajQuery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实解决了循环递归的问题，但是又问题来了，init是ajQuery原型上作为构造器的一个方法，那么其this就不是ajQuery了，所以this就完全引用不到ajQuery的原型了，所以这里通过new把init方法与ajQuery给分离成2个独立的构造器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见写法</span></span><br><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">selectorName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.selector;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">var a = new $$('aaa');  //实例化</span><br><span class="line"></span><br><span class="line">//得到选择器名字</span><br><span class="line">//aaa</span><br><span class="line">$("#test").html( a.selectorName() )</span><br></pre></td></tr></table></figure><h3>Q&amp;A</h3><h4>为什么init作为构造函数可以解决递归循环</h4><h4>return new jQuery.fn.init(selector);为什么不会出现递归循环</h4><p>最佳回答</p><p>去看一下new的过程，new的创建过程分为四步：</p><p>（1）创建一个新对象</p><p>（2）将构造函数的作用域赋值给新的对象</p><p>（3）执行构造函数的代码</p><p>（4）返回新对象</p><p>题目总的代码 return 返回的是一个对象，当然不会产生循环调用</p><h2>静态与实例方法共享设计</h2><p>保留上一节分割出2个构造器的疑问，我们先看看jQuery在接口的设计：</p><p><strong>遍历方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.aaron&quot;).each()   //作为实例方法存在</span><br><span class="line">$.each()             //作为静态方法存在</span><br></pre></td></tr></table></figure><p>这是最常见的遍历方法，第一条语句是给有指定的上下文调用的，就是(&quot;.aaron&quot;)获取的DOM合集，第二条语句$.each()函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次都会传递一个数组索引和相应的数组值作为参数。本质上来说2个都是遍历，那么我们是不是要写2个方法呢？</p><p>我们来看看jQuery的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype = &#123;</span><br><span class="line">    each: function( callback, args ) &#123;</span><br><span class="line">        return jQuery.each( this, callback, args );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例方法取于静态方法，换句话来说这是静态与实例方法共享设计，静态方法挂在jQuery构造器上，原型方法挂在哪里呢？</p><p>我们上节不是讲了内部会划分一个新的构造器init吗？jQuery通过new原型prototype上的init方法当作构造器，那么init的原型链方法就是实例的方法了，所以jQuery通过2个构造器划分2种不同的调用方式一种是静态，一种是原型。</p><p>方法是共享的，并且实例方法取于静态方法，2个构造器是完全隔离的 ,这个要如何处理？</p><p><strong>看看jQuery给的方案：</strong></p><p>画龙点睛的一处<code>init.prototype = jQuery.fn</code>，把jQuery.prototype原型的引用赋给jQuery.fn.init.prototype的原型，这样就把2个构造器的原型给关联起来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">        name: <span class="string">'aaron'</span>,</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.selector = selector; <span class="comment">//表示疑问???循环调用问题</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn.init.prototype = ajQuery.fn</span><br></pre></td></tr></table></figure><p>这段代码就是整个结构设计的最核心的东西了，有这样的一个处理，整个结构就活了！不得不佩服作者的设计思路，别具匠心。</p><p>看看init的的构造图：</p><p><a href="http://img.mukewang.com/540905880001daac05540230.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/540905880001daac05540230.jpg" alt="img"></a></p><p>通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。</p><h2>方法链式调用的实现</h2><p>jQuery的核心理念是Write less,Do more(写的更少,做的更多)，那么链式方法的设计与这个核心理念不谋而合。那么从深层次考虑这种设计其实就是一种Internal DSL。</p><p>DSL是指Domain Specific Language，也就是用于描述和解决特定领域问题的语言。</p><p>我们看一段链式代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input[type="button"]'</span>)</span><br><span class="line">    .eq(<span class="number">0</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'点击我!'</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">1</span>)</span><br><span class="line">.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'input[type="button"]:eq(0)'</span>).trigger(<span class="string">'click'</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">2</span>)</span><br><span class="line">.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.aa'</span>).hide(<span class="string">'slow'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.aa'</span>).show(<span class="string">'slow'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看这个代码的结构，我们或多或少都能猜到其含义：</p><p>☑  找出type类型为button的input元素</p><p>☑  找到第一个按钮，并绑定click事件处理函数</p><p>☑  返回所有按钮，再找到第二个</p><p>☑  为第二个按钮绑定click事件处理函数</p><p>☑  为第三个按钮绑定toggle事件处理函数</p><p>那么可见jQuery的Internal DSL形式带来的好处——编写代码时，让代码更贴近作者的思维模式；阅读代码时，让读者更容易理解代码的含义；应用DSL可以有效的提高系统的可维护性（缩小了实现模型和领域模型的距离，提高了实现的可读性）和灵活性，并且提供开发的效率。</p><p>jQuery的这种管道风格的DSL链式代码，总的来说：</p><p>☑  节约JS代码；</p><p>☑  所返回的都是同一个对象，可以提高代码的效率。</p><p>通过简单扩展原型方法并通过<code>return this</code>的形式来实现跨浏览器的链式调用。利用JS下的简单工厂方法模式，来将所有对于同一个DOM对象的操作指定同一个实例。</p><p>这个原理就超简单了,如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aQuery().init().name()</span><br></pre></td></tr></table></figure><p>分解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = aQuery();</span><br><span class="line">a.init()</span><br><span class="line">a.name()</span><br></pre></td></tr></table></figure><p>把代码分解一下，很明显实现链式的基本条件就是要实例对象先创建好，调用自己的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aQuery.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们如果需要链式的处理，只需要在方法内部方法当前的这个实例对象this就可以了，因为返回当前实例的this，从而又可以访问自己的原型了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。但是这种方法有一个问题是：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。</p><p>虽然Javascript是无阻塞语言，但是他并不是没阻塞，而是不能阻塞，所以他需要通过事件来驱动，异步来完成一些本需要阻塞进程的操作，这样处理只是同步链式，除了同步链式还有异步链式，异步链式jQuery从1.5开始就引入了<strong>Promise,jQuery.Deferred</strong>后期再讨论。</p><h2>插件接口的设计</h2><p>如果jQuery没有插件接口的设计，那么他就像个光杆司令没有兵，就是没有手下，只有自己一个封闭的城堡。因此jQuery城堡需要设计一个大门 - 插件接口，从而打开大门开始招兵买马。当然jQuery除了获得“开发者社区”的大力支持外，也有很多大公司纷纷对它投出了橄榄枝，这也是它成功的关键。</p><p>基于插件接口设计的好处也是颇多的，其中一个最重要的好处是把扩展的功能从主体框架中剥离出去，降低了框架的复杂度。接口的设计好比电脑上的配件如：CPU、内存、硬盘都是作为独立的模块分离出去了，但是主板提供模块的接口，例如支持串口的硬盘，我只要这个硬盘的接口能插上，甭管是500G还是1000G的容量的硬盘，都能使用。所以在软件设计中插件接口的提供把独立的功能与框架以一种很宽松的方式松耦合。</p><p>从之前的分析中我们可以知道jQuery对象的原理，所以一般来说，<strong>jQuery插件的开发分为两种：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☑  一种是挂在jQuery命名空间下的全局函数，也可称为静态方法；</span><br><span class="line"></span><br><span class="line">☑  另一种是jQuery对象级别的方法，即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法。</span><br></pre></td></tr></table></figure><p>提供的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.extend(target, [object1], [objectN])</span><br></pre></td></tr></table></figure><p>接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    removeData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    removeData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jQuery的主体框架就是之前提到的那样，通过<strong>工厂模式</strong>返回一个内部的init构造器生成的对象。但是根据一般设计者的习惯，如果要为jQuery添加静态方法或者实例方法从封装的角度讲是应该提供一个统一的接口才符合设计的。</p><p>jQuery支持自己扩展属性，这个对外提供了一个接口，jQuery.fn.extend()来对对象增加方法，从jQuery的源码中可以看到，jQuery.extend和jQuery.fn.extend其实是同指向同一方法的不同引用。</p><p>这里有一个设计的重点，通过调用的上下文，我们来确定这个方法是作为静态还是实例处理，在javascript的世界中一共有四种上下文调用方式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☑  jQuery.extend调用的时候上下文指向的是jQuery构造器</span><br><span class="line"></span><br><span class="line">☑  jQuery.fn.extend调用的时候上下文指向的是jQuery构造器的实例对象了</span><br></pre></td></tr></table></figure><p>通过extend()函数可以方便快速的扩展功能，不会破坏jQuery的原型结构，jQuery.extend = jQuery.fn.extend = function(){…}; 这个是连等，也就是2个指向同一个函数，怎么会实现不同的功能呢？这就是<strong>this</strong>力量了！</p><p>fn与jQuery其实是2个不同的对象，在之前有讲解：jQuery.extend 调用的时候，this是指向jQuery对象的(jQuery是函数，也是对象)，所以这里扩展在jQuery上。而jQuery.fn.extend 调用的时候，this指向fn对象，jQuery.fn 和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象。这里增加的是原型方法，也就是对象方法了。所以jQuery的API中提供了以上2个扩展函数。</p><p>jQuery的extend代码实现比较长，我们简单说一下重点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">aAron.extend = aAron.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options, src, copy,</span><br><span class="line">        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        length = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个参数，就是对jQuery自身的扩展处理</span></span><br><span class="line">    <span class="comment">//extend,fn.extend</span></span><br><span class="line">    <span class="keyword">if</span> (i === length) &#123;</span><br><span class="line">        target = <span class="keyword">this</span>; <span class="comment">//调用的上下文对象jQuery/或者实例</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//从i开始取参数,不为空开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">                copy = options[name];</span><br><span class="line">                <span class="comment">//覆盖拷贝</span></span><br><span class="line">                target[name] = copy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我来讲解一下上面的代码：因为extend的核心功能就是通过扩展收集功能（类似于mix混入），所以就会存在收集对象（target）与被收集的数据，因为jQuery.extend并没有明确实参，而且是通过arguments来判断的，所以这样处理起来很灵活。arguments通过判断传递参数的数量可以实现函数重载。其中最重要的一段<code>target = this</code>，通过调用的方式我们就能确实当前的this的指向，所以这时候就能确定target了。最后就很简单了，通过for循环遍历把数据附加到这个target上了。当然在这个附加的过程中我们还可以做<strong>数据过滤、深拷贝</strong>等一系列的操作了。</p><h2>回溯处理的设计</h2><p>接下来了解jQuery对DOM进行遍历背后的工作机制，这样可以在编写代码时有意识地避免一些不必要的重复操作，从而提升代码的性能。</p><p><strong>关于jQuery对象的包装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var $aaron = $(&quot;aaron&quot;);</span><br></pre></td></tr></table></figure><p>通过对sizzle的分析，我们可以得知Query选择器最终都是通过DOM接口实现取值的, 但是通过jQuery处理后返回的不仅仅只有DOM对象，而是一个包装容器，返回jQuery对象：$aaron。</p><p>我们来看一下代码：</p><p><img src="http://img.mukewang.com/54090d3400019da004300314.jpg" alt="img"></p><p><strong>在jQuery</strong>对象中<strong><strong>有个prevObject</strong></strong>对象，这个是干嘛用的呢?</p><p>如果你想知道prevObject是做什么的，咱们首先得先来了解一下jQuery对象栈，jQuery内部维护着一个jQuery对象栈。每个遍历方法都会找到一组新元素（一个jQuery对象），然后jQuery会把这组元素推入到栈中。</p><p>而每个jQuery对象都有三个属性：context、selector和prevObject，其中的prevObject属性就指向这个对象栈中的前一个对象，而通过这个属性可以回溯到最初的DOM元素集中。</p><p>为了方便理解，我们做几个简单的测试：</p><p>下面有一个父元素ul,嵌套了一个li节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;aaron&quot;&gt;</span><br><span class="line">    parent</span><br><span class="line">    &lt;li&gt;child&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>我们现给li绑定一个事件，这个很简单，找到ul下面的li，绑定即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var aaron = $(&quot;#aaron&quot;);</span><br><span class="line">    aaron.find(&apos;li&apos;).click(function()&#123;</span><br><span class="line">        alert(1);     //1</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>此时我又想给父元素绑定一个事件，我们是不是又要在aaron上绑定一次事件呢？是的，上面代码通过find处理后，此时的上下文是指向每一个li了,所以必须要重新引用aaron元素（li的父元素），然后再绑定click事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron.click(function()&#123;</span><br><span class="line">      alert(2);     //1</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>这样会不会很麻烦，所以jQuery引入一个简单的内部寻址的机制，可以回溯到之前的Dom元素集合，通过end()方法可以实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaron.find(<span class="string">'li'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">&#125;).end().click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jQuery为我们操作这个内部对象栈提供个非常有用的2个方法</p><p>.end()</p><p>.addBack()</p><p>这里需要指出来可能有些API上是andSelf，因为就Query的api是这样写的，andSelf现在是.addBack()的一个别名。在jQuery1.8和更高版本中应使用.addBack()</p><p>源码其实也是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.andSelf = jQuery.fn.addBack;</span><br></pre></td></tr></table></figure><p>调用第一个方法只是简单地弹出一个对象（结果就是回到前一个jQuery对象）。第二个方法更有意思，调用它会在栈中回溯一个位置，然后把两个位置上的元素集组合起来，并把这个新的、组合之后的元素集推入栈的上方。</p><p>利用这个DOM元素栈可以减少重复的查询和遍历的操作，而减少重复操作也正是优化jQuery代码性能的关键所在。</p><h2>end与addBack</h2><p>大多数jQueryDOM遍历方法来操作jQuery对象实例，并创建一个新的对象，匹配一个不同的DOM元素集合。当发生这种情况时，实际上是新的元素集合被压入到对象内部维护的栈中。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end()进行出栈操作，来返回栈中的前一个状态。</p><p>假设页面上有几个列表项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"second"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>end()方法主要用于jQuery的链式属性中。当没有使用链式用法时，我们通常只是调用变量名上的前一个对象，所以我们不需要操作栈。</p><p>使用end()时，我们可以一次性调用所有需要的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;).end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>链式的原理就是要返回当前操作的上下文。</p><p>下面的代码是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;).find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>上面的代码因为上下文被切换了，所以执行find(‘bar’)时就出错了。</p><p>下面的代码是正确的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;,&apos;red&apos;).end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>首先在链式用法中只在第一个列表中查找样式为 foo 的项目，并将其背景色变成红色。然后end()返回调用find()之前的状态。因此，第二次 find() 将只会查找 <ul class="first"> 中的 ‘.bar’，而不是继续在<li class="foo">中进行查找，结果是将匹配到的元素的背景色变成绿色。上述代码的最终结果是：第一个列表中的第 1 和第 3 个列表项的背景色有颜色，而第二个列表中的任何项目都没有背景色。</li></ul></p><p><strong>总的来说：end方法就是回溯到上一个Dom合集,因此对于链式操作与优化，这个方法还是很有意义的。</strong></p><p><strong>源码实现</strong></p><p>既然是回溯到上一个DOM合集，那么肯定end方法中返回的就是一个jQuery对象了，所以我们看源码其实就是返回prevObject对象了，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">end: function() &#123;</span><br><span class="line">     return this.prevObject || this.constructor(null);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>prevObject在什么情况下会产生？</strong></p><p>在构建jQuery对象的时候，通过pushStack方法构建，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    find: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...........................省略................................</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过sizzle选择器，返回结果集</span></span><br><span class="line">        jQuery.find(selector, self[i], ret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed because $( selector, context ) becomes $( context ).find( selector )</span></span><br><span class="line">        ret = <span class="keyword">this</span>.pushStack(len &gt; <span class="number">1</span> ? jQuery.unique(ret) : ret);</span><br><span class="line">        ret.selector = <span class="keyword">this</span>.selector ? <span class="keyword">this</span>.selector + <span class="string">" "</span> + selector : selector;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过jQuery.find后得到了结果ret这个就是通过纯的DOM节点，那么如果变成一个jQuery对象呢？</p><p>接着我们看pushStack对象，作用就通过新的DOM元素去创建一个新的jQuery对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pushStack: function( elems ) &#123;</span><br><span class="line">    // Build a new jQuery matched element set</span><br><span class="line">    var ret = jQuery.merge( this.constructor(), elems );</span><br><span class="line"></span><br><span class="line">    // Add the old object onto the stack (as a reference)</span><br><span class="line">    ret.prevObject = this;</span><br><span class="line">    ret.context = this.context;</span><br><span class="line"></span><br><span class="line">    // Return the newly-formed element set</span><br><span class="line">    return ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>流程解析：</strong></p><p>1、首先构建一个新的jQuery对象，因为constructor是指向构造器的，所以这里就等同于调用jQuery()方法了，返回了一个新的jQuery对象；</p><p>2、然后用jQuery.merge语句把elems节点合并到新的jQuery对象上；</p><p>3、最后给返回的新jQuery对象添加prevObject属性，我们看到prevObject其实还是当前jQuery的一个引用罢了，所以也就是为什么通过prevObject能取到上一个合集的原因了。</p><h2>仿栈与队列的操作</h2><p>jQuery既然是模仿的数组结构，那么肯定会实现一套类数组的处理方法，比如常见的栈与队列操作push、pop、shift、unshift、求和、遍历循环each、排序及筛选等一系的扩展方法。</p><p>jQuery对象栈是一个便于Dom的查找，提供的一系列方法，jQuery可以是集合元素，那么我们怎么快速的找到集合中对应的目标元素呢？</p><p>jQuery提供了.get()、:index()、 :lt()、:gt()、:even()及 :odd()这类索引值相关的选择器，他们的作用可以过滤他们前面的匹配表达式的集合元素，筛选的依据就是这个元素在原先匹配集合中的顺序。</p><p>我们来分别看一下这几个选择器的实现原理:</p><p>get方法–是通过检索匹配jQuery对象得到对应的DOM元素，如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get: function(num) &#123;</span><br><span class="line">    return num != null ?</span><br><span class="line">    // Return just the one element from the set</span><br><span class="line">    (num &lt; 0 ? this[num + this.length] : this[num]) :</span><br><span class="line">    // Return all the elements in a clean array</span><br><span class="line">    slice.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，因为jQuery查询出来的是一个数组的DOM集合，所以就可以按照数组的方法通过下标的索引取值，当然如果num的值超出范围，比如小于元素数量的负数或等于或大于元素的数量的数，那么它将返回undefined。 假设我们页面上有一个简单的无序列表，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li id=&quot;foo&quot;&gt;foo&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;bar&quot;&gt;bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果指定了index参数，.get()则会获取单个元素，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( $( &quot;li&quot; ).get( 0 ) );</span><br></pre></td></tr></table></figure><p>由于索引 index 是以 0 开始计数的，所以上面代码返回了第一个列表项<code>foo</code>。</p><p>然而，这种语法缺少某些 .get() 所具有的附加功能，比如可以指定索引值为负值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( $( &quot;li&quot; ).get(-1) );</span><br></pre></td></tr></table></figure><p>负的索引值表示从匹配的集合中从末尾开始倒数，所以上面这个例子将会返回列表中最后一项：<code>bar</code>。</p><p>由于是数组的关系，所以我们有几个快速方法，比如头跟尾的取值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first: function() &#123;</span><br><span class="line">    return this.eq( 0 );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">last: function() &#123;</span><br><span class="line">    return this.eq(-1);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>get与eq的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.eq()  减少匹配元素的集合，根据index索引值，精确指定索引对象。</span><br><span class="line">.get() 通过检索匹配jQuery对象得到对应的DOM元素。</span><br></pre></td></tr></table></figure><p><strong>同样是返回元素，那么eq与get有什么区别呢？</strong></p><p>eq返回的是一个jQuery对象，get返回的是一个DOM对象。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( &quot;li&quot; ).get( 0 ).css(&quot;color&quot;, &quot;red&quot;); //错误</span><br><span class="line">$( &quot;li&quot; ).eq( 0 ).css(&quot;color&quot;, &quot;red&quot;); //正确</span><br></pre></td></tr></table></figure><p>get方法本质上是把jQuery对象转换成DOM对象，但是css属于jQuery构造器的，DOM是不存在这个方法的，如果需要用jQuery的方法，我们必须这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var li = $( &quot;li&quot; ).get( 0 );</span><br><span class="line">$( li ).css(&quot;color&quot;, &quot;red&quot;); //用$包装</span><br></pre></td></tr></table></figure><p>取出DOM对象li，然后用$再次包装，使之转变成jQuery对象，才能调用css方法，这样要分2步写太麻烦了，所以jQuery给我们提供了一个便捷方法eq()。</p><p>eq()的实现原理就是在上面代码中的把eq方法内部转成jQuery对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eq: function( i ) &#123;</span><br><span class="line">    var len = this.length,</span><br><span class="line">        j = +i + ( i &lt; 0 ? len : 0 );</span><br><span class="line">    return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );</span><br></pre></td></tr></table></figure><p>上面实现代码的逻辑就是跟get是一样的，区别就是通过了pushStack产生了一个新的jQuery对象。</p><p>jQuery的考虑很周到，通过eq方法只能产生一个新的对象，但是如果需要的是一个合集对象要怎么处理？因此jQuery便提供了一个slice方法：</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.slice( start [, end ] )</span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><p>根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。</p><p>因为是数组对象，意味着我们可以用silce来直接取值了，所以针对合集对象我们可以这样写代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = []</span><br><span class="line">arr.push( this.slice(start[,end]) )     </span><br><span class="line">this.pushStack（arr）</span><br></pre></td></tr></table></figure><p>这个this指的是jQuery对象，因为jQuery对象是数组集合，所以我们可以通过原生的silce方法直接取到集合数，然后通过包装处理即可了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice: function() &#123;</span><br><span class="line">    return this.pushStack( slice.apply( this, arguments ) );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>迭代器</h2><p><strong>迭代器是一个框架的重要设计。我们经常需要提供一种方法顺序用来处理聚合对象中各个元素，而又不暴露该对象的内部，这也是设计模式中的迭代器模式(Iterator)。</strong></p><p>jQuery中的$.each方法就是一个典型的迭代器，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.each([<span class="number">52</span>, <span class="number">97</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">  alert(index + <span class="string">': '</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">$( <span class="string">"li"</span> ).each(<span class="function"><span class="keyword">function</span>(<span class="params"> index </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( index + <span class="string">": "</span><span class="string">" + $(this).text() );</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><p>针对迭代器，这里有几个特点：</p><p>☑ 访问一个聚合对象的内容而无需暴露它的内部。</p><p>☑ 为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</p><p>☑ 遍历的同时更改迭代器所在的集合结构可能会导致问题。</p><p>简单的说：封装实现，然后迭代器的聚合对象不用关心迭代的过程，从而符合SRP原则。</p><p>抛开jQuery的each方法，我们自己实现一个有简单的迭代器功能的代码：</p><p>1、简单回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> length = obj.length;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        callback(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">each(arr, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就满足了迭代模式的设计原则，对于集合内部结果常常变化各异，我们不想暴露其内部结构，但又想让客户代码透明地访问其中的元素，通过回调把逻辑给解耦出来。但是这样的处理其实太简单了，我们还要考虑至少四种情况：</p><p>☑ 聚合对象，可能是对象，字符串或者数组等类型</p><p>☑ 支持参数传递</p><p>☑ 支持上下文的传递</p><p>☑ 支持循环中退出</p><p>我们简单的修改一下上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function each(obj, callback, context, arg) &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    var value;</span><br><span class="line">    var length = obj.length;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">        callback.call(context || null, obj[i], arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">each(arr, function(name, arg) &#123;</span><br><span class="line">    console.log(name, arg ,this);</span><br><span class="line">&#125;, this, &apos;aaa&apos;)</span><br></pre></td></tr></table></figure><p>当然根据回调的处理，从而判断是否要立刻中断这个循环，从而节约性能，也是很简单的，我们可以通过获取处理的返回值来处理，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function each(obj, callback, context, arg) &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    var value;</span><br><span class="line">    var length = obj.length;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">        value = callback.call(context || null, obj[i], arg);</span><br><span class="line">        if (value === false) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见只要通过回调函数callback返回的ture/false的布尔值结果就可以来判断当前是否要强制退出循环。</p><h2>jQuery的each迭代器</h2><p>jQuery的each方法从使用上就要分2种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☑ $.each()函数</span><br><span class="line">☑ $(selector).each()</span><br></pre></td></tr></table></figure><p>$.each()函数和$(selector).each()是不一样的，后者是专门用来遍历一个jQuery对象的，是为jQuery内部服务的。</p><p>$.each()函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次传递一个数组索引和相应的数组值作为参数。（该值也可以通过访问this关键字得到，但是JavaScript始终将this值作为一个Object，即使它是一个简单的字符串或数字值。）该方法返回其第一个参数，这是迭代的对象。</p><p>jQuery的实例方法最终也是调用的静态方法，我们在之前就解释过jQuery的实例与原型方法共享的设计。</p><p>其中each的实例方法如下：</p><p>可见内部是直接调用的静态方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">each: function(callback, args) &#123;</span><br><span class="line">    return jQuery.each(this, callback, args);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>jQuery.each静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">obj, callback, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        length = obj.length,</span><br><span class="line">        isArray = isArraylike(obj);</span><br><span class="line">    <span class="keyword">if</span> (args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">                value = callback.apply(obj[i], args);</span><br><span class="line">                <span class="keyword">if</span> (value === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                value = callback.apply(obj[i], args);</span><br><span class="line">                <span class="keyword">if</span> (value === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>实现原理几乎一致，只是增加了对于参数的判断。对象用for in遍历，数组用for遍历。</p><p>jQuery可以是多个合集数组DOM，所以在处理的时候经常就针对每一个DOM都要单独处理，所以一般都需要调用this.each 方法，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dequeue: function( type ) &#123;</span><br><span class="line">        return this.each(function() &#123;</span><br><span class="line">            jQuery.dequeue( this, type );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>迭代器除了单纯的遍历，在jQuery内部的运用最多的就是接口的<strong>抽象合并</strong>，相同功能的代码功能合并处理：</p><p>例如一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">    class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(&#123;</span><br><span class="line">    mouseenter: &quot;mouseover&quot;,</span><br><span class="line">    mouseleave: &quot;mouseout&quot;,</span><br><span class="line">    pointerenter: &quot;pointerover&quot;,</span><br><span class="line">    pointerleave: &quot;pointerout&quot;</span><br><span class="line">&#125;, function( orig, fix ) &#123;</span><br><span class="line">    //处理的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h2&gt;对象简介&lt;/h2&gt;
&lt;p&gt;面向对象(OOP)的语言都有一个特点，它们都会有类的这一概念，通过类可以抽象出创建具体相同方法与属性的对象。但是ECMAScript中是没有类的概念的，因此它的对象与基于类的语言如java的定义是有所不同的。&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
  <entry>
    <title>网站迁移(hexo)</title>
    <link href="http://yoursite.com/2016/10/23/JQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2001/"/>
    <id>http://yoursite.com/2016/10/23/JQuery源码解读 01/</id>
    <published>2016-10-22T16:00:00.000Z</published>
    <updated>2018-02-23T07:34:08.874Z</updated>
    
    <content type="html"><![CDATA[<p>##简介</p><p>从整体入手理解架构，再深入攻破每个依赖模块，包括回调函数、异步加载、数据缓存、动画队列最后整体分析：选择器、DOM处理、AJAX、动画模块、事件</p><a id="more"></a><h2>jQuery设计理念</h2><p>引用百科的介绍：</p><p>jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理<strong>HTML（标准通用标记语言下的一个应用）、events、实现动画效果</strong>，并且方便地为网站提供<strong>AJAX交互</strong>。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p><p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！</p><p><strong>简洁的API:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.on</span><br><span class="line">$.css</span><br><span class="line">$.ajax</span><br><span class="line">….</span><br></pre></td></tr></table></figure><p><strong>优雅的链式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var jqxhr = $.ajax( &quot;example.php&quot; )</span><br><span class="line">    .done(function() &#123; alert(&quot;success&quot;); &#125;)</span><br><span class="line">    .fail(function() &#123; alert(&quot;error&quot;); &#125;)</span><br><span class="line">    .always(function() &#123; alert(&quot;complete&quot;); &#125;);</span><br></pre></td></tr></table></figure><p><strong>强大的选择器：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;div, span, p.myClass&quot; )</span><br><span class="line">$(&quot;div span:first-child&quot;)</span><br><span class="line">$(&quot;tr:visible&quot;)</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><strong>便捷的操作：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;p&quot;).removeClass(&quot;myClass noClass&quot;).addClass(&quot;yourClass&quot;);</span><br><span class="line">$(&quot;ul li:last&quot;).addClass(function(index) &#123;</span><br><span class="line">   return&quot;item-&quot; + index;</span><br><span class="line">&#125;);</span><br><span class="line">$(&apos;.container&apos;).append($(&apos;h2&apos;));</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><strong>为什么要做jQuery源码解析？</strong></p><p>虽然jQuery的文档很完善，潜意识降低了前端开发的入门的门槛，要实现一个动画随手拈来，只要简单的调用一个animate方法传递几个执行的参数即可，但如果要我们自己实现一个定制的动画呢？我们要考虑的问题太多太多了，浏览器兼容、各种属性的获取、逻辑流程、性能等等，这些才是前端开发的基础核心。</p><p>如果我们只知道使用jQuery，而不知道其原理，那就是“知其然,而不知其所以然”，说了这么多，那就赶快跟着慕课网进入“高大上”之旅吧，深入来探究jQuery的内部架构！</p><h2>jQuery整体架构</h2><p>任何程序代码不是一开始就复杂的，成功也不是一躇而蹴的，早期jQuery的作者John Resig在2005年提议改进Prototype的“Behaviour”库时，只是想让其使用更简单才发布新的jQuery框架。起初John Resig估计也没料想jQuery会如此的火热。我们可以看到从发布的第一个1.0开始到目前最新的2.1.1其代码膨胀到了9000多行，它兼容CSS3，还兼容各种浏览器，jQuery使用户能更方便地处理DOM、事件、实现动画效果，并且方便地为网站提供AJAX交互。</p><p>1、最新jQuery2.1.1版本的结构：</p><p>1、最新jQuery2.1.1版本的结构：代码请查看右侧代码编辑器（1-24行）</p><p>2、jQuery的模块依赖网：</p><p>2、jQuery的模块依赖网： <a href="http://img.mukewang.com/53fa8fec0001754806930473.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fa8fec0001754806930473.jpg" alt="img"></a></p><p>jQuery一共13个模块，从2.1版开始jQuery支持通过AMD模块划分，jQuery在最开始发布的1.0版本是很简单的，只有CSS选择符、事件处理和AJAX交互3大块。其发展过程中，有几次重要的变革：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">☑  1.2.3 版发布，引入数据缓存，解决循环引用与大数据保存的问题</span><br><span class="line">☑  1.3 版发布，它使用了全新的选择符引擎Sizzle，在各个浏览器下全面超越其他同类型JavaScript框架的查询速度，程序库的性能也因此有了极大提升</span><br><span class="line">☑  1.5 版发布，新增延缓对像(Deferred Objects)，并用deferred重写了Ajax模块</span><br><span class="line">☑  1.7 版发布，抽象出回调对象，提供了强大的的方式来管理回调函数列表。</span><br></pre></td></tr></table></figure><p>每一次大的改进都引入了一些新的机制、新的特性，通过这些新的机制就造就了如今jQuery库，一共13个模块，模块不是单一的，比如jQuery动画，都会依赖异步队列、动画队列、回调队列与数据缓存模块等。</p><p>jQuery抽出了所有可复用的特性，分离出单一模块，通过组合的用法，不管在设计思路与实现手法上jQuery都是非常高明的。</p><p><strong>五大块：</strong></p><p><strong>五大块：</strong>jQuery按我的理解分为五大块，选择器、DOM操作、事件、AJAX与动画，那么为什么有13个模块？因为jQuery的设计中最喜欢的做的一件事，就是抽出共同的特性使之“模块化”，当然也是更贴近S.O.L.I.D五大原则的“单一职责SRP”了，遵守单一职责的好处是可以让我们很容易地来维护这个对象，比如，当一个对象封装了很多职责的时候，一旦一个职责需要修改，势必会影响该对象的其它职责代码。通过解耦可以让每个职责更加有弹性地变化。</p><p>我们来看看jQuery文档针对业务层的Ajax的处理提供了一系列的门面接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.ajaxComplete()</span><br><span class="line">.ajaxError()</span><br><span class="line">.ajaxSend()</span><br><span class="line">.ajaxStart()</span><br><span class="line">.ajaxStop()</span><br><span class="line">.ajaxSuccess()</span><br></pre></td></tr></table></figure><p>底层接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax()</span><br><span class="line">jQuery.ajaxSetup()</span><br></pre></td></tr></table></figure><p>快捷方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jQuery.get()</span><br><span class="line">jQuery.getJSON()</span><br><span class="line">jQuery.getScript()</span><br><span class="line">jQuery.post()</span><br></pre></td></tr></table></figure><p></p><p><strong>jQuery接口的设计原理</strong></p><p>业务逻辑是复杂多变的，jQuery的高层API数量非常多，而且也非常的细致，这样做可以更友好的便于开发者的操作，不需要必须在一个接口上重载太多的动作。我们在深入内部看看Ajax的高层方法其实都是统一调用了一个静态的jQuery.ajax方法，</p><p>在jQuery.ajax的内部实现是非常复杂的，首先ajax要考虑异步的处理与回调的统一性，所以就引入了异步队列模块（Deferred）与回调模块（Callbacks）, 所以要把这些模块方法在ajax方法内部再次封装成、构建出一个新的jQXHR对象，针对参数的默认处理，数据传输的格式化等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">    factory(global);</span><br><span class="line">&#125;(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">window, noGlobal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;&#125;;</span><br><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line"><span class="comment">// 回调系统</span></span><br><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="comment">// 数据缓存</span></span><br><span class="line"><span class="comment">// 队列操作</span></span><br><span class="line"><span class="comment">// 选择器引</span></span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="comment">// 节点遍历</span></span><br><span class="line"><span class="comment">// 文档处理</span></span><br><span class="line"><span class="comment">// 样式操作</span></span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="comment">// 事件体系</span></span><br><span class="line"><span class="comment">// AJAX交互</span></span><br><span class="line"><span class="comment">// 动画引擎</span></span><br><span class="line"><span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2>立即调用表达式</h2><p>任何库与框架设计的第一个要点就是解决<strong>命名空间与变量污染</strong>的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p>jQuery的立即调用函数表达式的写法有三种：</p><p><strong>写法1：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(function(window, factory) &#123;</span><br><span class="line">    factory(window)</span><br><span class="line">&#125;(this, function() &#123;</span><br><span class="line">    return function() &#123;</span><br><span class="line">       //jQuery的调用</span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>可以看出上面的代码中嵌套了2个函数，而且把一个函数作为参数传递到另一个函数中并且执行，这种方法有点复杂，我们简化一下写法：</p><p><strong>写法2：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var factory = function()&#123;</span><br><span class="line">    return function()&#123;</span><br><span class="line">        //执行方法</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var jQuery = factory();</span><br></pre></td></tr></table></figure><p>上面的代码效果和方法1是等同的，但是这个factory有点变成了简单的<strong>工厂方法模式</strong>，需要自己调用，不像是一个单例的jQuery类，所以我们需要改成“自执行”，而不是另外调用。</p><p><strong>写法3：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(function(window, undefined) &#123;</span><br><span class="line">    var jQuery = function() &#123;&#125;</span><br><span class="line">    // ...</span><br><span class="line">    window.jQuery = window.$ = jQuery;</span><br><span class="line">&#125;)(window);</span><br></pre></td></tr></table></figure><p>从上面的代码可看出，自动初始化这个函数，让其只构建一次。详细说一下这种写法的优势：</p><p><strong>1、</strong> <strong>window</strong>和<strong>undefined</strong>都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。</p><p><strong>2、<strong>undefined也是同样的道理，其实这个</strong>undefined</strong>并不是JavaScript数据类型的undefined，而是一个普普通通的变量名。只是因为没给它传递值，它的值就是undefined，undefined并不是JavaScript的保留字。</p><p>关于留言，为什么要传递undefined？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。</span><br></pre></td></tr></table></figure><p>我们看一个</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var undefined = &apos;ulson&apos;</span><br><span class="line">;(function(window) &#123;</span><br><span class="line">  alert(undefined);//IE8 &apos;ulson&apos;</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure><p>IE8存在这个问题，当然，大部分浏览器都是不能被修改的</p><p>如果函数调用不传递，参数默认就是undefined</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(function(window,undefined) &#123;</span><br><span class="line">    //undefined</span><br><span class="line">&#125;)(window)</span><br></pre></td></tr></table></figure><p></p><p><strong>jQuery为什么要创建这样的一个外层包裹，其原理又是如何？</strong></p><p>这里要区分2个概念一个是匿名函数，一个是自执行。顾名思义，匿名函数，就是没有函数名的函数，<strong>也就是不存在外部引用</strong>。但是是否像下面代码实现呢：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">//代码逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是错了，声明了它但是又不给名字又没有使用，所以在语法上错误的，那么怎么去执行一个匿名的函数呢？</p><p>要调用一个函数，我们必须要有方法定位它、引用它。所以，我们要取一个名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var jQuery = function()&#123;</span><br><span class="line">//代码逻辑</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表），那么这小括号能把我们的表达式组合分块，并且每一块（也就是每一对小括号），都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的，就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。</p><p>最后，我们回到写法1看看jQuery利用写法3的写法，然后把整个函数作为参数传递给另外一个函数，主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码，看看jQuery的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if (typeof module === &quot;object&quot; &amp;&amp; typeof module.exports === &quot;object&quot;) &#123;</span><br><span class="line">    module.exports = global.document ?</span><br><span class="line">        factory(global, true) :</span><br><span class="line">        function(w) &#123;</span><br><span class="line">            if (!w.document) &#123;</span><br><span class="line">                throw new Error(&quot;jQuery requires a window with a document&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">            return factory(w);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    factory(global);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：全局变量是魔鬼, 匿名函数可以有效的保证在页面上写入JavaScript，而不会造成全局变量的污染，通过小括号，让其加载的时候立即初始化，这样就形成了一个单例模式的效果从而只会执行一次。</p><h2>jQuery的类数组对象结构</h2><p><strong>为什么是类数组对象呢？</strong></p><p>很多人迷惑的jQuery为什么能像数组一样操作，通过对象get方法或者直接通过下标0索引就能转成DOM对象。</p><p>首先我们看jQuery的入口都是统一的$, 通过传递参数的不同，实现了9种方法的<strong>重载</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1. jQuery([selector,[context]])</span><br><span class="line">2. jQuery(element)</span><br><span class="line">3. jQuery(elementArray)</span><br><span class="line">4. jQuery(object)</span><br><span class="line">5. jQuery(jQuery object)</span><br><span class="line">6. jQuery(html,[ownerDocument])</span><br><span class="line">7. jQuery(html,[attributes])</span><br><span class="line">8. jQuery()</span><br><span class="line">9. jQuery(callback)</span><br></pre></td></tr></table></figure><p>9种用法整体来说可以分三大块：选择器、dom的处理、dom加载。</p><p>换句话说jQuery就是为了获取DOM、操作DOM而存在的。所以为了更方便这些操作，让<strong>节点与实例对象</strong>通过一个桥梁给关联起来，jQuery内部就采用了一种叫“类数组对象”的方式作为存储结构，所以我们即可以像对象一样处理jQuery操作，也能像数组一样可以使用<strong>push、pop、shift、unshift、sort、each、map</strong>等类数组的方法操作jQuery对象了。</p><p><strong>jQuery对象可用数组下标索引是什么原理？</strong></p><p>通过<code>$(&quot;.Class&quot;)</code>构建的对象结构如下所示：</p><p><a href="http://img.mukewang.com/53fad4240001c7b805050236.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fad4240001c7b805050236.jpg" alt="img"></a></p><p><a href="http://img.mukewang.com/53fad4240001c7b805050236.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fad4240001c7b805050236.jpg" alt="img"></a>整个结构很明了，通过对象键值对的关系保存着属性，原型保存着方法。我们来简单的模拟一个这样的数据结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://img.mukewang.com/down/540812440001e40e00000000.js&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;style type=&quot;text/css&quot;&gt;</span><br><span class="line">div&#123;width: 30px;height: 10px;float:left;&#125;</span><br><span class="line">&lt;/style&gt;</span><br><span class="line">&lt;title&gt;data_structure&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line">&lt;button id=&quot;test1&quot;&gt;jQuey[0]&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;test2&quot;&gt;jQuey.get&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;test3&quot;&gt;aQuery[0]&lt;/button&gt;</span><br><span class="line">&lt;button id=&quot;test4&quot;&gt;aQuery.get&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;p id=&quot;book&quot;&gt;book&lt;/p&gt;</span><br><span class="line">&lt;div id=&quot;show1&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;show2&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;show3&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=&quot;show4&quot;&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line"></span><br><span class="line">var aQuery = function(selector) &#123;</span><br><span class="line">    //强制为对象</span><br><span class="line">if (!(this instanceof aQuery)) &#123;</span><br><span class="line">return new aQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line">var elem = document.getElementById(/[^#].*/.exec(selector)[0]);</span><br><span class="line">this.length = 1;</span><br><span class="line">this[0] = elem;</span><br><span class="line">this.context = document;</span><br><span class="line">this.selector = selector;</span><br><span class="line">this.get = function(num) &#123;</span><br><span class="line">return this[num];</span><br><span class="line">&#125;</span><br><span class="line">return this;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//结果是一个dom元素,可以把代码放到Google Chrome下运行</span><br><span class="line">//按F12通过调试命令 console.log() 打印出对象</span><br><span class="line">$(&quot;#test1&quot;).click(function() &#123;</span><br><span class="line">$(&apos;#show1&apos;).append($(&apos;#book&apos;)[0])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;#test2&quot;).click(function() &#123;</span><br><span class="line">$(&apos;#show2&apos;).append($(&apos;#book&apos;).get(0))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;#test3&quot;).click(function() &#123;</span><br><span class="line">$(&apos;#show3&apos;).append(aQuery(&quot;#book&quot;)[0])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(&quot;#test4&quot;).click(function() &#123;</span><br><span class="line">$(&apos;#show4&apos;).append(aQuery(&quot;#book&quot;).get(0))</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>以上是模拟jQuery的对象结构，通过aQuery方法抽象出了对象创建的具体过程，这也是软件工程领域中的广为人知的设计模式-工厂方法。</p><p><strong>jQuery的无new构建原理</strong></p><p>函数<strong>aQuery()<strong>内部首先保证了必须是通过</strong>new</strong>操作符构建。这样就能保证当前构建的是一个带有<strong>this</strong>的实例对象，既然是对象我们可以把所有的属性与方法作为对象的<strong>key</strong>与<strong>value</strong>的方式给映射到<strong>this</strong>上，所以如上结构就可以模拟出jQuery的这样的操作了，即可通过索引取值，也可以链式方法取值，但是这样的结构是有很大的缺陷的，每次调用<strong>ajQuery</strong>方法等于是创建了一个新的实例，那么类似<strong>get</strong>方法就要在每一个实例上重新创建一遍，性能就大打折扣，所以jQuery在结构上的优化不仅仅只是我们看到的，除了实现类数组结构、方法的原型共享，而且还实现方法的静态与实例的共存，这是我们之后将会重点分析的。</p><h2>jQuery中ready与load事件</h2><p>jQuery有3种针对文档加载的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//document ready 简写</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>一个是ready一个是load，这两个到底有什么区别呢？</strong></p><p>ready与load谁先执行：</p><p>ready与load谁先执行：大家在面试的过程中，经常会被问到一个问题：ready与load那一个先执行，那一个后执行？答案是<strong>ready先执行，load后执行</strong>。</p><p><strong>DOM文档加载的步骤：</strong></p><p><strong>DOM文档加载的步骤：</strong>要想理解为什么ready先执行，load后执行就要先了解下DOM文档加载的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 解析HTML结构。</span><br><span class="line">(2) 加载外部脚本和样式表文件。</span><br><span class="line">(3) 解析并执行脚本代码。</span><br><span class="line">(4) 构造HTML DOM模型。//ready</span><br><span class="line">(5) 加载图片等外部文件。</span><br><span class="line">(6) 页面加载完毕。//load</span><br></pre></td></tr></table></figure><p>从上面的描述中大家应该已经理解了吧，ready在第（4）步完成之后就执行了，但是load要在第（6）步完成之后才执行。</p><p><strong>结论：</strong></p><p>ready与load的区别就在于资源文件的加载，ready构建了基本的DOM结构，所以对于代码来说应该越快加载越好。在一个高速浏览的时代，没人愿意等待答案。假如一个网站页面加载超过4秒，不好意思，你1/4的用户将面临着流失，所以对于框架来说用户体验是至关重要的，我们应该越早处理DOM越好，我们不需要等到图片资源都加载后才去处理框架的加载，图片资源过多load事件就会迟迟不会触发。</p><p>我们看看jQuery是如何处理文档加载时机的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ready.promise = function( obj ) &#123;</span><br><span class="line">    if ( !readyList ) &#123;</span><br><span class="line">        readyList = jQuery.Deferred();</span><br><span class="line">        if ( document.readyState === &quot;complete&quot; ) &#123;</span><br><span class="line">            // Handle it asynchronously to allow scripts the opportunity to delay ready</span><br><span class="line">            setTimeout( jQuery.ready );</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            document.addEventListener( &quot;DOMContentLoaded&quot;, completed, false );</span><br><span class="line">            window.addEventListener( &quot;load&quot;, completed, false );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return readyList.promise( obj );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>jQuery的ready是通过promise给包装过的，这也是jQuery擅长的手法，统一了回调体系，以后我们会重点谈到。</p><p>可见jQuery兼容的具体策略**：针对高级的浏览器，我们当前很乐意用DOMContentLoaded事件了，省时省力。**</p><p><strong>那么旧的IE如何处理呢？</strong></p><p>继续看jQuery的方案：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">// Ensure firing before onload, maybe late but safe also for iframes</span><br><span class="line">document.attachEvent( &quot;onreadystatechange&quot;, completed );</span><br><span class="line">// A fallback to window.onload, that will always work</span><br><span class="line">window.attachEvent( &quot;onload&quot;, completed );</span><br><span class="line">// If IE and not a frame</span><br><span class="line">// continually check to see if the document is ready</span><br><span class="line">var top = false;</span><br><span class="line">try &#123;</span><br><span class="line">    top = window.frameElement == null &amp;&amp; document.documentElement;</span><br><span class="line">&#125; catch(e) &#123;&#125;</span><br><span class="line">if ( top &amp;&amp; top.doScroll ) &#123;</span><br><span class="line">    (function doScrollCheck() &#123;</span><br><span class="line">        if ( !jQuery.isReady ) &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                // Use the trick by Diego Perini</span><br><span class="line">                // http://javascript.nwbox.com/IEContentLoaded/</span><br><span class="line">                top.doScroll(&quot;left&quot;);</span><br><span class="line">            &#125; catch(e) &#123;</span><br><span class="line">                return setTimeout( doScrollCheck, 50 );</span><br><span class="line">            &#125;</span><br><span class="line">            // detach all dom ready events</span><br><span class="line">            detach();</span><br><span class="line"></span><br><span class="line">            // and execute any waiting functions</span><br><span class="line">            jQuery.ready();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果浏览器存在 <code>document.onreadystatechange</code> 事件，当该事件触发时，如果 <code>document.readyState=complete</code> 的时候，可视为 DOM 树已经载入。不过，这个事件不太可靠，比如当页面中存在图片的时候，可能反而在 onload 事件之后才能触发，换言之，它只能正确地执行于页面不包含二进制资源或非常少或者被缓存时作为一个备选吧。</p><p><strong>针对IE的加载检测</strong></p><p>DOMContent文章参考：<a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/" target="_blank" rel="noopener">JS、CSS以及img对DOMContentLoaded事件的影响</a>Diego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用，详情可见http://javascript.nwbox.com/IEContentLoaded/。原理就是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在上述中间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。结论：所以总的来说当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了。</p><p>这都是我们在第一时间内处理ready加载的问题，如果ready在页面加载完毕后呢？</p><p>jQuery就必须针对这样的情况跳过绑定了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if ( document.readyState === &quot;complete&quot; ) &#123;</span><br><span class="line">     // Handle it asynchronously to allow scripts the opportunity to delay ready</span><br><span class="line">     setTimeout( jQuery.ready );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接通过查看readyState的状态来确定页面的加载是否完成了。这里会给一个定时器的最小时间后去执行，主要保证执行的正确。</p><h2>jQuery多库共存处理</h2><p>多库共存换句话说可以叫无冲突处理。</p><p>总的来说会有2种情况会遇到：</p><p>1、$太火热，jQuery采用$作为命名空间，不免会与别的库框架或者插件相冲突。</p><p>2、jQuery版本更新太快，插件跟不上，导致不同版本对插件的支持度不一样。</p><p>出于以上的原因，jQuery给出了解决方案–– noConflict函数。</p><p>引入jQuery运行这个noConflict函数将变量$的控制权让给第一个实现它的那个库，确保jQuery不会与其他库的$对象发生冲突。</p><p>在运行这个函数后，就只能使用jQuery变量访问jQuery对象。例如，在要用到$(“aaron”)的地方，就必须换成jQuery(“aaron”)，因为$的控制权已经让出去了。</p><p>使用DEMO：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line"><span class="comment">// 使用 jQuery</span></span><br><span class="line">jQuery(<span class="string">"aaron"</span>).show();</span><br><span class="line"><span class="comment">// 使用其他库的 $()</span></span><br><span class="line">$(<span class="string">"aaron"</span>).style.display = ‘block’;</span><br></pre></td></tr></table></figure><p>这个函数必须在你导入jQuery文件之后，并且在导入另一个导致冲突的库之前使用。当然也应当在其他冲突的库被使用之前，除非jQuery是最后一个导入的。</p><p>由于比较简单，我们直接上代码解说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Var _jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line">    _$ = <span class="built_in">window</span>.$;</span><br><span class="line"></span><br><span class="line">jQuery.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"> deep </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.$ === jQuery ) &#123;</span><br><span class="line">        <span class="built_in">window</span>.$ = _$;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> ( deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery ) &#123;</span><br><span class="line">        <span class="built_in">window</span>.jQuery = _jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们需要同时使用jQuery和其他JavaScript库，我们可以使用 $.noConflict()把$的控制权交给其他库。旧引用的$ 被保存在jQuery的初始化; noConflict() 简单的恢复它们。</p><p>通过类似swap交换的概念，先把之前的存在的命名空间给缓存起来，通过对比当前的命名空间达到交换的目的，首先，我们先判断下当前的的$空间是不是被jQuery接管了，如果是则让出控制权给之前的_$引用的库，如果传入deep为true的话等于是把jQuery的控制权也让出去了。    如果不通过noConflict处理的话其后果可想而知，香喷喷的$大家都“觊觎已久”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://img.mukewang.com/down/540812440001e40e00000000.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>多库共存<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aaron"</span>&gt;</span>测试noConflict效果<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#aaron"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.noConflict(); <span class="comment">//让出控制权</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!$) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"使用noConflict后，$不存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (jQuery) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"使用noConflict后，jQuery存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//通过闭包隔离出$</span></span></span><br><span class="line"><span class="javascript">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> ($) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"通过闭包隔离后，转为局部变量$存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)(jQuery);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    jQuery(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;##简介&lt;/p&gt;
&lt;p&gt;从整体入手理解架构，再深入攻破每个依赖模块，包括回调函数、异步加载、数据缓存、动画队列
最后整体分析：选择器、DOM处理、AJAX、动画模块、事件&lt;/p&gt;
    
    </summary>
    
    
      <category term="前端" scheme="http://yoursite.com/tags/%E5%89%8D%E7%AB%AF/"/>
    
  </entry>
  
</feed>
