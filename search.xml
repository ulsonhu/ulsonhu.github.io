<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>2018 飘着</title>
      <link href="/2018%E5%B0%B1%E9%A3%98%E7%9D%80.html"/>
      <content type="html"><![CDATA[<p>眼看着2018就要结束了，倒不是非写个命题作文，但是整理整理过去一年的感悟还是很值得的。不过也不能就叫年终总结吧，想着今年暑假没能回去，也在外飘了1整年了，所以今年就飘着吧。</p><h2>正经事</h2><p>今年结束了四年的本科生活，记得是过完春节返校后，开始想起要要找工作了，于是悻然总结总结了这几年自己的所知所学，投了几份简历，幸而在家外企暂时安顿下来。不过其实仔细说起来，临毕业的最后那几个月估计是这一年里过得最充实与伤感的。记得陈老师特意问了问我未来的打算，大概没把Research做完，也是挺惋惜的吧。提前约了同学拍了毕业照，对照着大一和他们拍过的照片，感觉每个人的变化都相当大，但是该黑的绝对还是得黑的呀。还记得，Cecilia毕业前告诉我她想法后我的惊讶，在那之后，我们没再见过面的遗憾；还记得离校的最后一晚和盛哥在楼道喝啤酒聊未来的感慨；还记得毕业典礼前一晚，风雨操场的通宵狂欢；还记得舍友卧谈会那会儿的悠闲。离校最后一晚，约她一起去操场闲逛，算是和大学的一段感情做了告别，感慨我们彼此没有好好把握，有太多的也许。。。</p><p>罢了，但毕竟，毕业了，较之以往没有push的生活方式，取而代之是一种更有压力的状态。很奇怪，好似突然就过渡到了时常感叹光阴似箭的年龄。很多道理，之前无法理解，现在好像渐渐都明白了。</p><p>大学的生活并没有过到很充实，但毕竟凭着兴趣，学到了一点看待世界的思维方式和一点谋生的手段。毕业总结还是省了吧。只是，想想自己目前所缺失的，更多的是学习新东西的热情与积极扩大交际面的自主性。</p><p>有时想想“上班”的生活：起床，去公司，下班，回家free little time。每天重复，让人崩溃。还是在学校里好啊，读书真好！</p><p>今年也经历过很多第一次，罗列一下：</p><ul><li>第一次穿学士服</li><li>第一次和老外talking</li><li>第一次写英文工作邮件</li><li>第一次剪/拍视频</li><li>第一次吃榴莲</li><li>第一次用香水</li><li>第一次座摩天轮</li><li>第一次做菜</li><li>…</li></ul><p>至于博文，之前陆陆续续在不同平台上胡乱写了些。在今年求职前，索性把乱七八糟的文章放到Github page上archive了下。所以，大家看到目前这个blog显得有些乱。</p><p>关于技术，除去日常工作必要的数据库语言和数据分析工具外，跟了Coursera/Andrew NG的课和一个Go与语言专栏，为什么去学Go 语言呢？大概受 盛哥 毕业前给我好好普及区块链的影响吧，跟着学了起来。除此之外，最感兴趣的还是统计学。说到底还是离不开数学的魅力，在经过数学上完备性的论证后，统计学才真正成为一门学科，在如今数据爆炸的时代大有用武之地。往往数理的东西相比哲学对世界的解释更加直接，无论从时间还是空间角度，都能不必计较人客体的复杂性。</p><h3>关于目前职业前景</h3><p>其实从大一学DreamWeaver切网页，到NodeJS横空出世，再到如今所谓的大前端。前端领域的快速迭代发展几乎是近几年，技术影响商业社会快速变化的缩影。我们确实切身感受到了从Web2.0到移动互联网的普及到如今AI、BlockChain涌现，信息技术的革命对社会的塑造其实愈加深刻。我们的社会关系不再以简单的方式联结，而呈现出一个日益复杂而分散的网络系统。彼此联结程度紧密到无法想象，世界上90%以上的数据在过去两年产生，并形成一个循环：我们的每一次点击，都会成为Big data的组成部分，Big data被聪明的工程师拿去做分析，分析的结果又会反馈到网络上，引导我们的下一次点击。我们塑造了工具，却又被工具反过来塑造了。所以，说到底，搞数据本身还是一件很Fancy的事儿，也有很多能做和值得做的方向。</p><h2>不正经事</h2><p>Free time会干的事，包括但不限于旅行、画画、听戏、读书、动漫、博客、电影、游戏。工作后，Tasks一般不会带回家处理，所以下班时间还是能够自由支配的，也特地找了个离公司比较近的房子，这样一整天的通勤时间会控制在40分钟以内。</p><h3>阅读</h3><p>读书几乎占据了大部分的时间，今年大概读了40多本书，可见时间挤挤，还是相当多的。主要集中于外国文学，很多书非常值得一读。</p><ul><li><p>《蒙元入侵前夜的中国日常生活》<br>这本书背景是蒙古入侵前的南宋都城临安（杭州）的社会生活。在兵临城下的情况下，临安城内如是一如既往的悠闲。其中对衣食住行、婚丧嫁娶习俗和消闲时光的描绘格外有趣。抛开历史环境不谈，是一部描绘古代社会生活难得的参考资料。</p></li><li><p>《月亮与六便士》<br>很多人即使没有看过小说，应该也听过这个 quote：If you look on the ground in search of a sixpence, you don’t look up, and so miss the moon。书中塑造了一个纯粹的、毫无妥协的艺术家形象，其人物原型的法国画家梵高。我想我不必纠结于斯珠兰抛妻损友的行为的对错，大概艺术与世俗规矩本就水火不相容，对于他来说，生存与毁灭是不存在中间地带的。</p></li><li><p>《刀锋》《人性的枷锁》、《总结：毛姆写作生活回忆》<br>依然是毛姆的几篇代表作，其中《人性的枷锁》通过描写菲利普的一生，从大家的对话讨论或者内心独白中以不同的视角道出了人在成长过程中对于人生的认识和感悟。我想其中有挺多大概是作者自身的看法吧。并没有像《月亮与六便士》那样喜欢这本书，大概因为主角优柔寡断的性格很是让人讨厌吧，有时候会觉得主角很多时候完全是自讨苦吃，作茧自缚，可是又不得不承认每个人其实也都活在各自的枷锁之中，甚至有时候主角成长过程中的一些可笑的行为大概也能勾起自己曾经经历过的一些磕磕绊绊呢。也许人的一生就是不断地突破自己的一个个枷锁的过程。至于人生的意义，这个大概又太深奥了。从蜉蝣到宇宙，不论在什么尺度下，时间仍然像一条无尽的长河，大概没有什么东西是有绝对意义的吧。《刀锋》比较喜欢里面一些比较犀利的对话和讨论。整体来讲并不如《月亮与六便士》那样喜欢，但是要超过《人性的枷锁》一点。大概我不太懂主角拉里到底追寻的是什么。不过毛姆先生在书里把自己写得也是相当犀利和风趣，和《人性》里那个无知的少年似乎是判若两人。</p></li><li><p>《群上回唱》<br>高中时读过《追风筝的人》，再读这部《群山回唱》，依然折服于作者高超的叙事能力。</p></li><li><p>《人间失格》<br>其实作者一直在展示人性黑暗、肮脏的一面，但我想坐着本人是存在精神洁癖的。但是作者毕竟是人，他发现自身也存在肮脏的一面，问题在于，他并没有正视它或做积极的改变，导致这样的心结始终积郁难解，最终也只有走向人间失格。但是，看完这样一部文学作品，我想反求诸己总是可行的，爱会让一切变好。就像陀思妥耶夫斯基，借那么长的一步《卡拉马佐夫兄弟》，给读者传达出，坚信“善”的力量。</p></li><li><p>《萤火虫小巷》、《岛上书店》<br>两本都是来自美国作家的畅销书，没有什么太值得说的。作者讲述的故事本身是关于友情、亲情与爱情的，读来算事比较温馨。</p></li><li><p>《百年孤独》<br>读者经常会被开篇第一句话“多年以后，面对行刑队，奥雷里亚诺·布恩迪亚上校将会回想起父亲带他去见识冰块的那个遥远的下午”所吸引。伟大的作品往往第一句就不平凡，百年孤独就是这样一部书。我经常觉得真正的文学需要引导读者自己去探寻人的本质。马尔克斯讲述奥雷里亚诺家族一百多年来，六代人的权利情欲交织起来的家族盛衰史。最后一个儿子生下来就被蚂蚁啃食掉，预言手稿随着马孔多一起消失，展现了一个光怪陆离的世界。其实，越是奇怪、原始，则越是接近人的本质状态。其次，小说的描写，画面感极强，展现了南美洲缤纷多彩的文化。让我对“拉美文学大爆炸”时期的作家，产生浓厚的兴趣。</p></li><li><p>《查泰莱夫人的情人》<br>大概类似于中国的《金瓶梅》，其实都表达一个反世俗的主题。书中有大段情色描绘，并不淫秽，反而是一种健康的情欲，让读者能够将性和爱分开来看待。想想古代，牡丹亭都被列为禁书，而今，牡丹亭却成了中文系必修的课程。现在的少年们如何排解苦闷，可能就直接看A片了，岂不直接。人大概是欲望的综合体，合理分配吧。</p></li><li><p>《连城诀》<br>怀念金庸先生去世后读，《连城诀》大概是金庸武侠作品里最黑暗的一个吧。还记得当天消息出来后，赶忙去蔡澜先生的微博下去求证，结果看蔡澜早晨刚发一篇游记，与平常别无二致。尽管知道他们私交很好，但是能做到这么豁达，还是钦佩不已的。</p></li><li><p>《阿莱夫》<br>博尔赫斯的作品初看时总觉得散乱、难以理解。但是渐渐的，会被他文字传递出的精准性、深刻性所折服。所以，博尔赫斯的小说不读，很难说自己懂近现代的小说。</p></li></ul><blockquote><p>任何命运，不论如何漫长复杂，实际上只反映于一个瞬间：人们大彻大悟自己究竟是谁的瞬间。–[克鲁斯传记]</p></blockquote><ul><li><p>《情人》<br>懒得长篇大论的谈，可是不长篇大论有说不清杜拉斯的文学风格，两难啊。</p></li><li><p>《野性的呼唤》<br>拟人化的写法，讲的是一只狗重回野性，回归山林的过程。小说不长，很好读。</p></li><li><p>《红楼梦》<br>老实说，我还是第一次读红楼梦，对这部经典名著还是抱着敬畏之心的。就像图斯托耶夫斯基的《卡拉马佐夫兄弟》，到今天我也没读到一半。但是，红楼梦让我一读就停不下来，曹雪芹写的每个人都性格迥异。你很难想象一个作者能在一部作品同时塑造出那么多鲜活的人物，有人说，”拿出红楼梦中任意一段对话，你就能知道这是谁说的话。”由此可见，曹雪芹对人物刻画之精准。其实，在我这样一个年纪，读红楼梦大概已经不再单纯只读宝黛间的爱情了。更多的是体会到曹雪芹借大观园这座“青春王国”，传递给读者的人生盛衰相依的道理。也感慨如花美眷，似水流年。</p></li><li><p>《巴黎评论》作家访谈一|二|三<br>略</p></li></ul><p>今年入手了iPad和Apple pencil，搭配起来使用能保证娱乐和正事儿两不误。Notability加PDF Expert非常适合一边阅读文档一遍做笔记，同时iCloud同步到iPhone上，这样在通勤时间也可以看看，能很好的利用起碎片化时间。也学着在用Procreate画一些插画，消遣是个不错的选择。</p><h3>谈谈戏曲</h3><p>小时候，最常听的就是爷爷奶奶收音机里播的黄梅戏。记得每年端午节时，会有赛龙舟比赛，经常会请一些戏剧团到哪条庙街，沿街唱戏表演（我们那儿称花鼓戏）。但那时候，对听戏毫无兴趣。但，即使这样，《天仙配》依然是每个徽人都会熟悉的唱段。</p><p>黄梅戏唱词方言味道还是比较浓的，不过对我来说没什么障碍，反而会觉得很亲切。其中《梁祝》、《女驸马》、《桃花扇》常听，唱词与念白交织，尤其是念白常常颇具喜剧效果。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1546186422/dv00kppy1_908.jpg" width="80%" height="80%"><p>第一次看全折的牡丹亭是大三留校时，为什么留校？当然是好好学习呀。那会儿天气炎热，有时候晚上会下暴雨，十分消暑。一个人待在宿舍的话，常常找一折牡丹亭来看。昆曲是需要边看边听，因为昆曲本身就是动作戏与唱戏交织的。这一点与京剧不同，演员表演动作戏和唱戏是绝对不会交织的。看游园惊梦折，你会觉得昆曲原来那么美。大概，爱情的主题永远不会过时。就像看罗密欧与朱丽叶，虽然感觉很童话，但是总是会被双方爱情的纯粹性所感动。</p><p>昆曲的发音也很有趣，比如听牡丹亭中“原来姹紫嫣红”中的“姹”，“好天气也”中的“气”，都会发尖音。在昆曲和京剧里，今天普通话读<code>[ʨ]</code>、<code>[ʨʰ]</code>、<code>[ɕ]</code>的字被分为两类，一类仍读<code>[ʨ]</code>、<code>[ʨʰ]</code>、<code>[ɕ]</code>，称为团音，例如“既、气、戏”等字；另一类必须读<code>[ʦ]</code>、<code>[ʦʰ]</code>、<code>[s]</code>（汉语拼音方案作<code>z</code>、<code>c</code>、<code>s</code>），称为尖音，如“祭、砌、细”等字。</p><p>其实，昆曲的韵声唱法也是很讲究的。如部分普通话读<code>geng[kəŋ]</code>、<code>keng[kʰəŋ]</code>、<code>heng[xəŋ]</code>的字，昆曲中唱<code>jing[ʨiəŋ]</code>、<code>qing[ʨʰiəŋ]</code>、<code>xing[ɕiəŋ]</code>。 如：更、坑、衡。</p><h2>结语</h2><p>2019年不做计划，只希望能多思考，多踏实干事。</p>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Books &amp; Moive in 2018</title>
      <link href="/new_year_2018.html"/>
      <content type="html"><![CDATA[<a id="more"></a><h3>读书（文学类）</h3><ul><li>《守望的距离》.周国平</li><li>《蒙元入侵前夜的中国日常生活》.谢和耐</li><li>《月亮与六便士》.威廉·萨默塞特·毛姆</li><li>《刀锋》.威廉·萨默塞特·毛姆</li><li>《总结：毛姆写作生活回忆》.威廉·萨默塞特·毛姆</li><li>《人性的枷锁》.威廉·萨默塞特·毛姆</li><li>《群上回唱》.卡勒德·胡赛尼</li><li>《我是猫》.夏目漱石</li><li>《我脑袋里的怪东西》.奥尔罕·帕慕克</li><li>《人间失格》.太宰治</li><li>《萤火虫小巷》.克莉丝汀汉娜</li><li>《浮世画家》.石黑一雄</li><li>《百年孤独》.马尔克斯</li><li>《米格尔街》.奈保尔</li><li>《查泰莱夫人的情人》.DH劳伦斯</li><li>《岛上书店》.加布瑞埃泽拉文</li><li>《连城诀》.金庸</li><li>《阿莱夫》.博尔赫斯</li><li>《自深深处》.奥斯卡王尔德</li><li>《情人》. 杜拉斯</li><li>《野性的呼唤》. 杰克伦敦</li><li>《红楼梦》.曹雪芹</li><li>《巴黎评论》作家访谈</li></ul><h3>读书（自我提高及工具书）</h3><ul><li>《Tensorflow机器学习指南》</li><li>《MySQL必知必会》</li><li>瑞·达里奥《原则》</li></ul><p>多读自我提高类书籍本意在于掌握必须的知识与提升自身逻辑思考能力。</p><ul><li>Johnson. 实用多元统计分析.</li><li>茆诗松. 高等数理统计</li><li>Nasrabadi, Nasser M. “Pattern recognition and machine learning.”</li></ul><h3>看剧</h3><ul><li>《1公升的眼泪》- 看这部剧，的确很戳人泪点。疾病使人绝望，但爱让希望不灭</li><li>《寻梦环游记》</li><li>《时空恋旅人》 - 被我当作爆米花电影来看</li><li>《星际穿越》 - 同被我当作爆米花电影多次翻看</li><li>《火星救援》 - 近年来的硬科幻佳作</li><li>《镰仓物语》 - 治愈系佳作2018</li><li>《JoJo的奇妙冒险》全系列 - Jump动漫化大作，感受荒木老师构造的力与美的世界</li></ul><blockquote><p>人们生下来不是亚里士多德式，便是柏拉图式。这等于说，任何抽象性质的争辩都是亚里士多德和柏拉图论争的一个片断；古往今来，东南西北，姓名、方言、面孔可以改变，但主角是永远不变的。<br>人民的历史也记载了隐秘的连续性。<br>当阿尔米尼乌斯￼在沼泽地大败瓦鲁斯的军团时，他并不知道自己成了日耳曼帝国的先驱；<br>翻译《圣经》的路德￼没有料到他的目的是造成彻底消灭《圣经》的人民；<br>一七五八年被一颗莫斯科人的枪弹杀死的克里斯托夫·林德从某种意义上来说是为一九一四年的胜利作了准备；<br>希特勒以为自己是为一个国家而奋斗，事实上他是为所有的国家，甚至为他所侵略和憎恶的国家而奋斗。<br>他的自我也许不了解，但他的血液、他的意志知道这一点；<br>世界由于犹太教，由于犹太教的毛病——对耶稣的信仰——而趋于死亡；<br>我们用暴力和对剑的信仰来教导世界，那把剑如今在杀我们；<br>我们好比那个建了一座迷宫结果自己困死在里面的巫师；<br>也好比大卫，他审理一个隐掉名字的人，判了那人死刑，然后听到揭示：“你就是那个人。”<br>一个毫不通融的时代如今笼罩着世界。造就这个时代的是我们，已经成为时代牺牲品的我们。<br>我用镜子照照脸以便知道自己是谁，知道再过几小时当我面对自己的下场时如何动作。<br>我的肉体也许会害怕，我却不怕。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>《红楼梦》Dream of the Red Chamber</title>
      <link href="/%E7%BA%A2%E6%A5%BC%E6%A2%A6-Dream%20of%20the%20Chamber.html"/>
      <content type="html"><![CDATA[<p>曹雪芹在红楼梦第五回，借宝玉神游太虚幻境，道出书中女子各自的命运结局，虽已告知告知宝玉众人命运结局，当局者亦浑然不觉，只能看着剧中人一步一步走向那个已经注定的宿命。想罢，人生亦如是，命运总是在可解与不可解之间徘徊。</p><blockquote><p>仙姑笑道：“吾居离恨天之上，灌愁海之中，乃放春山遣香洞太虚幻境警幻仙姑是也：司人间之风情月债，掌尘世之女怨男痴。因近来风流冤孽，缠绵于此处，是以前来访察机会，布散相思。今忽与尔相逢，亦非偶然。此离吾境不远，别无他物，仅有自采仙茗一盏。亲酿美酒一瓮，素练魔舞歌姬数人，新填《红楼梦》仙曲十二支，试随吾一游否？</p></blockquote><ul><li>晴雯<br>霁月难逢，彩云易散。<br>心比天高，身为下贱。<br>风流灵巧招人怨。寿夭多因毁谤生，多情公子空牵念。<br>宝玉看了，又见后面画着一簇鲜花，一床破席，也有几句言词，写道是：</li><li>袭人<br>枉自温柔和顺，空云似桂如兰；<br>堪羡优伶有福，谁知公子无缘。<br>宝玉看了不解。遂掷下这个，又去开了副册厨门，拿起一本册来，揭开看时，只见画着一株桂花，下面有一池沼，其中水涸泥干，莲枯藕败，后面书云：</li><li>香菱<br>根并荷花一茎香，平生遭际实堪伤。<br>自从两地生孤木，致使香魂返故乡。</li><li>林黛玉、薛宝钗<br>可叹停机德，堪怜咏絮才。<br>玉带林中挂，金钗雪里埋。<br>宝玉看了仍不解。待要问时，情知他必不肯泄漏；待要丢下，又不舍。遂又往后看时，只见画着一张弓，弓上挂着香橼。也有一首歌词云：</li><li>元春<br>二十年来辨是非，榴花开处照宫闱。<br>三春争及初春景，虎兕相逢大梦归。<br>后面又画着两人放风筝，一片大海，一只大船，船中有一女子掩面泣涕之状。也有四句写云：</li><li>探春<br>才自精明志自高，生于末世运偏消。<br>清明涕送江边望，千里东风一梦遥。<br>后面又画几缕飞云，一湾逝水。其词曰：</li><li>史湘云<br>富贵又何为，襁褓之间父母违。<br>展眼吊斜晖，湘江水逝楚云飞。<br>后面又画着一块美玉，落在泥垢之中。其断语云：</li><li>妙玉<br>欲洁何曾洁，云空未必空。可怜金玉质，终陷淖泥中。后面忽见画着个恶狼，追扑一美女，欲啖之意，其书云：</li><li>迎春<br>子系中山狼，得志便猖狂。<br>金闺花柳质，一载赴黄粱。<br>后面便是一所古庙，里面有一美人在内看经独坐。其判云：</li><li>惜春<br>勘破三春景不长，缁衣顿改昔年妆。<br>可怜绣户侯门女，独卧青灯古佛旁。<br>后面便是一片冰山，上面有一只雌凤。其判曰：</li><li>王熙凤<br>凡鸟偏从末世来，都知爱慕此生才。<br>一从二令三人木，哭向金陵事更哀。<br>后面又是一座荒村野店，有一美人在那里纺绩。其判云：</li><li>巧姐<br>势败休云贵，家亡莫论亲。<br>偶因济刘氏，巧得遇恩人。<br>后面又画着一盆茂兰，旁有一位凤冠霞帔的美人。也有判云：</li><li>李纨<br>桃李春风结子完，到头谁似一盆兰。<br>如冰水好空相妒，枉与他人作笑谈。<br>后面又画着高楼大厦，有一美人悬梁自缢。其判云：</li><li>秦可卿<br>情天情海幻情身，情既相逢必主淫。<br>漫言不肖皆荣出，造衅开端实在宁。</li></ul><blockquote><p>好了歌<br>陋室空堂，当年笏满床；衰草枯杨，曾为歌舞场。<br>蛛丝儿结满雕梁，绿纱今又糊在蓬窗上。<br>说什么脂正浓、粉正香，如何两鬓又成霜？<br>昨日黄土陇头送白骨，今宵红灯帐底卧鸳鸯。<br>金满箱，银满箱，展眼乞丐人皆谤。<br>正叹他人命不长，那知自己归来丧！<br>训有方，保不定日后作强梁。<br>择膏粱，谁承望流落在烟花巷！<br>因嫌纱帽小，致使锁枷扛；昨怜破袄寒，今嫌紫蟒长。<br>乱烘烘你方唱罢我登场，反认他乡是故乡。<br>甚荒唐，到头来都是为他人作嫁衣裳！</p></blockquote><blockquote><p>女儿是水作的骨肉，男人是泥作的骨肉。</p></blockquote><p>宝玉会秦钟</p><blockquote><p>故其气亦必赋人，发泄一尽始散。使男女偶秉此气而生者，在上则不能成仁人君子，下亦不能为大凶大恶。<br>置之于万万人中，其聪俊灵秀之气，则在万万人之上；其乖僻邪谬不近人情之态，又在万万人之下。<br>若生于公侯富贵之家，则为情痴情种；<br>若生于诗书清贫之族，则为逸士高人；<br>纵再偶生于薄祚寒门，断不能为走卒健仆，甘遭庸人驱制驾驭，必为奇优名娼。<br>如前代之许由、陶潜、阮籍、嵇康、刘伶、王谢二族、顾虎头、陈后主、唐明皇、宋徽宗、刘庭芝、温飞卿、米南宫、石曼卿、柳耆卿、秦少游，近日之倪云林、唐伯虎、祝枝山，再如李龟年、黄幡绰、敬新磨、卓文君、红拂、薛涛、崔莺、朝云之流，此皆易地则同之人也。</p></blockquote><p>上述，曹雪芹罗列出的一系列古人。细想一下，皆为当时代最具个性之人，独领风骚，活出一个真自我。</p><blockquote><p>不一时，只见三个奶嬷嬷并五六个丫鬟，簇拥着三个姐妹来了。<br>第一个肌肤微丰，合中身材，腮凝新荔，鼻腻鹅脂，温柔沉默，观之可亲。<br>第二个削肩细腰，长挑身材，鸭蛋脸面，俊眼修眉，顾盼神飞，文彩精华，见之忘俗。<br>第三个身量未足，形容尚小。其钗环裙袄，三人皆是一样的妆饰。</p></blockquote>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>概率论的两个问题-球盒模型、匹配问题</title>
      <link href="/%E6%A6%82%E7%8E%87%E8%AE%BA%E7%9A%84%E4%B8%A4%E4%B8%AA%E9%97%AE%E9%A2%98-%E7%90%83%E7%9B%92%E6%A8%A1%E5%9E%8B%E3%80%81%E5%8C%B9%E9%85%8D%E9%97%AE%E9%A2%98.html"/>
      <content type="html"><![CDATA[<p>怎样利用“数数”的基本公式，来正确（不漏、不重）数出具体问题的数，并不是件容易的事儿。</p><h2>基础概念</h2><h3>1. 可重复组合数</h3><p>从 $n$ 种不同的元素中取 $m$ 个元素（方法是从 $n$ 个元素中每次取出一个后，放回，再取另外一个，直到取出 $m$ 个元素）有 $C_{n+m-1}^m$ 个不同的结果。</p><blockquote><p>证明（顺便提到球盒模型用到的“隔板法”）：<br>首先明确，所谓有重复组合就是不考虑取出的元素的顺序，通俗来说，你第一次取出 $1$ 号元素第二次取出 $3$ 号元素和你第一次取出 $3$ 号元素第二次取出 $1$ 号元素是一样的情况。<br>可以把该过程看作是一个“放球模型”； $n$ 个不同的元素看作是 $n$ 个格子，去掉头尾之后中间一共有 $n-1$ 块相同的隔板；用 $m$ 个相同的小球代表取 $m$ 次；则原问题可以简化为将 $m$ 个不加区别的小球放进 $n$ 个格子里面，问有多少种放法；<br>注意到格子的头尾两块隔板无论什么情况下位置都是不变的，故去掉不用考虑；相当于 $m$ 个相同的小球和 $n-1$ 块相同的隔板先进行全排列：一共有 $(m+n-1)!$ 种排法，再由于m个小球和（n-1）块隔板是分别不加以区分的，所以除以重复的情况：$m!*(n-1)!$;<br>于是答案就是：$\frac{(m+n-1)!}{m!*(n-1)!}=C_{n+m-1}^{m}$。</p></blockquote><h3>2. 第二类Stiring数：</h3><p>$n$ 个人分成 $k$ 组的分组方案的数量。$$S(n,k) = \frac{1}{k!}\sum_{j=1}^{k}(-1)^{k-j}C_k^j j^n$$$S(n,n-1)=C_n^2=\frac{n(n-1)}{2}$</p><h3>3. Jordan公式：</h3><p>概率加法公式的推广$$P(\bigcup_{i=1}^{n}A_i) = S_1-S_2+S_3-\cdots+(-1)^{n-1}S_n \\S_k = \underset{1&lt; i_1 &lt; i_2 &lt; \cdots&lt; i_k &lt; n}{\sum}P(A_{i_1}A_{i_2}\cdots A_{i_k})$$</p><h2>球盒模型</h2><h3>简例 - 1</h3><p>先从简单的例子讲起，$m$ 个球随机放入 $n$ 个盒子中，$n$ 个盒子都有球的概率。其中，“随机”的含义，可分两种情况讨论：</p><h4>1）球可分辨</h4><p>记 $B=n\text{个盒子中至少一个为空}$,$A_i = $第 $i$ 个盒子为空于是$$B=\bigcup_{i=1}^{n}A_i$$因而$$P(B) = p(\bigcup_{i=1}^{n}A_i). \\ P(A_i)=\frac{(n-1)^m}{n^m}, P(A_1A_2)=\frac{(n-2)^m}{n^m},\cdots \\ P(A_1\cdots A_{n-1})=\frac{1}{n^m},P(A_1\cdots A_{n}) = 0.$$按 Jordan 公式$$P(B)=\sum_{i=1}^{n}(-1)^{i-1}C_n^i \frac{(n-i)^m}{n^m}$$所求事件概率为 $1-P(B)$</p><h4>2）球不可分辨</h4><p>记 $A=n\text{个盒子都有球}$,可根据上述可重复组合数公式得$P(A)=C_{n+m-1}^{m}$，即数出 $n$ 个盒子都有球的情况数。</p><h3>标准模型</h3><p>标准的球盒模型，分别讨论球是否有区别、盒子是否有标志以及是否存在空盒，共计 $2^3=8$ 种状态。</p><table><thead><tr><th>Seq</th><th>Ball</th><th>Box</th><th>Amt in Box</th></tr></thead><tbody><tr><td>1</td><td>Non-Diff</td><td>Mark</td><td>No-limit</td></tr><tr><td>2</td><td>Non-diff</td><td>Mark</td><td>No empty box</td></tr><tr><td>3</td><td>Non-diff</td><td>Unmark</td><td>No-limit</td></tr><tr><td>4</td><td>Non-diff</td><td>Unmark</td><td>No empty box</td></tr><tr><td>5</td><td>Diff</td><td>Mark</td><td>No-limit</td></tr><tr><td>6</td><td>Diff</td><td>Mark</td><td>No empty box</td></tr><tr><td>7</td><td>Diff</td><td>Unmark</td><td>No-limit</td></tr><tr><td>8</td><td>Diff</td><td>Unmark</td><td>No empty box</td></tr></tbody></table><h3>简例 - 2</h3><p>简化上述理论，从8个排列组合问题来体会。</p><ol><li>8个相同的球放进3个相同的盒子里，每盒至少一个，有几种方法</li></ol><p>取球最少的盒子取1，取球第二少的盒子可以取[1,3]   3种取球最少的盒子取2，取球第二少的盒子可以取[2,3]   2种取球最少的盒子取3，此情况不存在，一共5种按取球多寡来分类讨论可以做到不遗漏，不重复</p><ol start="2"><li>8个相同的球放进3个不同的盒子里，每盒至少一个，有几种方法</li></ol><p>插板法，$C_7^2=21$</p><ol start="4"><li>8个不同的球放进3个相同的盒子里，每盒至少一个，有几种方法</li></ol><p>取球最少盒子取 1 时，有116, 125, 134三种情况，分别有$C_8^6=28,C_8^1*C_7^2=168, C_8^1*C_7^3=280$.取球最少盒子取 2 时，有224，233二种情况，分别有$\frac{C_8^2*C_6^2}{2}=210,\frac{C_8^3*C_5^3}{2}=280$.一共 $28+168+280+210+280=966.$</p><ol start="3"><li>8个不同的球放进3个不同的盒子里，每盒至少一个，有几种方法</li></ol><p>4问中的966种情况，每种情况的三个元素都是互异的，比如 116（因为球是不同的），这三个元素进行全排列$P_3^3=6$, 乘以 966=5796 即为所求</p><ol start="5"><li>8个相同的球放进3个相同的盒子里，有几种方法</li></ol><blockquote><p>最少盒子取0，次盒子取[0,4]<br>最少盒子取1，次盒子取[1,3]<br>最少盒子取2，次盒子取[2,3]<br>一共 5+3+2=10 种</p></blockquote><ol start="6"><li><p>8个相同的球放进3个不同的盒子里，有几种方法<br>预先在三个盒子种各放入一小球，则问题转化为11同球放3不同盒子，每盒至少1个，几种方法？ 用插板法，$C_10^2=45$</p></li><li><p>8个不同的球放进3个不同的盒子里，有几种方法</p></li></ol><p>每个球都有3种选择，8个球就有$3^8=6561$.</p><ol start="8"><li>8个不同的球放进3个相同的盒子里，有几种方法</li></ol><p>(7问) 中的一般情况(3个元素都相异)，比如116，一共有6种排列(球是不同的)，此问中，盒子是相同的，因此这6种排列都只算一种情况。 但如果2个元素相同的时候，有且只有008，只有3种排列，我们多添加3种进去，令其也重复6次，则6561+3就是 所有的情况都重复了6次，$\frac{6561+3}{6}=1094$ 即为所求。</p><h2>匹配问题</h2><p>问题：两套各标上号码 $1$ 至 $n$ 的卡片被随机地匹配，1）问至少有一对匹配成功的概率为多少？2）问至少有$k(k\leq n)$ 对匹配成功的概率为多少?</p><p>记$B=\text{至少有一对匹配成功}$，$A_i=\text{第i对卡片匹配成功},i=1,2,\cdots ,n$</p><p>事件 $B$ 跟较简单的事件$A_1,A_2,\cdots ,A_n$间有如下关系，$$B=\bigcup_{i=1}^{n}A_i$$</p><p>按Jordan公式，为求 $P(B)$ ，需求 $S_1,S_2,\cdots ,S_n$。为此，先来求 $P(A_1)$</p><p>$$P(A_1)=\frac{(n-1)!}{n!} = \frac{1}{n}$$</p><p>$P(A_2)=P(A_3)=\cdots =P(A_n)=P(A_1)$，所以 $S_1=n\cdot \frac{1}{n}=1$</p><p>至于 $S_1,S_2,\cdots ,S_n$类似求得$$P(A_1A_2)=\frac{(n-2)!}{n!}=\frac{1}{n(n-1)}, \quad S_2=C_n^2 \frac{1}{n(n-1)}=\frac{1}{2!} ;$$$$P(A_1A_2A_3)=\frac{1}{n(n-1)(n-2)}, \quad S_3=C_n^3 \frac{1}{n(n-1)(n-2)}=\frac{1}{3!} ;$$$$\cdots \cdots \cdots$$$$P(\bigcap_{i=1}^{n}A_i)=\frac{1}{n!}, \quad S_n = \frac{1}{n!} $$</p><p>$$P(B) = 1-\frac{1}{2!}+\frac{1}{3!}-\cdots +(-1)^{n-1}\frac{1}{n!}$$</p><p>其中，</p><p>$$1-e^{-1} = 1-\frac{1}{2!}+\frac{1}{3!}-\cdots +(-1)^{n-1}\frac{1}{n!}+\cdots = \sum_{n=1}^{\inf}\frac{(-1)^{n-1} }{n!}$$</p>]]></content>
      
      <categories>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Schwarz不等式知识归纳</title>
      <link href="/Schwarz%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3.html"/>
      <content type="html"><![CDATA[<p>Schwarz 不等式是个应用广泛的不等式，常见于线性代数的内积空间，数学分析的无穷级数，连续函数的积分以及概率论中的方差、协方差。</p><p>一般表述为</p><p>$\vert \langle x,y\rangle \vert ^2 \leq \langle x,x\rangle \dot \langle y,y \rangle$</p><p>在欧几里得空间$\mathcal{R^n}$中，$$(\sum_{i=1}^{n}x_i y_i)^2 \leq (\sum_{i=1}^{n}x_i^2)(\sum_{i=1}^{n}y_i^2)$$</p><p>$$\vert \int f^*(x)g(x)dx \vert ^2 \leq \int \vert f(x) \vert ^2dx \dot \int \vert g(x) \vert ^2dx$$</p><p>复向量空间 $\mathbb{C}^n$ 中，考虑两个向量 $x=(x_1,\ldots,x_n),y=(y_1,\ldots,y_n)$将 Schwarz 不等式两边平方并使用标准向量内积，可得$$\vert \sum_{i=1}^{n}\overline{x_i}{y_i}\vert ^2\leq \sum_{i=1}^{n}\vert x_i\vert ^2\cdot\sum_{j=1}^n\vert y_i\vert^2$$上面的式子描述了数列乘积之和与数列平方和乘积的 Cauchy 不等式。由于上式与 Schwarz 不等式本质上相同，故我们经常将上式称作 <strong>Cauchy-Schwarz</strong> 不等式。现在考虑我们熟悉的区间 $[0,1]$上的连续函数空间，Schwarz 不等式形式可以表达成,</p><p>$$\vert \int_0^1 \bar{f(t)}g(t) dt \vert^2 \leq \int_0^1 \vert f(t) \vert ^2dt \dot \int_0^1 g(t) \vert ^2dt$$</p><p>在一般的广义向量空间，我们定义二向量 $x$ 和 $y$ 的距离为</p><p>$$d(\mathbf{x},\mathbf{y})=\vert \mathbf{x}-\mathbf{y} \Vert = \sqrt{\langle\mathbf{x}-\mathbf{y},\mathbf{x}-\mathbf{y} \rangle}$$</p><p>注意，$d$ 称作向量范数，需要满足以下三个性质：</p><ol><li>$d(\mathbf{x},\mathbf{y})=d(\mathbf{y},\mathbf{x})$</li><li>$d(\mathbf{x},\mathbf{y})\geq 0$ ，当且仅当 $\mathbf{x}=\mathbf{y} $时，$d(\mathbf{x},\mathbf{y})=0$。</li><li>$d(\mathbf{x},\mathbf{y})\leq d(\mathbf{x},\mathbf{z})+d(\mathbf{z},\mathbf{y})$</li></ol><p>显然，向量范数 满足(1) 和 (2)，性质 (3) 即为三角不等式，此式可由 Schwarz 不等式导出，如下：</p><h3>关于证明</h3><p>可参考：<a href="https://ccjou.wordpress.com/2010/03/10/schwarz-%E4%B8%8D%E7%AD%89%E5%BC%8F/" target="_blank" rel="noopener">以 Bessel 不等式证明 Schwarz 不等式</a></p><h3>延伸点</h3><p>从数学分析到泛函分析里最重要的一些不等式:</p><ul><li>Schwarz不等式</li><li>Jesen不等式（凸分析与随机数学中出现得比较多）</li><li>赫尔德（Holder）不等式</li><li>闵可夫斯基（Minkowski）不等式</li><li>Hilbert空间的贝塞尔不等式</li><li>Poincare不等式（变分学中非常重要的不等式）</li><li>Soblev空间嵌入定理（在变分学和偏微分方程中非常重要的不等式）</li></ul><p>以上这些不等式，是必须记住、经常用到（不仅仅在数学自身学科中用到）的最基本的不等式。</p><p>结合运筹学与控制论方向，顺便说一说必须牢牢记住的、最常用的<strong>分析学</strong>定理:</p><ul><li>Banach不动点定理</li><li>Hilbert空间的投影定理</li><li>Hahn-Banach定理（核心中的核心）与分离超平面定理</li><li>反函数定理和隐函数定理（赋范线性空间的微分学）</li><li>阿尔采拉-阿斯科利定理</li><li>Sobolev嵌入定理</li><li>Rellich Kontracheev紧嵌入定理</li><li>Eblerlin Schulyman定理</li><li>Lagrange乘子定理</li><li>Kuhn-Tucker定理（无限维空间的版本，基于Hahn-Banach定理）</li><li>Pontryagin最大值原理（利用Frechet微分理论和前面的乘子定理去理解即可）</li><li>Brouwer（布劳威尔）不动点定理</li><li>Schaulder（绍德）不动点定理</li></ul><h3>复变函数中的柯西不等式</h3><p>设 $ f(z)$ 在区域 $D$ 及其边界上解析，$a$ 为 $D$ 内一点，以 $a$ 为圆心做圆周 $C_R: |z-a|=R$，只 $C_R$ 及其内部 $G$ 均被 $D$ 包含，则有：</p><p>$$\vert f^{(n)}(z_0) \vert \leq \frac{n!M}{R^n}$$</p><p>其中，$M$ 是 $\vert f(z) \vert$ 的最大值，$M= \max \vert f(x) \vert$</p><h3>其它推广</h3><p>$$\sqrt {\sum _{i=1}^{n} (\sum _{j=1}^{m} a_{ij})^2} \leq \sum _{j=1}^{m} \sqrt {\sum _{i=1}^{n}a_{ij}^2} \\ m \req \alpha &gt; 0,(\sum _{i=1}^{n} \prod _{j=1}^{m} a_{ij})^{\alpha }\leq \prod _{j=1}^{m}\sum _{i=1}^{n} a_{ij}^\alpha$$</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解拓扑空间的紧性</title>
      <link href="/%E7%90%86%E8%A7%A3%E6%8B%93%E6%89%91%E7%A9%BA%E9%97%B4%E7%9A%84%E7%B4%A7%E6%80%A7.html"/>
      <content type="html"><![CDATA[<p>文章转载自<a href="http://blog.pluskid.org/?p=785" target="_blank" rel="noopener">链接</a></p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1525365294/2018_05_03-00.png" width="80%" height="80%"><p>关于空间的紧性，我们在之前的分析中已经见过了：例如在实数轴上的有界闭区间就是典型的紧集，紧集具有很多优良的性质，比如我们知道在有界闭区间上的连续函数一定是一致连续的，并且能取到最大值和最小值。所以，在将空间的概念推广到一般的拓扑空间之后，我们也希望将紧性这一优良性质也带到拓扑空间中来。为此，我们需要找到什么是紧集最本质的东西。在实数轴上的紧集 $K$，有如下的一些等价刻画：</p><ul><li>$K$ 是有界闭集</li><li>$K$ 的任意无限子集必存在极限点</li><li>$K$ 中的任意序列必有收敛子列</li><li>$K$ 的任意开覆盖必有有限子覆盖</li></ul><p>其中第一条无法在拓扑空间中使用，因为“有界”的概念无法定义。第二或者第三条曾经被认为是实质性的，但是后来由于 $\text{Tychonoff}$ 定理，人们发现最后一条才是真正好的定义，因此将其作为拓扑空间紧性的定义，而第二条和第三条分别被叫做“极限点紧(<a href="http://en.wikipedia.org/wiki/Limit_point_compact" target="_blank" rel="noopener">Limit point compact</a>）”和“序列紧（<a href="http://en.wikipedia.org/wiki/Sequentially_compact_space" target="_blank" rel="noopener">Sequencially compact</a>）”。下面是正式内容，在给出定义之前，我先给出一个提纲：</p><ul><li>首先当然是要给出拓扑空间紧性的定义。</li><li>接下来当然是会举一些例子，一方面是把枯燥的定义从抽象中拉回来，另一方面也是非常重要的是给出紧空间的存在性的证据，因为定义总是可以随便给的，这样子我可以给出具有任意优良性质的定义来，然而所定义的东西如果是不存在的话，相关的一切性质其实都是空谈。</li><li>然后我们将介绍从已有的紧空间构造新的紧空间的方法：<font color="blue">包括集合的交、并、补，以及子空间、商空间和积空间——这一系列都是标准套路。</font>在这里将会出现一个大定理，就是刚才提到的 $\text{Tychonoff}$  定理。</li><li>接下来将暂时中断一下，讨论一下稍微具体一点的度量空间(Metric Space)中的紧性。因为度量空间更加具体一些，所以能得到的性质也更丰富一些。</li><li>最后我们将简要介绍一些将非紧空间（non-compact space）转化为紧空间（compactification，紧化）的初步知识。</li></ul><p>但从度量空间的紧性开始那部分内容并不在这里论述。</p><blockquote><p><strong>定义 1</strong>：设 $X$ 是一个集合，它的一族子集 $\mathcal{A}=\{A_\lambda | \lambda\in\Lambda\}$ 如果满足$$\bigcup_{\lambda\in\Lambda}A_\lambda = X$$则称为 $\mathcal{A}$ 为 $X$ 的一个覆盖，或 $\mathcal{A}$ 覆盖 $X$ 。特别地，如果 $X$ 是一个拓扑空间，而且每个 $A_\lambda$，$\lambda\in\Lambda$ 都是 $X$ 中的开集，则称 $\mathcal{A}$ 为 $X$ 的一个开覆盖。</p></blockquote><blockquote><p><strong>定义 2</strong>：拓扑空间 $X$ 称为紧的，如果它的任意开覆盖有有限子覆盖。</p></blockquote><p>其实根据这个定义里的描述，也可以看出紧性之所以好的一些端倪了，<font color="blue">不精确地说，利用紧性我们可以把无限的东西转化为有限的情况来处理。</font></p><p>我们最熟悉的紧空间的例子应该就是 $\mathbb{R}$ 中的闭区间了，在数学分析中已经证明过它是紧的。其他我们还可以举一些简单的例子，比如：</p><ul><li>任意由有限点集所构成的拓扑空间是紧的。因为无论在它上面给怎么样的拓扑，它所有的开集的个数总是有限的，所以任意开覆盖本身就是有限覆盖了。</li><li>具有余有限拓扑（cofinite topology ）的空间是紧的。因为假设 $\mathcal{A}$ 是具有 cofinite topology 的空间 $X$ 的一个开覆盖，从 $\mathcal{A}$ 中任选一个非空的元素 $A_0$，由 cofinite topology 的定义，知道 $X-A_0$ 只有有限个元素 $x_1,\ldots,x_n$ ，对于每一个 $x_i$，$i=1,\ldots,n$ 可以找到一个 $A_i\in\mathcal{A}$ 使得 $x_i\in A_i$ ，这样，${A_0,A_1,\ldots,A_n}$ 就是 $X$ 的开覆盖 $\mathcal{A}$ 的一个有限子覆盖。</li></ul><p>非紧空间的例子也很好举，例如 $\mathcal{R}$ 上的区间 $(0,1]$ 就不是紧的，因为我们可以构造一个开覆盖 $\{(1/n,1] \}_{n=1}^\infty$ ，它的任意一个有限子集族总是无法覆盖 $(0,1]$ 。</p><p>有了基本的例子之后，下面我们来讨论如何从已有的紧空间构造新的紧空间。从集合的角度来看，构造新的集合常用的操作有 $\cap$、$\cup$ ，从空间的角度来看则有子空间（$\iota$）、商空间（$\pi$）、积空间（$\Pi$），下面我们就依次讨论在这些操作下紧性是否能得到保持。</p><p><strong>首先是紧空间的交集</strong>，因为任意拓扑空间的交集上，最自然的拓扑就是这一系列包含映射所诱导的始端拓扑（<a href="http://en.wikipedia.org/wiki/Initial_topology" target="_blank" rel="noopener">Initial Topology</a>），如果这些拓扑空间互相之间没有什么关系的话，讨论起来就比较复杂了，通常我们会讨论所有要取交的拓扑空间是一个大的拓扑空间的子空间的情况，这个时候它们的交集实际上就是子空间的一种特殊情况，所以我们放到讨论子空间的紧性的时候再讨论。</p><p><strong>其次是并集</strong>。任意多个并的情况显然是不对的，例如 $\mathbb{R}$ 上可数个紧集 $[n,n+1]$，$n\in\mathbb{Z}$ 的并集是 $\mathbb{R}$ 本身，并不是紧的。不过有限个的情况表现还是良好的。</p><blockquote><p><strong>命题 1</strong>：若 $X_1,\ldots,X_n$ 是空间 $X$ 的有限个紧子集，则它们的并也是紧的。</p></blockquote><p>证明：记 $Y=\cup_{i=1}^n X_i$ 。设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $Y$ 的任一开覆盖，则显然它也是每一个 $X_i$，$i=1,\ldots,n$ 的开覆盖，因此对于每个 $X_i$ ，存在 $\mathcal{A}$ 的一个有限子集族 $\mathcal{A}_i$ 仍然覆盖 $X_i$ 。令$$ \mathcal{A}’=\bigcup_{i=1}^n \mathcal{A}_i $$</p><p>则显然 $\mathcal{A}’$ 是 $\mathcal{A}$ 的一个有限子集族，并且它仍然覆盖 $Y$ 。</p><p><strong>接下来我们讨论拓扑子空间的紧性</strong>。一个紧空间的子空间是否一定是紧的呢？显然不一定，明显的反例是紧空间 $[0,1]$ 的子空间 $(0,1]$ ，但是如果限制到闭子集的话，就可以做到了：</p><blockquote><p><strong>定理 1</strong>：紧空间的闭子集是紧的。</p></blockquote><p>注意这里我们称一个空间的子集是紧的，实际上是在说这个子集配上子空间拓扑之后是一个紧空间。在证明这个定理之前，我们先给一个方便的验证子空间紧性的判定定理：</p><blockquote><p><strong>定理 2</strong>：设 $Y$ 是 $X$ 的子空间，$Y$ 是紧的，当且仅当任意一族覆盖 $Y$ 的 $X$ 中的开集包含一个覆盖 $Y$ 的有限子族。</p></blockquote><p>这里的意思是说，如果 $Y$ 是 $X$ 的子空间，判断 $Y$ 的紧性的时候，用 $X$ 中的开集来覆盖还是用 $Y$ 中的开集来覆盖都是一样的。这个定理可以省去我们在验证的时候的一些麻烦。</p><p><font color="blue">证明：</font>首先证正向：设 $Y$ 是紧的，$\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是一族覆盖 $Y$ 的 $X$ 中的开集，则 $\mathcal{A}’={A_\lambda\cap Y|\lambda\in\Lambda}$ 是 $Y$ 的一个开覆盖，根据紧性，存在有限子覆盖$$\{A_{\lambda_1}\cap Y,\ldots,A_{\lambda_n}\cap Y\}$$显然对应的 $\mathcal{A}$ 的子族$$\{A_{\lambda_1},\ldots,A_{\lambda_n}\}$$仍然覆盖 $Y$ 。</p><p>再证反过来，设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $Y$ 的一族开集，它覆盖了 $Y$ ，则根据子空间拓扑的定义，对于每个 $A_\lambda$，$\lambda\in\Lambda$ ，存在 $X$ 中的开集 $U_\lambda$ 使得 $A_\lambda=U_\lambda\cap Y$ ，因此 ${U_\lambda|\lambda\in\Lambda}$ 是一族覆盖 $Y$ 的 $X$ 中的开集，由定理假设，它包含一个有限子族$$\{U_{\lambda_1},\ldots,U_{\lambda_n}\}$$仍然覆盖 $Y$ ，则对应的$$\{U_{\lambda_1}\cap Y=A_{\lambda_1},\ldots,U_{\lambda_n}\cap Y=U_{\lambda_n}\}$$是 $\mathcal{A}$ 的一个有限子族，并且仍然覆盖 $Y$ ，由此得 $Y$ 是紧的，即证。</p><p><font color="blue">定理 1 的证明</font>：设 $X$ 是紧空间，$K$ 是 $X$ 的闭子集，$\mathcal{A}$ 是 $K$ 的任一开覆盖，则$$\mathcal{B}=\mathcal{A}\cup\{X-K\}$$是 $X$ 的一个开覆盖，由 $X$ 的紧性，存在 $\mathcal{B}$ 的一个有限子族 $\mathcal{B}’;$ 仍然覆盖 $X$ 。如果 $X-K\in\mathcal{B}’$ 则将它从中去掉，否则不做任何操作，得到$$\mathcal{A}’=\mathcal{B}’-\{X-K\}$$是 $\mathcal{A}$ 的一个有限子族，并且它是覆盖 $K$ 的。证完。</p><p>借助子空间紧性的结论，对于刚才提到的紧集的交的紧性，我们可以有这样一个推论：</p><blockquote><p><strong>推论 1</strong>：设 $X$ 是一个拓扑空间，$\{K_\lambda|\lambda\in\Lambda\}$ 是 $X$ 的一族紧且闭的子集。那么它们的交 $\cap_\lambda K_\lambda$ 也是紧的。由任意闭集的交集是闭集，并且这个交集是其中某一个（任意一个）紧集 $K_\lambda$ 的子集，根据定理 1 立即得到。接下来我们讨论紧空间的商空间，紧性在这里的表现是很好的，但是我们并不直接给出商空间的紧性，而是叙述一个更一般的结论：</p></blockquote><blockquote><p><strong>定理 3</strong>：设 $f:X\rightarrow Y$ 是连续映射，$X$ 是紧空间，那么 $f(X)$ 也是紧的。由商映射的连续性以及到上性（满射），根据这个定理立即可以得到任意紧空间的商空间仍然是紧的。</p></blockquote><p><font color="blue">证明：</font>设 $\mathcal{A}=\{A_\lambda|\lambda\in\Lambda\}$ 是 $F(X)$ 的一个开覆盖，则由 $f$ 的连续性知$$\mathcal{B}=\{f^{-1}(A_\lambda)|\lambda\in\Lambda\}$$是 $X$ 的一个开覆盖。由 $X$ 的紧性，存在 $\mathcal{B}$ 的一个有限子集族$$\mathcal{B}’=\{f^{-1}(A_{\lambda_1}),\ldots,f^{-1}(A_{\lambda_n})\}$$仍然覆盖 $X$ 。则对应的集族$$\mathcal{A}’=\{A_{\lambda_1},\ldots,A_{\lambda_n}\}$$是 $\mathcal{A}$ 的一个有限子集族并且仍然覆盖 $f(X)$ 。证完。</p><p>由这个定理可以立即得到，<font color="blue">如果两个拓扑空间 $X$ 和 $Y$ 是同胚的，其中一个紧那么另一个必定也是紧的。</font>换句话说，紧性是一个拓扑性质。这样的性质通常可以用来方便地区分两个（在同胚意义下）不同的拓扑空间，因为要证明两个空间同胚，只要找出一个同胚映射就可以了，但是要证明两个空间不同胚，则是要证明不可能有同胚存在，通常是一个更加困难的问题，比较好解决的情况通常都用反证法来做了，就是假设同胚，但是又发现两个空间的某个拓扑性质是不一样，就导出矛盾。</p><p>例如，用紧性可以证明球面 $S^2$ 和平面 $\mathbb{R}^2$ 是不同胚的。类似地可以证明 $[0,1]$ 和 $(0,1)$ 是不同胚的。</p><p>不过，这里既然提到了同胚和连续映射，就正好也说一下<strong>紧空间的好处</strong>吧（因为我实在不知道这一小部分内容放在哪里讲比较好了）。我们知道从 $\mathbb{R}$ 上的紧集打出去的连续函数一定是一致连续的，一致连续是比连续要强得多的条件，不过在一般的拓扑空间中并不能方便地定义“一致连续”的概念，不过从紧空间打出去的连续映射仍然具有一些良好的性质：</p><blockquote><p><strong>定理 4</strong>：设 $f:X\rightarrow Y$ 是连续映射，如果 $X$ 是紧空间，$Y$ 是 <a href="http://en.wikipedia.org/wiki/Hausdorff_space" target="_blank" rel="noopener">Hausdorff</a> 空间，则 $f$ 是闭映射。闭映射是一个很好的东西，例如我们有一个非常直接的推论：</p></blockquote><blockquote><p><strong>推论 2</strong>：设 $f:X\rightarrow Y$ 是连续的双射，若 $X$ 是紧空间，$Y$ 是 Hausdorff 空间，则 $f$ 是同胚映射。为了证明定理 4 ，我们再引入另外两个结论，当然它们本身也是相当重要的，因此也是作为定理出现。首先我们要注意到，在一般的拓扑空间中，紧集不一定是闭的（类比 $\mathbb{R}$ 中：有界闭集等价于紧集）。例如最开始我们举的余有限拓扑空间中，任意集合都是紧的，然而只有有限集才是闭的。不过，如果加上了 Hausdorff 条件的话，这一点就可以得到保证了：</p></blockquote><blockquote><p><strong>定理 5</strong>：Hausdorff 空间中的紧子集是闭集。</p></blockquote><p>这个定理的证明过程本身是比较有用的，因此被抽取出来也作为一个定理：</p><blockquote><p><strong>定理 6</strong>：设 $K$ 是 Hausdorff 空间 $X$ 中的紧子集，$p\in X-K$ ，则存在 $X$ 中互不相交的开集 $U$、$V$，使得 $K\subset U$ 和 $p\in V$ 。</p></blockquote><p><font color="blue">证明</font>：$\forall x\in K$ ，由 $X$ 的 Hausdorff 性，存在互不相交的开集 $U_x$ 和 $V_x$ ，使得 $x\in U_x$、 $p\in V_x$ 。当 $x$ 取遍 $K$ 时，我们得到$$\mathcal{U}={U_x|x\in K}$$是 $K$ 的一个开覆盖，根据 $K$ 的紧性，存在 $\mathcal{U}$ 的一个有限子集族$${U_{x_1},\ldots,U_{x_n}}$$仍然覆盖 $K$ 。下面令$$U = \bigcup_{i=1}^n U_{x_i},\quad V=\bigcap_{i=1}^n V_{x_i}$$则 $U$ 和 $V$ 为互不相交的开集，且 $K\subset U$ 、$p\in V$ 。证完。</p><p><font color="blue">定理 5 的证明</font>：设 $K$ 是 Hausdorff 空间 $X$ 中的紧子集，我们现在证明 $X-K$ 是开集。对任意的 $x\in X-k$ ，根据定理 6 ，存在 $X$ 中互不相交的开集 $U$、$V$ 使得 $K\subset U$ 、 $p\in V$，因此 $p\in V\subset X-K$ ，即证。</p><p><font color="blue">定理 4 的证明</font>：任取 $X$ 中的闭集 $C$ ，由 $X$ 的紧性和定理 1 知 $C$ 是紧集，由 $f$ 的连续性和定理 3 知 $f© $ 是紧的，再由定理 $Y$ 的 Hausdorff 性和定理 5 知 $f© $ 是闭的。即证。</p><p>下面我们再回到主线：接下来只剩下积空间的紧性的讨论了。紧性在这里的表现也是优良的，Tychonoff 定理保证了任意一族紧空间的积空间也是紧的。这是一个很要紧的地方，因为我们在最开始列了 4 条 $\mathbb{R}$ 中紧性的刻画，其中末尾 3 条在度量空间中是等价的，然而在一般的拓扑空间中则不行了，那究竟选哪一条作为紧性的定义呢？正是 Tychonoff 定理一锤定音——选择当前的这个定义，可以得到 Tychonoff 定理的结论，而其他的定义则无法做到。</p><p>不过，在讲 Tychonoff 定理之前，我们先来看一下有限个紧空间的积空间的紧性。虽然有限个的情况证明方法和 Tychonoff 中任意积的证明完全不一样，但是有限的情况会引出一个本身也很有用的 <a href="http://en.wikipedia.org/wiki/Tube_lemma" target="_blank" rel="noopener">Tube Lemma</a> ，所以是不容错过的。由于有限积可以由两两积归纳得到，并且我们之后会有更加一般的情况，这里只给出两个紧空间的积空间的描述：</p><blockquote><p><strong>定理 7</strong>：若 $X$ 和 $Y$ 是紧空间，则 $X\times Y$ 也是紧的。</p></blockquote><p>证明这个定理需要用到下面的 <strong>Tube Lemma</strong> ：</p><blockquote><p><strong>定理 8 (Tube Lemma)</strong>：设 $X$ 和 $Y$ 是拓扑空间，其中 $Y$ 是紧的，若 $X\times Y$ 中的任一开集 $N$ 包含了“切片” $x_0\times Y$ ，则存在 $X$ 中 $x_0$ 的开领域 $W$ 使得 $W\times Y$ 也包含在 $N$ 中。证明过程可以参考下图，图取自 Munkres 的《Topology》</p></blockquote><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1525365294/2018_05_03-01.png" width="95%" height="95%"><p><font color="blue">证明</font>：首先，由于 $N$ 是开集，对于每一点 $(x_0,y)\in N$ ，存在其开领域 $N_y\subset N$ ，特别地，我们可以取积拓扑中的基开邻域 $N_y=U_y\times V_y$。令 $y$ 取遍 $Y$ 得到 $x_0\times Y$ 的一个开覆盖。</p><p>由于 $x_0\times Y$ 同胚于 $Y$ ，因此是紧的，故存在有限子覆盖。亦即存在有限个点 $y_1,\ldots,y_n\in Y$ ，使得$$\mathcal{N}={N_{y_1},\ldots,N_{y_n}}$$覆盖 $x_0\times Y$ ，令$$W=\bigcap_{i=1}^n U_{y_i}$$则 $W\times Y$ 为 $X\times Y$ 中的开集，且 $x_0\times Y\subset W\times Y$ ，下面只需要证明 $W\times Y\subset N$ 即可。任取 $(x,y)\in W\times Y$ ，对应点 $(x_0,y)\in x_0\times Y$ 必定被包含于 $\mathcal{N}$ 中的某一个元素里（有多个的时候任取一个即可），记为 $N_0=U_0\times V_0$ ，则我们有 $y\in V_0$ ，又由于 $x\in W\subset U_0$ ，因此得 $(x,y)\in U_0\times V_0$ ，再由于我们之前取的所有基开邻域 $N_{y}$ 都是包含于 $N$ 中的，因此 $(x,y)\in N$ ，即证。</p><p><font color="blue">定理 7 的证明</font>：设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X\times Y$ 的任一开覆盖。对任意的 $x_0\in X$ ，$x_0\times Y$ 是紧的，因此可以被有限个元素 ${A_{\lambda_1},\ldots,A_{\lambda_n}}$ 覆盖，记$$N=\bigcup_{i=1}^n A_{\lambda_i}$$则由 Tube Lemma ，存在 $x_0$ 的开领域 $W$ 使得 $W\times Y\subset N$ ，此时 $W\times Y$ 也被 $A_{\lambda_1}$ 到 $A_{\lambda_n}$ 这有限个 $\mathcal{A}$ 的元素所覆盖。</p><p>下面对于每个 $x\in X$ ，可以得到对应的 $W_x$ ，这构成 $X$ 的一个开覆盖$$\mathcal{W}={W_x|x\in X}$$再由 $X$ 的紧性知道，开覆盖 $\mathcal{W}$ 存在有限子覆盖，亦即存在有限个点 $x_1,\ldots,x_m$ ，使得 ${W_{x_1},\ldots,W_{x_m}}$ 仍然覆盖 $X$ 。因此所有的 tube 构成整个空间：$$X\times Y = \bigcup_{i=1}^m W_{x_i}\times Y$$又由于每个 tube 都可以被有限个 $\mathcal{A}$ 中的元素覆盖，因此整个空间（有限个 tube 的并）可以被有限个 $\mathcal{A}$ 中的元素覆盖。证完。</p><p>不过，以上的证明方法只适用于有限积的情况，如果是任意个空间的积空间的话，就没法做了，当然，结论还是成立的：</p><blockquote><p><strong>定理 9 (Tychonoff Theorem)</strong>：设 ${X_\lambda|\lambda\in\Lambda}$ 是任意一族紧空间，则 $\prod_\lambda X_\lambda$ 是紧的。</p></blockquote><p>要证明这个定理需要做许多准备工作。首先我们将暂时抛开开集，而用闭集来刻画空间的紧性。</p><blockquote><p><strong>定义 3</strong>：设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X$ 的一族子集，称 $\mathcal{A}$ 满足有限交条件，如果任意有限个 $\mathcal{A}$ 中的元素的交集是非空的。</p></blockquote><blockquote><p><strong>定理 10</strong>：拓扑空间 $X$ 是紧的，当且仅当 $X$ 的任一满足有限交条件的闭集族的交非空。</p></blockquote><p><font color="blue">证明</font>：$X$ 的紧性的定义等价于：对于 $X$ 中的一族开集 $\mathcal{A}$ ，如果 $\mathcal{A}$ 的任意有限子集族都不能覆盖 $X$ ，则 $\mathcal{A}$ 不能覆盖 $X$ 。</p><p>将开集族中的每个元素取补集可以得到一族对应的闭子集，因此上面的条件又等价于：对于任意一族闭子集 $\mathcal{A}’$ ，如果 $\mathcal{A}’$ 的任意有限子集族的交非空（满足有限交条件），则 $\mathcal{A}’$ 的交非空。即证。</p><blockquote><p><strong>定义 4</strong>：设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X$ 的一个开覆盖，称 $\mathcal{A}$ 为 $X$ 的</p></blockquote><ul><li>基开覆盖，如果每个 $A_\lambda\in\mathcal{A}$ 属于 $X$ 的某个给定的拓扑基；</li><li>子基开覆盖，如果每个 $A_\lambda\in\mathcal{A}$ 属于 $X$ 的某个给定的子基拓扑。</li></ul><p>为了接下来的叙述方便，下面再定义几个在其他地方不太常用的概念</p><blockquote><p>定义 5：我们称 $X$ 的一族闭子集 $\mathcal{B}$ 为</p></blockquote><ul><li>闭基，如果 ${X-B|B\in\mathcal{B}}$ 是 $X$ 的一个基；</li><li>闭子基，如果 ${X-B|B\in\mathcal{B}}$ 是 $X$ 的一个子基。</li></ul><blockquote><p><strong>定理 11</strong>：设 $X$ 是拓扑空间，如下命题等价：</p></blockquote><ul><li>(1)$X$ 是紧的；</li><li>(2)$X$ 的任一基开覆盖有有限子覆盖；</li><li>(3)$X$ 的任意一族满足有限交性质的闭基集合的交非空。</li></ul><p><font color="blue">证明</font>：(1) $\Rightarrow$ (2) 显然。(2) $\Leftrightarrow$ (3) 证明过程和定理 10 的证明完全类似。(2) $\Rightarrow$ (1) 设 $\mathcal{A}={A_\lambda|\lambda\in\Lambda}$ 是 $X$ 的任一开覆盖，任一 $A_\lambda\in\mathcal{A}$ 都是 $X$ 的一些基开集的并，因此$$\mathcal{B}=\{B|B\text{ is base set}, B\subset A_\lambda\text{ for some } A_\lambda\in\mathcal{A}\}$$是 $X$ 的一个基开覆盖，由条件，有有限多个 $B_{\lambda_1},\ldots,B_{\lambda_n}\in \mathcal{B}$ 覆盖 $X$ ，在 $\mathcal{A}$ 中取 $A_{\lambda_1},\ldots,A_{\lambda_n}$ 使得 $B_{\lambda_i}\subset A_{\lambda_i}$， $i=1,\ldots,n$ ，则 $\{A_{\lambda_1},\ldots,A_{\lambda_n}\}$ 是 $\mathcal{A}$ 的有限子覆盖。</p><blockquote><p><strong>定理 12 (Alexander Theorem, 1939)</strong>：设 $X$ 是拓扑空间，如下命题等价：</p></blockquote><ul><li>(1)$X$ 是紧的；</li><li>(2)$X$ 的任意子基开覆盖有有限子覆盖；</li><li>(3)$X$ 的任意一族满足有限交性质的闭子基集合有非空的交。</li></ul><p><font color="blue">证明：</font></p><ul><li>(1) $\Rightarrow$ (2) 显然。</li><li>(2) $\Leftrightarrow$ (3) 证明和定理 10 的证明完全类似。</li><li>接下来我们不直接证明 (3) $\Rightarrow$ (1) ，而是证明由本定理的 (3) 可以得到定理 11 的 (3) 。设 $\mathcal{B}={B_\lambda|\lambda\in\Lambda}$ 是 $X$ 中任意一族满足有限交性质的闭基集合，我们要证明它们的交非空。</li></ul><p>首先我们来构造一个“极大的”包含了 $\mathcal{B}$ 的具有有限交性质的闭基集族 $\mathcal{C}$。“极大”就是说没有比它更大了，稍后会精确定义，这里的想法是，如果我们能证明这个 $\mathcal{C}$ 的交是非空的，那么自然 $\mathcal{B}$ 的交也是非空的。这看上去好像把问题变难了，因为直观上来讲集族变大之后它们的交集就变小了，所以要保证交集非空就更加困难了。不过，这里的思想大致是将集族扩大到“合适”的程度，使得我们在寻找非空的那个交集的时候没有 $\mathcal{B}$ 那么多的自由度，关键就在于“极大性”上，让我们在构造的时候能做到“恰到好处”。</p><p>下面我们用 <a href="http://en.wikipedia.org/wiki/Zorn%27s_lemma" target="_blank" rel="noopener">Zorn’s Lemma</a> 来构造这个 $\mathcal{C}$ ，先令 $\mathbb{B} = \{\mathcal{D}|D$ 是满足有限交条件的闭基集族, $\mathcal{B}\subset\mathcal{D}\}$ 。首先 $\mathbb{B}\neq\emptyset$ ，因为 $\mathcal{B}\in\mathbb{B}$ 。我们以包含关系作为 $\mathbb{B}$ 里的一个偏序，下面证明任意一条链（全序子集）都在 $\mathbb{B}$ 中有上界。</p><p>设 $\{\mathcal{D}_k|k\in K\}\subset \mathbb{B}$ 是任意一个全序子集，令 $\mathcal{E}=\cup_k \mathcal{D}_k$ ，则对任意的 $k\in K$ ，$\mathcal{D}_k\subset \mathcal{E}$ 。如果我们证明 $\mathcal{E}$ 满足有限交条件，则 $\mathcal{E}\in\mathbb{B}$ ，显然，它是我们要找的上界。</p><p>任取有限个元素 $E_1,\ldots,E_m\in\mathcal{E}$ ，由链的有序性知，存在 $k_0\in K$ ，使得 $E_1,\ldots,E_m \in \mathcal{D}_{k_0}$ ，再由 $\mathcal{D}_{k_0}$ 满足有限交条件，知 $\cap_{i=1}^m E_i\neq\emptyset$ 。</p><p>以上我们证明了 Zorn’s Lemma 的条件是满足的，因此，$\mathbb{B}$ 存在最大元 $\mathcal{C}$ 。下面我们来证明集族 $\mathcal{C}$ 的交非空。</p><p>$\mathcal{C}$ 的每个元素是一个闭集集合，由于每个基集合都是有限个子基集合的交，我们有每个闭基集合都是有限个闭子基集合的并。即 $\forall C_\mu \in \mathcal{C}, \mu\in M$$$C_\mu = S_1\cap\cdots\cap S_n$$这里为了避免下标爆炸，只好乱用一下符号了。实际上对于每个不同的 $\mu$ ，$n$ 是不一样的，而且 $S_1$ 到 $S_n$ 也可能是不同的集合。接下来的下标也会有点乱……现在我们考虑某个特定的 $\mu$ ，如果我们能证明至少存在一个 $i$ 使得 $S_i\in\mathcal{C}$ ，那么对于每个闭基集合 $C_\mu, \mu\in M$ ，取对应的那个 $S_i$ 组成一个集族 ${S_\mu}\subset \mathcal{C}$ ，因此它满足有限交条件，由 (3) 的条件知（注意每个 $S_\mu$ 是闭子基集合），它们的交非空。由此可以立即得到：集族 $\mathcal{C}$ 的交也非空。</p><p>最后我们就来证明至少存在一个 $i$ 使得 $S_i\in\mathcal{C}$ ，这里终于要用到 $\mathcal{C}$ 的极大性了。用反证法，假设对任意的 $i=1,\ldots,n$ 都有 $S_i\not\in\mathcal{C}$ 。由于闭子基集合同时也是闭基集合，对于每一个 $i=1,\ldots,n$， 由 $\mathcal{C}$ 的极大性，知道$$\mathcal{C}\subsetneq\left(\mathcal{C}_i=\{S_i\}\cup \mathcal{C}\right)$$其中 $\mathcal{C}_i$ 必定不能满足有限交条件，亦即，存在 $\mathcal{C}_i$ 的有限子集族 $\mathcal{C}’_i$ （显然 $S_i$ 包含在其中），其交为空集。将所有这些（有限个） $S_i$ 并起来，我们得到 $C_\mu \in \mathcal{C}$ ，而将对应的 $\mathcal{C}’_i$ 交起来，我们得到一个 $\mathcal{C}$ 的子集族$$\mathcal{C}_f=\bigcap_{i=1}^n\mathcal{C}’_i$$由刚才的构造，知道$$C_\mu\cup\left(\bigcap_{C\in\mathcal{C}_f}C\right)=\emptyset$$</p><p>而 $\{C_\mu\}\cup \mathcal{C}_f$ 是 $\mathcal{C}$ 的一个有限子集族，这与 $\mathcal{C}$ 满足有限交条件相矛盾。证完。</p><p>有了这些准备工作之后，Tychonoff 的证明也就变得简单了：</p><p><font color="blue">定理 9 的证明</font>：空间 $\prod_{\lambda}X_\lambda$ 的一族子基是$$\{p^{-1}_\lambda(V_\lambda)|V_\lambda\subset X_\lambda, V_\lambda\text{open},\lambda\in \Lambda\}$$因此对应的闭子基的每个元素集合是形状如$$\prod_{\lambda\in\Lambda}C_\lambda$$的集合，其中 $C_\lambda$ 是 $X_\lambda$ 中的闭集（实际上除了最多一个之外，其他的全都是整个空间 $X_\lambda$ ）。对于任意一族如上形式的闭子基集族 $\mathcal{A}$ ，如果它们满足有限交性质，我们证明它们的交非空即可。根据上面的形式可以知道，将 $\mathcal{A}$ 以自然投影投影到任意的 $X_\lambda$ 中，仍然得到一族满足有限交性质的闭集，由 $X_\lambda$ 本身的紧性，知道它们的交非空，因此可以选择其中一点 $x_\lambda$ 。所有的这些点就构成了 $\prod_\lambda X_\lambda$ 中 $\bigcap_{A\in\mathcal{A}}A$ 里的一点 $(x_\lambda)_{\lambda\in\Lambda}$ ，即证。</p><p>最后，闲聊一下文章标题图片 Klein Bottle ，课堂上提到拓扑必然会举到的例子，什么橡皮泥啊、克莱因瓶之类的。默比乌斯带还是可以理解的，因为可以做出实物来，但是当时一直觉得克莱因瓶是不对的，所谓顺着瓶子的壁可以从里面爬到外面，我看这各种克莱因瓶的图，都觉得是不对的。到现在终于知道为什么了——确实是不对的，不过不是说 Klein Bottle 不存在，如果用 schematic representation 的话，还是比较可以接受的，只是关于 Klein Bottle 的 visualization ，却是有问题的，因为 Klein Bottle 不能嵌入到 $\mathbb{R}^3$ 中，直观地来说，我们无法在我们生活的三维世界里造出一个克莱因瓶来，如果强行把它放到 $\mathbb{R}^3$ 中，就会出现自相交了，也就是平时所看到的那些图里明显的不对劲的地方了。</p><p>不过我比较奇怪，其实用图片来做 visualization 的话，实际上是在 $\mathbb{R}^2$ 中了，结果最大的问题还是出在人类的想象力上吗？不过我觉得这里贴的这张图似乎有点意思了——因为看不太出那么明显的自交。</p>]]></content>
      
      <categories>
          
          <category> 数学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Note-关于事件的运算</title>
      <link href="/Note-%E5%85%B3%E4%BA%8E%E4%BA%8B%E4%BB%B6%E7%9A%84%E8%BF%90%E7%AE%97.html"/>
      <content type="html"><![CDATA[<h2>关于事件的运算</h2><p>$$\underset{n \rightarrow \infty}{\overline{lim}} A_n= \bigcap _{k=1}^{\infty} \bigcup _{n=k}^{\infty} A_n$$</p><p>$$\underset{n \rightarrow \infty}{\underline{lim}} A_n= \bigcup _{k=1}^{\infty} \bigcap _{n=k}^{\infty} A_n$$</p><p>其中，$\underset{n \rightarrow \infty}{\overline{lim}} A_n​$ 为事件序列$\{A_n\}​$的上限事件，表示$A_n​$发生无穷多次。类似的，称 $\underset{n \rightarrow \infty}{\underline{lim}} A_n​$ 为事件序列的下限事件，表示$A_n​$之多只有有限个不发生。</p><p>显然，有$$\underset{n \rightarrow \infty}{\overline{lim}} A_n \supset \underset{n \rightarrow \infty}{\underline{lim}} A_n$$</p><p>特别的，当$\underset{n \rightarrow \infty}{\overline{lim}} A_n = \underset{n \rightarrow \infty}{\underline{lim}} A_n$ 时，记 $ \underset{n \rightarrow \infty}{lim} A_n \equiv \underset{n \rightarrow \infty}{\overline{lim}} A_n = \underset{n \rightarrow \infty}{\underline{lim}} A_n$，并称它为事件序列$\{A_n\}$的极限事件。</p><p>由德摩根定律，有</p><p>$$\overline{(\bigcap _{k=1}^{\infty} \bigcup _{n=k}^{\infty} A_n)}=\bigcup _{k=1}^{\infty} \bigcap _{n=k}^{\infty} \overline{A_n}$$</p><p>$$\overline{(\bigcup _{k=1}^{\infty} \bigcap _{n=k}^{\infty} A_n)}=\bigcap _{k=1}^{\infty} \bigcup _{n=k}^{\infty} \overline{A_n}$$</p><p>因此$$\underset{n \rightarrow \infty}{\underline{lim}} \overline{A_n} = \overline{(\underset{n \rightarrow \infty}{\overline{lim}} A_n)}$$$$\underset{n \rightarrow \infty}{\overline{lim}} \overline{A_n} = \overline{(\underset{n \rightarrow \infty}{\underline{lim}} A_n)}$$</p><p>由此引出的$\text{Borel-Cantelli}$引理，在概率论中有着众多应用。</p><p>$\text{Borel-Cantelli lemma}$:</p><ol><li><p>若随机事件序列$\{A_n\}$满足$$\sum_{n=1}^{\infty}P(A_n)&lt;\infty$$则$$P\{ \underset{n \rightarrow \infty}{\overline{lim}} A_n\}=0, P\{ \underset{n \rightarrow \infty}{\underline{lim}} \overline{A_n}\}=1$$</p></li><li><p>若$\{A_n\}$是相互独立的随机事件序列，则$$\sum_{n=1}^{\infty}P(A_n)=\infty$$的充要条件为</p><p>$$P(\underset{n \rightarrow \infty}{\overline{lim}} A_n)=1 \text{  or  } P(\underset{n \rightarrow \infty}{\underline{lim}} \overline{A_n})=0 ​$$</p></li></ol><p>由此，我们可以进一步讨论以概率1收敛.</p><p>$$\xi_n(\omega) \overset{a.s.}{\rightarrow} \xi (\omega)$$</p>]]></content>
      
      <categories>
          
          <category> Note </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理统计 </tag>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>接触向量自回归模型</title>
      <link href="/%E6%8E%A5%E8%A7%A6%E5%90%91%E9%87%8F%E8%87%AA%E5%9B%9E%E5%BD%92%E6%A8%A1%E5%9E%8B.html"/>
      <content type="html"><![CDATA[<p>VAR方法通过把系统中每一个内生变量,作为系统中<strong>所有内生变量的滞后值的函数</strong>来构造模型，从而回避了结构化模型的要求。Engle, Granger（1987）指出两个或多个非平稳时间序列的线性组合可能是平稳的。假如这样一种平稳的或的线性组合存在，这些非平稳（有单位根）时间序列之间被认为是具有协整关系的。这种平稳的线性组合被称为协整方程且可被解释为变量之间的长期均衡关系。VAR模型对于相互联系的时间序列变量系统是有效的预测模型，同时，向量自回归模型也被频繁地用于分析不同类型的随机误差项对系统变量的动态影响。如果变量之间不仅存在滞后影响，而不存在同期影响关系，则适合建立VAR模型，因为VAR模型实际上是把当期关系隐含到了随机扰动项之中。</p><h2>目录</h2><ul><li>定义</li><li>概述</li><li>平稳性检验</li><li>向量自回归模型（VAR）</li><li>E-G检验与JJ检验</li><li>误差修正模型</li><li>脉冲响应函数</li><li>方差分解</li></ul><h2>定义</h2><p>向量自回归模型（英语：Vector Autoregression model，简称VAR模型）是一种常用的计量经济模型，由C.Sims提出。它扩充了只能使用一个变量的自回归模型(AR(1))，使容纳大于1个变量，因此经常用在多变量时间序列模型的分析上。</p><p>VAR模型描述在同一样本期间内的 $n$ 个变量（内生变量）可以作为它们过去值的线性函数。</p><p>一个 $VAR§$ 模型可以写成为：</p><p>$$y_{t}=c+A_{1}y_{t-1}+A_{2}y_{t-2}+\cdots +A_{p}y_{t-p}+e_{t},$$</p><p>其中：$c$ 是 $n* 1$ 常数向量，$A_i$ 是 $n*n$ 矩阵。$e_t$ 是 $n*1$ 误差向量，满足：</p><ol><li>$E(e_t)=0$ ,误差项的均值为 $0$</li><li>$E(e_{t}e_{t}’)=\Omega $, 误差项的协方差矩阵为 $\Omega$.（一个 $n*n$ 正定矩阵）</li><li>$E(e_{t}e_{t-k}’)=0$, （对于所有不为 $0$ 的 $k$ 都满足）,误差项不存在自相关</li></ol><h3>结构向量自回归</h3><p>一个结构向量自回归（Structural VAR）模型可以写成为：</p><p>$$ B_{0}y_{t}=c_{0}+B_{1}y_{t-1}+B_{2}y_{t-2}+\cdots +B_{p}y_{t-p}+\epsilon _{t},$$</p><p>其中：$c_0$ 是 $n*1$ 常数向量，$B_i$ 是 $n*n$ 矩阵，$\epsilon_t$ 是 $n*1$ 误差向量。</p><h2>概述</h2><p>简单说VAR模型建立</p><p>第一步：不问序列如何均可建立初步的VAR模型（建立过程中数据可能前平稳序列，也可能是部分平稳，还可能是没协整关系的同阶不平稳序列，也可能是不同阶的不平稳序列，滞后阶数任意指定。所有序列一般视为内生向量)，</p><p>第二步：在建立的初步VAR后进行</p><ol><li>滞后阶数检验，以确定最终模型的滞后阶数</li><li>在滞后阶数确定后进行因果关系检验，以确定哪些序列为外生变量</li></ol><p>至此重新构建VAR模型（此时滞后阶数已定，内外生变量已定），再进行AR根图表分析，</p><ul><li>如单位根均小于1，VAR构建完成可建立误差修正模型、脉冲响应函数及方差分解。</li><li>如单位根有大于1的，考虑对原始序进行降阶处理（一阶单整序列处理方法：差分或取对数，二阶单整序列：理论上可以差分与取对数同时进行，但由于序列失去了经济含义，应放弃此处理，可考虑序列的趋势分解，如分解后仍然不能满足要求，可以罢工，不建立任何模型，休息或是打砸了电脑），处理过后对新的序列（包括最初的哪些平稳序列）不断重复第一步与第二步，直至满足稳定性为止</li></ul><p>第三步，建立最终的VAR后，可考虑SVAR模型。如果变量不仅存在滞后影响，还存在同期影响关系，则建立VAR模型不太合适，这种情况下需要进行结构分析。</p><h2>平稳性检验</h2><p>平稳性检验有3个作用：</p><ol><li>检验平稳性，若平稳，做格兰杰检验，非平稳，作协整检验。</li><li>协整检验中要用到每个序列的单整阶数。</li><li>判断时间序列的数据生成过程。</li></ol><p>VAR建模时<code>lag intervals for endogenous</code>要填滞后期，但是此时你并不能判断哪个滞后时最优的，因此要多次尝试，选择不同的滞后期，至 $AIC$ 或 $SC$ 最小时，所对应着的滞后为最优滞后，此时做出来的VAR模型才较为可靠。</p><p>协整检验前需要提前估计VAR模型，原因在于，协整检验是对滞后期和检验形式非常敏感的检验，首先需要确定最优滞后。由于VAR是无约束的，而协整是有约束的，因此协整检验的最优滞后一般为VAR的最优滞后减去1，确定了最优滞后后，再去诊断检验形式，最终才能做协整。</p><h2>E-G检验与JJ检验</h2><p>当检验的数据是非平稳（即存在单位根），并且各个序列是同阶单整（协整检验的前提），想进一步确定变量之间是否存在协整关系，可以进行协整检验，协整检验主要有EG两步法和JJ检验</p><ul><li>EG两步法是基于回归残差的检验，可以通过建立OLS模型检验其残差平稳性</li><li>JJ检验是基于回归系数的检验，前提是建立VAR模型（即模型符合ADL模式），确定最优滞后阶数</li></ul><h3>Granger因果检验</h3><p>协整说的是变量之间存在长期的稳定关系，这只是从数量上得到的结论，但不能确定谁是因，谁是果。而因果关系检验就是为了解决这个问题。故，如果存在协整关系，如果存在协整可进一步检测格兰杰因果检验，看看某一个变量的先前的变化对另一个变量是否有影响。</p><h3>步骤</h3><p>变量 $X$ 是否为变量 $Y$ 的Granger原因，是可以检验的。 检验 $X$ 是否为引起 $Y$ 变化的Granger原因的过程如下：</p><p>第一步：检验原假设“$H_0$：X不是引起Y变化的Granger原因”。首先，估计下列两个回归模型：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1524449564/2018_04_14-01.png" width="95%"><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1524449564/2018_04_14-02.png" width="95%"><p>第二步：将 $Y$ 与 $X$ 的位置交换，按同样的方法检验原假设“$H_0$：Y不是引起X变化的Granger原因”。</p><p>第三步：要得到“ $X$ 是 $Y$ 的Granger原因”的结论，必须同时拒绝原假设“$H_0$：X不是引起Y变化的Granger原因”和接受原假设“$H_0$：Y不是引起X变化的Granger原因”。</p><blockquote><p>格兰杰检验<strong>只能用于平稳序列</strong> 这是格兰杰检验的前提，而其因果关系并非我们通常理解的因与果的关系，而是说 $X$ 的前期变化能有效地解释 $Y$ 的变化，所以称其为“格兰杰原因”。</p></blockquote><h2>误差修正模型（VEC）</h2><p>VEC是有协整约束（即有长期稳定关系）的VAR模型。当变量之间存在协整关系时，可以建立ECM进一步考察短期关系</p><h2>参考文献</h2><ul><li>《高级计量经济学与Stata应用》.陈强</li><li><a href="https://wenku.baidu.com/view/e56480cb9ec3d5bbfd0a746b.html" target="_blank" rel="noopener">向量自回归模型与向量误差修正模型的理论及EVIEWS操作</a></li><li>[应用VAR模型时的15个注意点]<a href="http://bbs.pinggu.org/forum.php?mod=viewthread&amp;tid=3219921&amp;ctid=2272" target="_blank" rel="noopener">http://bbs.pinggu.org/forum.php?mod=viewthread&amp;tid=3219921&amp;ctid=2272</a></li><li><a href="https://blog.csdn.net/oxuzhenyi/article/details/77850516" target="_blank" rel="noopener">R语言建立VAR模型分析联合内生变量的动态关系</a></li></ul>]]></content>
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计量经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>HMM-隐马尔可夫模型</title>
      <link href="/HMM-%E9%9A%90%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E6%A8%A1%E5%9E%8B.html"/>
      <content type="html"><![CDATA[<h2>马尔科夫链</h2><p>在介绍$\text{HMM}$之前，我们先要了解什么是马尔科夫链。马尔科夫链是一个随机过程，简单来说就是当前时刻的状态与前 $p$ 个时刻的状态有关，即</p><p>$$P(z(t) | z(t-1),z(t-2),\cdots,z(1),z(0)) = P(z(t)|z(t-1),z(t-2),\cdots,z(t-p))$$</p><p>这种被称作 $p$ 阶马尔科夫链；为了简化这个过程以方便应用到模型中，我们有两个假设：</p><ul><li>在序列中，当前时刻状态只依赖于前一时刻的状态，也就是$P(z(t)|z(t-1), z(t-2),\cdots, z(1), z(0)) = P(z(t)|z(t-1))$。</li><li>状态转移的分布不随时间的改变而改变，也就是说任意时刻下的状态产生与时间无关，仅仅与前一状态有关。</li></ul><p>但是实际生活中，这种状态本身是很难观测到的，我们只能根据其他的特征来观测这些状态，同时状态之间的 <strong>转移矩阵</strong>也是很难直接获得的，这就需要隐马尔科夫模型了.</p><h2>HMM 形象的例子描述</h2><p>在引入$\text{HMM}$的公式化描述之前，为了更好的理解 HMM 模型，我们先用一个掷骰子的例子来形象的描述 HMM模型.</p><p>模型描述假设我手里有三个不同的骰子。</p><ul><li><p>第一个骰子是我们平常见的骰子（称这个骰子为D6），6个面，每个面$（1，2，3，4，5，6）$出现的概率是1/6。</p></li><li><p>第二个骰子是个四面体（称这个骰子为D4），每个面$（1，2，3，4）$出现的概率是1/4。</p></li><li><p>第三个骰子有八个面（称这个骰子为D8），每个面$（1，2，3，4，5，6，7，8）$出现的概率是1/8。</p></li></ul><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523585401/2018_04_10-4.png" width="95%" height="95%"><p>假设我们开始掷骰子，我们先从三个骰子里挑一个，挑到每一个骰子的概率都是1/3。然后我们掷骰子，得到一个数字，$1，2，3，4，5，6，7，8$中的一个。不停的重复上述过程，我们会得到一串数字，每个数字都是$1，2，3，4，5，6，7，8$中的一个。例如我们可能得到这么一串数字（掷骰子10次）：$1 6 3 5 2 7 3 5 2 4$</p><p>这串数字叫做<strong>可见状态链</strong>。但是在隐马尔可夫模型中，我们不仅仅有这么一串可见状态链，还有一串<strong>隐含状态链</strong>。在这个例子里，这串隐含状态链就是你用的骰子的序列。比如，隐含状态链有可能是：D6 D8 D8 D6 D4 D8 D6 D6 D4 D8</p><p>一般来说，$\text{HMM}$中说到的马尔可夫链其实是指隐含状态链，因为隐含状态（骰子）之间存在转换概率（transition probability）。<font color="blue">在我们这个例子里，D6的下一个状态是D4，D6，D8的概率都是1/3。</font>D4，D8的下一个状态是D4，D6，D8的转换概率也都一样是1/3。这样设定是为了最开始容易说清楚，但是我们其实是可以随意设定转换概率的。比如，我们可以这样定义，D6后面不能接D4，D6后面是D6的概率是0.9，是D8的概率是0.1。这样就是一个新的$\text{HMM}$。</p><p>同样的，尽管可见状态之间没有转换概率，但是隐含状态和可见状态之间有一个概率叫做<strong>输出概率</strong>（emission probability）。就我们的例子来说，六面骰（D6）产生1的输出概率是1/6。产生2，3，4，5，6的概率也都是1/6。我们同样可以对输出概率进行其他定义。比如，我有一个被赌场动过手脚的六面骰子，掷出来是1的概率更大，是1/2，掷出来是2，3，4，5，6的概率是1/10。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523584361/2018_04_10-1.png" width="95%" height="95%">隐马尔可夫示意图<p>其实对于 $\text{HMM}$ 来说，<font color="blue">如果</font>提前知道所有隐含状态之间的转换概率和所有隐含状态到所有可见状态之间的输出概率，做模拟是相当容易的。</p><p>但是应用$\text{HMM}$模型时候呢，往往是缺失了一部分信息的，有时候你知道骰子有几种，每种骰子是什么，但是不知道掷出来的骰子序列；有时候你只是看到了很多次掷骰子的结果，剩下的什么都不知道。如果应用算法去估计这些缺失的信息，就成了一个很重要的问题。</p><h2>HMM模型解决的三个问题</h2><p><font color="blue">1. 知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想知道每次掷出来的都是哪种骰子（隐含状态链）</font></p><blockquote><p>这个问题呢，在语音识别领域呢，叫做 <strong>解码问题</strong>。这个问题其实有两种解法，会给出两个不同的答案。每个答案都对，只不过这些答案的意义不一样。</p><ul><li>第一种解法求最大似然状态路径，说通俗点呢，就是我求一串骰子序列，这串骰子序列产生观测结果的概率最大。</li><li>第二种解法呢，就不是求一组骰子序列了，而是求每次掷出的骰子分别是某种骰子的概率。比如说我看到结果后，我可以求得第一次掷骰子是D4的概率是0.5，D6的概率是0.3，D8的概率是0.2</li></ul></blockquote><p><font color="blue">2. 还是知道骰子有几种（隐含状态数量），每种骰子是什么（转换概率），根据掷骰子掷出的结果（可见状态链），我想知道掷出这个结果的概率</font></p><p>看似这个问题意义不大，因为你掷出来的结果很多时候都对应了一个比较大的概率。问这个问题的目的呢，其实是检测观察到的结果和已知的模型是否吻合。如果很多次结果都对应了比较小的概率，那么就说明我们已知的模型很有可能是错的，有人偷偷把我们的骰子給换了</p><p><font color="blue">3. <strong>知道骰子有几种（隐含状态数量），不知道每种骰子是什么（转换概率），观测到很多次掷骰子的结果（可见状态链），我想反推出每种骰子是什么(转换概率)</strong></font></p><blockquote><p>这个问题很重要，因为这是最常见的情况。很多时候我们只有可见结果，不知道$\text{HMM}$模型里的参数，我们需要从可见结果估计出这些参数，这是建模的一个必要步骤</p></blockquote><p>在实际应用中，比如中文分词，我们更多的是利用<strong>第三个问题</strong>去建模( 当然，如果利用工具的话，你拿到手的时候这部分的参数都是已经训练好了的 )，然后用<strong>第一个问题</strong>的解码去求隐含状态序列（这也是我们的目标，比如分词、词性标注等）.</p><h3>破解骰子序列</h3><p>举例来说，我知道我有三个骰子，六面骰，四面骰，八面骰。我也知道我掷了十次的结果<code>1 6 3 5 2 7 3 5 2 4</code>，我不知道每次用了那种骰子，我想知道最有可能的骰子序列</p><p>其实最简单而暴力的方法就是穷举所有可能的骰子序列，然后依照第零个问题的解法把每个序列对应的概率算出来。然后我们从里面把对应最大概率的序列挑出来就行了。如果马尔可夫链不长，当然可行。如果长的话，穷举的数量太大，就很难完成了。</p><p>另外一种很有名的算法叫做 Viterbi algorithm.</p><h2>HMM 的几个要素</h2><p>经过上面形象化的例子描述，读者应该对隐马尔科夫模型有了大致的了解，下面通过引入数学化描述，来正式介绍 $\text{HMM}$.读者在阅读 $\text{HMM}$ 数学化描述时，可以对照前面掷骰子的问题来理解.</p><ul><li><font color="blue">StatusSet : </font>状态值集合，常用 $S=\{S_1,S_2,\cdots ,S_Q\}$ 来表示系统的隐状态集合，其中 $Q$ 为隐状态数。用 $q_t=S_i$ 表示系统在时刻 $t$ 处于隐状态 $S_i$，隐状态序列为$Q=\{q_1,q_2,\cdots ,q_t\}$</li></ul><p>例如上面的三个不同的骰子，这些状态之间满足马尔科夫性质，是马尔科夫模型中实际所隐含的状态，这些状态通常无法直接观察得到.</p><ul><li><font color="blue">ObservedSet :</font>观察值集合，观测序列记为 $O = (o_1,o_2,\cdots,o_T)$，其中 $T$ 为观测序列的长度； $O_t$为时刻$t$  的观测随机变量，可以是一个数值或向量.</li></ul><blockquote><p>例如上面的 $1,2,3,4,5,\cdots $ 等值，在模型中与隐含状态相关联，可通过直接观测得到.</p></blockquote><ul><li><font color="blue">TransProbMatrix :</font>转移概率矩阵，状态转移的概率分布可表示为 $A=\{a_{ij}\}$，其中 $a_{ij} = P(q_{t+1} = S_j | q_t = S_i), 1 \leq i,j \leq Q$，且满足$a_{ij} \geq 0,\sum_{j=1}^Q a_{ij} = 1$ ，表示时刻 $t$ 从状态 $a_i$ 状态转移到时刻 $t+1$ 状态 $a_j$ 的概率.</li></ul><blockquote><p>例如上面的取不同骰子的概率，描述了 $\text{HMM}$ 模型中各个状态之间的转移概率，</p></blockquote><ul><li><font color="blue">EmitProbMatrix :发射概率矩阵，假设观测变量的样本空间为$V$ ，在状态 $S_i$ 时输出观测变量的概率分布可表示为:$B = \{ b_i(v),1 \leq i \leq Q,v \in V \}$ ，其中$b_i(v) = f\{ O_t = v | q_t = S_i \}$ 。</font></li></ul><blockquote><p>例如上面的每个骰子取不同值的概率，令 $N$代表隐含状态数目， $M$代表可观测状态数目，则 $B_{ij} = P(O_i | S_j),1 \leq i \leq M,1 \leq j \leq N$ 表示在 $t$ 时刻、隐含状态是$S_j$  条件下，观察状态为$O_i$  的概率.</p></blockquote><ul><li><font color="blue">InitStatus :</font>初始状态分布，一般用 $\pi $ 来表示，即 $\pi = \{ \pi_i,1 \leq i \leq Q \}$，其中 $\pi_i = P\{ q_1 = S_i \}$例如上面我们假设投掷的是第一枚骰子，表示隐含状态在初始时刻 $t=1$ 的概率矩阵.</li></ul><p>从定义可知，隐马尔科夫模型作了<strong>两个基本假设:</strong></p><ul><li><p><strong>齐次马尔科夫假设</strong>即假设隐藏的马尔科夫链在任意时刻  的状态只依赖于其前一时刻的状态，与其他时刻的状态及观测无关，也与时刻  无关.$$P(q_t | q_{t-1},o_{t-1},\cdots,q_1,o_1) = P(q_t | q_{t-1}),t = 1,2,\cdots,T$$</p></li><li><p><strong>观测独立性假设</strong>即假设任意时刻的观测只依赖于该时刻的马尔科夫链的状态，与其他观测及状态无关.$$P(o_t | q_T,o_T,q_{T-1},o_{T-1},\cdots,q_{t+1},o_{t+1},q_t,q_{t-1},o_{t-1},\cdots,q_1,o_1) = P(o_t | q_t)$$</p></li></ul><h2>观测序列的生成过程</h2><p>上面的例子中我们也大致讲了序列如何生成的，这里我们用数学描述提炼一下：</p><p><strong>输入</strong>: 隐马尔科夫模型 $\lambda=\{A,B,\pi \}$，观测序列长度 $T$;</p><p><strong>输出</strong>: 观测序列 $O = (o_1,o_2,\cdots,o_T)$</p><ul><li>按照初始状态分布 $\pi$ 产生状态 $q_1$</li><li>令 $t=1$</li><li>按照状态 $q_t$ 的观察概率分布 $b_{q_t}(v)$ 生成 $o_t$</li><li>按照状态 $q_t$ 的状态转移概率分布 $\{q_{ij}\}$ 产生状态 $q_{t+1},q_{t+1} \in \{ S_1,S_2,\cdots,S_Q \}$</li><li>令 $t=t+1$ ；如果 $t&lt;T$，转步 3；否则，终止.</li></ul><h2>$\text{HMM}$ 的基本问题</h2><p>隐马尔科夫模型在实际中运用，必须解决下面三个基本问题 :</p><p>给定观察序列 $O = (o_1,o_2,\cdots,o_T)$ 和模型 $\lambda=\{A,B,\pi \}$，如何有效地计算观测值序列的输出概率?</p><p><font color="blue">给定观察值序列和输出该观察值序列的隐马尔科夫模型 ，如何有效确定与之对应的最佳状态序列?</font>即估计出模型产出观察值序列最有可能经过的路径.</p><p>对于初始模型和给定用于训练的观察值序列 $O = (o_1,o_2,\cdots,o_T)$，如何调整模型参数$\lambda=\{A,B,\pi \}$ ，使得输出概率最大 $P(O|\lambda)$ ？</p><p>Note:对应到上面掷骰子的例子中所说的三个问题</p><h2>基本算法</h2><h3>直接计算</h3><p>给定模型 $\lambda=\{A,B,\pi \}$ 和观测序列 $O = (o_1,o_2,\cdots,o_T)$,计算观测序列 $O$ 出现的概率 $P(O|\lambda)$ . 最直接的方法就是按概率公式直接算：通过列举所有可能的长度为 $T$ 的状态序列 $Q={Q_1,Q_2,\cdots Q_t}$，求各个状态序列 $Q$ 与观测序列 $O = (o_1,o_2,\cdots,o_T)$ 的联合概率$P(O,Q|\lambda)$ ，然后对所有可能的状态序列求和，得到 $P(O|\lambda)$.</p><p>状态序列 $Q={Q_1,Q_2,\cdots Q_t}$ 的概率是$$P(Q|\lambda) = \pi_{q_1} a_{q_1 q_2} a_{q_2 q_3} \cdots a_{q_{T-1} q_{T}}$$</p><p>对固定的状态序列 $Q={Q_1,Q_2,\cdots Q_t}$, 观测序列 $O = (o_1,o_2,\cdots,o_T)$ 的概率是$$P(O|Q,\lambda) = b_{q_1}(o_1) b_{q_2}(o_2) \cdots b_{q_T}(o_T)$$</p><p>则 $O,Q$ 同时出现的联合概率为:$$P(O,Q|\lambda) = P(O|Q,\lambda) P(Q|\lambda) \\ = \pi_{q_1} b_{q_1}(o_1) a_{q_1 q_2} b_{q_2}(o_2) \cdots a_{q_{T-1} q_T} b_{q_T}(o_T) $$</p><p>然后，对所有可能的状态序列 $Q$ 求和，得到观测序列 $O$ 的概率 $P(O|\lambda)$ ，即</p><p>$$P(O|\lambda) = \sum_{Q} P(O|Q,\lambda) P(Q|\lambda) \\ = \sum_{q_1,q_2,\cdots,q_T} \pi_{q_1} b_{q_1}(o_1) a_{q_1 q_2} b_{q_2}(o_2) \cdots a_{q_{T-1} q_T} b_{q_T}(o_T) $$</p><p>但是，该式计算量很大，是 $O(TN^T)$ 阶的，这种算法不可行.</p><h3>前向-后向算法</h3><p>解决问题 1 的最常用、最有效的方法就是 <em>Baum</em> 等人提出的前向-后向算法。</p><p>该算法定义<strong>前向概率变量</strong>$$\alpha_t(i) : \alpha_t(i) = P(o_1,o_2,\cdots,o_t,q_t = S_i | \lambda)$$$\alpha(t_i)$ 可由下面递推公式计算得到 :</p><p>初始化:$\alpha_1(i) = \pi_i b_i(o_1), 1 \leq i \leq Q$</p><p>递推:$$\alpha_{t+1}(j) = [ \sum_{i=1}^Q \alpha_t(i) a_{ij} ] b_j(o_{t+1}) , 1 \leq j \leq Q,1 \leq t \leq T-1$$</p><p>结束:$P(O | \lambda) = \sum_{i=1}^Q \alpha_T(i)$</p><p>其中$\sum_{i=1}^Q \alpha_T(i)$  是把最后 $T$ 时刻的所有可能的状态下观察到 $O$ 的概率求和；因为到最后 $T$ 时刻时，每一条状态路径都能观察到观测序列 $O$，且有一个生成概率，即$\alpha_T(i)$，于是将  $T$时刻所有可能的状态对应的前向概率变量累加，就是将所有可能观察到观测序列的状态序列的概率相加，即 $P(O|\lambda)$上述前向算法的递推关系如图所示:</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523584358/2018_04_10-2.png" width="95%" height="95%"><p>与前向算法相似，后向算法是从后向前递推计算输出概率的方法。定义后向概率变量$$\beta_t(i) : \beta_t(i) = P(o_{t+1},o_t,\cdots,o_T | q_t = S_i,\lambda)$$</p><p>则 $\beta_t(i)$ 可由下面递推公式计算，后向算法的递推关系图如下所示:</p><p>初始化 : $\beta_T(i) = 1, 1 \leq i \leq Q$</p><p>递推公式:$$\beta_t(i) = \sum_{j=1}^Q a_{ij} b_j(o_{t+1}) \beta_{t+1}(j), 1 \leq i \leq Q,t = T-1,\cdots,1$$</p><p>结束 : $P(O | \lambda) = \sum_{i=1}^Q \beta_1(i) \pi_i = \beta_0(1)$</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1523584358/2018_04_10-3.png" width="95%" height="95%"><p>根据前向变量和后向变量的定义，显然下式成立 ：</p><p>$$P(O | \lambda) = \sum_{i=1}^Q \sum_{j=1}^Q \alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j),1 \leq t \leq T-1$$</p><p><font color="blue">如何来理解该式子？</font></p><p>$\alpha_t(i) a_{ij} b_j(o_{t+1}) \beta_{t+1}(j)$表示 $t$ 时刻为状态 $q_i$ 的前向概率（根据前向概率的定义，已经计算了 $t$ 时刻状态为 $q_i$ 时观测到 $o_t$ 的概率）， $t$时刻状态 $q_i$ 转移到 $t+1$ 时刻的状态 $q_j$，在 $t+1$ 时刻状态 $q_j$ 下观测到$o_{t+1}$ 的概率，最后乘以 $t+1$ 时刻状态为  $q_j$的后向概率（因为按后向概率的定义不包含当前状态的观察概率 $b_j(o_{t+1})$ 的计算）；分别求所有可能的状态 $q_i,q_j$ 的组合，就是$P(O|\lambda)$ .</p><p>利用该算法减少计算量的原因在于每一次计算直接引用前一个时刻的计算结果，避免重复计算.这样，利用前向概率计算 $P(O|\lambda)$  的计算量是 $O(N^2T)$ 阶的，而不是直接计算的 $O(TN^T)$ 阶.</p><h3>监督学习方法</h3><p>对于 $\text{HMM}$ 参数估计问题，可按训练数据的特点来分是有监督学习还是无监督学习，如果是有监督学习的话，可直接通过对训练样本做一些统计即可得到 $\text{HMM}$ 的参数估计；在中文自然语言处理中，许多标注问题就是这么做的.</p><p>假设已给训练数据包含 $K$ 个长度相同的观察序列和对应的状态序列 ${(O_1,Q_1),(O_2,Q_2),\cdots,(O_K,Q_K)}$，那么我们可以直接利用极大似然估计法来估计隐马尔科夫模型的参数，具体如下:</p><p>转移概率 $a_{ij}$ 的估计设样本中时刻 $t$ 处于状态 $q_i$，时刻 $t+1$ 时刻由状态 $q_i$ 转移到了 $q_j$，此种情况出现的频数为 $A_{ij}$ ，那么转移概率$a_{ij}$ 的估计值为</p><p>$$\hat{a}_{ij} = \frac{ A_{ij} }{\sum_{j=1}^Q A_{ij} },i = \{S_1,S_2,\cdots,S_Q\};j = \{S_1,S_2,\cdots,S_Q\}$$</p><p>即统计由状态 $q_i$ 转移到状态 $q_j$ 占状态 $q_i$ 转移出去的比例.</p><p>观测概率 $b_{q_j}(v)$ 的估计设样本中状态为$q_j$  并观测为 $o_v$ 的频数是 $B_{jv}$，那么状态为 $q_j$ 观测为 $o_v$ 的概率 $b_{q_j}(v)$ 的估计是:</p><p>$$\hat{b}_{q_j}(v) = \frac{B_{jv} }{\sum_{v=1}^M B_{jv} }$$</p><p>其中，$j = 1,2,\cdots,T;\quad v = 1,2,\cdots,M$.</p><h3>Baum-Welch 算法</h3><p><font color="blue">对于无监督学习的 HMM 参数估计问题，可以使用 Baum-Welch算法.</font></p><p>首先定义两个变量$r_t(i)$  和$\xi_t(i,j)$ ，给定观察序列 $O(e_1,e_2,\cdots ,e_T)$ 和模型参数 $\lambda=\{A,B,\pi \}$;</p><ul><li><p>$r_t(i)$为系统在时刻 $t$ 系统处在状态 $S_i$ 的概率，即$$r_t(i) = P(q_t = S_i | O,\lambda)$$</p></li><li><p>$\xi_t(i,j)$为 $t$ 时刻状态为 $S_j$ ，到 $t+1$ 时刻系统状态转为 $S_j$ 的概率，即$$\xi_t(i,j) = P(q_t = S_i,q_{t+1} = S_j | O,\lambda)$$</p></li></ul><p>根据前向-后向算法中 $\alpha_t(i)$ 和 $\beta_t(i)$ 定义有:</p><p>$$r_t(i) = \frac{\alpha_t(i) \beta_t(i)}{\sum_{j=1}^Q \alpha_t(j) \beta_t(j)},1 \leq i \leq Q \\ \xi_t(i,j) = \frac{\alpha_t(i) a_{ij} b_j(e_{t+1}) \beta_{t+1}(j)}{P(O|\lambda)} \\ \qquad =\frac{\alpha_t(i) a_{ij} b_j(e_{t+1}) \beta_{t+1}(j)}{\sum_{m=1}^Q \sum_{n=1}^Q \alpha_t(m) a_{mn} b_n(e_{t+1}) \beta_{t+1}(n)} ,1 \leq i,j \leq Q$$</p><p>则对于观察序列 $O(e_1,e_2,\cdots ,e_T)$ 而言，系统所处于状态 $S_j$ 的总次数（期望值）为 $\sum_{i=1}^Q r_t(i)$ ；同样，系统从状态 $S_i$ 转移到 $S_j$ 的总次数为 $\sum_{i=1}^Q \xi_t(i,j)$ .假设给定训练数据只包含 $K$ 个长度为 $T$ 的观测序列 $\{O_1,O_2,\cdots,O_K \}$ 而没有对应的状态序列，目标是学习隐马尔科夫模型 $\lambda=\{A,B,\pi \}$ 的参数.我们将观测序列数据看作观测数据 $O$，状态序列数据看作不可观测的隐数据 $I$，那么隐马尔科夫模型事实上是一个含有隐变量的概率模型</p><p>$$P(O|\lambda) = \sum_{I} P(O|I,\lambda) P(I|\lambda)$$</p><p>它的参数学习可以用<font color="blue">EM算法</font>来实现.</p><ol><li><p>确定完全数据的对数似然函数所有观测数据写成$O = (o_1,o_2,\cdots,o_T)$ ，所有隐数据写成 $I = (i_1,i_2,\cdots,i_T)$，完全数据是 $(O,I) = (o_1,o_2,\cdots,o_T,i_1,i_2,\cdots,i_T)$，完全数据的对数似然函数是 $\log(P(O,I|\lambda))$</p></li><li><p>EM 算法的 E 步: 求 $Q$ 函数 $Q(\lambda,\overline{\lambda})$$$Q(\lambda,\overline{\lambda}) = \sum_{I} \log \left( P(O,I|\lambda) P(O,I|\overline{\lambda}) \right)$$其中，$\overline{\lambda}$ 是隐马尔科夫模型参数的当前估计值，$\lambda$ 是要极大化的隐马尔科夫模型参数.$$P(O,I|\lambda) = \pi_{i_1} b_{i_1}(o_1) a_{i_1 i_2} b_{i_2}(o_2) \cdots a_{i_{T-1} i_T} b_{i_T}(o_T)$$于是函数 $Q(\lambda,\overline{\lambda})$ 可以写成:$$Q(\lambda,\overline{\lambda}) = \sum_{I} ( \log \pi_{i_1} ) P(O,I|\overline{\lambda}) \\ \sum_{I} ( \sum_{t=1}^{T-1} \log a_{i_t i_{t+1}} ) P(O,I|\overline{\lambda}) + \sum_{I} ( \sum_{t=1}^T \log b_{i_t}(o_t) ) P(O,I|\overline{\lambda})$$式中求和都是对所有训练数据的序列总长度 $T$ 进行的.</p></li></ol><blockquote><p>这其中的 $Q$ 函数，是直接用的《统计学习方法》中的概念，这本书中的 $Q$ 函数比较难懂.</p></blockquote><ol start="3"><li>EM 算法的 M 步: 极大化 $Q$ 函数 $Q(\lambda,\overline{\lambda})$ 求模型参数 $A,B,\pi$由于要极大化的参数在 $Q(\lambda,\overline{\lambda})$ 中单独地出现在 3 个项中，所以只需对各项分别极大化.</li></ol><p>(1). 第一项可以写成:$$\sum_{I} ( \log \pi_{i_1} ) P(O,I|\overline{\lambda}) = \sum_{i=1}^N (\log \pi_i) P(O,i_1 = i | \overline{\lambda})$$注意到 $\pi_i$ 满足约束条件$\sum_{}^N \pi_i = 1$ ，利用拉格朗日乘子法，写出拉格朗日函数:$$L(\pi_i,\gamma) = \sum_{i=1}^N (\log \pi_i) P(O,i_1 = i | \overline{\lambda}) + \gamma ( \sum_{i=1}^N \pi_i - 1 )$$对其求偏导数并令结果为零:$$\frac{\partial L}{\partial \pi_i} = \frac{1}{\pi_i} P(O,i_1 = i | \overline{\lambda}) + \gamma = 0 \\ P(O,i_1 = i | \overline{\lambda}) + \gamma \pi_i = 0 \\ \gamma = -P(O|\overline{\lambda}) \\ \pi_i = \frac{P(O,i_1 = i | \overline{\lambda})}{P(O|\overline{\lambda})}$$</p><p>(2). 第 2 项可以写成:$$\sum_{I} ( \sum_{t=1}^{T-1} \log a_{i_t i_{t+1}} ) P(O,I|\overline{\lambda}) \\ = \sum_{i=1}^N \sum_{j=1}^N \sum_{t=1}^{T-1} (\log a_{ij}) P(O,i_t = i,i_{t+1} = j|\overline{\lambda})$$</p><p>注意到约束条件 $\sum_{j=1}^N a_{ij} = 1$，应用拉格朗日乘子法得:$$L(a_{ij},\gamma) = \sum_{i=1}^N \sum_{j=1}^N \sum_{t=1}^{T-1} (\log a_{ij}) P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) + \gamma ( \sum_{j=1}^N a_{ij} - 1 )$$求其对 $\alpha_{ij}$ 的偏导，并令其等于零:$$\frac{\partial L}{\partial a_{ij}} = \sum_{t=1}^{T-1} ( \frac{1}{a_{ij}} P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) ) + \gamma = 0 \\ \sum_{t=1}^{T-1} P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) + \sum_{t=1}^{T-1} a_{ij} \gamma = 0$$</p><p>对 $j$ 求和:$$\sum_{j=1}^N \sum_{t=1}^{T-1} P(O,i_t = i,i_{t+1} = j|\overline{\lambda}) + \sum_{j=1}^N \sum_{t=1}^{T-1} a_{ij} \gamma = 0 \\ \sum_{t=1}^{T-1} P(O,i_t = i|\overline{\lambda}) + \sum_{t=1}^{T-1} \gamma = 0 \\ a_{ij} = \frac{\sum_{t=1}^{T-1} P(O,i_t = i,i_{t+1} = j | \overline{\lambda})}{\sum_{t=1}^{T-1} P(O,i_t = i|\overline{\lambda})}$$</p><p>(3). 第 3 项与第 2 项的计算类似:$$\sum_{I} \left( \sum_{t=1}^T \log b_{i_t}(o_t) \right) P(O,I|\overline{\lambda}) = \sum_{j=1}^N \sum_{t=1}^T \log b_j(o_t) P(O,i_t = j | \overline{\lambda})$$同样用拉格朗日乘子法，约束条件是 $\sum_{k=1}^M b_j(k) = 1$ .注意，只有在 $o_t=v_k$ 时 $b_j(o_t)$ 对 $b_j(k)$ 的偏导数才不为 $0$，以 $I(o_t=v_k)$ 表示，求得$$b_j(k) = \frac{\sum_{t=1}^T P(O,i_t = j | \overline{\lambda}) I(o_t = v_k)}{\sum_{t=1}^T P(O,i_t = j | \overline{\lambda})}$$</p><h4>Note</h4><p>则上面的概率公式整理一下，并用 $\gamma_t(i),\xi_t(i,j)$ 表示为:$$ a_{ij} = \frac{\sum_{t=1}^{T-1} \xi_t(i,j)}{\sum_{t=1}^{T-1} \gamma_t(i)} \\ b_j(k) = \frac{\sum_{t=1,o_t = v_k}^T \gamma_t(j)}{\sum_{t=1}^T \gamma_t(j)} \\ \pi_i = \gamma_1(i)$$</p><p>于是整理 Baum-Welech 完整算法描述如下:</p><p>输入：观测数据  $O=(o_1,o_2,\cdots,o_T)$输出：隐马尔科夫模型参数.</p><ul><li>初始化对 $n=0$，选取 $a_{ij}^{(0)},b_j(k)^{(0)},\pi_i^{(0)}$，得到模型 $\lambda^{(0)} = (A^{(0)},B^{(0)},\pi^{(0)})$</li><li>递推，对 $n = 1,2,\cdots$$$a_{ij}^{(n+1)} = \frac{\sum_{t=1}^{T-1} \xi_t(i,j)}{\sum_{t=1}^{T-1} \gamma_t(i)} \\ b_j(k)^{(n+1)} = \frac{\sum_{t=1,o_t = v_k}^T \gamma_t(j)}{\sum_{t=1}^T \gamma_t(j)} \\ \pi_i^{(n+1)} = \gamma_1(i) $$右端各值按观测 $O = (o_1,o_2,\cdots,o_T)$ 和模型 $\lambda^{(n)} = (A^{(n)},B^{(n)},\pi^{(n)})$ 计算.</li><li>终止，得到模型参数 $\lambda^{(n+1)} = (A^{(n+1)},B^{(n+1)},\pi^{(n+1)})$</li></ul><h2>R中的HMM</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">install.packages(<span class="string">"HMM"</span>)</span><br><span class="line"><span class="keyword">library</span>(HMM)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#后向算法求观察值出现的概率</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>),c(<span class="string">"L"</span>,<span class="string">"R"</span>),transProbs = matrix(c(<span class="number">0.8</span>,<span class="number">0.2</span>,<span class="number">0.2</span>,<span class="number">0.8</span>),<span class="number">2</span>),emissionProbs = matrix(c(<span class="number">0.6</span>,<span class="number">0.4</span>,<span class="number">0.4</span>,<span class="number">0.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># 序列观察值</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line">logBackwardProbabilities = backward(hmm,observations)</span><br><span class="line">print(exp(logBackwardProbabilities))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过前向算法求观察值出现的概率</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>), c(<span class="string">"L"</span>,<span class="string">"R"</span>), transProbs=matrix(c(<span class="number">.8</span>,<span class="number">.2</span>,<span class="number">.2</span>,<span class="number">.8</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observations</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line"><span class="comment"># Calculate forward probablities</span></span><br><span class="line">logForwardProbabilities = forward(hmm,observations)</span><br><span class="line">print(exp(logForwardProbabilities))</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 通过Baum-Welch算法训练 hmm参数</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>),c(<span class="string">"L"</span>,<span class="string">"R"</span>))</span><br><span class="line">transProbs = matrix(c(<span class="number">0.9</span>,<span class="number">0.1</span>,<span class="number">0.1</span>,<span class="number">0.9</span>),<span class="number">2</span>)</span><br><span class="line">emissionProbs = matrix(c(<span class="number">0.5</span>,<span class="number">0.51</span>,<span class="number">0.5</span>,<span class="number">0.49</span>),<span class="number">2</span>)</span><br><span class="line">print(hmm)</span><br><span class="line">a = sample(c(rep(<span class="string">"L"</span>,<span class="number">100</span>),rep(<span class="string">"R"</span>,<span class="number">300</span>)))</span><br><span class="line">b = sample(c(rep(<span class="string">"L"</span>,<span class="number">300</span>),rep(<span class="string">"R"</span>,<span class="number">100</span>)))</span><br><span class="line">observation = c(a,b)</span><br><span class="line"><span class="comment"># Baum-Welch</span></span><br><span class="line">bw = baumWelch(hmm,observation,<span class="number">10</span>)</span><br><span class="line">print(bw$hmm)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 观察序列最可能出现的概率</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>), c(<span class="string">"L"</span>,<span class="string">"R"</span>), transProbs=matrix(c(<span class="number">.8</span>,<span class="number">.2</span>,<span class="number">.2</span>,<span class="number">.8</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observations</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line"><span class="comment"># Calculate posterior probablities of the states</span></span><br><span class="line">posterior = posterior(hmm,observations)</span><br><span class="line">print(posterior)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Viterbi算法解码，求最可能的隐状态序列</span></span><br><span class="line"><span class="comment"># Initialise HMM</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>), c(<span class="string">"L"</span>,<span class="string">"R"</span>), transProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.6</span>,<span class="number">.4</span>,<span class="number">.4</span>,<span class="number">.6</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observations</span></span><br><span class="line">observations = c(<span class="string">"L"</span>,<span class="string">"L"</span>,<span class="string">"R"</span>,<span class="string">"R"</span>)</span><br><span class="line"><span class="comment"># Calculate Viterbi path</span></span><br><span class="line">viterbi = viterbi(hmm,observations)</span><br><span class="line">print(viterbi)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 训练hmm参数</span></span><br><span class="line"><span class="comment"># Initial HMM</span></span><br><span class="line">hmm = initHMM(c(<span class="string">"A"</span>,<span class="string">"B"</span>),c(<span class="string">"L"</span>,<span class="string">"R"</span>),</span><br><span class="line">              transProbs=matrix(c(<span class="number">.9</span>,<span class="number">.1</span>,<span class="number">.1</span>,<span class="number">.9</span>),<span class="number">2</span>),</span><br><span class="line">              emissionProbs=matrix(c(<span class="number">.5</span>,<span class="number">.51</span>,<span class="number">.5</span>,<span class="number">.49</span>),<span class="number">2</span>))</span><br><span class="line">print(hmm)</span><br><span class="line"><span class="comment"># Sequence of observation</span></span><br><span class="line">a = sample(c(rep(<span class="string">"L"</span>,<span class="number">100</span>),rep(<span class="string">"R"</span>,<span class="number">300</span>)))</span><br><span class="line">b = sample(c(rep(<span class="string">"L"</span>,<span class="number">300</span>),rep(<span class="string">"R"</span>,<span class="number">100</span>)))</span><br><span class="line">observation = c(a,b)</span><br><span class="line"><span class="comment"># Viterbi-training</span></span><br><span class="line">vt = viterbiTraining(hmm,observation,<span class="number">10</span>)</span><br><span class="line">print(vt$hmm)</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> 数理统计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>概率论（离散空间）杂谈</title>
      <link href="/%E6%A6%82%E7%8E%87%E8%AE%BA%E6%9D%82%E8%B0%88%E7%AF%87%E4%B8%80.html"/>
      <content type="html"><![CDATA[<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521877258/2018_03_09_01.jpg" height="90%"><p>关于概率论与统计学的不同，相信学过统计学的同学，看过上图后一定能秒懂。</p><blockquote><p>统计学：根据手中信息，猜猜桶里有啥？</p></blockquote><blockquote><p>概率论：根据桶中信息，猜猜手里有啥？</p></blockquote><h2>概率空间</h2><p>所有基本事件组成的集合，其中的每一个基本事件又称做样本点，样本空间用$\boldsymbol {\Omega }$表示，样本点用$\omega$表示,$\Omega=\{\omega \}$</p><ol><li>$\mathcal{\Omega}$－Sample space 样本空间，试验中所有可能结果的集合。（注：每个结果需要互斥，所有可能结果必须被穷举）</li><li>$\mathcal{F}$－Set of events 事件集合，是$\Omega$的一些子集构成的集合，并且它需要满足以下三点特性（也就是必须是$\sigma$－field）：</li></ol><ul><li>$\mathcal{\Phi \in F}$（也就是必须包含不可能事件）</li><li>如果$E\in F,E^C \in \mathcal{F}$。</li><li>如果$E_1,E_2,\cdots ,E_i \in \mathcal{F}$,那么 $U_{i=1}^{\infty}E_i \in \mathcal{F}$</li></ul><ol start="3"><li>$\mathcal{P}$－Probability measure 概率测度（或概率），描述一次随机试验中被包含在 $\mathcal{F}$中的所有事件的可能性。并且它「碰巧」也需要满足三点特性：</li></ol><ul><li>$0\leq P(E_i)\leq 1$（实际限制了总测度为1）</li><li>$P(\Omega)=1$（包含样本空间并且概率为1）</li><li>如果$E_1,E_2,\cdots ,E_i$是互斥事件,那么$P\{U_{i=1}^{\infty} E_i \}=\sum_{i=1}^{\infty} E_i$</li></ul><h2>谈斯特林公式</h2><p>$$n! \sim \sqrt{2\pi }n^{n+\frac{1}{2} }e^{-n} $$</p><p>证明见附录，这是概率论中非常重要的理论，基于此可以得到一些精确的数值估计</p><h3>Stirling与概率问题</h3><p>什么是一个事件（event）的概率？这是概率论最基本也是争议最多的问题【例】：抛一枚硬币，出现正面的概率？</p><p>这是什么意思，通常认为，将这枚硬币独立的抛「很多次」，那么正面出现的次数「大约」占一半。这是在随机事件中很确定的事。所谓的「平均律」(The law of average)或「大数定律」(The law of large numbers)隐约也是在解释这个说法。现在我们从常识出发，来考虑数学表达。</p><p>【问题1】抛 $2n$ 次硬币，正面恰好出现 $n$ 次的概率又多大？根据组合学，抛 $2n$ 次硬币，共有 $2^{2n}$ 种可能，假设每一种发生的结果机会均等，那么 $2n$ 次中有 $n$ 次正面的结果共有$C_{n}^{2n}$种，故得概率为</p><p>$p_{2n} = \frac{C_n^{2n}}{2^{2n}} = \frac{(2n)!}{2^{2n}\cdot n!\cdot n!} \qquad (1)$</p><p>更有趣的是，当$n$趋向$\infty$时，$p_{2n}$会趋近多少？上述常识性的解释似乎是说， $\lim_{n \to \infty } p_{2n} = 1$，这成立吗？这需要对$(1)$式作精确的估计，于是引出下面的问题</p><p>【问题2】当$n$很大时，如何估算？明确地说：当$n$趋向$\infty$时，$n!$的渐进相等式（Asymptotically equal formula）是什么？</p><p>即要找一个${a_n}$使得</p><p>$$\lim_{n \to \infty} \frac{n!}{a_n} = 1,\quad n! \sim a_n$$</p><p>我们希望找到这样的${a_n}$，然后带入$(1)$式中计算极限值 $\lim_{n \to \infty} p_{2n}$，就可以检验上述常识性的说法是否正确。</p><p>$n!$的渐进相等式（Asymptotically equal formula）存在吗？如何找？这时候就需要Stirling公式出场了。</p><h3>初步否定常识性的概率</h3><p>现在我们要利用Stirling 公式来探讨概率之谜(the enigma of probability)。</p><p>首先观察到一个显然的</p><p>【补题】设$\{a_n\},\{b_n\},\{c_n\}$及$\{d_n\}$皆为正项数列且  $\lim_{n \to \infty} \frac{a_n}{b_n} = l$。若 $a_n \sim c_n$且$b_n \sim d_n$，则  $\lim_{n \to \infty} \frac{c_n}{d_n} = l$。接着计算「丢$2n$次硬币，恰好出现$n$次正面的机率$p_{2 n}$在  $n \to \infty$的极限」</p><p>$$\lim_{n \to \infty}p_{2n} = \lim_{n \to \infty} \frac{(2n)!}{2^{2n}n!n!} \\=\lim_{n \to \infty} \frac{\sqrt{2\pi 2n}(2n)^{2n}e^{-2n}}{2^{2n}\cdot 2\pi \cdot  n\cdot n^{2n}\cdot e^{-2n}} \\=\lim_{n \to \infty}\frac{1}{\sqrt{\pi n}}=0$$</p><p>【定理3】  $ \lim_{n \rightarrow \infty} p_{2n} = 0$。因此，当 $n \to \infty$时，$p_{2n}$不但不如原先预计的趋近于1（即必然发生），反而是趋近于0（即不可能发生）。这警告我们，概率的解释与经验有很大出入。</p><p>【常识性的说法】「丢很多次硬币正面大约占一半。」如果将「大约占一半」， 解释为「恰好是一半」的说法，点估计显然是不对的。如何修正呢？自然想到的是改用区间估计的说法。</p><p>为了叙述方便起见，我们引入随机变量(random variable)的概念。对于$k =1, 2, 3, \cdots $，令随机变量</p><p>$$f(n) =\begin{cases}\epsilon_k =  1, &amp; \text{第$K$次硬币得到正面 } \\\epsilon_k =  0, &amp; \text{第$K$次硬币得到反面}\end{cases}$$</p><p>再令$$S_n = \epsilon_1 + \epsilon_2 + \cdots + \epsilon_n$$</p><p>这也是一个随机变数，定义在某个机率空间$\mathcal{(\Omega, F , P )}$上，代表丢$n$次硬币中，正面出现次数之随机变数，它具有二项分布。于是「$S_{2 n} = n$」就表示丢$2n$次正面恰好出现$n$次的事件，其概率记为$P ( S_{2 n} = n )$。</p><p>因此【定理3】是说。  $\lim_{n \rightarrow \infty} P(S_{2n}=n)=0$</p><p>进一步我们猜想：$S_{2n}$落在$n$的附近之概率应该会大起来吧？</p><p>也许这是「正面大约占一半」更贴切的解释。精确的计算是探求隐晦奥秘的不二法门，让我们就来算算看。</p><p>令$a &gt; 0​$唯一个固定数，那么</p><p>$$P(n-a \leq S_{2n} \leq n+a) = \sum_{k=n-a}^{n+a} C_{k}^{2n}\cdot \frac{1}{2^{2n} } \\ \sim \frac{2a}{ \sqrt{\pi n}} \rightarrow 0 ,when \quad  n \rightarrow \infty$$</p><p>因此我们又得到一个不出所料的结果：</p><p>【定理4】：对任意固定数$a &gt; 0$，$$\lim_{b \to \infty} P( \mid S_{2n} - n \mid \leq a ) = 0$$</p><p>换言之，以$n$为中心，左右之长皆为$a$之区间，概率依然为零！另外，将偶数$2n$改成奇数$2 n +1$，【定理4】仍然成立。因为当  $n \to \infty$时，相应项的比值为</p><p>$$\frac{ C_{k}^{2n+1}\cdot \frac{1}{ 2^{2n+1} } }{C_{k}^{2n} \frac{1}{2^{2n}}} = \frac {2n+1}{2n+1-k} \cdot \frac{1}{2} \to \frac{1}{2}$$所以$$P( -a \leq S_{2n+1} - \frac{2n+1}{2} \leq a )  \\ = \sum_{k=-a+ \frac {2n+1}{2}}^{a+ \frac {2n+1}{2}}  C_k^{2n} \frac{1}{2^{2n+1}}\\\sim \frac{1}{2}\sum_{k=-a+ \frac {2n+1}{2}}^{a+ \frac {2n+1}{2}}  C_k^{2n} \frac{1}{2^{2n}} \to 0$$</p><p>所以得到【定理5】：对任意有限正数$a$，恒有$$\lim_{n \to \infty} P(-a \leq S_{2n+1} - \frac{2n+1}{2} \leq a) = 0$$</p><p>将上述【定理4】与【定理5】归结起来就得到：</p><p>【定理6】：对任意有限正数$a$，恒有</p><p>$$\lim_{n \to \infty} P(-a \leq S_n - \frac{n}{2} \leq a) = 0 $$</p><p>这是一个令人惊异的结果，但也令人失望！逻辑的闷棍把常识的观点打得眼冒金星。用任何有限区间$[- a , a\ ]$来网罗住  $S_n - \frac{n}{2}$所散布的概率，当 $n \to \infty$时，根本没有往到任何概率，概率全部流失掉！</p><p>换言之，丢$n$次，出现正面的次数，落在包含$\frac{n}{2}$的任何有限区间的机会，当$n$很大时，微乎其微。</p><p>什么是概率？它仍然是很神秘！</p><blockquote><ol><li>表面来看，Stirling 公式并不漂亮，但却很多用途，它是揭开许多深刻奥秘的钥匙。在研究二项分布的性质时，De Moivre 最先得到这个公式（1718年）；后来James Stirling 在1730年又重新得到它。</li></ol></blockquote><blockquote><ol start="2"><li>$n!$的连续变化就是Gamma函数，内容精彩丰富，这是Euler的贡献。</li></ol></blockquote><h2>附录</h2><blockquote><p>斯特林公式证明，相当于一道考研题目</p></blockquote><p>$$log{n!}=log{1}+log{2}+\cdots+log{n} $$</p><p>因为$\log x$为单调函数，所以</p><p>$$\int_{k-1}^{k} \log{x} dx &lt; \log{n!} &lt; \int_{k}^{k+1}\log{x}dx $$把上式对$k$从$1$到$n$相加得到</p><p>$$\int_{0}^{n}\log{x}dx &lt; \log{n!} &lt; \int_{1}^{n+1}\log{x}dx \qquad(1)$$$$\Leftrightarrow n\log{n}-n &lt; \log{n!} &lt; (n+1)\log{(n+1)}-n \qquad(2)$$这是一个双重不等式，提示我们把$\log {n!}$与两端数的算数平均做比较，即想到$(n+\frac{1}{2})\log{n}-n$$$d_n=\log{n!}-(n+\frac{1}{2})\log{n}+n \qquad (3)$$$$d_n - d_{n+1}=\log{n!}-(n+\frac{1}{2})\log\frac{n+1}{n}-1$$$$\frac{n+1}{n}=\frac{1+\frac{1}{2n+1}}{1-\frac{1}{2n+1}}$$$\boldsymbol{Taylor}$展开得$$d_n - d_{n+1}=\frac{1}{3(2n+1)^2}+\frac{1}{5(2n+1)^4}+\cdots $$把上式与一个公比的几何级数进行比较得$$0 &lt; d_n-d_{n+1} &lt; \frac{1}{3\left [ (2n+1)^2-1 \right ]}=\frac{1}{12n}-\frac{1}{12(n+1)}$$知是${d_n}$下降序列，说明序列${d_n-(12n)^{-1} }$是上升的，因此，极限$\lim d_n = C$存在且有限，但是，由$(3)$知：$d_n \rightarrow C$等价于$$n! \sim e^C \cdot n^{n+\frac{1}{2} } \cdot e^{-n}$$</p><p>这就是斯特林公式的初步证明，其中关于$C$（$e^C=\sqrt{2\pi}$）的证明较复杂，有兴趣可参考相关文章，在此不赘述。</p>]]></content>
      
      <categories>
          
          <category> 概率论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 概率论 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用python做数据分析与科学计算(篇一)</title>
      <link href="/%E7%94%A8python%E5%81%9A%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E4%B8%8E%E7%A7%91%E5%AD%A6%E8%AE%A1%E7%AE%97(%E7%AF%87%E4%B8%80).html"/>
      <content type="html"><![CDATA[<p>用python做数据分析与科学计算主要涉及Numpy, Pandas, Scipy, Scikit-learn, Scipy等库，工作环境为Anaconda，这个IDE集成了大部分常用的包。同时，可以实现本地环境下Python的多版本切换，可参考之前文章,<a href="https://ulsonhu.github.io/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html" target="_blank" rel="noopener">MacOS下使用python的多版本方案</a></p><a id="more"></a><p>  通常做数据分析&amp;挖掘的workflow：拿到数据之后先要做一个数据的预处理(pandas+numpy+scipy)，接着会要对数据包含的特征做一些可视化输出(matplotlib)，之后需要提取特征&amp;建模调参(numpy+scikit-learn)，有了模型与结果，最后归纳整理做presentation &amp; report.</p><h2>Numpy</h2><p>用来存储和处理大型矩阵，比Python自身的嵌套列表（nested list structure)结构要高效的多，本身是由C语言开发。这个是很基础的扩展，其余的扩展都是以此为基础。数据结构为ndarray,一般有三种方式来创建。</p><table><thead><tr><th>Function</th><th>Useage</th></tr></thead><tbody><tr><td>array.shape</td><td>查看或改变数组的大小</td></tr><tr><td>array.reshape</td><td>修改数组的尺寸，原数组不变，两个数组共享内存，如果修改值的话这两个数组都会变</td></tr><tr><td>array.size</td><td>数组元素的总个数，等于shape属性中元组元素的乘积</td></tr><tr><td>array.ndim</td><td>数组的维数</td></tr><tr><td>array.dtype</td><td>array的数据规格</td></tr><tr><td>numpy.zeros(dim1,dim2)</td><td>创建dim1*dim2的零矩阵</td></tr><tr><td>numpy.eye(n)</td><td>创建$n*n$单位矩阵</td></tr><tr><td>numpy.identity(n)</td><td>创建$n*n$单位矩阵</td></tr><tr><td>numpy.arange</td><td>类似于list的range函数，通过指定初始值，终值，和步长来生成一维数组</td></tr><tr><td>array.astype(numpy.float64)</td><td>更换矩阵的数据形式</td></tr><tr><td>array * array</td><td>矩阵点乘</td></tr><tr><td>array[a:b]</td><td>切片</td></tr><tr><td>array.copy()</td><td>得到ndarray的副本，而不是视图</td></tr><tr><td>array [a] [b]=array [ a, b ]</td><td>两者等价</td></tr><tr><td>data[[4,3,0,6]]</td><td>索引，将第4,3,0,6行摘取出来，组成新数组</td></tr><tr><td>numpy.reshape(a,b)</td><td>将a<em>b的一维数组排列为a</em>b的形式</td></tr><tr><td>array([a,b,c,d],[d,e,f,g])</td><td>返回一维数组，分别为[a,d],[b,e],[c,f],[d,g]</td></tr><tr><td>array.T</td><td>array的转置</td></tr><tr><td>numpy.random.randn(a,b)</td><td>生成$a*b$的随机数组</td></tr><tr><td>numpy.dot(matrix_1,matrix_2)</td><td>矩阵乘法</td></tr><tr><td>array.transpose( (1,0,2,etc.) )</td><td>对于高维数组，转置需要一个由轴编号组成的元组</td></tr></tbody></table><p>numpy库提供了matrix类，使用matrix类创建的是矩阵对象，它们的加减乘除运算缺省采用矩阵方式计算。但是由于NumPy中同时存在ndarray和matrix对象，因此很容易将两者弄混。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 利用ones()创建一个2*4的全1矩阵</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.mat(np.ones((<span class="number">2</span>,<span class="number">4</span>))) </span><br><span class="line">matrix([[ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>],</span><br><span class="line">        [ <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>,  <span class="number">1.</span>]])</span><br></pre></td></tr></table></figure><h2>Pandas</h2><p>基于NumPy 的一种工具，该工具是为了解决数据分析任务而创建的。Pandas 纳入了大量库和一些标准的数据模型，提供了高效地操作大型数据集所需的工具。最具有统计意味的工具包，某些方面优于R软件。数据结构有一维的Series，二维的DataFrame(类似于Excel或者SQL中的表，如果深入学习，会发现Pandas和SQL相似的地方很多，例如merge函数)，三维的Panel（Pan（el) + da(ta) + s，知道名字的由来了吧）。</p><p>学习Pandas你要掌握的是：</p><ol><li>汇总和计算描述统计，处理缺失数据 ，层次化索引</li><li>清理、转换、合并、重塑、GroupBy技术</li><li>日期和时间数据类型及工具</li></ol><p><a href="http://pandas.pydata.org/pandas-docs/stable/10min.htmlml" target="_blank" rel="noopener">入门理解：</a></p><iframe src="http://nbviewer.jupyter.org/github/ulsonhu/mltest/blob/master/python_backup/Pandas_learn.ipynb" width="95%" height="300"></iframe><h3>使用pandas清洗数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pandas <span class="keyword">as</span> pd</span><br><span class="line">column_names = [<span class="string">"sex"</span>, <span class="string">"length"</span>, <span class="string">"diameter"</span>, <span class="string">"height"</span>, <span class="string">"whole weight"</span>, <span class="string">"shucked weight"</span>, <span class="string">"viscera weight"</span>, <span class="string">"shell weight"</span>, <span class="string">"rings"</span>]</span><br><span class="line">alone_df = pd.read_csv(<span class="string">'alone.csv'</span>,names=column_names)</span><br><span class="line">alone_df[<span class="string">'sex'</span>] = alone_df[<span class="string">'sex'</span>].map(&#123;<span class="string">'F'</span>:<span class="number">1</span>,<span class="string">'M'</span>:<span class="number">0</span>,<span class="string">'I'</span>:<span class="number">2</span>&#125;)</span><br><span class="line">alone_df[<span class="string">'sex'</span>] = alone_df.rings.map(<span class="keyword">lambda</span> x: <span class="number">1</span> <span class="keyword">if</span> x &gt; <span class="number">9</span> <span class="keyword">else</span> <span class="number">0</span>)</span><br><span class="line">alone_df.head()</span><br></pre></td></tr></table></figure><h2>Matplotlib</h2><p>Python中最著名的绘图系统，很多其他的绘图例如Seaborn（针对pandas绘图而来）也是由其封装而成。其中针对不是很复杂的数据，推荐使用Seaborn，容易上手，图表美观。<a href="http://seaborn.pydata.org/index.html" target="_blank" rel="noopener">Seaborn参考</a></p><p>需要掌握的内容</p><ol><li>散点图，折线图，条形图，直方图，饼状图，箱形图的绘制。</li><li>绘图的三大系统：pyplot，pylab(不推荐)，面向对象</li><li>坐标轴的调整，添加文字注释，区域填充，及特殊图形patches的使用</li><li>金融的同学要注意的是：可以直接调用Yahoo财经数据绘图（很好用）</li></ol><h3>简单的散点图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">y = np.sin(x)</span><br><span class="line">plt.scatter(x,y)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902375/2018_03_09_03.png" width="90%" height="90%"><h3>使用子图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">1</span>) <span class="comment"># （行，列，活跃区）</span></span><br><span class="line">plt.plot(x, np.sin(x), <span class="string">'r'</span>)</span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">'g'</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902375/2018_03_09_02.png" width="90%" height="90%"><p>使用子图只需要一个额外的步骤。即在调用 <code>plot()</code> 函数之前需要先调用<code>subplot()</code>函数。该函数的第一个参数代表子图的总行数，第二个参数代表子图的总列数，第三个参数代表活跃区域.</p><p>标题，标签和图例当需要快速创建图形时，你可能不需要为图形添加标签。但是当构建需要展示的图形时，你就需要添加标题，标签和图例。</p><h3>添加标题，坐标轴标记和图例</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">x = np.linspace(<span class="number">0</span>, <span class="number">2</span> * np.pi, <span class="number">50</span>)</span><br><span class="line">plt.plot(x, np.sin(x), <span class="string">'r-x'</span>, label=<span class="string">'Sin(x)'</span>)</span><br><span class="line">plt.plot(x, np.cos(x), <span class="string">'g-^'</span>, label=<span class="string">'Cos(x)'</span>)</span><br><span class="line">plt.legend() <span class="comment"># 展示图例</span></span><br><span class="line">plt.xlabel(<span class="string">'Rads'</span>) <span class="comment"># 给 x 轴添加标签</span></span><br><span class="line">plt.ylabel(<span class="string">'Amplitude'</span>) <span class="comment"># 给 y 轴添加标签</span></span><br><span class="line">plt.title(<span class="string">'Sin and Cos Waves'</span>) <span class="comment"># 添加图形标题</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>为了给图形添加图例，我们需要在 <code>plot()</code> 函数中添加命名参数 <code>label</code> 并赋予该参数相应的标签。然后调用 <code>legend()</code> 函数就会在我们的图形中添加图例。</p><p>接下来我们只需要调用函数 <code>title()</code>，<code>xlabel()</code> 和 <code>ylabel()</code> 就可以为图形添加标题和标签。</p><p>你会得到类似于下面这张拥有标题、标签和图例的图形：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521902376/2018_03_09_04.png" width="90%" height="90%"><p>参考文献</p><ol><li><a href="http://deeplearning.net/tutorial/" target="_blank" rel="noopener">Deep Learning Tutorials</a></li><li><a href="http://www.scipy-lectures.org/" target="_blank" rel="noopener">Scipy Lecture</a></li><li><a href="https://www.kesci.com/" target="_blank" rel="noopener">KeSci平台</a></li><li><a href="http://pandas.pydata.org/pandas-docs/stable/10min.html" target="_blank" rel="noopener">10 Minutes to pandas</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> Python </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SAS基础学习篇(一)</title>
      <link href="/SAS%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A0%E7%AF%87(%E4%B8%80).html"/>
      <content type="html"><![CDATA[<p>参考书籍</p><ol><li>《SAS编程与数据挖掘商业案例》（预热）</li><li>「the Little SAS Book」(推荐)</li><li>「Applied Econometrics Using The SAS System」</li></ol><p>SAS编程主要包括<code>DATA</code>和<code>PROC</code>两部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">* create sas data set named toads;</span><br><span class="line">* read the data file ToadJump.dta using list input;</span><br><span class="line">DATA toads;</span><br><span class="line">INFILE &apos;~/desktop/ToadJump.dta&apos;;</span><br><span class="line">INPUT ToadJump $ Weight Jump1 Jump2 Jump3;</span><br><span class="line">RUN;</span><br><span class="line">* print the data to make sure the file was read correctly;</span><br><span class="line">* PROC PRINT DATA = toads;</span><br><span class="line">TITLE &apos;SAS Data Set Toads&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>这样就建立了一个名为<code>toads</code>的临时数据集，然后读入外部文件<code>ToadJump.dat</code>，然后告诉SAS有四个变量，其中第一个是文本型,缺失值用一个点<code>.</code>标记</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">* Create a SAS data set named sales;</span><br><span class="line">* Read the data file OnionRing.dat using column input;</span><br><span class="line">DATA sales;</span><br><span class="line">INFILE ’~/desktop/OnionRing.dat’;</span><br><span class="line">INPUT VisitingTeam $ 1-20 ConcessionSales 21-24 BleacherSales 25-28</span><br><span class="line">OurHits 29-31 TheirHits 32-34 OurRuns 35-37 TheirRuns 38-40;</span><br><span class="line">RUN;</span><br><span class="line">* Print the data to make sure the file was read correctly;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">TITLE ’SAS Data Set Sales’;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h2>基本函数</h2><table><thead><tr><th>SAS文本类函数</th><th></th></tr></thead><tbody><tr><td>ANYALNUM(arg,start)</td><td>返回第一次出现任意数字或字母的位置，可选开始位置start</td></tr><tr><td>ANYALPHA(arg,start)</td><td>返回第一次出现任意字母的位置，可选开始位置start</td></tr><tr><td>ANYDIGIT(arg,start)</td><td>返回第一次出现任意数字的位置，可选开始位置start</td></tr><tr><td>ANYSPACE(arg,start)</td><td>返回第一次出现任意空白的位置，可选开始位置start</td></tr><tr><td>CAT(arg1,arg2,…argn)</td><td>连接字符串，留下头尾空白</td></tr><tr><td>CATS(arg1,arg2,…argn)</td><td>连接字符串，删除头尾空白</td></tr><tr><td>CATX(‘separator-string’, arg-1,…,arg-n)</td><td>连接字符串，删除头尾空白并用指定标点连接</td></tr><tr><td>COMPRESS(arg, ‘char’)</td><td>移除字符串中的空格和可选字符</td></tr><tr><td>INDEX(arg, ‘string’)</td><td>返回指定字符在变量中的位置</td></tr><tr><td>LEFT(arg)</td><td>字符串左对齐</td></tr><tr><td>LENGTH(arg)</td><td>返回字符串长度，不考虑尾部空格</td></tr><tr><td>PROPCASE(arg)</td><td>首字母大写</td></tr><tr><td>SUBSTR(arg,position,n)</td><td>从字符串中提取指定开始位置指定长度字符</td></tr><tr><td>TRANSLATE(source,to1,from1,…ton,fromn)</td><td>替换字符</td></tr><tr><td>TRANWRD(source,from,to)</td><td>替换字符串</td></tr><tr><td>TRIM(arg)</td><td>删除尾部空白</td></tr><tr><td>UPCASE(arg)</td><td>替换成大写</td></tr></tbody></table><table><thead><tr><th>SAS数值函数</th><th></th></tr></thead><tbody><tr><td>INT(arg)</td><td>返回整数</td></tr><tr><td>LOG(arg)</td><td>自然对数</td></tr><tr><td>LOG10(arg)</td><td>$10$为底对数</td></tr><tr><td>MAX(arg1,arg2,…argn)</td><td>最大值</td></tr><tr><td>MEAN(arg1,arg2,…argn)</td><td>均值</td></tr><tr><td>MIN(arg1,arg2,…argn)</td><td>最小值</td></tr><tr><td>N(arg1,arg2,…argn)</td><td>非缺失值个数</td></tr><tr><td>NMISS(arg1,arg2,…argn)</td><td>缺失值个数</td></tr><tr><td>ROUND(arg, roundoffunit)</td><td>保留几位小数</td></tr><tr><td>SUM(arg1,arg2,…argn)</td><td>求和</td></tr></tbody></table><table><thead><tr><th>SAS日期函数</th><th></th></tr></thead><tbody><tr><td>DATEJUL(julian-date)</td><td>标准julian日期到SAS日期</td></tr><tr><td>DAY(date)</td><td>返回「日」</td></tr><tr><td>MDY(month,day,year)</td><td>年月日到SAS日期</td></tr><tr><td>MONTH(date)</td><td>返回「月」</td></tr><tr><td>QTR(date)</td><td>返回季度</td></tr><tr><td>TODAY()</td><td>今日</td></tr><tr><td>WEEKDAY(date)</td><td>返回周几（周日为1）</td></tr><tr><td>YEAR(date)</td><td>返回「年」</td></tr><tr><td>YRDIF(start-date,end- date,’ACTUAL’)</td><td>返回相差年份</td></tr></tbody></table><h2>判断结构</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">* if then structure</span><br><span class="line">if model = &apos;Pink&apos; then make = &apos;Floyd&apos;;</span><br><span class="line"></span><br><span class="line">* 执行多项命令，需要嵌套do；可以用and和or</span><br><span class="line">if Year then Model = &apos;Mac&apos; or Model = &apos;pro&apos; then Make = &apos;Jobs&apos;;</span><br><span class="line">if Model = &apos;iphone5&apos; then do;</span><br><span class="line">Make = &apos;Tim&apos;;</span><br><span class="line">Seats = 2;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">* if else</span><br><span class="line">if Cost = . then CostGroup = &apos;Missing&apos;;</span><br><span class="line">else if Cost else if Cost else CostGroup = high;</span><br><span class="line"></span><br><span class="line">* use if to select sub-set</span><br><span class="line">if sex = &apos;m&apos;;if sex = &apos;m&apos; then detele;</span><br></pre></td></tr></table></figure><h2>数组操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">* Change all 9 to missing values;</span><br><span class="line">DATA songs;</span><br><span class="line">INFILE &apos;~/desktop/WBRK.dat&apos;;</span><br><span class="line">INPUT City $ 1-15 Age domk wj hwow simbh kt aomm libm tr filp ttr;</span><br><span class="line">ARRAY song (10) domk wj hwow simbh kt aomm libm tr filp ttr;</span><br><span class="line">DO i = 1 TO 10;</span><br><span class="line">IF song(i) = 9 THEN song(i) = .;</span><br><span class="line">END;</span><br><span class="line">RUN;</span><br><span class="line">PROC PRINT DATA = songs;</span><br><span class="line">TITLE &apos;WBRK Song Survey&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h2>基本模块调用</h2><p>搞定基本的函数之后，开始鼓捣$SAS$里面的模型。也就是说，要开始写<code>PROC</code>了。其实，$SAS$比较像$Stata$（计量经济学主流软件），无论是从输出的样式，还是语法。不习惯没有()的模型调用呀。若是说$SAS$和$Stata$的区别，怕只是$Stata$更侧重于<strong>计量模型</strong>而$SAS$则是服务于大多数<strong>统计模型</strong>吧。</p><h3>PROC的基本内容：CONTENT</h3><p><code>PROC:content</code>，可以显示数据集的主要特性。比如，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LIBNAME tropical &apos;~/MySASLib&apos;;</span><br><span class="line">PROC CONTENTS DATA = tropical.banana;</span><br></pre></td></tr></table></figure><p>这里主要是两个声明:<code>TITLE</code>和<code>FOOTNOTE</code>。前者输出时候会产生一个标题，后者会产生尾注。用法也是比较直接的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">TITLE ”Here’s another title”;</span><br><span class="line">TITLE ’Here’’s another title’;</span><br><span class="line">FOOTNOTE3 ’This is the third footnote’;</span><br></pre></td></tr></table></figure><h3>SAS PROC求子集:WHERE</h3><p>如果要在<code>PROC</code>里面先求子集的话，可以直接调用<code>WHERE</code>。感觉这里和$SQL$的思路比较像。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">PROC PRINT DATA = &apos;～/desktop/MySASLib/style&apos;;</span><br><span class="line">WHERE Genre = &apos;Impressionism&apos;;</span><br><span class="line">TITLE &apos;Major Impressionist Painters&apos;;</span><br><span class="line">FOOTNOTE &apos;F = France N = Netherlands U = US&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h3>SAS PROC 数据进行排序:SORT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA marine;</span><br><span class="line">INFILE &apos;~/desktop/Lengths.dat&apos;;</span><br><span class="line">INPUT Name $ Family $ Length @@;</span><br><span class="line">RUN;</span><br><span class="line">* Sort the data;</span><br><span class="line">PROC SORT DATA = marine OUT = seasort NODUPKEY;</span><br><span class="line">BY Family DESCENDING Length;</span><br><span class="line">PROC PRINT DATA = seasort;</span><br><span class="line">TITLE &apos;Whales and Sharks&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>这样数据就按照<code>Family</code>、<code>Length</code>（递减）排序了。</p><h3>SAS PROC 输出数据:PRINT</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Candy.dat&apos;;</span><br><span class="line">INPUT Name $ 1-11 Class @15 DateReturned MMDDYY10. CandyType $</span><br><span class="line">Quantity;</span><br><span class="line">Profit = Quantity * 1.25;</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY Class;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">BY Class;</span><br><span class="line">SUM Profit;</span><br><span class="line">VAR Name DateReturned CandyType Profit;</span><br><span class="line">TITLE &apos;Candy Sales for Field Trip by Class&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><h3>SAS PROC里面改变输出格式：FORMAT</h3><p>基本就是<code>FORMAT</code>一下就可以了，再就是<code>PUT</code>的时候也可以调整。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Candy.dat&apos;;</span><br><span class="line">INPUT Name $ 1-11 Class @15 DateReturned MMDDYY10. CandyType $</span><br><span class="line">Quantity;</span><br><span class="line">Profit = Quantity * 1.25;</span><br><span class="line">PROC PRINT DATA = sales;</span><br><span class="line">VAR Name DateReturned CandyType Profit;</span><br><span class="line">FORMAT DateReturned DATE9. Profit DOLLAR6.2;</span><br><span class="line">TITLE &apos;Candy Sale Data Using Formats&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>常用的格式有：</p><ul><li>文本型：<code>$HEXw.</code>和<code>$w.</code></li><li>日期型：<code>DATEw.</code>（输出为ddmmyy或者ddmmyyyy）、<code>DATETIMEw.d</code>（输出为ddmmyy:hh:mm:ss）、<code>DAYw.</code>（输出为dd）、<code>EURDFDDw.</code> 、<code>JULIANw.</code>、<code>MMDDYYw.</code>（输出为mmddyy或mmddyyyy）、<code>TIMEw.d</code>（输出为hh:mm:ss）、<code>WEEKDATEw.</code>（输出为工作日）、<code>WORDDATEw.</code>(输出为单词)。</li><li>数字型：<code>BESTw.</code>（自动选择）、<code>COMMAw.d</code>（逗号分隔）、<code>DOLLARw.d</code>（货币）、<code>Ew.</code>（科学计数法）、<code>PDw.d</code>、<code>w.d</code>（标准小数）</li></ul><p>输出的样本见下：</p><p>当然<code>FORMAT</code>还可以自定义<code>factor</code>型变量的输出格式，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA carsurvey;</span><br><span class="line">INFILE &apos;~/deskktop/Cars.dat&apos;;</span><br><span class="line">INPUT Age Sex Income Color $;</span><br><span class="line">PROC FORMAT;</span><br><span class="line">VALUE gender 1 = &apos;Male&apos; </span><br><span class="line">2 = &apos;Female&apos;;</span><br><span class="line">VALUE agegroup 13 -&lt; 20 = &apos;Teen&apos;</span><br><span class="line">20 -&lt; 65 = &apos;Adult&apos;</span><br><span class="line">65 - HIGH = &apos;Senior&apos;;</span><br><span class="line">VALUE $col &apos;W&apos; = &apos;Moon White&apos;</span><br><span class="line">&apos;B&apos; = &apos;Sky Blue&apos;</span><br><span class="line">&apos;Y&apos; = &apos;Sunburst Yellow&apos;</span><br><span class="line">&apos;G&apos; = &apos;Rain Cloud Gray&apos;;</span><br><span class="line">* Print data using user-defined and standard (DOLLAR8.) formats;</span><br><span class="line">PROC PRINT DATA = carsurvey;</span><br><span class="line">FORMAT Sex gender. Age agegroup. Color $col. Income DOLLAR8.;</span><br><span class="line">TITLE &apos;Survey Results Printed with User-Defined Formats&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>就可以把数字型的1，2转换为对应的文本<code>male</code>和<code>female</code>等，还可以把变量离散化。</p><h3>SAS总结数据:MEANS</h3><p>$SAS$当然还有类似于$Excel$的数据透视表和$R$的<code>data.table</code>的模块，就是<code>MEANS</code>。可以输出的描述性统计值，包括最大值、最小值、平均值、中位数、余非缺失值个数、缺失值个数、范围、标准差、和等等。此外，还可以使用<code>BY</code>或者<code>CLASS</code>进行分组统计，<code>VAR</code>选择变量等。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Flowers.dat&apos;;</span><br><span class="line">INPUT CustomerID $ @9 SaleDate MMDDYY10. Petunia SnapDragon</span><br><span class="line">Marigold;</span><br><span class="line">Month = MONTH(SaleDate);</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY Month;</span><br><span class="line">* Calculate means by Month for flower sales;</span><br><span class="line">PROC MEANS DATA = sales;</span><br><span class="line">BY Month;</span><br><span class="line">VAR Petunia SnapDragon Marigold;</span><br><span class="line">TITLE &apos;Summary of Flower Sales by Month&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以实现</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> Summary of  Flower Sales by Month 1</span><br><span class="line">---------------- Month=5 --------------</span><br><span class="line">The MEANS Procedure</span><br><span class="line">Variable N Mean Std Dev Minimum Maximum</span><br><span class="line">----------------------------------------</span><br><span class="line">Petunia 3 86.6666667 35.1188458 50.0000000 120.0000000</span><br><span class="line">SnapDragon 3 113.3333333 41.6333200 80.0000000 160.0000000</span><br><span class="line">Marigold 3 81.6666667 25.6580072 60.0000000 110.0000000</span><br><span class="line">---------------- Month=6 ---------------</span><br><span class="line">Variable N Mean Std Dev Minimum Maximum</span><br><span class="line">-----------------------------------------</span><br><span class="line">Petunia 4 81.2500000 16.5201897 60.0000000 100.0000000</span><br><span class="line">SnapDragon 4 97.5000000 47.8713554 60.0000000 160.0000000</span><br><span class="line">Marigold 4 83.7500000 19.7378655 60.0000000 100.0000000</span><br><span class="line">-------------------------------------------</span><br></pre></td></tr></table></figure><p>当然这些统计量也可以直接的写入一个SAS数据表，只需要加上一个<code>OUTPUT</code>就可以了。原数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">756-01 05/04/2008 120 80 110</span><br><span class="line">834-01 05/12/2008 90 160 60</span><br><span class="line">901-02 05/18/2008 50 100 75</span><br><span class="line">834-01 06/01/2008 80 60 100</span><br><span class="line">756-01 06/11/2008 100 160 75</span><br><span class="line">901-02 06/19/2008 60 60 60</span><br><span class="line">756-01 06/25/2008 85 110 100</span><br></pre></td></tr></table></figure><p>SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">DATA sales;</span><br><span class="line">INFILE &apos;~/desktop/Flowers.dat&apos;;</span><br><span class="line">INPUT CustomerID $ @9 SaleDate MMDDYY10. Petunia SnapDragon Marigold;</span><br><span class="line">PROC SORT DATA = sales;</span><br><span class="line">BY CustomerID;</span><br><span class="line">* Calculate means by CustomerID, output sum and mean to new data set;</span><br><span class="line">PROC MEANS NOPRINT DATA = sales;</span><br><span class="line">BY CustomerID;</span><br><span class="line">VAR Petunia SnapDragon Marigold;</span><br><span class="line">OUTPUT OUT = totals MEAN(Petunia SnapDragon Marigold) =</span><br><span class="line">MeanPetunia MeanSnapDragon MeanMarigold</span><br><span class="line">SUM(Petunia SnapDragon Marigold) = Petunia SnapDragon Marigold;</span><br><span class="line">PROC PRINT DATA = totals;</span><br><span class="line">TITLE &apos;Sum of Flower Data over Customer ID&apos;;</span><br><span class="line">FORMAT MeanPetunia MeanSnapDragon MeanMarigold 3.;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终结果为：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_01.png" width="90%" height="90%"></p><h3>SAS PROC统计频率：FREQ</h3><p>计数的话，就要靠SAS里面的<code>FREQ</code>模块了。比如我们有一个数据集：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">esp w cap d cap w kon w ice w kon d esp d kon w ice d esp d</span><br><span class="line">cap w esp d cap d Kon d . d kon w esp d cap w ice w kon w</span><br><span class="line">kon w kon w ice d esp d kon w esp d esp w kon w cap w kon w</span><br></pre></td></tr></table></figure><p>然后可以用<code>FREQ</code>来统计一些基本量：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DATA orders;</span><br><span class="line">INFILE &apos;~/desktop/Coffee.dat&apos;;</span><br><span class="line">INPUT Coffee $ Window $ @@;</span><br><span class="line">* Print tables for Window and Window by Coffee;</span><br><span class="line">PROC FREQ DATA = orders;</span><br><span class="line">TABLES Window Window * Coffee;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终会得到一个$2*5$的表格：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_02.png" width="90%" height="90%"></p><h3>SAS PROC汇报表格：TABULATE</h3><p>基本看到TABULATE就可以想到那个著名的软件Tabular了…不过貌似SAS也自带了一个类似的表格模块。这个东西可以变得非常复杂，不过鉴于一时半会儿还用不到，没有细细看。抄个例子吧。</p><p>原数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Silent Lady Maalea sail sch 75.00</span><br><span class="line">America II Maalea sail yac 32.95</span><br><span class="line">Aloha Anai Lahaina sail cat 62.00</span><br><span class="line">Ocean Spirit Maalea power cat 22.00</span><br><span class="line">Anuenue Maalea sail sch 47.50</span><br><span class="line">Hana Lei Maalea power cat 28.99</span><br><span class="line">Leilani Maalea power yac 19.99</span><br><span class="line">Kalakaua Maalea power cat 29.50</span><br><span class="line">Reef Runner Lahaina power yac 29.95</span><br><span class="line">Blue Dolphin Maalea sail cat 42.95</span><br></pre></td></tr></table></figure><p>SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36;</span><br><span class="line">RUN;</span><br><span class="line">* Tabulations with three dimensions;</span><br><span class="line">PROC TABULATE DATA = boats;</span><br><span class="line">CLASS Port Locomotion Type;</span><br><span class="line">TABLE Port, Locomotion, Type;</span><br><span class="line">TITLE &apos;Number of Boats by Port, Locomotion, and Type&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>最终结果：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_03.png" width="90%" height="90%"></p><p>类似的，还可以增加统计量（类似于<code>MEANS</code>那里）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36;</span><br><span class="line">RUN;</span><br><span class="line">* PROC TABULATE report with options;</span><br><span class="line">PROC TABULATE DATA = boats FORMAT=DOLLAR9.2;</span><br><span class="line">CLASS Locomotion Type;</span><br><span class="line">VAR Price;</span><br><span class="line">TABLE Locomotion ALL, MEAN*Price*(Type ALL)</span><br><span class="line">/BOX=&apos;Full Day Excursions&apos; MISSTEXT=&apos;none&apos;;</span><br><span class="line">TITLE;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以得到：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_04.png" width="90%" height="90%"></p><p>最后还可以混合<code>FORMAT</code>等等，可以变得相当的复杂。貌似这东西是美国劳工部鼓捣出来的格式…</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DATA boats;</span><br><span class="line">INFILE &apos;~/desktop/Boats.dat&apos;;</span><br><span class="line">INPUT Name $ 1-12 Port $ 14-20 Locomotion $ 22-26 Type $ 28-30</span><br><span class="line">Price 32-36 Length 38-40;</span><br><span class="line">RUN;</span><br><span class="line">* Using the FORMAT= option in the TABLE statement;</span><br><span class="line">PROC TABULATE DATA = boats;</span><br><span class="line">CLASS Locomotion Type;</span><br><span class="line">VAR Price Length;</span><br><span class="line">TABLE Locomotion ALL,</span><br><span class="line">MEAN * (Price*FORMAT=DOLLAR6.2 Length*FORMAT=6.0) * (Type ALL);</span><br><span class="line">TITLE &apos;Price and Length by Type of Boat&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>BOSS级汇报表格呈现了…</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_05.png" width="90%" height="90%"><p>我只能感慨，不愧是商业软件啊，用户需求考虑的真的是特别的周到…这种费时费力做汇报表格的事情也被搞定了，强悍。</p><p>SAS里面的报告：REPORT还有一个REPORT，看到有TABULATE的时候我已经不奇怪并略略的有些期待一个做报告的模块出现了。这东西基本就是前面几个的超级混合体，反正你想搞到的汇报模式总是能够搞出来的。</p><p>又是一堆数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">17 sci 9 bio 28 fic 50 mys 13 fic 32 fic 67 fic 81 non 38 non</span><br><span class="line">53 non 16 sci 15 bio 61 fic 52 ref 22 mys 76 bio 37 fic 86 fic</span><br><span class="line">49 mys 78 non 45 sci 64 bio 8 fic 11 non 41 fic 46 ref 69 fic</span><br><span class="line">34 fic 26 mys 23 sci 74 ref 15 sci 27 fic 23 mys 63 fic 78 non</span><br><span class="line">40 bio 12 fic 29 fic 54 mys 67 fic 60 fic 38 sci 42 fic 80 fic</span><br></pre></td></tr></table></figure><p>然后一堆SAS代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">DATA books;</span><br><span class="line">INFILE &apos;c:\MyRawData\LibraryBooks.dat&apos;;</span><br><span class="line">INPUT Age BookType $ @@;</span><br><span class="line">RUN;</span><br><span class="line">* Define formats to group the data;</span><br><span class="line">PROC FORMAT;</span><br><span class="line">VALUE agegpa</span><br><span class="line">0-18 = &apos;0 to 18&apos;</span><br><span class="line">19-25 = &apos;19 to 25&apos;</span><br><span class="line">26-49 = &apos;26 to 49&apos;</span><br><span class="line">50-HIGH = &apos; 50+ &apos;;</span><br><span class="line">VALUE agegpb</span><br><span class="line">0-25 = &apos;0 to 25&apos;</span><br><span class="line">26-HIGH = &apos; 26+ &apos;;</span><br><span class="line">VALUE $typ</span><br><span class="line">&apos;bio&apos;,&apos;non&apos;,&apos;ref&apos; = &apos;Non-Fiction&apos;</span><br><span class="line">&apos;fic&apos;,&apos;mys&apos;,&apos;sci&apos; = &apos;Fiction&apos;;</span><br><span class="line">RUN;</span><br><span class="line">*Create two way table with Age grouped into four categories;</span><br><span class="line">PROC FREQ DATA = books;</span><br><span class="line">TITLE &apos;Patron Age by Book Type: Four Age Groups&apos;;</span><br><span class="line">TABLES BookType * Age / NOPERCENT NOROW NOCOL;</span><br><span class="line">FORMAT Age agegpa. BookType $typ.;</span><br><span class="line">RUN;</span><br><span class="line">* Create two way table with Age grouped into two categories;</span><br><span class="line">PROC FREQ DATA = books;</span><br><span class="line">TITLE &apos;Patron Age by Book Type: Two Age Groups&apos;;</span><br><span class="line">TABLES BookType * Age / NOPERCENT NOROW NOCOL;</span><br><span class="line">FORMAT Age agegpb. BookType $typ.;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>然后一堆交叉计数的结果就出来了：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_06.png" width="90%" height="90%"></p><p>当然，简单的计算和分类统计也不在话下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">DATA natparks;</span><br><span class="line">INFILE &apos;c:\MyRawData\Parks.dat&apos;;</span><br><span class="line">INPUT Name $ 1-21 Type $ Region $ Museums Camping;</span><br><span class="line">RUN;</span><br><span class="line">*Statistics in COLUMN statement with two group variables;</span><br><span class="line">PROC REPORT DATA = natparks NOWINDOWS HEADLINE;</span><br><span class="line">COLUMN Region Type N (Museums Camping),MEAN;</span><br><span class="line">DEFINE Region / GROUP;</span><br><span class="line">DEFINE Type / GROUP;</span><br><span class="line">TITLE &apos;Statistics with Two Group Variables&apos;;</span><br><span class="line">RUN;</span><br><span class="line">*Statistics in COLUMN statement with group and across variables;</span><br><span class="line">PROC REPORT DATA = natparks NOWINDOWS HEADLINE;</span><br><span class="line">COLUMN Region N Type,(Museums Camping),MEAN;</span><br><span class="line">DEFINE Region / GROUP;</span><br><span class="line">DEFINE Type / ACROSS;</span><br><span class="line">TITLE &apos;Statistics with a Group and Across Variable&apos;;</span><br><span class="line">RUN;</span><br></pre></td></tr></table></figure><p>可以得到一个看起来很fancy的表格：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521555460/2018_03_07_07.png" width="90%" height="90%"></p><h3>SAS数据总结综述</h3><p>我的感觉是，<code>MEANS</code>, <code>TABULATE</code>和<code>REPORT</code>这三个模块各有千秋，基本就是可以替代EXCEL的数据透视表，虽然效率上说不好谁比谁高。</p>]]></content>
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> SAS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Excel知识点备忘</title>
      <link href="/Excel%E7%9F%A5%E8%AF%86%E7%82%B9%E5%A4%87%E5%BF%98.html"/>
      <content type="html"><![CDATA[<p>Excel系统学习：<a href="http://study.163.com/course/courseMain.htm?courseId=670032" target="_blank" rel="noopener">视频教程</a></p><h2>相对引用与绝对引用</h2><ul><li><code>$A1</code>列绝对引用</li><li><code>A$1</code>行绝对引用</li><li><code>$A$1</code>行列都为绝对引用</li></ul><p>快捷键<code>F4</code></p><h2>条件格式</h2><p>学会使用条件格式，其中与混合应用交叉，可实现相关功能</p><h2>排序</h2><ul><li>一般排序</li><li>多条件排序</li><li>按照特定字段排序</li><li>排序的延伸</li></ul><h2>筛选</h2><h2>一、时间与日期函数</h2><ol><li><code>today()</code>返回日期格式的当前日期,输入日期快捷键<code>Ctrl+;</code></li><li><code>now()</code>,输入日期时间快捷键<code>Ctrl+Shift+;</code></li><li><code>weekday(serial_number,return_type)</code></li><li><code>workday()</code></li><li><code>dateif(start_date,end_date,unit[Y|M|D])</code>返回两个日期之间年/月/日的间隔数</li></ol><p>输入日期快捷键<code>Ctrl+;</code></p><h2>二、统计函数</h2><ol><li><code>count</code></li><li><code>countif(range,criteria)</code>计算区域中满足指定条件的单元格个数</li><li><code>countifs(range1,criteria1,range2,criteria2,...)</code></li><li><code>sumif(range,criteria,sum_range)</code></li><li><code>sumifs(sum_range,criteria_range1,criteria1,criteria_range2,criteria2,...)</code></li></ol><h2>三、查找和引用函数</h2><ol><li><code>vlookup(lookup_value,table_array,col_index_num,range_lookup)</code></li></ol><ul><li><code>lookup_value</code>需要在数据表第一列查找的数值</li><li><code>table_array</code>需要查找的数据区域</li><li><code>col_index_num</code>为待返回的匹配值的列序号</li><li><code>range_lookup</code>精确匹配与模糊匹配</li></ul><h3>关于跨表引用</h3><table><thead><tr><th>产品编号</th><th>系列</th><th>产品名称</th><th>进货单价</th></tr></thead><tbody><tr><td>AP11001</td><td>老婆饼</td><td>老婆饼（花生）</td><td>6.5</td></tr><tr><td>AP11002</td><td>老婆饼</td><td>老婆饼（桂花）</td><td>6.5</td></tr></tbody></table><p>如根据“产品编号”自动返回基本信息表“系列”字段内容<code>vlookup($D2,产品基本信息表!$B$3:$F$38,2,false)</code></p><blockquote><p>跨表查询，工作中常用</p></blockquote><p>注意：</p><ul><li>查找值一定要在第一列</li><li>模糊匹配时第一列一定要升序排列</li></ul><ol start="2"><li><code>index(查找的区域，区域内第几行，区域内第几列)</code>与<code>match(查找指定的值，查找所在区域，查找方式的参数)</code>，两者连用，基本可以替代’Vlookup()'的查找，其中’Vlookup()'只是针对文本内容的查找</li></ol><p>如<code>index(A:A,match(C1,B:B,0))</code></p><ol start="3"><li><blockquote><p>=Lookup（查找的值，值所在的位置，返回相应位置的值）</p></blockquote></li></ol><p><code>lookup()</code>函数弥补了<code>vlookup()</code>函数第三参数的劣势，但其本身也存在缺点，即不能精确匹配使用<code>lookup()</code>函数需要熟悉Excel数组的运算.详见<a href="http://study.163.com/course/courseLearn.htm?courseId=670032#/learn/video?lessonId=823422&amp;courseId=670032" target="_blank" rel="noopener">视频18课时62:00</a></p><ol start="4"><li><p><code>choose(index_num, value1, [value2], ...)</code></p></li><li><p><code>Offset(指定点，偏移多少行，偏移多少列，返回多少行，返回多少列)</code>建立坐标系，以坐标系为原点，返回距离原点的值或者区域。正数代表向下或向右，负数则相反。通过’Offset()'函数可以实现动态图标、动态数据透视表</p></li><li><p><code>Row()</code></p></li></ol><p>返回单元格所在的行</p><ol start="7"><li><code>Column()</code></li></ol><p>返回单元格所在的列</p><h2>四、文本函数</h2><ul><li><code>text(text)</code>设置数字格式并将其转换为文本</li><li><code>concatenate(text1,text2,...)</code>将几个文本项合并为一个文本项</li><li><code>len(text)</code>计算字符串的长度</li><li><code>mod(number,divisor)</code> 返回两数相除的余数。</li><li><code>right(text,num_chars)</code> 返回文本值中最右边的字符</li><li><code>left(text,num_chars)</code>返回文本值中最左边的字符</li><li><code>mid(text,start_num,num_chars))</code>从文本字符串中的指定位置起返回特定个数的字符</li><li><code>trim(text)</code>设置数字格式并将其转换为文本</li></ul><h2>五、数据透视表</h2><p>Excel中十分重要的一项功能，主要功能是将数据聚合，按照各子段进行<code>sum()</code>，<code>count()</code>的运算。应用范围</p><ul><li>包括大量复杂数据的表格，希望快速整理出一份具有实际意义的报表</li><li>希望找出同类数据在不同时期的某种特定关系</li><li>希望对数据进行合理有效的分组</li><li>需要经常查询分析数据的变化趋势</li><li>数据源经常变化，然而有需要经常分析和处理最新的数据源</li></ul><h3>数据分析</h3><p>查找<code>Ctrl+F</code>与替换</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">=if(average(A2:A5)&gt;50,sum(B2:B5),0)</span><br><span class="line">=if(A2=10,&quot;科技处&quot;,if(A2=20,&quot;财务处&quot;,&quot;人事处&quot;))</span><br><span class="line">=sumif(销售记录汇总!$A$2:$A$107,$B5,销售记录汇总!$G$2,$G$107)</span><br><span class="line">=sumif(条件区域,条件值,求和区域)</span><br><span class="line"></span><br><span class="line">=sumifs(求和区域,条件区域,条件值)</span><br><span class="line">=sumif(销售记录汇总!$G$2,$G$107,销售记录汇总!$A$2:$A$107,$B5)</span><br></pre></td></tr></table></figure><p>条件可以是数字、表达式或文本，但是要使用引号</p><h3>数组计算相关</h3><p>计算结果<code>Ctrl+Shift+Enter</code></p><h2>杂类技巧</h2><ol><li>选择性粘贴 $\rightarrow $ 转置</li><li><code>column()``row()</code>返回当前列(行)数</li><li><code>Ctrl+Enter</code>，以当前单元格为始，往下填充数据和函数。</li><li><code>Ctrl+Space</code>，选定整列。<code>Shift+Space</code>，选定整行。</li><li><code>Alt+Enter</code>，换行。</li></ol>]]></content>
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Excel </tag>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Oracle SQL语句学习及总结</title>
      <link href="/MySQL%E8%AF%AD%E5%8F%A5%E5%AD%A6%E4%B9%A0%E5%8F%8A%E6%80%BB%E7%BB%93.html"/>
      <content type="html"><![CDATA[<p>  推荐：<a href="http://zh.sqlzoo.net/" target="_blank" rel="noopener">在线SQL编辑网站</a></p><h1>一、数据库基础</h1><ol><li>创建数据库</li></ol><p><code>CREATE DATABASE database_name;</code></p><ol start="2"><li>查询数据库</li></ol><p><code>show create database &lt;database_name&gt;;</code></p><ol start="3"><li>删除数据库</li></ol><p><code>drop database &lt;database_name&gt;;</code></p><ol start="4"><li>修改数据库</li></ol><p><code>alter database &lt;database_name&gt; character set &lt;str_coll&gt; collate &lt;rules&gt;</code></p><p><strong>补充</strong>:</p><ul><li>切换数据库 <code>use db_name;</code> -&gt; 当有多个数据库的情况,需要<code>use db_name;</code> 先切换到要操作的数据库</li><li>查看当前正在使用数据库: <code>select database();</code></li></ul><ol start="5"><li>数据表操作:</li></ol><ul><li>创建数据表</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> table_name(</span><br><span class="line">   column_1 column_1_type,</span><br><span class="line">   column_2 column_2_type,</span><br><span class="line">   column_3 column_3_type,</span><br><span class="line">   column_4 column_4_type</span><br><span class="line">);</span><br></pre></td></tr></table></figure><ul><li>技巧：复制表结构</li></ul> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> New_table <span class="keyword">as</span> </span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">from</span> Old_table </span><br><span class="line"><span class="keyword">where</span> <span class="number">1</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure><h2>1. SQL功能概述</h2><p>SQL（Structured Query Language，结构化查询语言）是用户操作关系数据库的通用语言。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520904956/2018_03_06.png" width="80%" height="80%"></p><h2>基本数据类型</h2><table><thead><tr><th>数据类型</th><th>说明</th><th>存储空间</th></tr></thead><tbody><tr><td>bit</td><td>数据类型是整型，其值只能是0、1或空值。(很省空间的一种数据类型，如果能够满足需求应该尽量多用)</td><td>$1$ byte</td></tr><tr><td>tinyint</td><td>数据类型能存储从$0~255$之间的整数。</td><td>$1$ byte</td></tr><tr><td>smallint</td><td>数据类型可以存储从$-32768~32767$之间的整数。这种数据类型对存储一些常限定在特定范围内的数值型数据非常有用</td><td>$2$ byte</td></tr><tr><td>int</td><td>数据类型可以存储从$-2^{31}-2^{31}$之间的整数。存储到数据库的几乎所有数值型的数据都可以用这种数据类型</td><td>$4$ byte</td></tr><tr><td>numeric(p,s) or decimal(p,s)</td><td>数据类型能用来存储从$-10^{38}-1~10^{38}-1$的固定精度和范围的数值型数据。</td><td>$\leq17$byte</td></tr><tr><td>char(n)</td><td>char数据类型用来存储指定长度的定长非统一编码型的数据,$n$表示字符串的最大长度，取值范围为$1~8000$ （若实际字符串控件小于n,系统自动在后面补空格）</td><td>$n$ byte</td></tr><tr><td>varchar(n)</td><td>可变长度的字符串类型,n表示字符串的最大长度。</td><td>字符数+2字节额外开销</td></tr><tr><td>text</td><td>text 数据类型用来存储大量的非统一编码型字符数据。</td><td>每个字符一个字节</td></tr><tr><td>nchar(n)</td><td>用来存储定长统一编码字符型数据。此数据类型能存储4000种字符，使用的字节空间上增加了一倍.</td><td>$2n$ byte</td></tr><tr><td>nvarchar(n)</td><td>数据类型用作变长的统一编码字符型数据。此数据类型能存储4000种字符，使用的字节空间增加了一倍.</td><td>字符数+2字节额外开销</td></tr><tr><td>ntext</td><td>可存储$2^{30}-1$个字符</td><td>每个字符$2$byte</td></tr></tbody></table><p><a href="http://download.csdn.net/detail/u012792686/9757894" target="_blank" rel="noopener">MySQL5中文参考手册</a> -&gt; 部分不知道的字段可以通过这个文档查询</p><h1>二、SQL数据操作语言</h1><h2>1.数据查询语句</h2><h3>1.1 查询语句的基本结构</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> &lt;目标列名序列&gt;  <span class="comment">--需要哪些列</span></span><br><span class="line">    <span class="keyword">From</span> &lt;表名&gt;      <span class="comment">--来自哪张表</span></span><br><span class="line">    [<span class="keyword">WHERE</span> &lt;行选择条件&gt;]</span><br><span class="line">    [<span class="keyword">GROUP</span> <span class="keyword">BY</span> &lt;分组依据列&gt;]</span><br><span class="line">    [<span class="keyword">HAVING</span> &lt;组&gt;]</span><br><span class="line">    [<span class="keyword">ORDER</span> <span class="keyword">BY</span> &lt;排序依据列&gt;]</span><br></pre></td></tr></table></figure><p><code>SELECT</code>子句用于指定输出的字段</p><p><code>FROM</code>子句用于指定数据的来源</p><p><code>WHERE</code>子句用于指定数据的选择条件</p><p><code>GROUP BY</code>子句用于对检索到的记录进行分组</p><p><code>HAVING</code> 子句用于指定组的选择条件</p><p><code>ORDER BY</code> 子句用于对查询的结果进行排序</p><h3>1.2 单表查询</h3><ol><li>选择表中列数据</li></ol><p><code>SELECT &lt;column_name[*]&gt; FROM &lt;table_name&gt;</code></p><p>例子 ：<code>SELECT Sname,year(getdata()) - year(Birthdate) FROM Student</code></p><ol start="2"><li>选择表中的若干元祖</li></ol><ul><li>消除取值相同的行：<code>DISTINCT</code></li></ul><p><code>SELECT DISTINCT &lt;val&gt; FROM &lt;table_name&gt;</code></p><p>例子 ：<code>SELECT DISTINCT Tom FROM Student</code></p><ul><li>查询满足条件的元组</li></ul><table><thead><tr><th>查询条件</th><th>谓 词</th></tr></thead><tbody><tr><td>比较</td><td>=、&gt;、&gt;=、&lt;=、&lt;、&lt;&gt;、!=、!&gt;、!&lt;</td></tr><tr><td>确定范围</td><td>BETWEy …AND、 NOT BETWEy …AND</td></tr><tr><td>确定集合</td><td>IN 、NOT IN</td></tr><tr><td>字符匹配</td><td>LIKE 、NOT LIKE</td></tr><tr><td>空值</td><td>IS NULL、IS NOT NULL</td></tr><tr><td>多重条件（逻辑谓词）</td><td>AND、OR</td></tr></tbody></table><ol start="3"><li>对查询结果进行排序:将查询结果按照指定的顺序显示。<code>ASC</code>表示按列值升序排列（从上往下，值从大到小）。<code>DESC</code>表示按列值降序排列（从上往下，值从小到大）, 默认为<code>ASC</code>。</li></ol><p><code>ORDER BY &lt;column_name&gt; [ASC|DESC]</code></p><p>例子 ：<code>SELECT Sno,Grade FROM SC ORDER BY Grade DESC</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 用 row_number 排序</span></span><br><span class="line">row_number() over(partition by [分组字段] order by [排序字段] desc) as row_number</span><br></pre></td></tr></table></figure><ol start="4"><li>使用聚合函数统计数据:聚合函数也称为统计函数或集合函数，作用是对一组值进行计算并返回一个统计结果。</li></ol><table><thead><tr><th>聚合函数</th><th>含义</th></tr></thead><tbody><tr><td>COUNT(*)</td><td>统计表中元组的个数</td></tr><tr><td>COUNT([DISTINCT]&lt;column_name&gt;)</td><td>统计本列的非空列值个数</td></tr><tr><td>SUM(&lt;column_name&gt;)</td><td>计算列值的和值（必须是数值型列）</td></tr><tr><td>AVG(&lt;column_name&gt;)</td><td>计算列值的平均值（必须是数值型列）</td></tr><tr><td>MAX(&lt;column_name&gt;)</td><td>计算列值的最大值</td></tr><tr><td>MIN(&lt;column_name&gt;)</td><td>计算列值的最小值</td></tr></tbody></table><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（统计学生总人数）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*) <span class="keyword">FROM</span> Student</span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计“001”学号学生的考试平均成绩）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(Grade) <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Sno = <span class="string">'001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询“C001”号课程考试成绩的最高分和最低分）</span></span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(Grade) 最高分,<span class="keyword">MIN</span>(Grade) 最低分 <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br></pre></td></tr></table></figure><p>注意：聚合函数不能出现在 <code>WHERE</code> 子句中！</p><ol start="5"><li>对数据进行分组统计:需要先对数据进行分组，然后再对每个组进行统计。分组子句<code>GROUP BY</code>。在一个查询语句中，可以用多个列进行分组。分组子句跟在<code>WHERE</code>子句的后面：</li></ol><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GROUP BY &lt;分组依据列&gt;[,...n]</span><br><span class="line">    [HAVING &lt;组筛选条件&gt;]</span><br></pre></td></tr></table></figure><h3>1.3 多表连接查询</h3><p>若一个查询同时涉及到两张或以上的表，则称为连接查询。</p><p>####1. 内连接:使用内连接时，如果两个表的相关字段满足条件，则从两个表中提取数据组成新的记录。</p><p><code>FROM &lt;table1&gt; [INNER] JOIN &lt;table2&gt; ON &lt;Join Condition&gt;</code></p><p>注意：连接条件中的连接字段必须是可比的，必须是语义相同的列。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询学生及选课的详细信息）</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.Sno = SC.Sno</span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询计算机系学生的选课情况，列出该学生的名字、所修课程号、成绩）---行选择条件</span></span><br><span class="line"><span class="keyword">SELECT</span> Sname,Cno,Grade <span class="keyword">FROM</span> Student <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> Student.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计每个系的平均成绩） ---分组的多表查询</span></span><br><span class="line"><span class="keyword">SELECT</span> Dept,<span class="keyword">AVG</span>(Grade) <span class="keyword">AS</span> AverageGrade <span class="keyword">FROM</span> Student S <span class="keyword">INNER</span> <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">Group</span> <span class="keyword">BY</span> Dept</span><br><span class="line"></span><br><span class="line"><span class="comment">--（统计计算机系每个学生的选课门数、平均成绩、最高成绩、最低成绩）--分组和行选择条件的多表连接查询</span></span><br><span class="line"><span class="keyword">SELECT</span> Sno,<span class="keyword">COUNT</span>(*),<span class="keyword">AVG</span>(Grade),<span class="keyword">MAX</span>(Grade),<span class="keyword">MIN</span>(Grade) <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span> <span class="keyword">Group</span> <span class="keyword">BY</span> Dept</span><br></pre></td></tr></table></figure><h4>补充：</h4><p><font color="blue">INNER JOIN连接三个表、五个表以上时的SQL语句</font></p><ul><li>连接三个数据表，语法格式可以概括为：</li></ul><p>FROM (table1 INNER JOIN table2 ON table1.key = table2.key) INNER JOIN table3 ON table1.key = table3.key</p><ul><li>连接四个数据表，语法格式可以概括为：</li></ul><p>FROM ((table1 INNER JOIN table2 ON table1.key=table2.key) INNER JOIN table3 ON table1.key=table3.key) INNER JOIN table4 ON Member.key=table4.key</p><blockquote><p>遵循的规则就是从内而外依次执行</p></blockquote><h4>2. 自连接:</h4><p>自连接是一种特殊的内连接，相互连接的表在物理上是一张表，但在逻辑上可以看做是两张表。</p><p><code>FROM &lt;table1&gt; AS T1 JOIN &lt;table1&gt; AS T2</code></p><p>通过为表取别名的方法，可以让物理上的一张表在逻辑上成为两张表。<font color="blue">（一定要为表取别名！）</font></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询与刘晨在同一个系学习的学生的姓名、所在系）</span></span><br><span class="line"><span class="keyword">SELECT</span> S1.Sname,S1.Dept <span class="keyword">FROM</span> Student S1 <span class="keyword">JOIN</span> Student S2 </span><br><span class="line"><span class="keyword">ON</span> S1.Dept = S2.Dept   <span class="comment">--同一个系的学生</span></span><br><span class="line"><span class="keyword">WHERE</span> S2.Sname = <span class="string">'刘晨'</span>  <span class="comment">--S2表作为查询条件</span></span><br><span class="line"><span class="keyword">AND</span> S1.Sname != <span class="string">'刘晨'</span>  <span class="comment">--S1表作为结果表，并从中去掉‘刘晨’本人信息</span></span><br></pre></td></tr></table></figure><h4>3. 外连接:</h4><p>在内连接操作中，只有满足条件的元祖才能出现在查询结果集中。外连接是只限制一张表中的数据必须满足条件，而另一张表的数据可以不满足条件。</p><p><code>FROM &lt;table1&gt; LEFT|RIGHT [OUTER] JOIN &lt;table2&gt; ON &lt;Join Condition&gt;</code></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LEFT [OUTER] JOIN <span class="comment">--称为左外连接，含义是限制表2中的数据必须满足条件，但不管表1中的数据是否满足条件，均输出表1中的数据。 </span></span><br><span class="line">LEFT [OUTER] JOIN <span class="comment">--称为右外连接，含义是限制表1中的数据必须满足条件，但不管表2中的数据是否满足条件，均输出表2中的数据。</span></span><br></pre></td></tr></table></figure><h2>2.数据更改功能</h2><h3>2.1 插入数据</h3><p><code>INSERT INTO &lt;table_name&gt;[(column_name)] VALUES (val)</code></p><p>（1）简单插入语句</p><p>INSERT INTO Student VALUES (‘001’,‘陈东’,‘男’,‘1996/6/23’,‘信息管理系’)</p><p>（2）多行插入语句</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> SC <span class="keyword">VALUES</span>(<span class="string">'001'</span>,<span class="string">'C001'</span>,<span class="number">90</span>),</span><br><span class="line">                     (<span class="string">'001'</span>,<span class="string">'C002'</span>,<span class="number">30</span>),</span><br><span class="line">                     (<span class="string">'001'</span>,<span class="string">'C005'</span>,<span class="literal">NULL</span>)</span><br></pre></td></tr></table></figure><p>（3）不按表顺序插入语句</p><p>按与表列顺序不同的顺序插入数据<code>INSERT INTO Student(Sno,Sname,Sex,Dept) VALUES ('001','陈东','男','1996/6/23','信息管理系')</code></p><h3>2.2 更新数据</h3><p><code>UPDATE &lt;table_name&gt; SET column_name = val</code></p><p>（1）无条件更新</p><p><code>UPDATE SC SET Grade = Grade+10</code></p><p>（2）有条件更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（将“C001”号课程的学分改成5分）</span></span><br><span class="line"><span class="keyword">UPDATE</span> Course <span class="keyword">SET</span> Grade = <span class="number">5</span> <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（将计算机系全体学生的成绩加5分）</span></span><br><span class="line"><span class="keyword">UPDATE</span> SC <span class="keyword">SET</span> Grade = Grade+<span class="number">5</span> <span class="keyword">FROM</span> SC <span class="keyword">JOIN</span> Student S <span class="keyword">ON</span> S.Sno = SC.Sno <span class="keyword">WHERE</span> Dept = <span class="string">'计算机系'</span></span><br></pre></td></tr></table></figure><h3>2.3 删除数据</h3><p><code>DELETE [TOP (expression) [PERCENT]] FROM &lt;table_name&gt;</code></p><p>（1）无条件删除</p><p><code>DELETE FROM Student</code></p><p>（2）有条件删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（删除所有考试成绩不合格的学生的选课记录）</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> SC <span class="keyword">WHERE</span> Grade &lt; <span class="number">60</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（删除Student表中2.5%的行数据）</span></span><br><span class="line"><span class="keyword">DELETE</span> TOP (<span class="number">2.5</span>) <span class="keyword">PERCENT</span> <span class="keyword">FROM</span> Student</span><br></pre></td></tr></table></figure><h1>三、高级查询</h1><h2>1. CASE函数</h2><p>CASE函数是一种多分支函数，它可以根据条件列表的值返回多个可能的结果表达式中的一个。</p><h3>1.1 简单CASE函数</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE input_expression</span><br><span class="line">    WHEN when_expression THEN result_expression</span><br><span class="line">    [...n]</span><br><span class="line">    [ELSE else_expression]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><ul><li><code>input_expression</code>：所计算的表达式，可以是一个变量名、字段名、函数或子查询。</li><li><code>when_expression</code> ：要与input _expression进行比较的简单表达式。简单表达式中不可包含比较运算法，只需给出被比较的表达式或值。</li><li><code>else_expression</code> ： 比较结果均不为TRUE时返回的表达式。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">--（查询选了JAVA课程的学生的学号、姓名、所在系、成绩，</span></span><br><span class="line"><span class="comment">--若所在系为“计算机系”，则显示“CS”；若所在系为“信息管理系”，则显示“IM”；若所在系为“通信工程系”，则显示“COM”）</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> Dept</span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'计算机系'</span> <span class="keyword">THEN</span> <span class="string">'CS'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'信息管理系'</span> <span class="keyword">THEN</span> <span class="string">'IM'</span></span><br><span class="line">        <span class="keyword">WHEN</span> <span class="string">'通信工程系'</span> <span class="keyword">THEN</span> <span class="string">'COM'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 所在系,Grade 成绩</span><br><span class="line">    <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno </span><br><span class="line">    <span class="keyword">JOIN</span> Course C <span class="keyword">ON</span> C.Cno = SC.Cno</span><br><span class="line">    <span class="keyword">WHERE</span> Cname = <span class="string">'Java'</span></span><br></pre></td></tr></table></figure><h3>1.2 搜索CASE函数</h3><p>简单 CASE函数只能将<code>input_expression</code>与一个单值进行比较，如果需要跟一个范围内的值进行比较，就需要搜索<code>CASE</code>函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">CASE </span><br><span class="line">    WHEN Boolean_expression THEN result_expression</span><br><span class="line">    [...n]</span><br><span class="line">    [ELSE else_expression]</span><br><span class="line"><span class="keyword">END</span></span><br></pre></td></tr></table></figure><p><code>Boolean_expression</code> ：比较表达式，可以包含比较运算符，直接将两者进行比较。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 上述例子也可以用搜索CASE函数：</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'计算机系'</span> <span class="keyword">THEN</span> <span class="string">'CS'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'信息管理系'</span> <span class="keyword">THEN</span> <span class="string">'IM'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Dept = <span class="string">'通信工程系'</span> <span class="keyword">THEN</span> <span class="string">'COM'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 所在系,Grade 成绩</span><br><span class="line">    <span class="keyword">FROM</span> Student S <span class="keyword">JOIN</span> SC <span class="keyword">ON</span> S.Sno = SC.Sno </span><br><span class="line">    <span class="keyword">JOIN</span> Course C <span class="keyword">ON</span> C.Cno = SC.Cno</span><br><span class="line">    <span class="keyword">WHERE</span> Cname = <span class="string">'Java'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--（查询C001课程的考试情况，列出学号和成绩，然后根据成绩划分等级）</span></span><br><span class="line"><span class="keyword">SELECT</span> S.Sno 学号,Sname 姓名,</span><br><span class="line">    <span class="keyword">CASE</span> </span><br><span class="line">        <span class="keyword">WHEN</span> Grade &gt;= <span class="number">90</span> <span class="keyword">THEN</span> <span class="string">'优'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">80</span> <span class="keyword">AND</span> <span class="number">99</span> <span class="keyword">THEN</span> <span class="string">'良'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">70</span> <span class="keyword">AND</span> <span class="number">79</span> <span class="keyword">THEN</span> <span class="string">'中'</span></span><br><span class="line">        <span class="keyword">WHEN</span> Grade <span class="keyword">BETWEEN</span> <span class="number">60</span> <span class="keyword">AND</span> <span class="number">69</span> <span class="keyword">THEN</span> <span class="string">'及格'</span></span><br><span class="line">    <span class="keyword">END</span> <span class="keyword">AS</span> 成绩</span><br><span class="line">    <span class="keyword">FROM</span>  SC <span class="keyword">ON</span> <span class="keyword">WHERE</span> Cno = <span class="string">'C001'</span></span><br></pre></td></tr></table></figure><h2>2. 子查询</h2><p>如果一个<code>SELECT</code>语句嵌套在另一个<code>SELECT</code>、<code>INSERT</code>、<code>UPDATE</code>或<code>DELETE</code>语句中，则称为子查询或内层查询；而包含子查询的语句称为主查询。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> cunstomers</span><br><span class="line"><span class="keyword">WHERE</span> cust_id <span class="keyword">IN</span>(<span class="keyword">SELECT</span> cust_id </span><br><span class="line">        <span class="keyword">FROM</span> orders </span><br><span class="line">        <span class="keyword">WHERE</span> order_num <span class="keyword">IN</span> (<span class="keyword">SELECT</span> order_num </span><br><span class="line">                <span class="keyword">FROM</span> orderitems </span><br><span class="line">                <span class="keyword">WHERE</span> prod_id = <span class="string">'TN2'</span>););</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 使用联结操作简化子查询</span></span><br><span class="line"><span class="keyword">SELECT</span> cust_name,cust_contact</span><br><span class="line"><span class="keyword">FROM</span> cunstomers,orders,orderitems <span class="comment">--good</span></span><br><span class="line"><span class="keyword">WHERE</span> cunstomers.cust_id = orders.cust_id</span><br><span class="line"><span class="keyword">AND</span> orderitems.order_num = orders.order_num</span><br><span class="line"><span class="keyword">AND</span> prod_id = <span class="string">'TN2'</span>;</span><br></pre></td></tr></table></figure><p>子查询通常用于满足下列需求之一：</p><ul><li>把一个查询分解成一系列的逻辑步骤</li><li>提供一个列表作为<code>WHERE</code>子句和<code>IN</code>、<code>EXISTS</code>、<code>ANY</code>、<code>ALL</code>的目标对象</li><li>提供由外层查询中每一条记录驱动的查询</li></ul><p>子查询通常有几种形式：</p><ul><li><code>WHERE 列名 [NOT] IN (子查询)</code></li><li><code>WHERE 列名 比较运算符 (子查询)</code></li><li><code>WHERE EXISTS(子查询)</code></li></ul><h1>四、其他</h1><h3>1. 年月日相关</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> </span><br><span class="line"><span class="keyword">from</span> dual;</span><br></pre></td></tr></table></figure><h2>2. Decode语句</h2><p><code>decode(condition,val_1,return_1,val_2,return_2,...,val_n,return_n,default)</code></p><p>可以类比语句理解：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">IF condition = val_1 THEN</span><br><span class="line">　　　　RETURN(gval_1)</span><br><span class="line">ELSIF condition = val_2 THEN</span><br><span class="line">　　　　RETURN(gval_2)</span><br><span class="line">ELSIF condition = val_n THEN</span><br><span class="line">　　　　RETURN(gval_n)</span><br><span class="line">ELSE</span><br><span class="line">　　　　RETURN(default)</span><br><span class="line"><span class="keyword">END</span> <span class="keyword">IF</span></span><br></pre></td></tr></table></figure><h2>3. Use_hash</h2><h2>4. Over() function</h2><p>常见的分析函数如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">row_number() over(partition by ... order by ...)</span><br><span class="line">rank() over(partition by ... order by ...)</span><br><span class="line">dense_rank() over(partition by ... order by ...)</span><br><span class="line">count() over(partition by ... order by ...)</span><br><span class="line">max() over(partition by ... order by ...) </span><br><span class="line">min() over(partition by ... order by ...)</span><br><span class="line">sum() over(partition by ... order by ...)</span><br><span class="line">avg() over(partition by ... order by ...)</span><br><span class="line">first_value() over(partition by ... order by ...)</span><br><span class="line">last_value() over(partition by ... order by ...)</span><br><span class="line">lag() over(partition by ... order by ...)</span><br><span class="line">lead() over(partition by ... order by ...)</span><br></pre></td></tr></table></figure><h2>4. sql * load</h2><p>SQL*Loader是Oracle提供的用于数据加载的一种工具，它比较适合业务分析类型数据库（数据仓库），能处理多种格式的平面文件，批量数据装载比传统的数据插入效率更高。以<code>sqlldr</code>命令参数执行。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1537061180/sqlload.jpg" width="80%" height="80%"><p>使用sql*loader上传数据，必须指定 控制文件(Control File) (.ctl),</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">load data</span><br><span class="line">infile &apos;example.dat&apos;  &quot;var 3&quot;</span><br><span class="line">into table example</span><br><span class="line">fields terminated by &apos;,&apos; optionally enclosed by &apos;&quot;&apos;</span><br><span class="line">(col1 char(5),</span><br><span class="line"> col2 char(7))</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数据分析 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
            <tag> SQL </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>VC维理论-统计学习理论基础</title>
      <link href="/VC%E7%BB%B4%E7%90%86%E8%AE%BA-%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA%E5%9F%BA%E7%A1%80.html"/>
      <content type="html"><![CDATA[<p>目录：</p><ul><li>说说历史</li><li>Hoeffding不等式</li><li>Connection to Learning</li><li>学习可行的两个核心条件</li><li>Effective Number of Hypotheses</li><li>Growth Function</li><li>Break Point与Shatter</li><li>VC Bound</li><li>VC dimension</li><li>深度学习与VC维</li><li>小结</li><li>参考文献</li></ul><p>VC维在机器学习领域是一个很基础的概念，它给诸多机器学习方法的可学习性提供了坚实的理论基础，但有时候，对我们而言，SVM，LR，深度学习等可能都已经用到线上了，但却不理解VC维。</p><p>这里，在台湾大学<a style="color: #109eff" href="https://www.coursera.org/course/ntumlone" target="_blank" rel="noopener">机器学习基石</a>课程的基础上，我们简单聊聊“VC维的来龙去脉”。我们将解决以下问题：为什么某机器学习方法是可学习的？为什么会有过拟合？拿什么来衡量机器学习模型的复杂度？深度学习与VC维的关系？</p><h2>说说历史</h2><p>在讲VC维之前，我们不妨来说说VC维的历史。而说起VC维的历史，又不得不提起神经网络，一方面是因为神经网络与VC维的发明过程是交织在一起的，另一方面是由于神经网络乏善可陈的泛化控制方法，深度学习在理论基础上一直被怀疑，甚至神经网络和VC维的代表SVM还一起争风吃醋过好多年。</p><ul><li>1943年，模拟神经网络由麦卡洛可（McCulloch）和皮茨（Pitts)提出，他们分析了理想化的人工神经元网络，并且指出了它们进行简单逻辑运算的机制。</li><li>1957年，康奈尔大学的实验心理学家弗兰克·罗森布拉特(Rosenblatt)在一台IBM–704计算机上模拟实现了一种他发明的叫作“感知机”（Perceptron）的神经网络模型。神经网络与支持向量机都源自于感知机（Perceptron）。</li><li>1962年，罗森布拉特著作：《神经动力学原理：感知机和大脑机制的理论》（Principles of Neurodynamics: Perceptrons and the Theory of Brain Mechanisms）。</li><li>1969年，明斯基和麻省理工学院的另一位教授佩普特合作著作：《感知机：计算几何学》（Perceptrons: An Introduction to Computational Geometry)。在书中，明斯基和佩普特证明单层神经网络不能解决XOR（异或）问题。</li><li>1971年，V. Vapnik and A. Chervonenkis在论文“On the uniform convergence of relative frequencies of events to their probabilities”中提出<strong>VC维</strong>的概念。</li><li>1974年，V. Vapnik提出了结构风险最小化原则。</li><li>1974年，沃波斯（Werbos）的博士论文证明了在神经网络多加一层，并且利用“后向传播”（Back-propagation）学习方法，可以解决XOR问题。那时正是神经网络研究的低谷，文章不合时宜。</li><li>1982年，在加州理工担任生物物理教授的霍普菲尔德，提出了一种新的神经网络，可以解决一大类模式识别问题，还可以给出一类组合优化问题的近似解。这种神经网络模型后被称为霍普菲尔德网络。</li><li>1986年，Rummelhart与McClelland发明了神经网络的学习算法Back Propagation。</li><li>1993年，Corinna Cortes和Vapnik等人提出了支持向量机(support vector machine)。神经网络是多层的非线性模型，支持向量机利用核技巧把非线性问题转换成线性问题。</li><li>1992~2005年，SVM与Neural network之争，但被互联网风潮掩盖住了。</li><li>2006年，Hinton提出神经网络的Deep Learning算法。Deep Learning假设神经网络是多层的，首先用Restricted Boltzmann Machine（非监督学习）学习网络的结构，然后再通过Back Propagation（监督学习）学习网络的权值。</li><li>现在，deep learning的应用越来越广泛，甚至已经有超越SVM的趋势。一方面以Hinton，Lecun为首的深度学习派坚信其有效实用性，另一方面Vapnik等统计机器学习理论专家又坚持着理论阵地，怀疑deep learning的泛化界。</li></ul><h2>Hoeffding不等式</h2><p>Hoeffding不等式是关于一组随机变量均值的概率不等式。 如果$X_1,X_2,\cdots,X_n$为一组独立同分布的参数为$p$的伯努利分布随机变量，$n$为随机变量的个数。定义这组随机变量的均值为：$$\bar{X}=\frac{X_1+X_2+\cdots+X_n}{n}$$</p><p>对于任意$\sigma &gt; 0$, Hoeffding不等式可以表示为</p><p>$$P(|\bar{X}-E(\bar{X})|\geq \sigma) \leq exp(-2{\sigma}^2n^2)$$</p><p>更多请参考:<a style="color: #109eff" href="http://science.scileaf.com/library/2461" target="_blank" rel="noopener">Hoeffding不等式</a>，<a style="color: #109eff" href="http://zh.wikipedia.org/zh-cn/%E9%9B%86%E4%B8%AD%E4%B8%8D%E7%AD%89%E5%BC%8F" target="_blank" rel="noopener">集中不等式</a></p><h3>示例:</h3><p>在统计推断中，我们可以利用样本的统计量(statistic)来推断总体的参数(parameter)，譬如使用样本均值来估计总体期望。如下图所示，我们从罐子里抽球，希望估计罐子里红球和绿球的比例。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780790/2018_03_04_01bin_sample.png" alt="bin_sample" width="60%" height="60%">直觉上，如果我们有更多的样本(抽出更多的球)，则样本期望$v$应该越来越接近总体期望$\mu $。事实上，这里可以用hoeffding不等式表示如下：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780789/2018_03_04_02.png" width="50%" height="50%">从hoeffding不等式可以看出，当$n$逐渐变大时，不等式的UpperBound越来越接近0，所以样本期望越来越接近总体期望。</p><h2>Connection to Learning</h2><p>接下来，我们希望可以将机器学习关联到上一节讨论的hoeffding不等式。一个基本的机器学习过程如下图所示。其中的概念定义为：</p><ul><li>$f$ 表示理想的方案(可以是一个函数，也可以是一个分布)</li><li>$H$ 是该机器学习方法的假设空间</li><li>$g$ 表示我们求解的用来预测的假设，$g$属于$H$</li></ul><p><font color="blue">机器学习的过程就是：通过算法$A$，在假设空间$H$中，根据样本集$D$，选择最好的假设作为$g$。选择标准是$g$近似于$f$。</font><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520780789/2018_03_04_03.png" width="80%" height="80%"></p><p>拿<a style="color: #109eff" href="http://zh.wikipedia.org/zh/%E6%84%9F%E7%9F%A5%E5%99%A8" target="_blank" rel="noopener">感知机(perceptron)</a>来举例。</p><p>感知机（perceptron）是一个线性分类器(linear classifiers）。 线性分类器的几何表示：直线、平面、超平面。</p><p>perceptron的假设空间，用公式描述，如下所示：$$h(x)=sign((\sum_{i=1}^{n})-threshod)$$</p><p>感知器的优化目标如下式所示，$w_g$就是我们要求的最好的假设。$$W_g\rightarrow argmin\sum_{n=1}^{N}\left [y_n \neq sign(W^Tx_n)  \right ]$$</p><p>设定两个变量，如下图所示，图中 $f(x)$表示理想目标函数，$h(x)$是我们预估得到的某一个目标函数，$h(x)$是假设空间$H$中的一个假设。<strong>$E_{out}(h)$</strong>，可以理解为在理想情况下(已知f)，总体(out-of-sample)的损失(这里是0–1 loss)的期望，称作expected loss。<strong>$E_{in}(h)$</strong>，可以理解为在训练样本上(in-of-sample)，损失的期望，称作expirical loss。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781757/2018_03_05learning_hoeffding.png" width="80%" height="80%"><p>当训练样本量$N$足够大，且样本是独立同分布的，类比于上面“抽球”的例子，可以通过样本集上的expirical loss $E_{in}(h)$ 推测总体的expected loss $E_{out}(h)$。基于Hoeffding不等式，我们得到下面式子：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781760/2018_03_05_02.png" width="80%" height="80%">根据上面不等式，我们可以推断，当$N$足够大时，expected loss和expirical loss将非常接近。注意在上面推导中，我们是针对某一个特定的解$h(x)$。在我们的假设空间$H$中，往往有很多个假设函数(甚至于无穷多个)，这里我们先假定$H$中有$M$个假设函数。那么对于整个假设空间，也就是这M个假设函数，可以推导出下面不等式：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781758/2018_03_05hoeffding_12.png" width="80%" height="80%"></p><p>上面式子的含义是：在假设空间$H$中，设定一个较小的$\epsilon$值，任意一个假设$h$，它的$E_{in}(h)$与$E_{out}(h)$的差由该值$2\cdot M\cdot exp{-2\epsilon^2\cdot N}$所约束住。注意这个bound值与 “样本数$N$和假设数$M$” 密切相关。</p><h2>学习可行的两个核心条件</h2><p>在往下继续推导前，先看一下<strong>什么情况下Learning是可行的</strong>?</p><p>如果假设空间$H$的size M是有限的，当$N$足够大时，那么对假设空间中任意一个$g$，$E_{out}(g)$约等于$E_{in}(g)$；利用算法A从假设空间$H$中，挑选出一个$g$，使得$E_{in}(g)$接近于0，那么<a style="color: #109eff" href="http://en.wikipedia.org/wiki/Probably_approximately_correct_learning" target="_blank" rel="noopener">probably approximately correct</a>而言，$E_{out}(g)$也接近为0；</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781759/2018_03_05x.png" width="80%" height="80%">上面这两个核心条件，也正好对应着test和train这两个过程。train过程希望损失期望(即$E_{in}(g)$)尽可能小；test过程希望在真实环境中的损失期望也尽可能小，即$E_{in}(g)$接近于$E_{out}(g)$。<p>但往往我们更多在关心，如何基于模型的假设空间，利用最优化算法，找到$E_{in}$最小的解$g$。但容易忽视test这个过程，如果让学习可行，不仅仅是要在训练集表现好，在真实环境里也要表现好。从上述推导出来的不等式，我们看到假设数$M$在这两个核心条件中有着重要作用。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520781760/2018_03_05.png" width="80%" height="80%"></p><p>$M$太小，当$N$足够大时，$E_{in}和$E_{out}$比较接近，但如果候选假设集太小，不容易在其中找到一个$g$，使得$E_{in}(g)$约等于0，第二项不能满足。而如果$M$太大，这时候选集多了，相对容易在其中找到一个$g$，使得$E_{in}(g)$约等于0，但第一项就不能满足了。所以假设空间$H$的大小$M$很关键。</p><p>对于一个假设空间，$M$可能是无穷大的。要能够继续推导下去，那么有一个直观的思路，能否找到一个有限的因子$m_H$来替代不等式bound中的$M$。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_06.png" width="80%" height="80%"><p>虽说假设空间很大，上述推导里，我们用到了$P(h_1,h_2,\cdots ,h_m) \leq P(h_1) + P(h_2) + \cdots + P(h_m)$。但事实上，多个$h$之间并不是完全独立的，他们是有很大的重叠的，也就是在$M$个假设中，可能有一些假设可以归为同一类。</p><p>下面我们以二维假设空间为例，来解释一下该空间下各假设在确定的训练样本上的重叠性。</p><p>举例来说，如果我们的算法要在平面上(二维空间)挑选一条直线方程作为$g$，用来划分一个点$x_1$。假设空间$H$是所有的直线，它的size M是无限多的。但是实际上可以将这些直线分为两类，一类是把$x_1$判断为正例的，另一类是把$x_1$判断为负例的。如下图所示：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_07.png" width="50%" height="50%"></p><p>那如果在平面上有两个数据点$x_1,x_2$，这样的话，假设空间$H$中的无数条直线可以分为4类。那依次类推，3个数据点情况下，$H$中最多有8类直线。4个数据点，$H$中最多有14类直线<font color="blue">(注意：为什么不是16类直线)</font>。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_08.png" width="60%" height="60%">从上面在二维假设空间中的分析，我们可以推测到一个结论，假设空间size M是很大，但在样本集$D$上，有效的假设函数数目是有限的。接下来我们将继续推导这个有效的假设函数值。</p><h2>Effective Number of Hypotheses</h2><p>对于这个有效的假设函数值，我们尝试用一个数学定义来说明：从$H$中任意选择一个方程$h$，让这个$h$对样本集合$D$进行二元分类，输出一个结果向量。例如在平面里用一条直线对2个点进行二元分类，输出可能为${1,–1}，{–1,1}，{1,1}，{–1,–1}$，这样每个输出向量我们称为一个dichotomy。</p><p>下面是hypotheses与dichotomies的概念对比：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782701/2018_03_05_09.png" width="80%" height="80%">注意到，如果对平面上的4个点来分类，根据前面分析，输出的结果向量只有14种可能，即有14个dichotomies。如果有$N$个样本数据，那么有效的假设个数定义为： $effective(N) = H$作用于样本集$D$“最多”能产生多少不同的dichotomy。所以有一个直观思路，能否用$effective(N)$来替换Hoeffding不等式中的M。接下来我们来分析下$effective(N)$。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782700/2018_03_05_10.png" width="80%" height="80%"><h2>Growth Function</h2><p>$H$作用于$D$“最多”能产生多少种不同的dichotomies？</p><p>这个数量与假设空间$H$有关，跟数据量$N$也有关。将$H$作用于$D$“最多”能产生的dichotomies数量(即effective(N) )表示为数学符号：$max_H(x_1,x_2,\cdots,x_N)$</p><p>这个式子又称为“成长函数”(growth function)。在$H$确定的情况下，growth function是一个与$N$相关的函数。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520782701/2018_03_05_11.png" width="80%" height="80%"></p><p>下图举4个例子，分别计算其growth function：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783290/2018_03_05_12.png" width="80%" height="80%">对于第一个例子，positive ray，相当于是正向的射线。该假设空间，作用于1个样本点，可以产生2种dichotomies：(–1)，(+1)。作用于2个样本点，可以产生3种dichotomies：(–1,+1)，(–1,–1)，(+1,+1)。作用于3个样本点，可以产生4种dichotomies。依次类推，可以推导出其成长函数 $m_H(N)=N+1$；求解出$m_H(N)$后，那是不是可以考虑用$m_H(N)$替换$M$? 如下所示：$$P[|E_{in}(g)-E_{out}(g)|>\epsilon]\leq 2\cdot m_H(N)\cdot N $$<h2>Break Point与Shatter</h2><p>在进一步推导前，再看两个概念：<font color="blue">shatter，break point。</font></p><p><strong>Shatter的概念</strong>：当假设空间H作用于$N$个input的样本集时，产生的dichotomies数量等于这$N$个点总的组合数$2N$是，就称：这$N$个inputs被$H$给shatter掉了。</p><p>要注意到 shatter 的原意是“打碎”，在此指“$N$个点的所有(碎片般的)可能情形都被H产生了”。所以$m_{H}=2N$的情形是即为“shatter”。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520784111/2018_03_05_13.png"><p>对于给定的成长函数$m_H(N)$，从$N=1$出发，$N$慢慢变大，当增大到$k$时，出现$m_{H}(N)&lt;2k$的情形，则我们说k是该成长函数的<strong>break point</strong>。对于任何$N&lt; k$个inputs而言，$H$都没有办法再shatter他们了。</p><p>举例来说，对于上面的positive ray的例子，因为$m_H(N)=N+1$，当$N=2$时，$m_H(2)&lt;2^2$， 所以它的break point就是2。</p><h2>VC Bound</h2><p>说完break point的概念后，再回到成长函数。我们将成长函数的上界，设为$B(N,k)$，意为：maximum possible $m_H(N)$ when $break point = k$。</p><p>那么我们做一些简单的推导：</p><ul><li>$B(2,2)=3$。因为break point=2，任意两个点都不能被shatter，$m_H(2)$肯定小于$2^2$，所以$B(2,2)=3$。</li><li>$B(3,2)=4$。因为任意两个点都不能被shatter，那么3个点产生的dichotomies不能超过4，所以$B(3,2)=4$。</li><li>$B(N,1)=1$。</li><li>$B(N,k)=2^N \quad for \quad N &lt; k$;$\qquad B(N,k)=2^{N–1} \quad for \quad N=k$；</li><li>$B(4,3)=？$去掉其中的一个数据点$x_4$后，考虑到break point=3，余下数据$(x1,x2,x3)$的dichotomies数目不能超过$B(3,3)$。当扩展为$(x1,x2,x3,x4)$时，$(x1,x2,x3)$上的dichotomies只有部分被重复复制了，设被复制的dichotomies数量为$a$，未被复制的数量为$b$。于是有$B(3,3) = a+b; B(4,3) = 2a + b$。因为$a$被复制了，表示$x_4$有两个取值，那么$(x1,x2,x3)$上的$a$应该小于等于$B(3,2)$。所以推导出$B(4,3) = 2a + b \leq B(3,3) + B(3,2)$。对于任意$N&gt;k$，类推可以得到，$B(N,k) \leq B(N−1,k)+B(N−1,k−1)$</li></ul><p>最后利用数学归纳法，可以证明得到下面的bounding function($N&gt;k$)：$$m_H{N}\leq \sum_{i=0}^{k-1}\binom{N}{i}$$</p><p>这个式子显然是多项式的，多项式的最高幂次项为：$N^{k–1}$。</p><p>所以我们得到结论：如果break point存在（有限的正整数），生长函数$m_{H}(N)$是多项式的。</p><p>再重复一遍，$H$作用于数据量为$N$的样本集$D$，方程的数量看上去是无穷的，但真正有效(effective)的方程的数量却是有限的，这个数量为$m_H(N)$。$H$中每一个$h$作用于$D$都能算出一个$E_{in}$来，一共有$m_H(N)$个不同的$E_{in}$。</p><p>OK，到目前为止，关于$m_H(N)$的推导结束。回到growth function小节提出的问题，能否用<strong>$m_H(N)$直接替换M?</strong></p><p>既然得到了$m_H(N)$的多项式上界，我们希望对之前的不等式中$M$进行替换，用$m_H(N)$来替换$M$。这样替换后，当break point存在时，$N$足够大时，该上界是有限的。$$P[h\in H\quad s.t \quad |E_{in}(h)-E_{out}(h)|&gt;\epsilon]\leq 2 \\m_{H}N\cdot exp(-2\cdot {\epsilon}^2\cdot N)$$</p><p>然而直接替换是存在问题的，主要问题是：$E_{in}$的可能取值是有限个的，但$E_{out}$的可能取值是无限的。可以通过将$E_{out}$ 替换为验证集(verification set) 的$E_{in}$来解决这个问题。</p><p>下面是推导过程：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783670/2018_03_05_14.png" width="80%" height="80%"></p><p>最后我们得到下面的VC bound:<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_15.png" width="80%" height="80%"></p><p>关于这个公式的数学推导，我们可以暂且不去深究。我们先看一下这个式子的意义，如果假设空间存在有限的break point，那么$m_H(2N)$会被最高幂次为$k–1$的多项式上界给约束住。随着$N$的逐渐增大，指数式的下降会比多项式的增长更快，所以此时VC Bound是有限的。更深的意义在于，$N$足够大时，对$H$中的任意一个假设$h，E_{in}(h)$都将接近于$E_{out}(h)$，这表示学习可行的第一个条件是有可能成立的。</p><h2>VC dimension</h2><p>说了这么多，VC维终于露出庐山真面目了。此概念由Vladimir Vapnik与Alexey Chervonenkis提出。一个假设空间$H$的<strong>VC dimension</strong>，是这个$H$最多能够shatter掉的点的数量，记为$d_{vc}(H)$。如果不管多少个点$H$都能shatter它们，则$d_{vc}=\infty$。还可以理解为：$vc-dim$就是$argmax\quad x_n\quad {growth function=2^n}$。</p><p>根据定义，可以得到一个明显的结论：$$k = d_{vc}(H) + 1$$</p><p>根据前面的推导，我们知道VC维的大小：与学习算法$A$无关，与输入变量$X$的分布也无关，与我们求解的目标函数$f$ 无关。<font color="blue">它只与模型和假设空间有关。</font></p><p>我们已经分析了，对于2维的perceptron，它不能shatter 4个样本点，所以它的VC维是3。此时，我们可以分析下2维的perceptron，如果样本集是线性可分的，perceptron learning algorithm可以在假设空间里找到一条直线，使$E_{in}(g)=0$；另外由于其VC维=3，当$N$足够大的时候，可以推断出：$E_{out}(g)$约等于$E_{in}(g)$。这样学习可行的两个条件都满足了，也就证明了2维感知器是可学习的。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783663/2018_03_05_16.png" width="80%" height="80%"></p><p>总结回顾一下，要想让机器学到东西，并且学得好，有2个条件：</p><ul><li>$H$的$d_{vc}$是有限的，这样VC bound才存在。(good H)；$N$足够大(对于特定的$d_{vc}$而言)，这样才能保证VC bound不等式的bound不会太大。(good D)</li><li>算法A有办法在$H$中顺利的挑选一个使得$E_{in}最小的$g$。(good A)</li></ul><p>回到最开始提出的学习可行的两个核心条件，尝试用VC维来解释：<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_17.png" width="80%" height="80%"></p><p>从上图可以看出，当VC维很小时，条件1容易满足，但因为假设空间较小，可能不容易找到合适的$g$,使得$E_{in}(g)$约等于0。当VC维很大时，条件2容易满足，但条件1不容易满足，因为VC bound很大。</p><p>VC维反映了假设空间$H$的强大程度(powerfulness)，VC 维越大，$H$也越强，因为它可以打散(shatter)更多的点。</p><p>定义模型自由度是，模型当中可以自由变动的参数的个数，即我们的机器需要通过学习来决定模型参数的个数。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783662/2018_03_05_18.png" width="80%" height="80%"><p>一个实践规律：VC 维与假设参数$w$的自由变量数目大约相等。$d_{VC} \approx  free parameters$。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520783663/2018_03_05_19.png" width="80%" height="80%"><p>上面式子中的第3项表示模型复杂度。模型越复杂，VC维大，$E_{out}$可能距离$E_{in}$ 越远。如下图所示，随着$d_{vc}$的上升，$E_{in}$不断降低，而模型复杂度不断上升。</p><p>它们的上升与下降的速度在每个阶段都是不同的，因此我们能够寻找一个二者兼顾的，比较合适的$d_{vc}$，用来决定应该使用多复杂的模型。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785729/2018_03_05_20.png" width="80%" height="80%"></p><p>模型较复杂时($d_{vc}$ 较大)，需要更多的训练数据。 理论上，数据规模$N$约等于 $10000*d_{vc}$（称为采样复杂性，sample complexity）；然而，实际经验是，只需要 $N = 10*d_{vc}$。</p><p>造成理论值与实际值之差如此之大的最大原因是，VC Bound 过于宽松了，我们得到的是一个比实际大得多的上界。<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785731/2018_03_05_21.png" height="80%"></p><p>注意在前述讨论中，理想的目标函数为$f(x)$，error measure用的是“0–1 loss”。如果在unknown target上引入噪声(+noise)，或者用不同的error measure方法，VC theory还有效吗？这里只给出结论，VC theory对于绝大部分假设空间(or 加入噪声)和error度量方法，都是有效的。</p><p>除此外，我们为了避免overfit，一般都会加正则项。那加了正则项后，新的假设空间会得到一些限制，此时新假设空间的VC维将变小，也就是同样训练数据条件下，$E_{in}$更有可能等于$E_{out}$，所以泛化能力更强。这里从VC维的角度解释了正则项的作用。</p><h2>深度学习与VC维</h2><p>对于神经网络，其VC维的公式为：$d_{VC} = O(V\cdot D)$，其中$V$表示神经网络中神经元的个数，$D$表示weight的个数，也就是神经元之间连接的数目。(注意：此式是一个较粗略的估计，深度神经网络目前没有明确的VC bound)<img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520785730/2018_03_05_22.png"></p><p>举例来说，一个普通的三层全连接神经网络：input layer是1000维，hidden layer有1000个nodes，output layer为1个node，则它的VC维大约为$O(1000*1000*1000)$。</p><p>可以看到，神经网络的VC维相对较高，因而它的表达能力非常强，可以用来处理任何复杂的分类问题。根据上一节的结论，要充分训练该神经网络，所需样本量为10倍的VC维。如此大的训练数据量，是不可能达到的。所以在20世纪，复杂神经网络模型在out of sample的表现不是很好，容易overfit。</p><p>但现在为什么深度学习的表现越来越好。原因是多方面的，主要体现在：</p><ul><li>通过修改神经网络模型的结构，以及提出新的regularization方法，使得神经网络模型的VC维相对减小了。例如卷积神经网络，通过修改模型结构(局部感受野和权值共享)，减少了参数个数，降低了VC维。2012年的AlexNet，8层网络，参数个数只有60M；而2014年的<a style="color: #109eff" href="http://www.cs.unc.edu/~wliu/papers/GoogLeNet.pdf" target="_blank" rel="noopener">GoogLeNet</a>，22层网络，参数个数只有7M。</li><li>dropout，drop connect，denosing等regularization方法的提出，也一定程度上增加了神经网络的泛化能力。</li><li>训练数据变多了。随着互联网的越来越普及，相比于以前，训练数据的获取容易程度以及量和质都大大提升了。训练数据越多，$E_{in}$越容易接近于$E_{out}$。而且目前训练神经网络，还会用到很多data augmentation方法，例如在图像上，剪裁，平移，旋转，调亮度，调饱和度，调对比度等都使用上了。</li><li>除此外，pre-training方法的提出，GPU的利用，都促进了深度学习。</li></ul><p>但即便这样，深度学习的VC dimension和VC Bound依旧很大，其泛化控制方法依然没有强理论支撑。但是实践又一次次证明，深度学习是好用的。所以VC维对深度学习的指导意义，目前不好表述，有一种思想建议，深度学习应该抛弃对VC维之类概念的迷信，尝试从其他方面来解释其可学习型，例如使用泛函空间（如<a style="color: #109eff" href="http://en.wikipedia.org/wiki/Banach_space" target="_blank" rel="noopener">Banach Space</a>）中的概率论。</p><p>更多细节请参考下面链接：</p><ol><li><a style="color: #109eff" href="http://ttic.uchicago.edu/~tewari/lectures/lecture12.pdf" target="_blank" rel="noopener">VC Dimension of Multilayer Neural Networks</a>，该文章给出了多层神经网络的VC bound的相关证明。</li><li><a style="color: #109eff" href="http://www.kdnuggets.com/2014/02/exclusive-yann-lecun-deep-learning-facebook-ai-lab.html" target="_blank" rel="noopener">Lecun: What is the relationship between Deep Learning and Support Vector Machines / Statistical Learning Theory?</a>Vapnik really believes in his bounds. He worried that neural nets didn’t have similarly good ways to do capacity control (although neural nets do have generalization bounds, since they have finite VC dimension).Lecun’s counter argument was that the ability to do capacity control was somewhat secondary to the ability to compute highly complex function with a limited amount of computation.</li></ol><h2>小结</h2><p>上面仔细分析了VC维的来龙去脉，讲述了VC维在机器学习理论中的指导意义。考虑到VC维在机器学习领域虽是基础，却也是大坑，难免有理解不深或不当之处，敬请谅解。若希望获得更深理解，请参考下面的参考文献。</p><h2>参考文献</h2><ol><li><a style="color: #109eff" href="http://www.autonlab.org/tutorials/vcdim.html" target="_blank" rel="noopener">VC dimension Tutorial Slides by Andrew Moore</a></li><li><a style="color: #109eff" href="https://www.coursera.org/course/ntumlone" target="_blank" rel="noopener">机器学习基石</a> x(上文的截图均出自于该课程的讲义)</li><li><a style="color: #109eff" href="http://www.svms.org/vc-dimension/" target="_blank" rel="noopener">vc-dimension in svms</a></li><li><a style="color: #109eff" href="http://www.36dsj.com/archives/21236" target="_blank" rel="noopener">机器学习简史</a></li><li><a style="color: #109eff" href="http://en.wikipedia.org/wiki/Vapnik%E2%80%93Chervonenkis_theory" target="_blank" rel="noopener">Vapnik–Chervonenkis theory</a></li><li><a style="color: #109eff" href="http://www.cs.nyu.edu/~yann/talks/lecun-ranzato-icml2013.pdf" target="_blank" rel="noopener">Deep Learning Tutorial</a></li><li><a style="color: #109eff" href="http://www.zhihu.com/question/27434103" target="_blank" rel="noopener">深度学习的研究领域是否有被过度夸大</a></li><li><a style="color: #109eff" href="http://freemind.pluskid.org/slt/vc-theory-vapnik-chervonenkis-dimension" target="_blank" rel="noopener">VC Theory: Vapnik–Chervonenkis Dimension</a></li></ol>]]></content>
      
      <categories>
          
          <category> 机器学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lasso回归算法</title>
      <link href="/LASSO%E5%9B%9E%E5%BD%92%E7%AE%97%E6%B3%95.html"/>
      <content type="html"><![CDATA[<p><a href="http://rokia.org/?tag=p_value" target="_blank" rel="noopener">关于P值滥用的简要介绍</a></p><p>计量模型中关于变量选择，很多同学可能第一个想到的是：前进法，后退法，向前向后逐步回归。但是，这些方法存在一些固有的缺陷,它们会导致某些可能为最优的变量组合无法共同进入模型。</p><p>我们抛开传统的统计学教材，把眼光瞄向统计学习理论，就会发现，其实有大量的模型可供我们选择。今天，先介绍最基础的方法：Lasso。</p><h2>一、The lasso的提出</h2><p>Lasso,即Lesat absolute shrinkage and seletion operator.改方法由统计学习领域的执牛耳者<a href="http://statweb.stanford.edu/~tibs/lasso/lasso.pdf" target="_blank" rel="noopener">Robert Tibshirani于1996年开创</a>。至今为止，这篇文章被引用次数已达14000多次。据说，在学术领域，被引用次数能达到几十次已经可以引以为傲。经过将近20年的发展，这个方法养活了一大群人，同时也发展出了很多更为成熟的理论，如Adaptive lasso，The Grouped lasso,SCAD。</p><h2>二、The lasso的原理</h2><p>lasso的思想其实很简单，就是在传统的最小二乘估计上对模型的系数施加一个$L_1$惩罚。模型形式如下。$$\widehat{\beta}^{lasso} =\quad  argmin_{\beta}\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 \\ \qquad s. t\sum_{j = 1}^{p}|\beta_j|\leq t.$$</p><p>上式等价于</p><p>$$\widehat{\beta}^{lasso} = argmin_{\beta}{\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 + \lambda\sum_{j = 1}^{p}|\beta_j|}$$</p><p>看到这个表达式，有没有一种熟悉的感觉？看！</p><p>$$\widehat{\beta}^{ridge} = argmin_{\beta} {\sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2 + \lambda\sum_{j = 1}^{p}\beta_{j}^2}$$</p><p>没错！它其实跟我们在回归分析教材中常见的岭回归(ridge regression)非常相似，只是将$L_2$惩罚换成了$L_1$惩罚。Zou and Hastie在2005年，提出了一种在ridge regression和the lasso之间折衷的方法：the <strong>elastic net</strong> penalty,思想也非常简单，但是却很有影响力。</p><p>回头看下，lasso为何如此流行。这么做的好处是一举多得的：</p><ul><li>可以解决岭回归能够解决的问题：多重共线性问题,过拟合问题等；</li><li>还可以解决岭回归不能解决的问题：将一部分变量的系数压缩至0，即实现变量选择。</li></ul><p>我们可以从一张图看出来。<br><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764085/2018_03_04p1.png" width="70%" height="70%"></p><p>这幅图可以这样理解蓝色的区域是$\beta$的可行域。由于the lasso的约束是$L_1$约束，必然是方形区域，区域的大小取决于$t$的大小；而ridge regression是$L_2$约束，所以可行域呈圆形。</p><p>$$Z = \sum_{i = 1}^{N}(y_i - \beta_0 - \sum_{j = 1}^{p}x_{ij}\beta_j)^2$$</p><p>从上面的式子可以看出，（如果我的空间解析几何没记错的话，）函数$Z(\beta_1,\beta_2)$描述的是一个椭圆抛物面的形状。而椭圆抛物面在$(\beta_1,\beta_2)$平面上的投影就是类似上图红色圆圈所表述的形状，每一圈代表着不同的$Z$值。而中间的黑点，自然就是最小的$Z$，即没有约束下，普通最小二乘得到的解。我们可以想象，当蓝色的圆圈足够大，以至于涵盖了中间的小黑点时，约束没有起到作用，取到的解就是中间的小黑点，此时等价于普通最小二乘；当约束比较紧，取到的解靠近0，为两个区域相切的点。</p><p>我们可以直观地看到，the lasso更容易取到角点解，即：使得某些变量的系数压缩至零。如果你还是不相信自己的眼睛，我们待会还可以从一个示例中看出这一特点。</p><p>一些爱思考的同学可能会继续追问：“它能够保证留下来的变量都是对因变量有着更大影响的吗？”这一点稍微思考一下，应该是可以保证的。但是，如果存在一组高度相关的变量时，Lasso倾向于选择其中的一个变量，而忽视其他所有的变量。这样可能会导致结果的不稳定性。要解决这个问题，可以去探究一下 <strong>elastic net</strong> penalty。</p><h2>三、lasso的R实现</h2><p>lasso的实现可以采用glmnet包。glmnet包作者是Friedman, Hastie, and Tibshirani这三位统计学习领域的大牛，可信度无可置疑。这个包采用的算法是循环坐标下降法（cyclical coordinate descent），能够处理的模型包括 linear regression,logistic and multinomial regression models, poisson regression 和 the Cox model，用到的正则化方法就是$l1$范数（lasso）、$l2$范数（岭回归）和它们的混合 （elastic net）。</p><p>这里，给出一个实现lasso的示例。</p><p>数据来源于ISLR包中的Hitters数据集，该数据集描述了美国1986年和1987年的棒球运动员相关数据。我们来探究一下对运动员薪水起主要作用的因素有哪些。</p><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">library</span>(ISLR)</span><br><span class="line">str(Hitters)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 'data.frame':    322 obs. of  20 variables:</span></span><br><span class="line"><span class="comment">##  $ AtBat    : int  293 315 479 496 321 594 185 298 323 401 ...</span></span><br><span class="line"><span class="comment">##  $ Hits     : int  66 81 130 141 87 169 37 73 81 92 ...</span></span><br><span class="line"><span class="comment">##  $ HmRun    : int  1 7 18 20 10 4 1 0 6 17 ...</span></span><br><span class="line"><span class="comment">##  $ Runs     : int  30 24 66 65 39 74 23 24 26 49 ...</span></span><br><span class="line"><span class="comment">##  $ RBI      : int  29 38 72 78 42 51 8 24 32 66 ...</span></span><br><span class="line"><span class="comment">##  $ Walks    : int  14 39 76 37 30 35 21 7 8 65 ...</span></span><br><span class="line"><span class="comment">##  $ Years    : int  1 14 3 11 2 11 2 3 2 13 ...</span></span><br><span class="line"><span class="comment">##  $ CAtBat   : int  293 3449 1624 5628 396 4408 214 509 341 5206 ...</span></span><br><span class="line"><span class="comment">##  $ CHits    : int  66 835 457 1575 101 1133 42 108 86 1332 ...</span></span><br><span class="line"><span class="comment">##  $ CHmRun   : int  1 69 63 225 12 19 1 0 6 253 ...</span></span><br><span class="line"><span class="comment">##  $ CRuns    : int  30 321 224 828 48 501 30 41 32 784 ...</span></span><br><span class="line"><span class="comment">##  $ CRBI     : int  29 414 266 838 46 336 9 37 34 890 ...</span></span><br><span class="line"><span class="comment">##  $ CWalks   : int  14 375 263 354 33 194 24 12 8 866 ...</span></span><br><span class="line"><span class="comment">##  $ League   : Factor w/ 2 levels &amp;quot;A&amp;quot;,&amp;quot;N&amp;quot;: 1 2 1 2 2 1 2 1 2 1 ...</span></span><br><span class="line"><span class="comment">##  $ Division : Factor w/ 2 levels &amp;quot;E&amp;quot;,&amp;quot;W&amp;quot;: 1 2 2 1 1 2 1 2 2 1 ...</span></span><br><span class="line"><span class="comment">##  $ PutOuts  : int  446 632 880 200 805 282 76 121 143 0 ...</span></span><br><span class="line"><span class="comment">##  $ Assists  : int  33 43 82 11 40 421 127 283 290 0 ...</span></span><br><span class="line"><span class="comment">##  $ Errors   : int  20 10 14 3 4 25 7 9 19 0 ...</span></span><br><span class="line"><span class="comment">##  $ Salary   : num  NA 475 480 500 91.5 750 70 100 75 1100 ...</span></span><br><span class="line"><span class="comment">##  $ NewLeague: Factor w/ 2 levels &amp;quot;A&amp;quot;,&amp;quot;N&amp;quot;: 1 2 1 2 2 1 1 1 2 1 ...&lt;/code&gt;&lt;</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Hitters&lt;-na.omit(Hitters)</span><br><span class="line"><span class="comment">## sampling</span></span><br><span class="line">x&amp;lt;-model.matrix(Salary~.,Hitters)[,-<span class="number">1</span>]</span><br><span class="line">y&amp;lt;-Hitters$Salary</span><br><span class="line"></span><br><span class="line">set.seed(<span class="number">1</span>)</span><br><span class="line">train&amp;lt;-sample(<span class="number">1</span>:nrow(x),nrow(x)/<span class="number">2</span>)</span><br><span class="line">test&amp;lt;-(-train)</span><br><span class="line">y.test&amp;lt;-y[test]</span><br><span class="line"></span><br><span class="line"><span class="comment">## ridge regression</span></span><br><span class="line"><span class="keyword">library</span>(glmnet)</span><br><span class="line">grid&amp;lt;-<span class="number">10</span>^seq(<span class="number">10</span>,-<span class="number">2</span>,length = <span class="number">100</span>)</span><br><span class="line">ridge.mod&amp;lt;-glmnet(x,y,alpha = <span class="number">0</span>,lambda = grid)</span><br><span class="line">plot(ridge.mod, main = &amp;quot;The ridge&amp;quot;)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018.03_04lasso01.png" width="70%" height="70%"><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## the lasso</span></span><br><span class="line">lasso.mod&amp;lt;-glmnet(x[train,],y[train],alpha = <span class="number">1</span>,lambda = grid)</span><br><span class="line">plot(lasso.mod, main = &amp;quot;The lasso&amp;quot;)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018_03_04lasso02.png" width="70%" height="70%"><p>从上面两幅图对比可知，the lasso相比起ridge regression，在压缩变量方便表现更出色。当然，你还可以使用这个包内部的交叉验证函数对<span class="math inline">(\lambda)</span>进行参数优化，使得模型更具有稳健性。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">## cross-validation</span><br><span class="line">set.seed(1)</span><br><span class="line">cv.out&amp;lt;-cv.glmnet(x[train,],y[train],alpha = 1)</span><br><span class="line">plot(cv.out)</span><br></pre></td></tr></table></figure><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520764084/2018_03_04_lasso03.png" width="70%" height="70%"><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bestlam&amp;lt;-cv.out$lambda.min</span><br><span class="line">lasso.pred&amp;lt;-predict(lasso.mod,s = bestlam,newx = x[test,])</span><br><span class="line">mean((lasso.pred - y.test)^<span class="number">2</span>)</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## [1] 100743.4</span></span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">out&amp;lt;-glmnet(x,y,alpha = <span class="number">1</span>,lambda = grid)</span><br><span class="line">lasso.coef&amp;lt;-predict(out,type = &amp;quot;coefficients&amp;quot;,s = bestlam)[<span class="number">1</span>:<span class="number">20</span>,]</span><br><span class="line">lasso.coef</span><br></pre></td></tr></table></figure><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##  (Intercept)        AtBat         Hits        HmRun         Runs </span></span><br><span class="line"><span class="comment">##   18.5394844    0.0000000    1.8735390    0.0000000    0.0000000 </span></span><br><span class="line"><span class="comment">##          RBI        Walks        Years       CAtBat        CHits </span></span><br><span class="line"><span class="comment">##    0.0000000    2.2178444    0.0000000    0.0000000    0.0000000 </span></span><br><span class="line"><span class="comment">##       CHmRun        CRuns         CRBI       CWalks      LeagueN </span></span><br><span class="line"><span class="comment">##    0.0000000    0.2071252    0.4130132    0.0000000    3.2666677 </span></span><br><span class="line"><span class="comment">##    DivisionW      PutOuts      Assists       Errors   NewLeagueN </span></span><br><span class="line"><span class="comment">## -103.4845458    0.2204284    0.0000000    0.0000000    0.0000000</span></span><br></pre></td></tr></table></figure><p>可见，很多变量的系数确实被压缩至零。</p><h2>四、lasso的优缺点分析</h2><ul><li>相比较于其他变量选择方法，如：best subset，Partial Least Squares(偏最小二乘)，Principal components regression(主成分回归)，the lasso和ridge regression对参数的调整是连续的，并不是一刀切的。</li><li>the lasso相比于ridge regression的优势在于压缩变量表现更出色。</li><li>但是，正如前面所说，lasso还是会有一些潜在的问题，有时候，elastic net等其他的一些lasso的变形会是更好的选择。</li></ul><h2>五、参考文献</h2><ol><li>The Elements of Statistical Learning: Data Mining, Inference and Prediction. Second edition</li><li>An Introduction to Statistical Learning with R</li><li><a href="http://site.douban.com/182577/widget/notes/10567212/note/288551448/" target="_blank" rel="noopener">线性回归建模–变量选择和正则化（1）：R包glmnet</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> 数量经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>因果推断：工具变量（Instrumental Variable）</title>
      <link href="/%E5%9B%A0%E6%9E%9C%E6%8E%A8%E6%96%AD%EF%BC%9A%E5%B7%A5%E5%85%B7%E5%8F%98%E9%87%8F%EF%BC%88Instrumental%20Variable%EF%BC%89.html"/>
      <content type="html"><![CDATA[<h2>一、线性回归和最小二乘法</h2><p>线性模型和最小二乘的理论起源于高斯的天文学研究，“回归”（regression）这个名字则是 Francis Galton 在研究优生学的时候提出来的。为了描述的方便，我们假定回归的自变量只有一维，比如个体$i$是否接受某种处理（吸烟与否；参加某个工作；等等），记为$D_i$。 回归的因变量也是一维，表示我们关心的结果（是否有肺癌；是否找到工作培训与否；等等），记为$Y_i$。假定我们的研究中有 $n$ 个个体，下面的线性模型用于描述$D$和$Y$之间的“关系”：</p><p>$$Y_i = \alpha + \beta D_i + \varepsilon_i, i=1, \cdots, n. \quad \quad (1)$$</p><p>一般情形下，我们假定个体间是独立的。模型虽简单，我们还是有必要做一些解释。首先，我们这里的讨论都假定$D_i$是随机变量，对应统计学中的随机设计 （random design）的情形；这和传统统计学中偏好的固定设计（fixed design）有点不同—那里假定$D_i$总是固定的。（统计学源于实验设计，那里的解释变量都是可以控制的，因此统计学教科书有假定固定设计的传统。）假定$D_i$是随机的，既符合很多社会科学和流行病学的背景，又会简化后面的讨论。另外一个问题是 $\varepsilon_i$，它到底是什么含义？Rubin 曾经嘲笑计量经济学家的$\varepsilon_i$道：为了使得线性模型的等式成立，计量经济学家必须加的一项，就叫$\varepsilon_i$。批评的存在并不影响这个线性模型的应用；关键的问题在于，我们在这个$\varepsilon_i$上加了什么假定呢？最根本的假定是：</p><p>$$E(\varepsilon_i) = 0, \text{ and }  \text{cov}(D_i, \varepsilon_i) = 0. \quad \quad (2)$$</p><p>不同的教科书稍有不同，比如 Wooldridge 的书上假定$E(\varepsilon_i\mid D_i ) =0$，很显然，这蕴含着上面两个假定。零均值的假定并不强，因为 $\alpha$“吸收”了$\varepsilon_i$的均值；关键在第二个协方差为零的假定—它通常被称为“外生性”（exogeneity）假定。在这个假定下，我们在 (1) 的两边关于$D_i$取协方差，便可以得到：</p><p>$$\text{cov}(Y_i, D_i )= \beta \text{var}(D_i),$$</p><p>因此，$\beta = \text{cov}(Y_i, D_i) / \text{var}(D_i)$，我们立刻得到了矩估计：</p><p>$$\widehat{\beta}_{OLS}=\frac{\sum_{i=1}^n(Y_i-\bar{Y})(D_i-\bar{D})}{\sum_{i=1}^n(D_i-\bar{D})^2}$$</p><p>上面的估计式也是通常的最小二乘解，这里只是换了一个推导方式。如果将 (1) 看成一个数据生成的机制，在假定 (2) 下我们的确可以估计出因果作用$\beta$.</p><h2>二、内生性和工具变量</h2><p>问题的关键是假定 (2) 很多时候并不成立（$\text{cov}(D_i, \varepsilon_i)\neq 0$），比如，吸烟的人群和不吸烟的人群本身很不相同，参加工作培训的人可能比不参加工作培训的人有更强的找工作动机，等等。因此，包含个体$i$其他所有隐藏信息的变量$\varepsilon_i$不再与$D_i$不相关了—这被称为“内生性”（endogeneity）。这个时候，最小二乘估计收敛到$\beta + \text{cov}(D,\varepsilon)/\text{var}(D)$, 因而在$\text{cov}(D,\varepsilon)\neq 0$时不再是$\beta$的相合估计。</p><p>前面几次因果推断的介绍中提到，完全的随机化实验，可以给我们有效的因果推断。但是很多问题中，强制性的随机化实验是不现实或者不符合伦理的。比如，我们不能强制某些人吸烟，或者不吸烟。但是，“鼓励性实验”依然可行。我们可以随机地给吸烟的人以某种金钱的奖励，如果他们放弃吸烟，则获得某种经济上的优惠。将这个“鼓励性”的变量记为$Z_i$，它定义为是否被鼓励的示性变量，取值 0-1。由于我们的鼓励是完全随机的，有理由假定$\text{cov}(Z_i, \varepsilon_i)=0$。</p><p>以上的各个假定，可以用下面的一个图来形象的描述。</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520746493/2018_03_03iv.png" alt="iv" width="70%" height="70%"><p>如图所示，由于$D$和$Y$之间存在一个混杂因素$U$，两者之间的因果作用是不可以用线性回归相合估计的。工具变量$Z$的存在，使得$D$到$Y$的因果作用的识别成为了可能。这里的工具变量$Z$满足如下的条件: $Z\perp U, Z\not \perp D$，并且$Z\perp Y|(D,U)$。第三个条件，可以理解成为“无 $Z$到$Y$的直接作用”。</p><p>此时，我们在线性模型 (1) 两边关于$Z_i$取协方差，得到</p><p>$$\text{cov}(Z_i, Y_i) = \beta \text{cov} (Z_i, D_i),$$</p><p>因此，$\beta = \frac{  \text{cov}(Z_i, Y_i)} {\text{cov} (Z_i, D_i) } $，我们立刻得到如下的矩估计：</p><p>$$\widehat{\beta}_{OLS} = \frac{\sum_{i=1}^n (Y_i – \bar{Y}) (D_i – \bar{D})}{\sum_{i=1}^n (D_i – \bar{D})^2}$$</p><p>根据大数定律，这个“工具变量估计”是$\beta$的相合估计量。上面的式子对一般的$Z_i$都是成立的；当$Z_i$是 0-1 变量时，上面的式子可化简成：</p><p>$$\widehat{\beta}_{IV} = \frac{  \bar{Y}_1 – \bar{Y}_0 } { \bar{D}_1 – \bar{D}_0 },$$</p><p>其中$\bar{Y}_1$表示$Z_i=1$组的平均结果，$\bar{Y}_0$表示$Z_i=0$组的平均结果，关于$D$的定义类似。上面的估计量，很多时候被称为 Wald 估计量（它的直观含义是什么呢？） 需要注意的是，(3) 要求$\text{cov}(Z_i,D_i)\neq 0$，即“鼓励”对于改变人的吸烟行为是有效的；否则上面的工具变量估计量在大样本下趋于无穷大。</p><h2>三、潜在结果视角下的因果作用</h2><p>工具变量估计量在文献中存在已有很多年了，一直到了 Angrist, Imbens and Rubin (1996) 年的文章出现，才将它和潜在结果视角下的因果推断联系起来。关于 Neyman 引进的潜在结果，需要回顾这一系列的第二篇文章。</p><p>一般地， $Z$表示一个 0-1 的变量，表示随机化的变量（1 表示随机化分到非鼓励组；0 表示随机化分到鼓励组）；$D$ 表示最终接受处理与否（1 表示接受处理；0 表示接受对照）；$Y$ 是结果变量。为了定义因果作用，我们引进如下的潜在结果：$(Y_i(1), Y_i(0))$表示个体$i$接受处理和对照下$Y$的潜在结果；$(D_i(1), D_i(0))$表示个体$i$非鼓励组和鼓励组下$D$的潜在结果。由于随机化，下面的假定自然的成立：</p><p>（随机化）$Z_i \perp { D_i(1), D_i(0), Y_i(1), Y_i(0) }.$</p><p>根据鼓励性实验的机制，个体在受到鼓励的时候，更加不可能吸烟，因为下面的单调性也是很合理的：</p><p>（单调性）$D_i(1) \leq D_i(0).$</p><p>由于个体的结果$Y$直接受到所受的处理$D$的影响，而不会受到是否受鼓励$Z$的影响，下面的排除约束（exclusion restriction）的假定，很多时候也是合理的：</p><p>（排除约束）$D_i(1) = D_i(0) $ 蕴含着 $Y_i(1) = Y_i(0)$.</p><p>上面的假定表明，当随机化的“鼓励”$Z$不会影响是否接受处理$D$时，随机化的“鼓励” $Z$也不会影响结果变量$Y$。也可以理解成，随机化的“鼓励” $Z$ 仅仅通过影响是否接受处理$D$来影响结果$Y$，或者说，随机化“鼓励” $Z$本身对与结果变量$Y$没有“直接作用”。</p><p>以上三个假定下，我们得到：</p><p>$$ ACE(Z \rightarrow Y) \\ E{Y_i(1)} -E{Y_i(0)} \\ P{ D_i(1)=1, D_i(0)=0} E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=0 }\\ + P{ D_i(1)=0, D_i(0)=0} E{Y_i(1)-Y_i(0)\mid D_i(1)=0, D_i(0)=0 }\\+P{ D_i(1)=1, D_i(0)=1} E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=1 }\\ P{ D_i(1)=1, D_i(0)=0} E{Y_i(1) -Y_i(0)\mid D_i(1)=1, D_i(0)=0 }.$$</p><p>单调使得 $D$ 的潜在结果的组合只有三种；排除约束假定使得上面分解的后两个式子为$0$。由于对于 $(D_i(1)=0, D_i(0)=0)$ 和 $(D_i(1)=1, D_i(0)=1)$两类人，随机化的“鼓励”对于$D$的作用为$0$，$(D_i(1)=1, D_i(0)=0)$一类人的比例就是$Z$对$D$平均因果作用：$ACE(Z\rightarrow D) = P{ D_i(1)=1, D_i(0)=0} $. 因此，</p><p>$$<br>CACE= E{Y_i(1)-Y_i(0)\mid D_i(1)=1, D_i(0)=0 } = \frac{ ACE(Z \rightarrow Y) }{ ACE(Z\rightarrow D) }.<br>$$</p><p>上面的式子被定义为$CACE$是有理由的。它表示的是子总体$(D_i(1)=1, D_i(0)=0)$中，随机化对于结果的因果作用；由于这类人中随机化和接受的处理是相同的，它也表示处理对结果的因果作用。这类人接受处理与否完全由于是否接受鼓励而定，他们被成为“依从者”（complier），因为这类人群中的平均因果作用又被成为“依从者平均因果作用”（CACE：complier average causal effect）;计量经济学家称它为“局部处理作用”（LATE：local average treatment effect）。</p><p>由于$Z$是随机化的，它对于$D$和$Y$的平均因果作用都是显而易见可以得到的。因为$\widehat{ACE}(Z\rightarrow D) = \bar{D}_1 – \bar{D}_0, \widehat{ACE}(Z\rightarrow Y) = \bar{Y}_1 – \bar{Y}_0$，CACE 的一个矩估计便是</p><p>$$ \frac{\widehat{ACE}(Z\rightarrow Y)  } {  \widehat{ACE}(Z\rightarrow D)   } = \widehat{\beta}_{IV}.$$</p><p>由此可见工具变量估计量的因果含义。上面的讨论既显示了工具变量对于识别因果作用的有效性，也揭示了它的局限性：我们只能识别某个子总体的平均因果作用；而通常情况下，我们并不知道某个个体具体属于哪个子总体。</p><h2>四、实例</h2><p>这部分给出具体的例子来说明上理论的应用，具体计算用到了第五部分的一个函数（其中包括用delta方法算的抽样方差）。这里用到的数据来自一篇政治学的文章 Green et al. (2003) “Getting Out the Vote in Local Elections: Results from Six Door-to-Door Canvassing Experiments”，<a href="http://dvn.iq.harvard.edu/dvn/faces/study/StudyPage.xhtml?globalId=hdl:1902.1/21729&amp;studyListingIndex=5_c49f1060ddaa41a23e5759168940" target="_blank" rel="noopener">数据点击此处可以在此下载</a>。</p><p>文章目的是研究某个社会实验是否能够提到投票率，实验是随机化的，但是并非所有的实验组的人都依从。因此这里的变量 $Z$ 表示随机化的实验，$D$ 表示依从与否，$Y$ 是投票与否的示性变量。具体的数据描述，可参加前面提到的文章。</p><p>原始数据总结如下：</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1520746493/2018_03_03table1.png" width="70%" height="70%">根据下一个部分的函数，我们得到如下的结果：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">CACE.IV(Y, D, Z)</span><br><span class="line">$CACE</span><br><span class="line">[1] 0.07914375</span><br><span class="line"></span><br><span class="line">$se.CACE</span><br><span class="line">           [,1]</span><br><span class="line">[1,] 0.02273439</span><br><span class="line"></span><br><span class="line">$p.value</span><br><span class="line">             [,1]</span><br><span class="line">[1,] 0.0004991073</span><br><span class="line"></span><br><span class="line">$prob.complier</span><br><span class="line">[1] 0.2925123</span><br><span class="line"></span><br><span class="line">$se.complier</span><br><span class="line">[1] 0.004871619</span><br></pre></td></tr></table></figure><p>由此可见，这个实验对于提高投票率，有显著的作用。</p><h2>五、R code</h2><figure class="highlight r"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## function for complier average causal effect</span></span><br><span class="line">CACE.IV = <span class="keyword">function</span>(outcome, treatment, instrument)</span><br><span class="line">&#123;</span><br><span class="line">Y = outcome</span><br><span class="line">D = treatment</span><br><span class="line">Z = instrument</span><br><span class="line">N = length(Y)</span><br><span class="line"></span><br><span class="line">Y1 = Y[Z == <span class="number">1</span>]</span><br><span class="line">Y0 = Y[Z == <span class="number">0</span>]</span><br><span class="line">D1 = D[Z == <span class="number">1</span>]</span><br><span class="line">D0 = D[Z == <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">mean.Y1 = mean(Y1)</span><br><span class="line">mean.Y0 = mean(Y0)</span><br><span class="line">mean.D1 = mean(D1)</span><br><span class="line">mean.D0 = mean(D0)</span><br><span class="line"></span><br><span class="line">prob.complier = mean.D1 - mean.D0</span><br><span class="line">var.complier  = var(D1)/length(D1) + var(D0)/length(D0)</span><br><span class="line">se.complier   = var.complier^<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">CACE = (mean.Y1 - mean.Y0)/(mean.D1 - mean.D0)</span><br><span class="line"></span><br><span class="line"><span class="comment">## COV</span></span><br><span class="line">pi1 = mean(Z)</span><br><span class="line">pi0 = <span class="number">1</span> - pi1</span><br><span class="line"></span><br><span class="line">Omega = c( var(Y1)/pi1, cov(Y1, D1)/pi1, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">           cov(Y1, D1)/pi1, var(D1)/pi1, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">           <span class="number">0</span>, <span class="number">0</span>, var(Y0)/pi0, cov(Y0, D0)/pi0,</span><br><span class="line">           <span class="number">0</span>, <span class="number">0</span>, cov(Y0, D0)/pi0, var(D0)/pi0 )</span><br><span class="line">Omega = matrix(Omega, byrow = <span class="literal">TRUE</span>, nrow = <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">## Gradient</span></span><br><span class="line">Grad = c(<span class="number">1</span>, -CACE, -<span class="number">1</span>, CACE)/(mean.D1 - mean.D0)</span><br><span class="line"></span><br><span class="line">COV.CACE = t(Grad)%*%Omega%*%Grad/N</span><br><span class="line"></span><br><span class="line">se.CACE = COV.CACE^<span class="number">0.5</span></span><br><span class="line"></span><br><span class="line">p.value = <span class="number">2</span>*pnorm(abs(CACE/se.CACE), <span class="number">0</span>, <span class="number">1</span>, lower.tail = <span class="literal">FALSE</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">##results</span></span><br><span class="line">res = list(CACE          = CACE,</span><br><span class="line">           se.CACE       = se.CACE,</span><br><span class="line">           p.value       = p.value,</span><br><span class="line">           prob.complier = prob.complier,</span><br><span class="line">           se.complier   = se.complier)</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>(res)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> 数量经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JUMP少年周刊-最全漫画排行榜</title>
      <link href="/JUMP%E5%B0%91%E5%B9%B4%E5%91%A8%E5%88%8A-%E6%9C%80%E5%85%A8%E6%BC%AB%E7%94%BB%E6%8E%92%E8%A1%8C%E6%A6%9C.html"/>
      <content type="html"><![CDATA[<p>其中，一些台词我们仍记忆犹新诸如</p><p>龟–派--汽–功  $\quad \Rightarrow $ 七龙珠<br>你已经死了      $\quad \Rightarrow $北斗神拳<br>教练我想打篮球！ $\quad \Rightarrow $灌篮高手<br>燃烧吧，小宇宙   $\quad \Rightarrow $圣斗士星矢<br>我可是要当海贼王的男人 $\quad \Rightarrow $One Peice<br></p><p>JUMP的连载原则：把在十话内没有得到读者青睐的漫画统统砍掉，并要求高人气作品不准完结，要不顾剧情发展的连载下去。虽然，这样的的条款压抑了创作者空间，但是作为一个企业来说，JUMP以这样的原则给我们呈现了数不清的优秀作品，也获得了巨大的商业成功，稳居日本漫画龙头地位。</p><table><thead><tr><th style="text-align:center">排行</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>香蕉时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>奇异果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>芒果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">No.1</td><td style="text-align:center"><strong>破廉耻学园</strong></td><td style="text-align:center">永井 豪</td><td style="text-align:center">1968-1972</td><td style="text-align:center"><strong>七龙珠</strong></td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1984-1995</td><td style="text-align:center"><strong>海贼王</strong></td><td style="text-align:center">尾田荣一郎</td><td style="text-align:center">2000-2013</td></tr><tr><td style="text-align:center">No.2</td><td style="text-align:center">根性青蛙</td><td style="text-align:center">吉泽保美</td><td style="text-align:center">1970-1976</td><td style="text-align:center">筋肉人</td><td style="text-align:center">蚵仔煎</td><td style="text-align:center">1979-1987</td><td style="text-align:center"><strong>全职猎人</strong></td><td style="text-align:center">富坚 义博</td><td style="text-align:center">1998-</td></tr><tr><td style="text-align:center">No.3</td><td style="text-align:center"><strong>乌龙派出所</strong></td><td style="text-align:center">秋本 治</td><td style="text-align:center">1976-2016</td><td style="text-align:center"><strong>灌篮高手</strong></td><td style="text-align:center">井上 雄彦</td><td style="text-align:center">1990-1996</td><td style="text-align:center"><strong>火影忍者</strong></td><td style="text-align:center">岸本 齐史</td><td style="text-align:center">1999-2013</td></tr><tr><td style="text-align:center">No.4</td><td style="text-align:center">魔投手</td><td style="text-align:center">梶原一骑</td><td style="text-align:center">1971-1974</td><td style="text-align:center"><strong>北斗神拳</strong></td><td style="text-align:center">武论尊</td><td style="text-align:center">1983-1988</td><td style="text-align:center"><strong>美食的俘虏</strong></td><td style="text-align:center">岛袋 光年</td><td style="text-align:center">2008-2016</td></tr><tr><td style="text-align:center">No.5</td><td style="text-align:center"><strong>男儿当大将</strong></td><td style="text-align:center">本宫</td><td style="text-align:center">1968-1973</td><td style="text-align:center">城市猎人</td><td style="text-align:center">北条司</td><td style="text-align:center">1985-1991</td><td style="text-align:center">死神</td><td style="text-align:center">久保 带人</td><td style="text-align:center">2001-2016</td></tr><tr><td style="text-align:center">No.6</td><td style="text-align:center">阿拉蕾</td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1980-1984</td><td style="text-align:center"><strong>足球小将</strong></td><td style="text-align:center">高桥 阳一</td><td style="text-align:center">1981-1988</td><td style="text-align:center"><strong>棋魂</strong></td><td style="text-align:center">堀田由美</td><td style="text-align:center">1999-2003</td></tr><tr><td style="text-align:center">No.7</td><td style="text-align:center">魔神z</td><td style="text-align:center">永井 豪</td><td style="text-align:center">1972-1973</td><td style="text-align:center">High School！奇面组</td><td style="text-align:center">新泽基荣</td><td style="text-align:center">1982-1987</td><td style="text-align:center">游戏王</td><td style="text-align:center">高桥和希</td><td style="text-align:center">1996-2004</td></tr><tr><td style="text-align:center">No.8</td><td style="text-align:center">Play Ball</td><td style="text-align:center">千叶昭雄</td><td style="text-align:center">1973-1978</td><td style="text-align:center"><strong>Jo-Jo奇妙冒险</strong></td><td style="text-align:center">荒木飞吕彦</td><td style="text-align:center">1987-2004</td><td style="text-align:center">银魂</td><td style="text-align:center">空知 英秋</td><td style="text-align:center">2004-至今</td></tr><tr><td style="text-align:center">No.9</td><td style="text-align:center"><strong>猫眼三姐妹</strong></td><td style="text-align:center">北条司</td><td style="text-align:center">1981-1984</td><td style="text-align:center">橙路</td><td style="text-align:center">松本泉</td><td style="text-align:center">1984-1987</td><td style="text-align:center">黑子的篮球</td><td style="text-align:center">藤卷忠俊</td><td style="text-align:center">2009-2014</td></tr><tr><td style="text-align:center">No.10</td><td style="text-align:center">赛道之狼</td><td style="text-align:center"></td><td style="text-align:center">1975-1979</td><td style="text-align:center"><strong>幽游白书</strong></td><td style="text-align:center">富坚义博</td><td style="text-align:center">1990-1993</td><td style="text-align:center"><strong>网球王子</strong></td><td style="text-align:center">许斐刚</td><td style="text-align:center">1999-2008</td></tr><tr><td style="text-align:center">No.11</td><td style="text-align:center"><strong>料理人味平</strong></td><td style="text-align:center">牛次郎</td><td style="text-align:center">1973-1977</td><td style="text-align:center"><strong>浪客剑心</strong></td><td style="text-align:center">和月 伸宏</td><td style="text-align:center">1994-1999</td><td style="text-align:center">死亡笔记</td><td style="text-align:center">大场</td><td style="text-align:center">2004-2006</td></tr><tr><td style="text-align:center">No.12</td><td style="text-align:center">东大一直线</td><td style="text-align:center">小林</td><td style="text-align:center">1976-1979</td><td style="text-align:center"><strong>圣斗士星矢</strong></td><td style="text-align:center">车田 正美</td><td style="text-align:center">1986-1990</td><td style="text-align:center">暗杀教室</td><td style="text-align:center">松井 优征</td><td style="text-align:center">2012</td></tr><tr><td style="text-align:center">No.13</td><td style="text-align:center">天际球团</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">铁拳对钢拳</td><td style="text-align:center">森田真法</td><td style="text-align:center">1988-1997</td><td style="text-align:center">家庭教师HITMAN REBORN</td><td style="text-align:center">天野明</td><td style="text-align:center">2004-1012</td></tr><tr><td style="text-align:center">No.14</td><td style="text-align:center">厕所博士</td><td style="text-align:center"></td><td style="text-align:center">1970-1977</td><td style="text-align:center">魁！！男塾</td><td style="text-align:center">宫下亚喜罗</td><td style="text-align:center">1985-1991</td><td style="text-align:center"><strong>通灵王</strong></td><td style="text-align:center">武井 宏之</td><td style="text-align:center">1998-2004</td></tr><tr><td style="text-align:center">No.15</td><td style="text-align:center">眼睛蛇</td><td style="text-align:center">寺泽 武一</td><td style="text-align:center">1978-1984</td><td style="text-align:center">电影少女</td><td style="text-align:center">桂 正和</td><td style="text-align:center">1989-1992</td><td style="text-align:center">Bobobo-bo Bo-bobo</td><td style="text-align:center">泽井 磐夫</td><td style="text-align:center">2001-2007</td></tr><tr><td style="text-align:center">No.16</td><td style="text-align:center">杜宾刑警</td><td style="text-align:center">武论尊</td><td style="text-align:center">1975-1979</td><td style="text-align:center">幻法小魔星</td><td style="text-align:center">江川 达也</td><td style="text-align:center">1988-1992</td><td style="text-align:center"><strong>草莓100%</strong></td><td style="text-align:center">河下 水希</td><td style="text-align:center">2002-2005</td></tr><tr><td style="text-align:center">No.17</td><td style="text-align:center">停止！！云雀</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1981-1983</td><td style="text-align:center">秀逗泰山</td><td style="text-align:center">德弘正也</td><td style="text-align:center">1988-1995</td><td style="text-align:center">出包王女</td><td style="text-align:center">矢吹 健太郎</td><td style="text-align:center">2006-2009</td></tr><tr><td style="text-align:center">No.18</td><td style="text-align:center">热拳本色</td><td style="text-align:center">车田 正美</td><td style="text-align:center">1977-1981</td><td style="text-align:center">灵异教师神眉</td><td style="text-align:center"></td><td style="text-align:center">1993-1999</td><td style="text-align:center">ROOKIES</td><td style="text-align:center">森田</td><td style="text-align:center">1998-2003</td></tr><tr><td style="text-align:center">No.19</td><td style="text-align:center">赤脚的元</td><td style="text-align:center">中泽 磐治</td><td style="text-align:center">1973-1974</td><td style="text-align:center">银牙</td><td style="text-align:center">高桥义广</td><td style="text-align:center">1983-1987</td><td style="text-align:center">光速蒙面侠21</td><td style="text-align:center">村田雄介</td><td style="text-align:center">2002-2009</td></tr><tr><td style="text-align:center">No.20</td><td style="text-align:center">前进！！海盗</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1997-1980</td><td style="text-align:center">顺带着稀里糊涂</td><td style="text-align:center"></td><td style="text-align:center">1985-1989</td><td style="text-align:center">搞怪吹笛手</td><td style="text-align:center">臼田京介</td><td style="text-align:center">2000-2010</td></tr></tbody></table><blockquote><p>表格注：JUMP于2012年连载的人气漫画诸如：<strong>排球少年、食戟之灵</strong>等优秀作品暂未列入排行榜。</p></blockquote><p>2000年代以来，JUMP三台柱就分别是“死神、火影、海贼王”，但是死神和火影的正式完结，人气却弄的相当低迷，海贼王目前也可以看到，尾田休刊次数也增加不少。目前JUMP少年周刊可以说迎来了一个低迷时期。</p><p>于2008年连载的《美食俘虏》，JUMP虽有意提拔其为台柱，甚至把主角请到《海贼王》中客串，但目前看来依然扶不起。目前连载中算是老油条的《银魂》，也是准备暖身进入最终章了。</p><p>2014年人气漫画，《黑子的篮球》完结。2016年，三台柱中《死神》、《火影忍者》完结，超人气作品《暗杀教室》完结，《食戟之灵》进入新篇章后人气也随之下滑。</p><p>目前，发展看好的有优秀运动向排球漫画《排球少年》，于2014年连载的《我的英雄学院》也一直维持着相当高的人气。</p><p>说了这么多还是希望，海贼王不要烂尾 $$Thanks \\ ShonenJump.$$</p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1521696877/jum.jpg" width="90%" height="90%">]]></content>
      
      <categories>
          
          <category> 漫画兴趣 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JUMP周刊 </tag>
            
            <tag> 漫画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>广义矩估计(GMM)方法</title>
      <link href="/%E5%B9%BF%E4%B9%89%E7%9F%A9%E4%BC%B0%E8%AE%A1(GMM)%E6%96%B9%E6%B3%95.html"/>
      <content type="html"><![CDATA[<p>首先广义矩估计($GMM$)很容易使我们联想到统计学中参数估计方法之一的矩估计。</p><h2>矩估计</h2><p>矩估计是什么呢？简单的说，就是用样本矩代替总体矩进行统计推断的方法。</p><p>一个最基础的例子是正态总体的参数估计问题。如果$x_i \sim N(\mu,{\sigma}^2)$，如何估计$\mu$和$\sigma$呢？本科的统计学一般会介绍两种方法：极大似然估计和矩估计。其中矩估计是我们今天的主角。观察到：</p><p>$$E(x_i)=\mu,\quad E(x_{i}^2)={\mu}^2+{\sigma}^2$$而根据大数定理，在一定的条件下，我们有：$$\bar{x_i}-\mu=O_p(1),\quad \bar{x_{i}^2}={\mu}^2+{\sigma}^2+O_p(1)$$</p><p>也就是说，当样本量足够大的时候，样本矩与总体矩只差了一个无穷小量，那么我们是不是可以<font color="blue">用样本矩代替总体矩得到参数的估计呢？</font></p><p>按照上面的思路，我们把$O_p(1)$去掉，同时把未知的总体参数写成其估计值，也就是$\hat{x}$的形式，我们得到了：$$\hat{\mu}=\bar{x_i},\quad \hat{\sigma^2}=\bar{x_{i}^2}+\bar{x_i}^2$$</p><p>如此，我们得到了两个总体矩的点估计。<font color="blue">在这个简单的例子里面，你只要把上面的大数定理的结论带到上面两个式子里面，很容易的就可以证明出两个点估计是一致的估计量。当然，值得注意的是，即便我使用的是矩条件，$\sigma$的估计也不是无偏的。一般而言，除了特殊情况，不管是$MLE$还是$MM$还是$GMM$，都不一定可以得到无偏的估计量。特别是在比较复杂的应用里面，一致就很不错了，无偏性的讨论真的繁琐。</font></p><h2>广义矩估计</h2><p>在上面的例子中，我们只使用了<strong>两个矩条件</strong>。然而我们知道，正态分布的矩是有无穷多个可以用的，那么我们是不是可以使用更多的矩条件呢？</p><p>但是有个问题不好解决。在这个例子里面，我们有两个未知参数，如果只使用一阶矩，那么只有一个方程解两个未知数，显然是不可能的。像上面一样，我们用两个矩条件解两个未知数，就解出来了。然而，当我们用一到三阶矩，总共三个方程求解的时候，三个方程求解两个未知数，可能无解。</p><p>方程数多了，反而没有解了，为什么呢？其实很简单，用三个方程中的任意两个方程，都可以求出一组解，那么三个方程我们就可以求出三组解。所以应该如何把这些矩条件都用上呢？到这里我们不妨引入一些记号。还是使用上面的例子，我们把上面的三个矩条件写到一个向量里面去，记：</p><p>$$g(x_i,\theta)=[x_i-\mu,{x_i}^2-\mu^2-\sigma^2,{x_i}^3-\mu^3-3\cdot \mu \sigma^2],\theta={\mu,\sigma^2}$$我们可以得到一个$3*1$的列向量，并且：</p><p>$$Eg(x_i,\theta)=0$$</p><p>上面就是我们要用的矩条件。而根据上面的思路，用其样本矩代替总体矩：</p><p>$$\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})=0$$解这个方程应该就可以得到参数$\theta$的估计。但是正如上面所说的，三个方程两个未知数，并不能确保这个方程有解，所以必须想一些其他办法。一个比较自然的想法是，上面的矩条件等于0，虽然我不太可能保证三个方程同时等于0，但是仿照$OLS$，我们可以让他们的平方和最小，也就是：</p><p>$$\underset{\hat{\theta} }{min}{ [ \frac{1}{N}\sum_{i}g(x_i,\hat{\theta}) ]}’[\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})]$$这样我们就能保证三个矩条件的样本矩都足够贴近于0，当然不可能同时为0。这样不就综合使用了三个矩条件的信息么？</p><p>更一般的，由于上面的$g$函数是一个$3*1$的列向量，我们可以使用一个权重矩阵$W$来赋予每个矩条件以不同的权重：</p><p>$$\underset{\hat{\theta} }{min}{ [ \frac{1}{N}\sum_{i}g(x_i,\hat{\theta}) ]}'W[\frac{1}{N}\sum_{i}g(x_i,\hat{\theta})]$$</p><p>只要这个$W$是一个正定矩阵，那么仍然可以保证每个样本矩都足够贴近于0。那么问题来了，既然对$W$的要求只要求正定矩阵，那么使用不同的权重矩阵就有可能得到不同的结果。</p><p>问题是，有没有一个最优的权重矩阵呢？当然是有的。可以证明，最优的权重矩阵应该是：使用这个权重矩阵，就得到了最有效的估计。</p><blockquote><p>$GMM$估计相当于给不同的矩条件赋予了不同的权重，然后才能这个权重得到最小化条件，不同的权重阵其实就对不同的估计量，“OLS, IV, 2SLS, GLS, RE, FE, SUR, 3SLS, Pooled OLS…全是它的特殊情况”</p></blockquote><h2>GMM延伸</h2><p>计量经济学的很多问题基本都可以归结为$GMM$的问题。从最简单的$OLS、2SLS$到稍微复杂一点的面板数据、动态面板等等，本质上都是在找矩条件。比如工具变量的$2SLS$，可以发现矩条件不过就是：</p><p>$$E[(y_i-{x_i}’\beta)*z_i]=0$$</p><p>套一下上面的公式，最优权重矩阵(的逆)为：</p><p>$$E[(y_i-{x_i}’\beta_0)*z_i*{z_i}’*(y_i-{x_i}’\beta_0)’]=E[e_i^2z_i{z_i}’]=\sigma^2Ez_i{z_i}’$$</p><p>带入到目标函数中，就得到了$2SLS$。甚至，一些其他的估计量，比如$MLE、M-estimator$等，在一定的条件下也可以转化为$GMM$，因为这些估计量的一阶条件可以看成是矩条件。所以$GMM$也就变成了一个统一的框架。为什么$GMM$这么受欢迎呢？因为$GMM$把复杂的统计过程抽象化成为一个（看似）简单的过程：找矩条件。只要你能找到矩条件，你就能估计。$GMM$把估计的繁琐细节全都抽象了，面对一个模型，你所需要做的所有事情就是找到矩条件，证明这个模型是可以识别的，然后什么也不用管，一股脑儿塞进去，结果就出来了。</p><p>所以呢如果你去看一些稍微复杂的模型，基本都可以归结为矩条件。</p><h2>参考</h2><ol><li><a href="https://www.zhihu.com/question/41312883/answer/91484566" target="_blank" rel="noopener">如何用简单的例子解释什么是 Generalized Method of Moments (GMM)?</a></li><li><a href="https://zh.wikipedia.org/wiki/%E5%B9%BF%E4%B9%89%E7%9F%A9%E4%BC%B0%E8%AE%A1" target="_blank" rel="noopener">广义矩估计</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> 数量经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本科计量经济学之回炉重造篇</title>
      <link href="/%E6%9C%AC%E7%A7%91%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B9%8B%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%E7%AF%87.html"/>
      <content type="html"><![CDATA[<p>本文基于本科的计量经济学课程，主要涉及宏微观、高等数学、线性代数、统计学相关知识。<br>学完我们需要掌握的主要内容包括计量经济学中基本假设及违背基本假设的处理；横截面、面板数据的分析与处理；基础时间序列分析与预测</p><p>参考书籍为</p><ul><li><a href="https://book.douban.com/subject/4717098/" target="_blank" rel="noopener">李子奈.计量经济学</a></li><li><a href="https://book.douban.com/subject/5068097/" target="_blank" rel="noopener">伍德里奇.计量经济学导论</a></li></ul><h2>1 基本假设篇</h2><p>通常在实际研究的计量经济学问题中，完全满足回归的基本假设的情况并不多见。不满足基本假定的情况。称为<strong>违背基本假定</strong>，其情况主要包括:</p><ol><li>随机干扰项存在异方差</li><li>随机干扰项的序列相关（或称自相关）</li><li>解释变量之间的多重共线</li><li>解释变量为随机变量，存在内生性</li></ol><h3>1.1 异方差性</h3><p>线性模型的基本假设中有$Var(\mu|x_1,x_2,\cdots,x_k)=d$，即<strong>随机干扰项的方差不因自变量的不同而不同</strong>。表现在现实的经济生活中，以消费水平受到收入水平的影响为例。$C = b_0 + b_1 * Y + \mu$,对于收入水平Y较低的群众而言，消费情况的变化是比较小的，但是对于收入水平较大的群体而言，其消费水平的变化差异可能就非常大了。用公式表示，即为$var(\mu|x_1,x_2,\cdots,x_k) = f(x_i,d)$</p><h3>1.2 数据异方差性的后果</h3><ol><li>导致参数估计无效，在估计的有效性中，利用了$Ε（\mu '\mu）= d^2I$这条同方差的假设,但是现在d与X是相关的，不能直接拿出来</li><li>参数显著性检验失去意义（显著性检验中，是要用到随机干扰项的误差的，由于异方差性，使用最小二乘法得出来的参数的方差并不是其真实方差了）</li><li>模型预测失效。（模型预测也是要用到随机干扰项的方差的）</li></ol><h3>1.3 检验异方差</h3><ol><li><p><strong>图示检验</strong>（使用Y-X散点图，或者$e^2~X$散点图进行判断，如果呈现一条水平线则是不存在异方差，否则，可能存在），这种方法的问题是：判断并不准确，是否算是水平线还是复杂性的异方差无法判断</p></li><li><p><strong>帕克（Park）检验与戈里瑟检验</strong>。 对样本残差平方$e_i^2$与X之间进行检验。设定模型$e_i^2\sim f(X)+\mu $,如果$e_i^2$与X之间存在显著的相关性，则原模型存在异方差性。<strong>该检验存在的问题</strong>：模型$e_i^2\sim f(X)+\mu $的函数形式和变量选择存在不确定性，而且，该模型本身自己也可能存在异方差性</p></li><li><p><strong>G-Q（Goldfeld-Quandt）检验</strong>:</p></li></ol><ul><li>a.按照某一个被认为可能存在异方差性的变量将样本进行从小到大的排序；</li><li>b.将样本分成两个部分，一个部分自变量大，一个部分自变量小；</li><li>c.对这两个样本分别进行回归，得到各自的残差平方和，在同方差的假设下，这两个残差平方和的大小应当是差异不大的；</li><li>使用上面得出的残差平方和构建F统计量。</li></ul><p><strong>方法的问题</strong>:只能检验单调递增还是单调递减型方差，并且可能需要对各个解释变量进行轮流实验。</p><ol start="4"><li><strong>怀特检验进行辅助回归</strong>：$e_i^2 \sim b_0 + b_1x_1 + b_2x_2 + b_3x_1x_2 + b_4x_1^2 + b_5x_2^2 + \mu $，可以证明，在同方差的假设下，从该辅助回归得到的$R^2$与样本容量的积，渐近服从自由度为辅助回归方程中解释变量个数的卡方分布 $nR^2 \sim \chi^2(k)$ 。WLS加权最小二乘法思想就是将不稳定的方差转换为稳定的方差乘以一个不稳定的函数。通过变换，使得模型变为同方差的情况。</li></ol><p>  假设我们已经知道了随机误差项的方差和自变量之间的关系:$var(\mu_i)=E(\mu_i^2)=d_i^2=f(X_{i,j}) \cdot q^2$(而不是在无异方差的情况下的 $var(\mu |X)=q^2$ )。那么，我们可以使用$\sqrt{f(X_{ij})}$去除以原模型，使得变化后的模型称为无异方差的情况。注：公式中$j$为变量的标号, $i$为样本的标号。 变化后的模型如下：</p><p>$$ Y_i / \sqrt{f(X_{ij})} = b_0 / \sqrt{f(X_{ij})} + b_1x_1 / \sqrt{f(X_{ij})} + \cdots + b_k  x_k / \sqrt{f(X_{ij})} + u_i/\sqrt(f(X_{ij}))$$</p><p>注意到这里，每个变量$X_{ij}$除以的都是其相对应的$f(X_{ij})$. 上面模型，异方差就是不存在的了，便可以用加权后的模型对参数进行估计。现在的问题是，如何对权重$f(x_{ij})$进行估计呢？</p><p>观察可以发现，等式左边可以用样本残差$e_i^2$来代替，等式左边$f(X_{ij})$中有$j$个参数，$q^2$为另一个参数。两边取对数，能够将等式转换为线性模型进行估计。接着就是使用帕克检验的方法，进行各种形式的尝试。从而估计出$f(X_{ij})$的形式 。</p><h3>1.4 异方差稳健标准误法</h3><p><strong>加权最小二乘法</strong>的关键是要寻找模型中随机扰动项$\mu $的方差与解释变量间的适当的函数形式，而这并非一件容易的事。</p><p>如果很难找到的话，可以用异方差的稳健标准误方法，进行替代。 <font color="red">在有异方差的情况下，参数估计仍然是无偏的，但是参数估计的方差和标准差会与传统的有所区别，从而无法保证估计的有效性，但并不影响估计的无偏性和一致性。</font>那么我们仍然采用普通的最小二乘估计量，但是在进行参数检验的时候使用修正后的相应方差。（至于参数的有效性无法满足的问题，并不关注）</p><ol><li>在无异方差下，参数估计的方差为$var(b|X) = d^2 (x’x)^{-1}$，在有异方差下，则为 $var(b) =　(x’x)^{-1}x’D(x’x)^{-1}x’$,这里$D$为$n*1$的向量。使用普通最小二乘法估计的残差平方$e_i^2$形成的向量$e’e$作为向量D的代表。怀特证明了这种做法是对$var(b) =　(x’x)^{-1} * x’ * D * (x’x)^{-1} * x’$的一致估计。</li><li>当存在异方差时，异方差稳健标准误法虽然不能得到有效的参数估计，但是由于得到了普通最小二乘估计量的正确的方差估计，使得以估计量方差为基础的各项检验不再失效，是消除异方差性不良后果的主要手段。</li></ol><h2>2 序列相关性</h2><h3>2.1 序列相关的含义</h3><p>  在经典的线性模型假设中，有<font color="red">随机干扰项独立，即互不相关的假设。</font>这个假设的意思是说，对于造成结果而言，不能由自变量解释到的那部分随机干扰项是独立的。<font color="blue">例如</font>，有两块相邻的水田，其各自产量与施肥量，日照量等有关。但两块水田产量的随机因素之间是不存在关系的，不会因为这块水田随机因素大，那块也大。</p><p>用公式描述，就是：$Cov(\mu _i, \mu _j)=0$， i和j是观测样本。序列相关则意味着样本之间随机因素是具有相关性的，上面例子中，有些无法观测到的对水田产量的因素，例如土壤肥力如果是随机干扰项的话，那么毫无疑问相邻两块土地之间的随机干扰项是具有相关性的。</p><p>通常，由于样本中有$n$个随机干扰项，如果仅存在$E（\mu _i,\mu _{i+1}）\neq 0$，那么称之为一阶自相关，一阶自相关是比较常见的序列相关问题。<font color="blue">例如</font>：一个人的素质可能与他的朋友的素质是相关的，但是与其朋友的朋友的素质之间，相关性就可以忽略了；或者我们可以理解为，一个人素质与其朋友的朋友之间的关系，事实上是通过其朋友来传导的。那么，这样我们就可以将多阶自相关的问题，通过一阶自相关来理解了。</p><p>因此，为了能够便于理解和进行计算，我们通常都进行一阶自相关的研究。我们将一阶自相关用公式表述为：$\mu _i = p*\mu <em>{i+1} + e</em>{i -1}  &lt; p$</p><p>一般经验而言，对于采用时间序列数据作样本的计量经济学问题，由于在不同样本点上解释变量以外的其它因素（随机干扰项）在时间上的连续性，或者说惯性，往往会导致序列相关性。</p><h3>2.2 序列相关性的后果</h3><ol><li><p><strong>参数估计非有效</strong>：在有效性的证明中利用了 $E(uu’) = d^2I$, 但是现在这个条件是无法满足了。所以有效性便不再满足。</p></li><li><p><strong>变量的显著性检验失去意义：</strong>随机干扰项向量的协方差矩阵不再是 $d^2I$，因此原本的参数分布和显著性t检验也不再满足。</p></li><li><p><strong>模型的预测失效：</strong>原因同变量显著性检验失去意义。</p></li></ol><h3>2.3 检验序列相关</h3><ol><li><p><strong>图示法</strong>： 使用OLS的样本残差作为随机干扰项的估计，画出$e_t$和$e_{t-1}$之间的散点图，看二者之间是否存在明显的相关性。该方法存在主观性和不确定性。</p></li><li><p><strong>回归检验法</strong>： 对$e_t$和$e_{t-1}$进行回归检验，看二者之间是否存在显著的关系。</p></li><li><p><strong>DW检验</strong>：构造一个统计量，服从DW分布，然后再使用DW准则进行检验。（用的较少，局限性很大）</p></li><li><p><strong>拉格朗日乘数（LM）检验</strong>：将模型转换为受约束的回归方程即$Y_i=b_0+b_1*x_{i1}+b_2*x_{i2}+\cdots+b_k*x_{ik}+p_1*u_{i-1}+p_2*u_{i-2}+\cdots+p_k*u_{i-k}+e_k$。检验约束条件$H_0：p_1=p_2=\cdots =p_k=0$(k可以自行决定)，再使用检验模型约束条件的LM统计量检验该约束条件即可。</p></li></ol><h3>2.4 如何补救序列相关</h3><p>补救序列相关与补救异方差一样,存在两种思路:</p><ul><li>一就是变换原模型为不存在序列相关的模型,再用OLS来进行估计,即为广义最小二乘法(GLS)和广义差分法（GDM）;</li><li>另一条途径是仍然采用OLS的估计参数，但是对参数估计量的方差或者标准差进行修正。</li></ul><h4>2.4.1 广义最小二乘法</h4><p>  广义最小二乘，是具有普遍意义的最小二乘，普通最小二乘和加权最小二乘是它的特例。<font color="red">广义最小二乘是不需要同方差性和无序列相关的假设的。</font>它将随机变量的协方差矩阵不再表示为 $d^2I$这样的形式， 而是用$cov(u,u’) = p^2 * W$来表示。其中 $W = DD’$.进一步的，变换模型为 $D^{-1}*Y = D^{-1} * X_b + D^{-1}*u$, 该模型便不再有异方差和序列相关，可以对其使用OLS进行估计。（李子奈《计量经济学》pp.127）</p><p>  广义最小二乘法真正的难题是如何去估计协方差矩阵$W$，在序列自相关的情况下，若只有$n$个样本点，要对$\frac{n*(n-1)}{2} + k +2$ 个参数进行估计是几乎不可能的。因此，只能是说对随机干扰项自相关的结构事先给出必要的假设。一般而言，我们假设随机干扰项是一阶自相关的：即$\mu _t = p\mu _{t-1} + e$，对该模型进行估计，便可以得到协方差矩阵W以及权重矩阵D 。</p><h4>2.4.2 广义差分法</h4><p>  广义差分法实质上就是广义最小二乘法，不过是损失了部分样本观测值，具体可见《计量经济学》（李子奈）pp.129。</p><p>随机干扰项相关系数的估计：无论是使用广义最小二乘法还是广义差分法，都需要知道不同样本点之间随机干扰项的相关系数$r_1,r_2\cdots r_p$等，必须对其进行估计，即对$u_t = r_1 * u_{t-1} + r_2 * u_{t-2} + …+ r_p * u_{t-p} + e_t$进行估计。但是事实上$\mu <em>{t}$是无法观测到的，我们只能使用$e</em>{t}$来对其进行近似的估计。</p><p>具体方法为，先使用OLS对原始模型进行估计，对$e_{t},e_{t-1}\cdots e_{t-p}$之间进行线性估计得出随机干扰项的相关系数。再将其带入到广义差分法或者广义最小二乘法中，得到新的$e_{t},e_{t-1}\cdots e_{t-p}$,再次进行估计，得出他们的相关系数，重复上述步骤，直到$e_{t},e_{t-1}\cdots e_{t-p}$的值趋于稳定。我们称该方法为<strong>科克伦-奥科特（Cochrane-Orcutt）迭代法</strong>。</p><p><strong>序列相关稳健标准误法</strong>存在序列相关时，OLS估计的无偏性和一致性仍然是有的，但是有效性无法保证，因此，我们可以对随机干扰项的协方差进行修正，在进行显著性检验时使用改修正的稳健标准误。具体公式过于冗长，可参考《计量经济学》（李子奈）pp.130</p><h3>2.5 虚假序列相关问题</h3><p>  若模型设定中遗漏了重要的解释变量，从而导致了序列相关的出现，我们称之为<strong>虚假序列相关</strong>。我们在处理序列相关问题时，应当要将虚假序列相关的可能性先排除掉，即排除掉遗漏变量的可能。如何避免出现模型设定的偏误问题呢？那就是在开始时建立一个“一般”的模型，然后逐渐剔除缺失不显著的变量。</p><h2>3 多重共线性</h2><p>共线性是指自变量之间存在较大的相关性，导致$|X’X| \neq 0$，从而$(X’X)^{-1}$对角线上的元素较大，随机干扰项的协方差矩阵$d^2(X’X)^{-1}$对角线上的元素也较大，导致一系列的不良后果。主要包括：</p><ol><li>完全共线性下，估计量不存在，完全共线性下$|X’X|=0$，$X’X$没有逆，OLS没法得出参数估计量。</li><li>普通最小二乘法方差变大，导致通过样本计算出来的t值比较小$(X’X）^{-1}$在t统计量的分母中，导致t统计量较小），由于样本本身的共线性问题，导致了t检验的不可靠。同时，也会使得因变量区间预测的“区间”变大，使得预测失去意义，模型不能进行外推。</li><li>参数估计量的经济含义不合理。若$X_1，X_2$之间存在共线性，那么二者其中一个可以由另一个表征出来。他们各自的参数估计量不再代表本身的经济意义，而是代表二者对被解释变量的共同影响。<strong>经验告诉我们，在多元线性回归模型的估计中，如果出现了参数估计值的经济意义明显不合理的情况，应该首先怀疑是否存在多重共线性</strong>。</li></ol><h3>3.1 造成多重共线性的原因</h3><ol><li>经济变量相关的共同趋势。这在时间序列样本中情况比较多。</li><li>滞后变量的引入。例如,居民消费$C$受到总收入以及前期的消费$C_{t-1}$的影响，但是毫无疑问的，前期的消费$C_{t-1}$会影响到当期的收入$Y_{t}$。所以模型中毫无疑问会出现共线性的问题。在这样一种情况下，$Y_{t}$的参数$b_{1}$就不再代表收入对消费的影响了，而是$Y_{t}$与$C_{t-1}$对$C_{t}$的共同影响，二者的参数经济意义不明了。所以可能会出现不合常理的参数估计值。</li><li>样本资料的限制。由于社会科学采用的数据是“社会实验”得出，而并非是控制实验得出，所以自变量样本是不受控制的，某些变量之间可能总是会存在一些共线性。例如时间序列样本就算是这种情况。</li></ol><h3>3.2 多重共线性的检验</h3><p><strong>对两个解释变量</strong>：可以通过解释变量的样本协方差矩阵，发现解释变量之间的两两相关性，对于相关性非常高的两个解释变量，可能存在共线性的问题。</p><p><strong>对多个解释变量之间的相关性</strong>：所谓多个解释变量相关就是如$x_1 = x_2 + x_3 + x_4$这种。使用综合统计检验，如果在OLS下，模型的$R^2$与$F$值较大，但是各参数检验的$t$值较小，说明各解释变量对$Y$的联合线性作用显著。但从较小的$t$值，我们可以估计到，可能存在共线性，从而使得解释变量对$Y$的独立作用不能分辨，故$t$检验不显著。</p><h3>3.3 判别多重共线性的范围</h3><p>知道模型有多重共线性，进一步的，我们希望能够将引起多重共线性的变量找出来，以进一步地对模型进行调整。</p><p>具体的方法有判定系数检验法和逐步回归法。</p><ol><li><p>判定系数检验法：使模型中每个解释变量分别以其余解释变量为解释变量进行回归计算,即 $X_{i} \sim x_{1} + x_{2}+\cdots +x_{i-1} + x_{i+1}+\cdots +x_{k}$。如果发现该模型的判定系数$R^2$较大，则说明该解释变量$x_{i}$能够用其它解释变量表征出来。至于如何判定$R^2$是否足够大，我们可以做$F$检验。</p></li><li><p>逐步回归法：</p></li></ol><ul><li>先做$Y$与各$X_i$分别一元线性回归，找出$R^2$最大的那个$X_i$，以该一元线性回归为基础；</li><li>逐个引入解释变量，观察拟合优度（修正后的拟合优度）的变化（也可以使用AIC准侧），如果拟合优度变化显著，则说明该变量是一个独立解释变量，如果拟合优度变化不显著，说明该解释变量可以用其它变量的线性组合替代，也就是说它与其它变量之间存在共线性关系。</li></ul><h3>3.4 克服多重共线性的办法</h3><ol><li><p><strong>排除引起共线性的变量</strong>：这种方法可能存在的问题是，某变量本来是应当存在于模型当中的，只是由于样本的问题，使得该变量显示出共线性。剔除掉该变量将会导致回归模型在进行预测时的准确性下降。如果换一组样本，可能共线性的情况就不再存在了。因此，是否真的应当剔除掉变量应当还要进行实际经济模型或者实际意义进行考虑。如果某个变量是具有非常明显的经济意义的，那么即使该变量存在共线性，也不能轻易剔除掉。</p></li><li><p><strong>差分法</strong>：常用于时间序列数据中，使用自变量和因变量的增量作为回归的变量。这是由于变量增量的相关性毫无疑问肯定是要比变量本身的相关性弱的。</p></li><li><p><strong>岭回归与LASSO</strong>：可参见<a href="http://www.cnblogs.com/pingzeng/p/5040911.html" target="_blank" rel="noopener">多重共线性的解决方法之——岭回归与LASSO</a></p></li></ol><h2>4 随机解释变量问题 （内生性问题）</h2><p>  计量经济假设中，我们是假设自变量是确定变量，是非随机的。<s>所谓是确定变量，我们可以用科学实验中的对照实验来进行说明，<font color="blue">例如</font>：判断不同的水分条件对粮食产量的影响时，我们将控制其它对产量有影响的变量，如光照，土壤，种子等，仅仅使得水分条件不一样，进而判断水分条件对产量的影响。在这种实验中，水分是可以进行人为控制的确定变量，我们称这种实验为“对照实验”。</s></p><p><s>然而，由于伦理和实际操作上的种种不可行，经济学家是不可能拿整个社会来做实验的。例如不能故意控制某个地方的公共投资高，另一个地方的公共投资低，从而判断政府公共投资对收入的影响。经济学家只能使用既有的现实社会运行数据，通过判断不同公共投资地区的GDP的不同来判断公共投资的影响，经济学家称这种为“自然实验”。 但是，事实上，公共投资却并不是完全的确定性的，它并不是政府主动控制想投入多少就投入多少，其大小毫无疑问是受到地方财政收入的约束的。从这个角度上来说，也就是GDP越高的地方，毫无疑问也就能够投入越多的公共投资。</s></p><p><s><font color="red">那么公共投资与GDP的因果关系就变得非常复杂了，到底公共投资是因？还是GDP是因呢？我们称这种情况为随机解释变量问题：即解释变量无法控制，是具有随机性的。</font></s></p><p>  随机解释变量问题可以分为3种不同的情况：</p><ol><li>随机解释变量$X_i$与随机干扰项$\mu $独立： $cov(X_{i},\mu ) = E(X_{i}\mu )= E(X_{i})*E(\mu )=0$，这种情况，随机解释变量问题对模型的估计不会产生影响。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期无关但是异期相关： $cov(X_{i}, \mu _{i-s}) \neq 0$，这种情况，得到的参数估计量是有偏的，但是却是一致的（可以从OLS估计量的形式中推出来）。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期先关：这种情况得到的参数估计量有偏且非一致。</li></ol><h3>4.1 引起内生性问题的通常理由</h3><ol><li>经济模型中因变量滞后项的引用，通常会造成随机解释变量异期相关。</li><li>存在互为因果的模型，例如上文所述公共投资与GDP。</li></ol><h3>4.2 随机解释变量的解决方法</h3><h4>4.2.1 工具变量</h4><p>工具变量是指该变量与随机解释变量之间存在较高的相关性，而且对随机解释变量的解释能力也非常高（$R^2$比较大），但是该解释变量与模型的随机干扰项不相关，与被解释变量也不相关。即满足：</p><ul><li>工具变量必须外生，即$Cov(z,\mu )=0$。</li><li>工具变量必须与内生变量$x$相关，即$Cov(z,x) \neq 0$。</li></ul><h4>4.2.2 工具变量的估计</h4><p>应该根据常识及经济理论判断$Cov(z,\mu )$是否合理。</p><p>我们可以检验$Cov(z,x )\neq 0$是否成立,即检验在$H_0:\pi_1 = 0$在$x=\pi_0+\pi_1 z+v$,这称作第一阶段回归</p><p>假设简单回归情形$y=\beta_0+\beta_1 x+\mu$，并给定我们假设$Cov(z,y)=\beta_1 Cov(z,x)+Cov(z,\mu )$</p><p>于是解出$\beta_1=\frac{Cov(z,x)}{Cov(z,x)}$，得到$\beta_1$估计量$$\hat{\beta_1}=\frac{\sum_{i=1}^n(z_i-z)(y_i - \bar{y})}{\sum_{i=1}^n(z_i-\bar{z})(x_i - x)}$$</p><p>为了进行推断，我们需要计算统计量和置信区间的标准误。通常的方法是增加一个同方差假设</p><p>$E(\frac{\mu^2}{z})=\sigma2=Var(\mu )$得出，$$Var(\hat{\beta_1})=\frac{\sigma^2}{n\sigma_x^2 \rho_{x,z}^2} \\ se(\hat{\beta_1})=\frac{\hat{\sigma}^2}{ SST_{x}R_{x,z}^2}$$</p><blockquote><p>未完待续 loading…</p></blockquote>]]></content>
      
      <categories>
          
          <category> 经济学 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数量经济学 </tag>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网站迁移(hexo)</title>
      <link href="/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB-hexo.html"/>
      <content type="html"><![CDATA[<p>由于wordpress访问速度太慢，懒得折腾XD，把一些博客文章迁移到新博客上。目前使用Github Page + Hexo的方案比较流行，留作日常记录。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo g // Generate content.</span><br><span class="line">hexo s // preview <span class="keyword">in</span> localhost.</span><br><span class="line">hexo d // deploy to the blog.</span><br></pre></td></tr></table></figure><div align="center">The end</div>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017年(Lunar Year)读书与看剧</title>
      <link href="/Lunar_Year.html"/>
      <content type="html"><![CDATA[<a id="more"></a><h3>读书（文学类）</h3><ul><li>加缪. 《鼠疫》</li><li>朱光潜.《西方美学史》 <em>读的慢，忘的快</em></li><li>乔治·奥威尔. 《1984》</li><li>乔治·奥威尔. 《动物农庄》</li><li>艾玛·拉金《在缅甸寻找乔治·奥威尔》</li><li>凯鲁亚克. 《在路上》</li><li>白先勇 《台北人》</li><li>尤瓦尔·赫拉利 《人类简史:从动物到上帝》</li><li>尤瓦尔, 赫拉利. 《未来简史》</li><li>斯蒂芬·茨威格. 《人类群星闪耀时》</li><li>尼古拉斯·斯帕克思. 《分手信》</li><li>卡勒德·胡赛尼. 《群山回唱》</li><li>费孝通. 《乡土中国》</li></ul><h3>读书（自我提高及工具书）</h3><ul><li>李忠秋. 《结构思考力》</li><li>尼尔·布朗《学会提问》</li><li>布鲁克·诺埃尔·摩尔《批判性思维》</li><li>读自我提高类书籍本意在于提升自身逻辑思考能力，上面几本书能够很好的达到目的。</li><li>Johnson. 实用多元统计分析.</li><li>RobertV.Hogg. 数理统计学导论</li><li>张维迎. 博弈论与信息经济学</li><li>Nasrabadi, Nasser M. “Pattern recognition and machine learning.”</li></ul><h3>看剧</h3><ul><li>《怦然心动》- 纯爱类影片，学会从整体审视生活</li><li>《时空恋旅人》 - 看完觉得幸福了一辈子</li><li>《饮食男女》 - 人之大欲，不过饮食男女</li><li>《闻香识女人》 - 善良、正直，是走得多远都不能丢弃的道德品质</li><li>《海边的曼彻斯特》 - 每个人都是一座孤独的岛</li><li>《东京爱情故事》 - 爱情是个很难说的事儿吧，thank you，赤名莉香</li><li>《白色巨塔》- 过程正义与结果正义</li><li>《NANA》 - 主题曲很好听</li><li>《熔炉》 - 不想评论，谢谢</li><li>《聚焦》 - 同上</li><li>《两杆大烟枪》 - 同《低俗小说》《疯狂的石头》，贵在叙事方式</li><li>《傲慢与偏见》、《罗马假日》、《南丁格尔》、《乱世佳人》还说什么，都是经典，无论看几遍，都能品出味道来.</li></ul><div align="center">和子由渑池怀旧 .苏轼<br>人生到处知何似，应似飞鸿踏雪泥。<br>泥上偶然留指爪，鸿飞那复计东西。<br>老僧已死成新塔，坏壁无由见旧题。<br>往日崎岖还知否，路长人困蹇驴嘶。<br></div>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MacOS下使用python的多版本方案</title>
      <link href="/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88.html"/>
      <content type="html"><![CDATA[<h2>背景</h2><p>MacOS系统本身自带python，但是版本仍然停留在python2.7。私以为python2与python3语言差别比较大，python3额外一些新特性如**“通配符**，字典可排序，统一的Unicode编码”**等，都值得去尝试。为此，保证电脑上两个版本都能共存是很必要的。</p><h2>方案一：使用pyenv兼容多版本</h2><p>pyenv 是轻量的Python版本管理器，帮助你在电脑上建立多个版本的python环境，并提供方便的切换方法。pyenv-virtualenv 是 pyenv的扩展工具（类Unix系统上），可以搭建虚拟且独立的python环境，可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。</p><h3>1. 使用Mac OSX的 Homebrew 安装</h3><p>Homebrew作为OS X上强大的包管理器，为系统软件提供了非常方便的安装方式，独特式的解决了包的依赖问题，并不再需要烦人的sudo，一键式编译，无参数困扰，安装Homebrew：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>安装完成后，根据提示将如下语句加入到 <code>～/.bash_profile</code> 或<code>~/.bashrc</code> 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot; # 这句可以不加</span><br></pre></td></tr></table></figure><h3>2. pyenv 常用命令</h3><p>使用 <code>pyenv commands</code> 显示所有可用命令</p><h4>python 安装与卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv install 2.7.3   # 安装python</span><br><span class="line">~$ pyenv uninstall 2.7.3 # 卸载python</span><br></pre></td></tr></table></figure><h4>python切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv global 2.7.3  # 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span><br><span class="line">~$ pyenv local 2.7.3 # 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</span><br></pre></td></tr></table></figure><h4>python优先级</h4><p><strong>shell &gt; local &gt; global</strong></p><p>pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv shell <span class="number">2.7</span><span class="number">.3</span> <span class="comment"># 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。</span></span><br><span class="line"><span class="comment"># 这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。</span></span><br><span class="line">~$ pyenv shell --unset</span><br><span class="line">~$ pyenv rehash  <span class="comment"># 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</span></span><br></pre></td></tr></table></figure><h2>方案二：使用Anaconda包管理多版本python</h2><p>Anaconda 是 Python 的一个发行版，如果把 Python 比作 Linux，那么 Anancoda 就是 CentOS 或者 Ubuntu。它解决了Python开发者的两大痛点。</p><ul><li>提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。</li><li>提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题。###1. 下载 Anaconda直接在官网下载最新版本的 <a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">https://www.continuum.io/downloads</a> 安装包， 选择对应Python版本的安装包，下载完成后直接安装，安装过程选择默认配置即可，大约需要1.8G的磁盘空间。</li></ul><p>conda 是 Anaconda 下用于包管理和环境管理的命令行工具，是 pip 和 vitualenv 的组合。安装成功后 conda 会默认加入到环境变量中，因此可直接在命令行窗口运行 <code>conda</code> 命令，命令帮助可通过<code>conda -h</code>查看。如果你熟悉 virtualenv，那么上手 conda 非常容易，不熟悉 virtulenv 的也没关系，它提供的命令就几个，非常简单。我们可以利用 conda 的虚拟环境管理功能在 Python2 和 Python3 之间自由切换。</p><h3>2. 多版本切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 基于 python2.7 创建一个名为py2_env 的环境</span><br><span class="line">conda create --name py2_env python=2.7</span><br><span class="line"></span><br><span class="line"># 基于 python3.6 创建一个名为py3_env 的环境</span><br><span class="line">conda create --name py3_env python=3.6 </span><br><span class="line"></span><br><span class="line"># 激活python环境</span><br><span class="line">activate py3_env  # windows</span><br><span class="line">source activate py3_env # linux/mac</span><br><span class="line"></span><br><span class="line"># 切换到python3</span><br><span class="line">activate py3_env</span><br></pre></td></tr></table></figure><h3>3. 包管理</h3><p>conda 的包管理功能是对 pip 的一种补充，如果当前已经激活了某个Python环境，那么就可以在当前环境开始安装第三方包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装 numpy </span><br><span class="line">conda install numpy</span><br><span class="line"># 查看已安装的包</span><br><span class="line">conda list </span><br><span class="line"># 包更新</span><br><span class="line">conda update numpy</span><br><span class="line"># 删除包</span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 机器学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python字符串处理拾掇</title>
      <link href="/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%8B%BE%E6%8E%87.html"/>
      <content type="html"><![CDATA[<p>Python 字符串操作（string替换、删除、截取、复制、连接、比较、查找、包含、大小写转换）</p><p>一、去空格及特殊符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.strip().lstrip().rstrip(<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p>二、复制字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strcpy(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strcpy'</span></span><br><span class="line">sStr2 = sStr1</span><br><span class="line">sStr1 = <span class="string">'strcpy2'</span></span><br><span class="line">print(sStr2)</span><br></pre></td></tr></table></figure><p>三、连接字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strcat(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strcat'</span></span><br><span class="line">sStr2 = <span class="string">'append'</span></span><br><span class="line">sStr1 += sStr2</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>四、查找字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strchr(sStr1,sStr2)</span></span><br><span class="line"><span class="comment"># &lt; 0 为未找到</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'s'</span></span><br><span class="line">nPos = sStr1.index(sStr2)</span><br><span class="line">print(nPos)</span><br></pre></td></tr></table></figure><p>五、比较字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strcmp(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'strch'</span></span><br><span class="line">print(cmp(sStr1,sStr2))</span><br></pre></td></tr></table></figure><p>六、扫描字符串是否包含指定的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strspn(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'12345678'</span></span><br><span class="line">sStr2 = <span class="string">'456'</span></span><br><span class="line"><span class="comment">#sStr1 and chars both in sStr1 and sStr2</span></span><br><span class="line">print(len(sStr1 <span class="keyword">and</span> sStr2))</span><br></pre></td></tr></table></figure><p>七、字符串长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlen(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'strlen'</span></span><br><span class="line">print(len(sStr1))</span><br></pre></td></tr></table></figure><p>八、将字符串中的大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlwr(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'JCstrlwr'</span></span><br><span class="line">sStr1 = sStr1.upper()</span><br><span class="line"><span class="comment">#sStr1 = sStr1.lower()</span></span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>九、追加指定长度的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncat(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">sStr2 = <span class="string">'abcdef'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 += sStr2[<span class="number">0</span>:n]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十、字符串指定长度比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncmp(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">sStr2 = <span class="string">'123bc'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">print( cmp(sStr1[<span class="number">0</span>:n],sStr2[<span class="number">0</span>:n]))</span><br></pre></td></tr></table></figure><p>十一、复制指定长度的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncpy(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">''</span></span><br><span class="line">sStr2 = <span class="string">'12345'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 = sStr2[<span class="number">0</span>:n]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十二、将字符串前n个字符替换为指定的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strnset(sStr1,ch,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">ch = <span class="string">'r'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 = n * ch + sStr1[<span class="number">3</span>:]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十三、扫描字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strpbrk(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'cekjgdklab'</span></span><br><span class="line">sStr2 = <span class="string">'gka'</span></span><br><span class="line">nPos = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> sStr1:</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">in</span> sStr2:</span><br><span class="line">        nPos = sStr1.index(c)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print( nPos)</span><br></pre></td></tr></table></figure><p>十四、翻转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strrev(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr1 = sStr1[::<span class="number">-1</span>]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十五、查找字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strstr(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr2 = <span class="string">'cde'</span></span><br><span class="line">print(sStr1.find(sStr2))</span><br></pre></td></tr></table></figure><p>十六、分割字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strtok(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">sStr2 = <span class="string">','</span></span><br><span class="line">sStr1 = sStr1[sStr1.find(sStr2) + <span class="number">1</span>:]</span><br><span class="line">print(sStr1)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">s = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">print(s.split(<span class="string">','</span>))</span><br></pre></td></tr></table></figure><p>十七、连接字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter = <span class="string">','</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line">print(delimiter.join(mylist))</span><br><span class="line">PHP 中 addslashes 的实现</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addslashes</span><span class="params">(s)</span>:</span></span><br><span class="line">    d = &#123;<span class="string">'"'</span>:<span class="string">'\\"'</span>, <span class="string">"'"</span>:<span class="string">"\\'"</span>, <span class="string">"\0"</span>:<span class="string">"\\\0"</span>, <span class="string">"\\"</span>:<span class="string">"\\\\"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s) </span><br><span class="line">s = <span class="string">"John 'Johny' Doe (a.k.a. \"Super Joe\")\\\0"</span></span><br><span class="line">print(s)</span><br><span class="line">print( addslashes(s))</span><br></pre></td></tr></table></figure><p>十八、只显示字母与数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnlyCharNum</span><span class="params">(s,oth=<span class="string">''</span>)</span>:</span></span><br><span class="line">    s2 = s.lower();</span><br><span class="line">    fomart = <span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">in</span> fomart:</span><br><span class="line">            s = s.replace(c,<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line">print(OnlyStr(<span class="string">"a000 aa-b"</span>))</span><br></pre></td></tr></table></figure><p>十九、截取字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str = ’<span class="number">0123456789</span>′</span><br><span class="line"><span class="keyword">print</span> str[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#截取第一位到第三位的字符</span></span><br><span class="line"><span class="keyword">print</span> str[:] <span class="comment">#截取字符串的全部字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">6</span>:] <span class="comment">#截取第七个字符到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-3</span>] <span class="comment">#截取从头开始到倒数第三个字符之前</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>] <span class="comment">#截取第三个字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-1</span>] <span class="comment">#截取倒数第一个字符</span></span><br><span class="line"><span class="keyword">print</span> str[::<span class="number">-1</span>] <span class="comment">#创造一个与原字符串顺序相反的字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment">#截取倒数第三位与倒数第一位之前的字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:] <span class="comment">#截取倒数第三位到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取，具体啥意思没搞明白？</span></span><br></pre></td></tr></table></figure><p>二十、直接贴过来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"Hello My friend"</span></span><br><span class="line"><span class="comment"># 字符串是一个整体。如果你想直接修改字符串的某一部分，是不可能的。</span></span><br><span class="line"><span class="comment"># 但我们能够读出字符串的某一部分。</span></span><br><span class="line"><span class="comment"># 子字符串的提取</span></span><br><span class="line">str[:<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 字符串包含判断操作符：in，not in</span></span><br><span class="line"><span class="string">"He"</span> <span class="keyword">in</span> str</span><br><span class="line"><span class="string">"she"</span> <span class="keyword">not</span> <span class="keyword">in</span> str</span><br><span class="line"></span><br><span class="line"><span class="comment"># string模块，还提供了很多方法，如</span></span><br><span class="line">S.find(substring, [start [,end]]) <span class="comment">#可指范围查找子串，返回索引值，否则返回-1</span></span><br><span class="line">S.rfind(substring,[start [,end]]) <span class="comment">#反向查找</span></span><br><span class="line">S.index(substring,[start [,end]]) <span class="comment">#同find，只是找不到产生ValueError异常</span></span><br><span class="line">S.rindex(substring,[start [,end]])<span class="comment">#同上反向查找</span></span><br><span class="line">S.count(substring,[start [,end]]) <span class="comment">#返回找到子串的个数</span></span><br><span class="line"></span><br><span class="line">S.lowercase()</span><br><span class="line">S.capitalize()      <span class="comment">#首字母大写</span></span><br><span class="line">S.lower()           <span class="comment">#转小写</span></span><br><span class="line">S.upper()           <span class="comment">#转大写</span></span><br><span class="line">S.swapcase()        <span class="comment">#大小写互换</span></span><br><span class="line"></span><br><span class="line">S.split(str, <span class="string">' '</span>)   <span class="comment">#将string转list，以空格切分</span></span><br><span class="line">S.join(list, <span class="string">' '</span>)   <span class="comment">#将list转string，以空格连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理字符串的内置函数</span></span><br><span class="line">len(str)                <span class="comment">#串长度</span></span><br><span class="line">cmp(<span class="string">"my friend"</span>, str)   <span class="comment">#字符串比较。第一个大，返回1</span></span><br><span class="line">max(<span class="string">'abcxyz'</span>)           <span class="comment">#寻找字符串中最大的字符</span></span><br><span class="line">min(<span class="string">'abcxyz'</span>)           <span class="comment">#寻找字符串中最小的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># string的转换</span></span><br><span class="line">            </span><br><span class="line">float(str) <span class="comment">#变成浮点数，float("1e-1")  结果为0.1</span></span><br><span class="line">int(str)        <span class="comment">#变成整型，  int("12")  结果为12</span></span><br><span class="line">int(str,base)   <span class="comment">#变成base进制整型数，int("11",2) 结果为2</span></span><br><span class="line">long(str)       <span class="comment">#变成长整型，</span></span><br><span class="line">long(str,base)  <span class="comment">#变成base进制长整型，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的格式化（注意其转义字符，大多如C语言的，略）</span></span><br><span class="line">str_format % (参数列表) <span class="comment">#参数列表是以tuple的形式定义的，即不可运行中改变</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> <span class="string">""</span>%s<span class="string">'s height is %dcm" % ("My brother", 180)</span></span><br><span class="line"><span class="string">          #结果显示为 My brother'</span>s height <span class="keyword">is</span> <span class="number">180</span>cm</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 机器学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在大三下学期</title>
      <link href="/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%B8%89%E4%B8%8B%E5%AD%A6%E6%9C%9F.html"/>
      <content type="html"><![CDATA[<p>  大学时光经不起回味，一眨眼的时间，大学生生活已经步入尾声，随之而来的就该是毕业季的伤感了。步入大三的同学们，都在为步入”社会“摩拳擦掌，该考研的考研，该工作的工作。即使是平时班上最不爱学习的，也时不时开始向人打听起公务员考试的相关事宜了 :blush: :blush:</p><a id="more"></a><h2>时代的浪潮已经拍到了我们这代人的脚下</h2><p>  每每看到知乎上“大三了，考研还来得及吗？”，“大三了，学计算机还来得及吗？”诸如此类的问题，总也庆幸自己两年多的时间做了一些事读了一些书，但我知道自己做的还远远远远不够看。大三的生活，伴着毕业的步伐，来的匆匆。自己的学年论文加上向老师申请的论文，学的懵懂的专业课，还得挤出时间来为考研蓄力，冷不丁还夹带点感情的纠结。Flag ～</p><p>时光总是匆匆的催人老，情爱总是让人烦恼。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=394467&auto=0&height=66"></iframe><h2>写博客的初衷</h2><p>  大脑的存储空间是有限的，为了让新知识进来，你就得把暂时用不上旧知识遗忘掉。但是，自己当时花了那么多宝贵时间，一步一步摸索着过来所接触到的总结过的知识点，就这样被遗忘，或者被藏在某本笔记本的角落是在太可惜。当你怀着一颗热忱的心去进入一个领域，你只有从宏观上清楚了行业整体，从微观上把握住各个知识点原理，才算得上入门选手。</p><p>  为此，记录下来并且可查可复习非常重要，这也就是Blog能为我提供的。</p><p><em>性格决定你做怎样的选择，你的选择决定你怎样的人生。生命只有一次，而且它正在以不可逆转的姿态向前推进。你可以去旅行，可以朝九晚五地上班，还可以不顾一切地去创业。只是，千万不要选择平庸的人生。</em></p><blockquote><p>黄色的树林里分出两条路，可惜我不能同时去涉足，我在那路口久久伫立，我向着一条路极目望去，直到它消失在丛林深处。</p></blockquote><blockquote><p>但我选了另外一条路，它荒草萋萋，十分幽寂，显得更诱人，更美丽；虽然在这条小路上，很少留下旅人的足迹。</p></blockquote><blockquote><p>那天清晨落叶满地，两条路都未经脚印污染。啊，留下一条路等改日再见！但我知道路径延绵无尽头，恐怕我难以再回返。</p></blockquote><blockquote><p>也许多少年后在某个地方，我将轻声叹息将往事回顾：一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。——罗伯特·弗罗斯特《未选择的路》</p></blockquote>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「如何高效的学习」读书笔记</title>
      <link href="/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0.html"/>
      <content type="html"><![CDATA[<p>《如何高效学习》从学习的战略上指导学习知识的策略抛出整体性学习的概念，以及结构、模型、高速公路的观点;详细分析了学习的顺序和信息的分类。以战术的方式分解学习的各种战术，如快速阅读、笔记流、比喻法、内在化、联想法、图表法、挂钩法、信息压缩、知识应用、模型纠错等。下面是我阅读时写下的感想，比较少的书摘。</p><a id="more"></a><h3>1. 类比</h3><p>首先，类比是一个推理方法。<br>其次，类比是把两个具有相似或者相同特征的对象进行推理它们具有其他相似或相同特征的方法。</p><h3>2. 概括</h3><p>   读书，将核心用词语总结概括，是最好的学习习惯，只有这样，知识才真正理解，被你加工，通过联想、概括出自己的观点和想法，知识才被刚刚固化，为了知识更加牢固，还需要将知识进行实践运用，知识最好的实践方式就是传播，传播有时候会收到很多不同意见。相互碰撞，如果你能简单轻松的让他们理解并认可你的观点，说明你基本吃透这个知识点。他们当中的不同声音会让你更加容易固化你的知识点，尝试让他们也信服你如果你是正确的。</p><h3>3. 知识纵向拓展</h3><p>   知识纵向拓展，寻根究底。如学习企业管理知识，企业管理包含了财务、人事等管理，那么财务管理是怎样的，人事管理又是怎样的?再深入财务和人事管理里面的各种细节。结合自己所在公司，思考为什么要这样管理，自己公司是这样管理的吗?别人公司是怎样管理的，自己公司和别的公司管理上有什么差别，如何改进?这就是深度拓展，不断深挖细节。</p><h3>4. 知识横向拓展</h3><p>   知识横向拓展，昨天在印象笔记整理文章的时候，正好看到营销这个词，于是就把各类营销词汇整理了一番，方便以后学习归档，如病毒营销、邮件营销、关系营销、内容营销、事件营销等等，可能里面多个营销方式有很多共同点，分别找出来，也有不同点把它们区别开，这些营销方式适合什么场景下使用，适合企业的什么阶段使用，需要哪些辅助工作才能完成，成本多少?这就是横向拓展，通过知识与知识的联系发现他们共同点和不同点，找出他们的差异化，其实横向拓展和纵向拓展是不会绝对分开，当你开始比较的时候，大脑其实就进入了深度拓展和横向拓展，多思考多关联多实践多PK。</p><h3>5. 结构：理解就是结构高度发达完善的结果。</h3><p>   理解的重要性，一个人看书是否学到东西，看他的笔记和读后感就知道，如果这个人笔记和读后感总结都是勾画的原作者的文字，这是较少理解，不够深入，最差的理解是读书笔记和读后感都没有的，也是最差的学习方式，刚刚说的这些话都是错误的!<br>   真正理解，是可以通过结构化思维表达出来。理解帮忙我们把知识结构化，总感觉这里翻译的有问题，只有理解后的知识才便于储存，便于在大脑里结构化。怎么来理解呢?举个例子<br>   当我们阅读&quot;理解就是结构高度发达完善的结果&quot;的时候，如果很快就弄懂了这句话，这句话可能就相当于电脑内存中的一行数据，当我们阅过这句话，看到下段文字的时候这句话已经从内存中消失。但恰巧我读到时候，有意识觉得这里可以写点什么，就反复读了几遍，理解是结构发达的结果，理解是名词，结构发达是短语，结果是名词是产出物，正确说法是因为〖怎么样〗所以〖造成这个结果〗，那么就应该是因为理解所以造成结构发达的结果。修改后：结构高度发达完善就是理解的结果。<br>   有点咬文嚼字，扯远了，当我开始纠结这句话，大脑其实在高速运转，调动了我大脑磁盘里的相关信息来帮助我理解这句话，并做出推断。然后这句话就会固化在我的大脑磁盘里，不是一闪而过的内存数据，同时我刚刚调用过的知识再次被激活得以运用，知识就是越来应用的，不用就不属于你的知识。<br>   我不敢说解释得很明白，希望你们能够看到我对一字一句的理解，以及我狭小硬盘储存的不是特别完善的知识结构是如何被调用的。<br>   我在这里有意的写笔记是为了培养以后习惯性的思考。</p><h3>6. 模型：模型就像是结构的种子，是一座建筑的地基和框架，是知识最核心的概念，在此基础上将引伸出全部的知识。</h3><p>   先回顾，整体性学习的三个重要概念：结构，模型，高速公路。<br>   当我读完模型这一小节，我的脑子里浮现出类似原子的东西，在黑色的空间里自由漂浮，每个原子并不孤立，它们之间有一条耀眼的类似光线的&quot;脐带&quot;互相交错连接，这条连接线经常是一团亮斑从原子这头快速移动到另一头，所以看整体非常耀眼，其实这就是知识的传递与连接。<br>   现在看来，模型就是知识的最小结构，知识的结构由无数的模型和连接组成，我不知道我理解的连接是不是笔者的高速路公路，带着问题继续往下读，等待犹如开奖的那一惊心动魄。</p><h3>7. 高速公路：结构与结构之间的联系。</h3><p>   高速公路的比喻用得非常精准，这是城际之间的快速通道，是连接结构与结构之间的线路。这条线路传递和连接的知识(不是知识点，模型才是知识点)将以光速进行传递，也就是我们常说的一念之间。<br>   结构是模型的集合，模型与模型之间相互交错连接，结构与结构之间交错连接。知识点互相关联，知识互相连接交错。完美的一幅图画，黑暗的空间，一个个大型的分子，分子是若干原子的集合，是原子的仓库，不断有新的原子增加或者删除，我能清晰的透过分子的透薄如水的墙壁看到原子瞬间增加和破灭的过程，每个原子其中的若干连接线突然断裂，它在瞬间被孤立最后立即消亡，这是一个正常情况无法看到感知到的过程。分子的存亡和原子的存活方式完全不一样，只要有一个原子存在，依靠这类原子组成的分子就不会死亡。</p><h3>8. 结构分类</h3><p>   成熟结构、感知结构、生活经验、关系结构、基础数学结构</p><h3>9. 学习顺序</h3><p>   获取、理解、拓展、纠错、应用，测试伴随以上每一步，总结自省伴随以上每一步。</p><h3>10. 信息获取</h3><p>   信息获取，信息大爆炸的今天我们随时都能接触到海量信息，信息获取渠道非常丰富，百度、百科、知道、知乎、各类APP、新闻网站、社交媒体、自媒体等等，所以我们要提高信息获取的手段和筛选方法。<br></p><ul><li>订阅，订阅自己关注的内容或则话题</li><li>筛选，使用印象笔记或有道云笔记以及剪藏功能，把自己粗读有价值的信息收集整理，记得设置标签，方便以后索引。</li><li>(3) 定时整理笔记工具里的内容，整理成文章总结，将信息进行归类。总结的时候可以根据内容进行发散联想，拓展更广的话题，写下来整理成文章，这就是你的学习所得。</li></ul><h3>11. 信息获取方法</h3><p>   精简信息、增加信息获取的数量和信息来源、提高阅读速度效率</p><h3>12. 信息拓展方法</h3><p>   深度拓展、纵向拓展、横向拓展</p><h3>13.信息获取小结</h3><p>   一句话概括，通过不同手段获取知识，不断理解深入研究，拓展和联想相关知识，不断纠错判断，沉淀正确的知识并实践应用。<br>   拓展知识有三个方法，深度拓展、横向拓展、纵向拓展，深度拓展又可以理解为背景拓展，主要了解知识形成的背景、原因和过程，深度拓展和纵向理解容易造成误会，所以固化背景拓展最佳。<br>   关于信息获取每一步的测试单独说下：</p><ul><li>获取——是否看过听过，如果看过比较了解可以略过，进入初期筛选</li><li>理解——真的明白了知识点的含义了吗?是否可以用最简单的语言和比喻解释清楚</li><li>拓展——知识背景如何，相关知识有哪些，存在什么关系</li><li>纠错——哪些知识点、观点是错误的，正确的是什么?为什么它是错的</li><li>运用——这些知识如何运用到现实生活?有什么意义和价值?</li></ul><h3>14. 信息分类</h3><p>   随意信息、观点信息、过程信息、具体信息、抽象信息</p><h3>15. 挂钩法</h3><p>   刚刚我做了一个关于挂钩法有趣的小实验，用了大概二十秒钟记住8件东西，缺了两样，但是我觉得挂钩法依然非常有效。<br>   这几样东西分别是：</p><table><thead><tr><th style="text-align:center">培根</th></tr></thead><tbody><tr><td style="text-align:center">鸡蛋</td></tr><tr><td style="text-align:center">葡萄酒</td></tr><tr><td style="text-align:center">电池</td></tr><tr><td style="text-align:center">泡泡糖</td></tr><tr><td style="text-align:center">牛奶</td></tr><tr><td style="text-align:center">信封</td></tr><tr><td style="text-align:center">菠菜</td></tr><tr><td style="text-align:center">咖啡</td></tr><tr><td style="text-align:center">番茄</td></tr></tbody></table><p>   然后在一边分别把他们列出来。我是这样记忆的，时不时我上班会去早餐店买一份叫培根煎饼的早餐，里面有培根、鸡蛋、生菜、沙拉酱或者番茄酱或则辣椒酱，我就把生菜巧妙替换成菠菜，煎饼比较干那么肯定得来杯牛奶，营养又健康，和牛奶一样的饮品(联想法)有我平时最爱喝的咖啡，最近我还在学习做牛扒，家里一直缺红酒，红酒也是装逼利器哟，吃完早餐喝完咖啡，心里还想着牛扒红酒高逼格的美食，也该进入工作状态(继续挂钩)，打开邮件(映射信封)，查看有没有工作方面的事情，一边嚼着同事给的口香糖，其实我从不买泡泡糖那种口香糖，太甜越嚼越没味道，回到家吃了这么多好吃的肯定担心自己胖了没就需要称称，恰好，电子称没电了，一直拖着没去买电池。   写了好长时间了啊，实际上就是脑子里一瞬间的联想和挂钩。</p><h3>16. 内在化</h3><p>   通过将信息转化为更容易想象的形式，你可以为知识建立广泛的联系</p><h3>17. 内化与内在化</h3><p>   本文用词稍微不太严谨，前面提到的是内在化，这里提的是内化。</p><ul><li>知识内化，是企业管理的重要组成部分，按字面意思理解就是知识的内部消化吸收再创新。</li><li>知识内在化，我又只有闭眼冥想我那黑暗的知识空间，存在无数的知识分子和原子，当我获得新的知识点(原子)的时候就会通过光速连接(本书中的高速公路)找到适合该原子归类的仓库(分子)，如果这不是简单的知识点本身可以独立成新的知识，会自动产生一个分子并包含最少一个原子，这个分子与刚刚通过的光速连接那端的分子自动连接建立索引，便于以后快速搜索及时反馈。继续扩展下内化的过程是不是和搜索引擎很像，检索新的网页(信息收集)然后通过算法判断是否索引或者更新快照(理解、纠错)，蜘蛛沿着网页入口进行纵向和横向爬行(拓展)然后重复算法的判断，合格的网页进行存储并排序展示给用户(应用)。</li></ul><h3>18. 学习的战略战术</h3><p>   简单说战略指导思想，战术指导方法。学习知识的战略指导你把知识融会贯通，运用到现实生活和工作中，学习知识的战术指导你如何去学习。</p><ul><li>获取知识：快速阅读、笔记流</li><li>联系观点：比喻法、内在化、图表法</li><li>随意信息处理：联想法、挂钩法、信息压缩</li><li>知识拓展：知识应用、模型纠错、以项目为基础学习</li></ul><h3>19. 笔记流</h3><p>   &quot;一次学会&quot;表示你在学习时要全神贯注地听老师讲课，而不是忙着做细致漂亮的笔记，等到课下再学。工作中，尤其是会议，用关键词记录，会议后整理，效率高。<br>   一旦你写下了一个观点，下一步就是在这个观点和其他观点之间画上一些箭头呈现出相互关联的关系，形成一张观点网络。</p><h3>20. 读书笔记</h3><p>   写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</p><h3>21. 费曼技巧</h3><ul><li>选择要学习的内容</li><li>以老师的身份学习</li><li>疑惑时返回学习</li><li>用简单直白和比喻去解释知识点</li></ul><h3>22. 提高效率</h3><ul><li>健康身心</li><li>聪明学习</li><li>不拖延</li><li>批处理碎片信息</li><li>坚持做清单、写日子</li></ul><h3>23. 自我教育</h3><ul><li>养成阅读习惯</li><li>设定学习目标写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</li></ul>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVM支持向量机</title>
      <link href="/SVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA.html"/>
      <content type="html"><![CDATA[<blockquote><p>通俗来讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p></blockquote><a id="more"></a><h2>从线性回归讲起</h2><p>SVM主要是用来做分类工作，诸如文本分类，图像分类，生物序列分析和生 物数据挖掘， 手写字符识别等领域都有很多的应用。</p><p>对分类最简单的即线性分类器用X表示数据点，Y表示类别（二分类中，y取1或-1），一个线性分类器的目标是在数据空间中找到一个分隔平面,这个分隔平面方程可以表示为：$$\omega^{T}x+b=0$$为使目标函数值在-1到1之间，我们使用Logistic函数作为假设函数。</p><p>假设函数：</p><p>$$h_\theta(x)=g(\theta^{T}x)=\frac{1}{1+e^(-\theta^{T}x)}, \quad h_\theta(x)\in(0,1)$$</p><p>其中，x是n维特征向量，所以假设函数就是y=1的概率：</p><p>$$P(y=1|x;\theta)=h_\theta(x) \ P(y=0|x;\theta)=1-h_\theta(x)$$</p><p>从而，有$h_\theta(x)&gt;0.5$就是y=1的类，反之属于y=0的类。接下来，将结果中y = 0 和 y = 1 替换为 y =-1，y = 1，然后将$\theta^Tx= \theta_0x_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$中的$x_0$替换 为 b，最后将后面的$\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$替换为$\omega^Tx$，也就是说除了 y 由 y = 0 变为 y =1 外，线性分类函数跟 Logistic 回归的形式化表示$h_\theta(x)=g(\theta^Tx)=g(\omega^Tx+b)$没区别。<img src="http://img.blog.csdn.net/20170226133437427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3>函数间隔与几何间隔</h3><p>在超平面 $\omega^{T} x + b = 0$ 确定的情况下，$|\omega^{T} x + b|$ 能够表示点 x 到距离超平面的远近 ，而通过观察 $\omega^{T} x + b$的符号与类标记 y 的符号是否一致可判断分类是否正确，所以，可以用 $y(\omega^{T} x + b)$ 的正负性来判定或表示分类的正确性。</p><p>给定的训练数据集T和超平面w,b)，定义超平面(w,b)关于样本点(xi,yi)的函数间隔为：$$\hat{\gamma}=y(\omega^{T}x+b)=y(f(x))$$但这样定义的函数间隔有问题，即如果成比例的改变 w 和 b（如将它们改成 2w 和 2b），则函数间隔的值 f(x) 却变成了原来的 2 倍（虽然此时超平面没有改变），所以只 有函数间隔还远远不够。</p><p>平面法向单位化的函数间隔，即几何间隔$$\gamma=\frac{\omega^{T}x+b}{||\omega||}=\frac{f((x)}{||\omega||}$$假定对于一个点 x ，令其垂直投影到超平面上的对应点为 $x_0$ ，w 是垂直于超平面 的一个向量， 为样本 x 到分类间隔的距离，如图所示。<img src="http://img.blog.csdn.net/20170226134808933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log"></p><p>从上述的定义可以看出：几何间隔就是函数间隔除以 $∥\omega∥$，而且函 数间隔 $y(w ^T x + b) = yf(x)$ 实际上就是 $|f(x)|$，只是人为定义的一个间隔度量，而几何 间隔 $|f(x)|/∥\omega∥$ 才是直观上的点到超平面的距离。</p><h2>最大间隔分类器</h2><p>对一个数据点进行分类， SVM的思想是当超平面离数据点的“间隔”越大， 分类的确信度 （conﬁdence）也越大。<img src="http://img.blog.csdn.net/20170226135127419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>定义目标函数：<img src="http://img.blog.csdn.net/20170226135744814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>回顾一下几何间隔的定义 $\tilde{\gamma}=y\gamma = \frac{hat{\gamma}}{∥\omega∥}$ 可知， 如果令函数间隔 $\hat{\gamma}$等于 1， 则有$\tilde{\gamma}=\frac{1}{∥w∥}$ 且 $y_i (\omega ^T x_i + b) \geq1; \quad i = 1; \cdots; n$</p><p>从而上述目标函数转化成了：</p><p>$$ max\quad \frac{1}{||w||} ;\ s.t. y_i (w^{T} x_i + b)\geq1;\quad i = 1, \cdots,n$$</p><p>这个目标函数便是在相应的约束条件$y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$条件下，最大化这个 $\frac{1}{||w||}$ 值，而 $\frac{1}{||w||}$便是几何间隔$\tilde{\gamma}$。</p><h2>拉格朗日乘子法</h2><p>由于求 $\frac{1}{||w||}$ 的最大值相当于求 $\frac{1}{2}||w||^2$ 的最小值，所以上述目标函数等价于</p><p>$$ min\quad \frac{1}{2}||w||^2 ; \ s.t. y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$$</p><p>因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。这个问题可以用现成的 QP (Quadratic Programming) 优化包进行求解。一言以蔽之：在一定的约束条件下，目标最优，损失最小。</p><p>此外，由于这个问题的特殊结构，还可以通过拉格朗日对偶性（Lagrange Duality） 变换到对偶变量 (dual variable) 的优化问题， 即通过求解与原问题等价的对偶问题 （dual problem）得到原始问题的最优解，这就是线性可分条件下支持向量机的对偶算 法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数， 进而推广到非线性分类问题。</p><p>那什么是拉格朗日对偶性呢？简单来讲，通过给每一个约束条件加上一个拉格朗日乘子（Lagrange multiplier），定义拉格朗日函数</p><p>$$L(\omega,b,\alpha)= \frac{1}{2}||w||^2-\sum_{i=1}^{n}\alpha_i(y_i(w_i^Tx_i+b)-1)$$</p><p>原问题是极小极大问题:$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)$$</p><p>原始问题的对偶问题，是极大极小问题:$$\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p>将拉格朗日函数$L(w,b,\alpha)$分别对w，b求偏导并令其为0,</p><p><img src="http://img.blog.csdn.net/20170226142614206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log00"></p><p>将上式带入拉格朗日函数$L(w,b,\alpha)$中，得到：</p><p><img src="http://img.blog.csdn.net/20170226142712754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"></p><p>继续求$\underset{w,b}{min}L(w,b,\alpha)$对$\alpha$的极大值:</p><p><img src="http://img.blog.csdn.net/20170226142934391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>整理目标函数，求解出最优的$\alpha^{*}$<img src="http://img.blog.csdn.net/20170226172322298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>上式为一般的含不等式约束问题，存在最优化解法的必要和充分条件即KKT条件（详情可查看<a href="http://blog.csdn.net/touristman5/article/details/57418552" target="_blank" rel="noopener">等式约束与不等式约束问题</a>）：为方便理解，我们把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$$L(a,b,x)=f(x)+a∗g(x)+b∗h(x)$$</p><p>KKT条件是说最优值必须满足以下条件：</p><ol><li>$\frac{\partial{L}}{\partial{x_i}}=0$对x求导为零；</li><li>$h(x) =0;$</li><li>$a*g(x) = 0;$</li></ol><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为$g(x)&lt;=0$，如果要满足这个等式，必须$\alpha=0$或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><p>所谓 支撑向量Supporting Vector 也在这里显示出来——事实上，所有非 Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上 只要针对少量的“支持向量”而不是所有的训练数据即可。</p><h3>核函数</h3><p>对于线性不可分的情况，可以使用核函数，将输入空间映射到特征空间（通俗说来是从低维空间映射到高维空间），从而使得原本线性不可分的样本可以在特征空间可分。</p><p><img src="http://img.blog.csdn.net/20170226174650918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log04"></p><p>在实际应用中，往往依赖先验领域知识才能选择有效的核函数####常见的核函数有</p><ul><li>多项式核函数：$$K(x_1,x_2)=(\left \langle x_1,x_2  \right \rangle)^d$$</li><li>高斯核函数：$$K(x_1,x_2)=exp^ { \frac{||x_1-x_2||}{2\sigma^2} } $$</li></ul><p>参考链接：</p><ol><li>统计学习方法，李航著，清华大学出版社，2012年</li><li><a href="http://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7624837</a></li><li><a href="http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html" target="_blank" rel="noopener">http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> 机器学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Tensorflow写简单的神经网络</title>
      <link href="/%E7%94%A8Tensorflow%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C.html"/>
      <content type="html"><![CDATA[<p>TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。</p><a id="more"></a><p><img src="http://tensorfly.cn/images/tensors_flowing.gif" alt="log00"></p><p>根据上图，可以看出一个简单神经网络所具有的模块结构，首先输入层(Input Layer)，接受相关的结构化化数据；其次是隐藏层(Hidden Layer)，隐藏层主要加权运算，通过激活函数达到拟合线性非线性函数的目的；最后有输出层(Output Layer)，其结果成为下一次迭代的初始值。</p><p>一个的单层神经网络如下：<img src="http://hahack.com/images/ann2/w4eQd.png" alt="log01"></p><p>就此，我们用Tensorflow实现一个单层神经网络，参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs,in_size,out_size,activation_function=None)</span>:</span></span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_size,out_size]))</span><br><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>,out_size])+<span class="number">0.1</span>)</span><br><span class="line">    Wx_plus_b = tf.matmul(inputs,Weights)+biases</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x_d = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">300</span>)[:,np.newaxis]</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>,<span class="number">0.05</span>,x_d.shape)</span><br><span class="line">y_d = np.square(x_d) - <span class="number">0.5</span> + noise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义placeholder，可以更方便</span></span><br><span class="line">xs = tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">1</span>])</span><br><span class="line">ys = tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加隐藏层</span></span><br><span class="line">layer1 = add_layer(xs,<span class="number">1</span>,<span class="number">10</span>,activation_function = tf.nn.relu)</span><br><span class="line">predict = add_layer(layer1,<span class="number">10</span>,<span class="number">1</span>,activation_function = <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - predict),reduction_indices=[<span class="number">1</span>]))</span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.3</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="comment"># init = tf.initialize_all_variables() no long valid from</span></span><br><span class="line"><span class="comment"># 2017-03-02 if using tensorflow &gt;= 0.12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int((tf.__version__).split(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span>:</span><br><span class="line">    init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_d, ys: y_d&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># to see the step improvement</span></span><br><span class="line">        print(sess.run(loss, feed_dict=&#123;xs: x_d, ys: y_d&#125;))</span><br></pre></td></tr></table></figure><p>单机运行结果如下：<img src="http://img.blog.csdn.net/20170225020607154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log2"></p><blockquote><p>[1]参考链接：<a href="https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13" target="_blank" rel="noopener">https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 机器学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>唐璜节选</title>
      <link href="/%E5%94%90%E7%92%9C%E8%8A%82%E9%80%89.html"/>
      <content type="html"><![CDATA[<p>   诗歌能做到以更简练、更摄人心魄的精准语言与我们的灵魂直接沟通。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生命激荡着青葱的希望</span><br><span class="line">爱意伴随着激情的火焰</span><br><span class="line">美食、酒神，都是爱情的风帆</span><br><span class="line">——唐璜-「七」岩穴奇情</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生命的美好不能束缚他，死亡的狰狞也不能毁灭它</span><br><span class="line">来自他的母亲—摩尔人赋予她刚强的性格</span><br><span class="line">他将彻底面对世界</span><br><span class="line">乐园和荒漠，没有第三条路</span><br><span class="line"></span><br><span class="line">希腊的少女曾用哀歌，咏叹海黛的爱</span><br><span class="line">迁居的岛民，也曾在漫漫长夜将这一切讲述</span><br><span class="line">夜色大海静，传说流万古</span><br><span class="line">孤岛痴女情，唯有诗人知</span><br><span class="line">——唐璜-「十六」伤逝</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">爱情犹如鸦片，不用太多</span><br><span class="line">一口便让人迷醉</span><br><span class="line">除了泪水情人的眼睛什么都能汲取</span><br><span class="line">尤其是生命的泉水</span><br><span class="line"></span><br><span class="line">这已经足够，爱情虚无飘渺</span><br><span class="line">它因自私而起，又因自私结束</span><br><span class="line">还有一种爱情只是一时的热忱</span><br><span class="line">把自己的脆弱与孤独的美相结合</span><br><span class="line">点缀那一颗疯狂的无法遏制的心</span><br><span class="line">如果没有这种美，热情也就消失</span><br><span class="line">——唐璜-「三十二」女皇的恩宠</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 读书思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>共轭先验</title>
      <link href="/%E5%85%B1%E8%BD%AD%E5%85%88%E9%AA%8C.html"/>
      <content type="html"><![CDATA[<blockquote><p>定义：如果先验分布和似然函数可以使得先验分布和后验分布有相同的形式，那么就称先验分布与似然函数是共轭的。</p></blockquote><a id="more"></a><p>读数理统计学导论时，遇到过共轭先验的概念。  贝叶斯判别准则中，分别假设了先验分布$p(\theta)$，后验分布$p(\theta|X)$，以及$p(X), p(X|\theta)$似然函数。</p><p>贝叶斯定理可以写作：$$P(\theta|X)=\frac{P(\theta)P(X|\theta)}{P(X)}$$</p><p>即 「后验分布 =先验分布 * 似然函数 / P(X)」</p><p>  之所以采用共轭先验的原因是可以使得先验分布和后验分布的形式相同，这样一方面合符人的直观（它们应该是相同形式的；另外一方面是可以形成一个先验链，即现在的后验分布可以作为下一次计算的先验分布，如果形式相同就可以形成一个链条。为了使得先验分布和后验分布的形式相同，我们定义：如果先验分布和似然函数可以使得先验分布和后验分布有相同的形式，那么就称先验分布与似然函数是共轭的。所以共轭是指：先验分布和似然函数共轭。</p><h3>例子：</h3><p>共轭先验通常可以由分布的pdf或pmf来确定。</p><p>考虑二项模型：$$p(x)={n \choose x}q^{x}(1-q)^{n-x}$$</p><p>写成以q为参数的函数形式：$$f(q)\propto q^{a}(1-q)^{b}$$</p><p>通常这个函数应该还缺少一个乘数因子，以保证pdf的积分值为1。</p><p>这个乘数项是a，b的函数。写作下面的形式$$p(q)={q^{\alpha -1}(1-q)^{\beta -1} \over \mathrm {B} (\alpha ,\beta )}$$</p><p>可以看出，乘上的$\mathrm {B} (\alpha ,\beta )$作为归一化常熟存在，根据上面定义，可得二项分布的共轭分布族是<strong>贝塔分布。</strong></p><p>  与共轭先验对应的概念是共轭分布族(Conjugate family of distribution),所谓共轭分布族是指参数$\theta$的后验pdf与作为先验的分布族是相同的，则称此类先验pdf关于具有pdf$f(x|\theta),\theta \in \Omega$的分布族为共轭分布。</p><p>  例如，给定$\theta$时随机变量X的pmf是均值为$\theta$的泊松分布。若我们选取伽马先验，由贝叶斯定理计算出后验也是伽马分布族。则称，伽马分布族构成这种泊松模型的共轭先验类。</p><blockquote><p>一般而言，有了先验和似然，计算后验能够方便我们实现变分推断和Gibbs采样等</p></blockquote><p>参考资料：</p><ol><li>Pattern Recognition and Machine Learning ,  M. Bishop</li><li>数理统计学导论 ,Robert V.Hogg</li><li>Conjugate prior - Wikipedia</li><li><a href="https://link.zhihu.com/?target=https%3A//alexanderetz." target="_blank" rel="noopener">以贝塔分布为例，解释了共轭分布，并给出了R语言的code.</a>com/2015/07/25/understanding-bayes-updating-priors-via-the-likelihood/</li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全局优化算法之粒子群算法</title>
      <link href="/%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E4%B9%8B%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95.html"/>
      <content type="html"><![CDATA[<h2>序言</h2><p>  前面讨论过一些迭代算法，包括牛顿法、梯度方法、共轭梯度方法和拟牛顿法，能够从初始点出发，产生一个迭代序列。很多时候，迭代序列只能收敛到局部极小点。因此，为了保证算法收敛到全局最小点，有时需要在全局极小点附近选择初始点。此外，这些方法需要计算目标函数。</p><p>  全局优化算法又称现代启发式算法，是一种具有全局优化性能、通用性强且适合于并行处理的算法。这种算法一般具有严密的理论依据，而不是单纯凭借专家经验，理论上可以在一定的时间内找到最优解或近似最优解。遗传算法属于智能优化算法之一。</p><p>  常用的全局优化算法有： 遗传算法 、模拟退火算法、禁忌搜索算法、粒子群算法、蚁群算法。</p><h2>PSO算法</h2><p>  粒子群算法（Particle swarm optimization）是由James Kennedy &amp;<a href="http://www.engr.iupui.edu/~eberhart/" target="_blank" rel="noopener">Russell Eberhart</a>提出。区别于上节讨论的模拟退火算法，粒子群算法并不是只更新单个迭代点，而是更新一组迭代点，称为群。群中每个点称为粒子。可将群视为一个无序的群体，其中的每个成员都在移动，意在形成聚集，但移动方向是随机的。</p><p>  具体来说，求取目标函数在$\mathbb{R}^n$上极小点的过程。</p><ol><li>在$\mathbb{R}^n$随机产生一组数据点，为每个点赋予一个速度，构成一个速度向量。这些点视为粒子所在的位置，以指定速度在运动。</li><li>针对每个数据点计算对应的目标函数值，基于计算结果，产生一组新的数据点，赋予新的运动速度。</li></ol><p>  其每个粒子都持续追踪到目前为止最好的位置，称到目前为止最好的位置为Pbest，全局最好为止Gbest。基于粒子的个体最好位置和群的群的全局最优位置，调整各粒子的运动速度，实现粒子的“交互“。即在每次迭代中，产生两个随机数，分别作为pbest和gbest的权重，以此构成pbest和gbest的一个组合值，分别称为速度项和随机项，再加上加权后的原有速度，可以实现对原有速度的更新。</p><p>  目标函数在$\mathbb{R}^n$中，由种群数m组成粒子群，其中第i个粒子在d维的位置为$x_{id}$，其飞行速度为$v_{id}$，该粒子当前搜索的最优位置为，整个粒子群当前位置为，更新公式如下：$$v_{id}^{t+1}=v_{id}^{t}+c_1r_1(P_{id}-x_{id}+c_2r_2(P_{gd}-x_{id}))\quad (1) \ x_{id}^{t+1}=x_{id}{t}+v_{id}^{t+1} \quad \quad(2)$$</p><p>$r_1、r_2$是服从U(0,1)分布的随机数，学习因子$c_1、c_2$为非负常数，通常取$c_1=c_2=2$，$v_id \in [v_{min},v_{max}],v_{max}$是自设定的常数，迭代终止条件为预设的最大迭代数或预定的最小适应度阈值。</p><p>Matlab代码示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 该代码为基于PSO的函数极值寻优</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%% 清空环境</span></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line"><span class="comment">%粒子群算法中的两个参数</span></span><br><span class="line">c1 = <span class="number">1.49445</span>;</span><br><span class="line">c2 = <span class="number">1.49445</span>;</span><br><span class="line"></span><br><span class="line">maxgen=<span class="number">500</span>;   <span class="comment">% 进化次数  </span></span><br><span class="line">sizepop=<span class="number">100</span>;   <span class="comment">%种群规模</span></span><br><span class="line"></span><br><span class="line">Vmax=<span class="number">1</span>;</span><br><span class="line">Vmin=<span class="number">-1</span>;</span><br><span class="line">popmax=<span class="number">5</span>;</span><br><span class="line">popmin=<span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 产生初始粒子和速度</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:sizepop</span><br><span class="line">    <span class="comment">%随机产生一个种群</span></span><br><span class="line">    pop(<span class="built_in">i</span>,:)=<span class="number">5</span>*rands(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">%初始种群</span></span><br><span class="line">    V(<span class="built_in">i</span>,:)=rands(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">%初始化速度</span></span><br><span class="line">    <span class="comment">%计算适应度</span></span><br><span class="line">    fitness(<span class="built_in">i</span>)=fun(pop(<span class="built_in">i</span>,:));   <span class="comment">%染色体的适应度</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 个体极值和群体极值</span></span><br><span class="line">[bestfitness bestindex]=min(fitness);</span><br><span class="line">zbest=pop(bestindex,:);   <span class="comment">%全局最佳</span></span><br><span class="line">gbest=pop;    <span class="comment">%个体最佳</span></span><br><span class="line">fitnessgbest=fitness;   <span class="comment">%个体最佳适应度值</span></span><br><span class="line">fitnesszbest=bestfitness;   <span class="comment">%全局最佳适应度值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 迭代寻优</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:maxgen</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:sizepop</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%速度更新</span></span><br><span class="line">        V(<span class="built_in">j</span>,:) = V(<span class="built_in">j</span>,:) + c1*<span class="built_in">rand</span>*(gbest(<span class="built_in">j</span>,:) - pop(<span class="built_in">j</span>,:)) + c2*<span class="built_in">rand</span>*(zbest - pop(<span class="built_in">j</span>,:));</span><br><span class="line">        V(<span class="built_in">j</span>,<span class="built_in">find</span>(V(<span class="built_in">j</span>,:)&gt;Vmax))=Vmax;</span><br><span class="line">        V(<span class="built_in">j</span>,<span class="built_in">find</span>(V(<span class="built_in">j</span>,:)&lt;Vmin))=Vmin;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%种群更新</span></span><br><span class="line">        pop(<span class="built_in">j</span>,:)=pop(<span class="built_in">j</span>,:)+<span class="number">0.5</span>*V(<span class="built_in">j</span>,:);</span><br><span class="line">        pop(<span class="built_in">j</span>,<span class="built_in">find</span>(pop(<span class="built_in">j</span>,:)&gt;popmax))=popmax;</span><br><span class="line">        pop(<span class="built_in">j</span>,<span class="built_in">find</span>(pop(<span class="built_in">j</span>,:)&lt;popmin))=popmin;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%适应度值</span></span><br><span class="line">        fitness(<span class="built_in">j</span>)=fun(pop(<span class="built_in">j</span>,:)); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:sizepop</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%个体最优更新</span></span><br><span class="line">        <span class="keyword">if</span> fitness(<span class="built_in">j</span>) &lt; fitnessgbest(<span class="built_in">j</span>)</span><br><span class="line">            gbest(<span class="built_in">j</span>,:) = pop(<span class="built_in">j</span>,:);</span><br><span class="line">            fitnessgbest(<span class="built_in">j</span>) = fitness(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">%群体最优更新</span></span><br><span class="line">        <span class="keyword">if</span> fitness(<span class="built_in">j</span>) &lt; fitnesszbest</span><br><span class="line">            zbest = pop(<span class="built_in">j</span>,:);</span><br><span class="line">            fitnesszbest = fitness(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    yy(<span class="built_in">i</span>)=fitnesszbest;    </span><br><span class="line">        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 结果分析</span></span><br><span class="line">plot(yy)</span><br><span class="line">title(<span class="string">'最优个体适应度'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);</span><br><span class="line">xlabel(<span class="string">'进化代数'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);ylabel(<span class="string">'适应度'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>参考论文：</p><ol><li>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</li><li><a href="http://www.jos.org.cn/1000-9825/18/861.pdf" target="_blank" rel="noopener">一种更简化更高效的粒子群算法</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全局优化算法之模拟退火算法</title>
      <link href="/%E5%85%A8%E5%B1%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95.html"/>
      <content type="html"><![CDATA[<h2>序言</h2><p>前面讨论过一些迭代算法，包括牛顿法、梯度方法、共轭梯度方法和拟牛顿法，能够从初始点出发，产生一个迭代序列。很多时候，迭代序列只能收敛到局部极小点。因此，为了保证算法收敛到全局最小点，有时需要在全局极小点附近选择初始点。此外，这些方法需要计算目标函数。</p><a id="more"></a><p>全局优化算法又称现代启发式算法，是一种具有全局优化性能、通用性强且适合于并行处理的算法。这种算法一般具有严密的理论依据，而不是单纯凭借专家经验，理论上可以在一定的时间内找到最优解或近似最优解。遗传算法属于智能优化算法之一。</p><p>常用的全局优化算法有：遗传算法 、模拟退火算法、禁忌搜索算法、粒子群算法、蚁群算法。</p><h2>1、随机搜索算法</h2><p>模拟退火算法是一种随机搜索算法，随机搜索方法也称作概率搜索算法，这很好理解，是一种能够在优化问题的可行集中随机采样，逐步完成搜索的算法。German首次将模拟退火算法应用在凸显处理领域。<a href="http://www.stat.cmu.edu/~acthomas/724/Geman.pdf" target="_blank" rel="noopener">论文地址</a>后续有时间我可以是这翻译一下。</p><h3>朴素随机搜索算法步骤：</h3><ol><li>令$K=0$，选定初始点$x^{(0)}\in \Omega$</li><li>从$N(x^{(k)})$中随机选定一个备选点$z^{(k)}$</li><li>如果$f(z^{(k)}) &lt; f(x^{(k)})$,则令$x^{(k+1)}=z_{(k)}$，否则$x^{(k+1)}=x_{(k)}$</li><li>如果满足停止条件，则停止迭代</li><li>令$k=k+1$，回到第2步</li></ol><p>算法分析：朴素随机搜索算法面临的问题在于领域$N(x^{(k)})$的设计，一方面要保证领域足够大，否则算法可能会在局部点&quot;卡住&quot;；但如果使领域太大的话，会使得搜索过程变得很慢。另一种，对领域问题的解决方案是对朴素随机搜索算法进行修改，使其能够&quot;爬出&quot;局部极小点的&quot;领域&quot;。<font color="red"><strong>这意味着两次迭代中，算法产生的新点可能会比当前点要差。模拟退火算法就设计了这样的机制。</strong></font></p><h2>2、模拟退火算法</h2><h3>算法步骤</h3><ol><li>令$K=0$，选定初始点$x^{(0)}\in \Omega$</li><li>从$N(x^{(k)})$中随机选定一个备选点$z^{(k)}$</li><li><font color="red"><strong>设计一枚特殊的硬币，使其在一次抛投过程中出现正面的概率为$P(k,f(z^{(k)}),f(x^{(k)}))$。抛一次硬币，如果出现正面，则令$x^{(k+1)}=z^{(k)}$，否则$x^{(k+1)}=x_{(k)}。$</strong></font></li><li>如果满足停止条件，则停止迭代</li><li>令$k=k+1$，回到第2步</li></ol><p>注：其中所说的&quot;抛硬币&quot;实际可理解成一种随机决策。</p><p>算法进行中，第k次迭代，可以追踪到目前最好的点$x_{best}^{(k)}$，即能够对所有的$i \in {0,\cdots ,k },$都有$f(x^{(j)})\leqslant  f(x^{(i)})$成立的$x^{(j)}$。</p><p>$x_{best}^{(k)}$按照以下方式进行更新</p><p><img src="http://img.blog.csdn.net/20170228102458217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><font color="red"><strong>通过持续追踪并更新当前为止最好的点，可以将模拟退火算法简单视为一个搜索过程，搜索过程的最终目的是出处当前为止最好的点。这种说法适合绝大部分启发式算法。</strong></font></p><h2>3、模拟退火算法与朴素随机搜索算法的区别</h2><p>模拟退火算法与朴素随机搜索算法区别在于步骤3，该步骤中，<font color="red"><strong>模拟退火算法以一定的概率选择备选点作为下一次迭代点，即使这个备选点比当前的迭代点要差。这一概率被称作接受概率，接受概率要合理设定，才能保证迭代过程正确进行</strong>。</font>$$P(k,f(z^{(k)}),f(x^{(k)}))=min(1,exp(\frac{-f(x^{(k)})+f(z^{(k)})}{T_k}))$$$T_k$称为冷却温度</p><p>从上式我们至少可以推出，如果$f(z^{(k)})\leqslant f(x^{(k)})$，则p=1，即$x^{(k+1)}=z^{(k)}$。如果$f(z^{(k)}) &gt;f(x^{(k)})$，则仍有一定概率使得$x^{(k+1)}=z^{(k)}$，这一概率为,$exp(\frac{-f(x^{(k)})+f(z^{(k)})}{T_k})$。</p><p><font color="red"><strong>$f(z^{(k)}) 与f(x^{(k)})$之间差异越大，采用$z^{(k)}$作为下一迭代点的概率就越小。类似的，$T_k$越小，采用$z^{(k)}$作为下一迭代点的概率就越小。</strong></font>通常的做法是令温度$T_k$递减到0（表示冷却过程）。也就是说，随着迭代次数的增加，算法趋于更差点的概率越来越小。</p><p>对于温度参数的研究，可以<a href="https://stuff.mit.edu/afs/athena/course/6/6.435/www/Hajek88.pdf" target="_blank" rel="noopener">参考论文</a></p><h2>4、 模拟退火算法伪代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* J(y)：在状态y时的评价函数值</span></span><br><span class="line"><span class="comment">* Y(i)：表示当前状态</span></span><br><span class="line"><span class="comment">* Y(i+1)：表示新的状态</span></span><br><span class="line"><span class="comment">* r： 用于控制降温的快慢</span></span><br><span class="line"><span class="comment">* T： 系统的温度，系统初始应该要处于一个高温的状态</span></span><br><span class="line"><span class="comment">* T_min ：温度的下限，若温度T达到T_min，则停止搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>( T &gt; T_min )</span><br><span class="line">&#123;</span><br><span class="line">　　dE = J( Y(i+<span class="number">1</span>) ) - J( Y(i) ) ; </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> ( dE &gt;=<span class="number">0</span> ) <span class="comment">//表达移动后得到更优解，则总是接受移动</span></span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　&#123;</span><br><span class="line"><span class="comment">// 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">exp</span>( dE/T ) &gt; random( <span class="number">0</span> , <span class="number">1</span> ) )</span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　T = r * T ; <span class="comment">//降温退火 ，0&lt;r&lt;1 。r越大，降温越慢；r越小，降温越快</span></span><br><span class="line">　　<span class="comment">/*</span></span><br><span class="line"><span class="comment">　　* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值</span></span><br><span class="line"><span class="comment">　　*/</span></span><br><span class="line">　　i ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</li><li><a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html" target="_blank" rel="noopener">http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全局优化算法之遗传算法</title>
      <link href="/%E5%85%A8%E5%B1%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95.html"/>
      <content type="html"><![CDATA[<h2>全局优化算法概述</h2><p>前面讨论过一些迭代算法，包括牛顿法、梯度方法、共轭梯度方法和拟牛顿法，能够从初始点出发，产生一个迭代序列。很多时候，<font color="blue">迭代序列只能收敛到局部极小点。</font>因此，为了保证算法收敛到全局最小点，有时需要在全局极小点附近选择初始点。此外，这些方法需要计算目标函数。</p><a id="more"></a><p>全局优化算法又称现代启发式算法，是一种具有全局优化性能、通用性强且适合于并行处理的算法。这种算法一般具有严密的理论依据，而不是单纯凭借专家经验，理论上可以在一定的时间内找到最优解或近似最优解。遗传算法属于智能优化算法之一。</p><p>常用的全局优化算法有：遗传算法 、模拟退火算法、禁忌搜索算法、粒子群算法、蚁群算法。</p><h3>1、染色体编码</h3><p>实际上遗传算法并不是直接针对约束集中的点进行操作，而是针对这些点的编码后再进行相关变异交叉等操作。具体说来，如约束集$\omega$中的点24映射为一个字符串集合-- 11000，这些字符串全部都是等长的，称为染色体。基本遗传算法（SGA）使用二进制串进行编码。</p><h3>2、适应度函数</h3><p>遗传算法对一个个体（解）的好坏用适应度函数值来评价，适应度函数值越大，解的质量越好。适应度函数是遗传算法进化过程的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。</p><h3>3、选择和进化步骤</h3><p>在选择步骤中，利用选择操作构造一个新的种群$M(k)$，使其个体数量与种群相等，种群中个体数量称为个体容量，用N表示，M是在P的基础上进行随机处理后得到的，即M中的每个个体以概率<font size="3">$$\frac{f(x^{(k)})}{F(k)}$$</font>等于$P(k)$中的$x^{(k)}$，其中，<font size="3">$F(k)=\sum f(x_{i}^{(k)})$</font>，指的是对整个P进行求和，也就是说，染色体被选中的概率与其适应度函数值大小成正比。</p><h4>轮盘赌选择方法：</h4><img src="http://hi.csdn.net/attachment/201101/12/8394323_1294826341f6bF.jpg" width="50%" height="50%"><p>轮盘赌选择法可用如下过程模拟来实现：</p><ol><li>在［0, 1］内产生一个均匀分布的随机数r。</li><li>若r≤q(1),则染色体x(1)被选中。</li><li>若$q(k-1)&lt; r ≤ q(k)$,其中(2≤k≤N), 则染色体x(k)被选中。其中的qi称为染色体$x_i (i=1, 2, \cdots, n)$的积累概率, 其计算公式为</li></ol><p>$$q_i=\sum_{j=1}^{i}P_j$$</p><p>得到积累概率为：</p><img src="http://hi.csdn.net/attachment/201101/12/8394323_129482634014NA.jpg" width="50%" height="50%"><p>轮盘赌选择方法的实现步骤:</p><ol><li>计算群体中所有个体的适应度值；</li><li>计算每个个体的选择概率；</li><li>计算积累概率；</li><li>采用模拟赌盘操作（即生成0到1之间的随机数与每个个体遗传到下一代群体的概率进行匹配）来确定各个个体是否遗传到下一代群体中。</li></ol><h3>4、交叉算子</h3><p>交叉运算，是指对两个相互配对的染色体依据交叉概率，按某种方式相互交换其部分基因，从而形成两个新的个体。</p><p>交叉运算是遗传算法区别于其他进化算法的重要特征，它在遗传算法中起关键作用，是产生新个体的主要方法。基本遗传算法（SGA）中交叉算子采用单点交叉算子。</p><p>单点交叉运算</p><p><img src="http://hi.csdn.net/attachment/201101/12/8394323_1294826338NWUh.jpg" alt="log02"></p><h3>5、变异算子</h3><ul><li>变异运算，是指改变个体编码串中的某些基因值，从而形成新的个体。</li><li>变异运算是产生新个体的<strong>辅助方法</strong>，决定遗传算法的局部搜索能力，保持种群多样性。</li><li>交叉运算和变异运算的相互配合，共同完成对搜索空间的全局搜索和局部搜索。</li><li>基本遗传算法（SGA）中变异算子采用基本位变异算子。</li></ul><p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则将其变为1；反之，若原有基因值为1，则将其变为0 。</p><p><img src="http://hi.csdn.net/attachment/201101/12/8394323_129482633872s3.jpg" alt="log03"></p><div align="center">基本位变异算子的执行过程</div><p><font color="red"><strong>交叉和变异操作目的在于创建一个新的种群，使得新种群目标函数的平均值能够大于上一代种群。总的说来，遗传算法就是针对种群迭代开展交叉和变异操作，产生新种群，直到满足预定的停止条件。</strong></font></p><p>Matlab示例：</p><p>选择适应度函数为：$f(x) = x + 10sin(5x) + 7cos(4x)$函数图像为</p><p><img src="http://img.blog.csdn.net/20170227193922105?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log04"></p><p>运行结果为：</p><p><img src="http://img.blog.csdn.net/20170227193901589?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log05"></p><p>最优个体为： 10101111011111011</p><p>最优值为：24.8554</p><p>相关Matlab代码参考：<a href="https://github.com/yanshengjia/artificial-intelligence/tree/master/genetic-algorithm-for-functional-maximum-problem/src" target="_blank" rel="noopener">Github地址</a></p><ol><li>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</li><li><a href="http://blog.csdn.net/v_JULY_v/article/details/6132775" target="_blank" rel="noopener">http://blog.csdn.net/v_JULY_v/article/details/6132775</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>等式约束与不等式约束问题</title>
      <link href="/%E7%AD%89%E5%BC%8F%E7%BA%A6%E6%9D%9F%E4%B8%8E%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98.html"/>
      <content type="html"><![CDATA[<p>针对特殊约束条件下的优化问题，有着不同类别适应不同条件的求解算法。包括梯度法、求解线性等式约束问题的投影梯度法、适用于含有等式约束规划和含有不等式规划的拉格朗日乘子法、针对不等式约束的KKT条件法、罚函数法等。</p><a id="more"></a><h2>等式约束问题</h2><p>设目标函数为f(x)，约束条件为$h_k(x)$，形如$$min \quad f(x) \  s.t. \quad h_k(x)=0 \quad k=1,2,\cdots k$$则解决方法是消元法或者拉格朗日法。消元法不再多说，拉格朗日法这里在提一下，因为后面提到的KKT条件是对拉格朗日乘子法的一种泛化。</p><p>$$L(x,\lambda)=f(x)+\sum_{k=1}^{l}\lambda_kh_k(x)$$其中$λ_k$是各个约束条件的待定系数。然后解偏导方程组：$$\frac{\partial F }{\partial x_i}=0 \quad  \frac{\partial F }{\partial \lambda_k}=0 \ \cdots$$</p><p>至于为什么这么做可以求解最优化？维基百科上给出了一个比较好的直观解释。</p><p>举个二维最优化的例子：</p><p>$$min f(x,y)   \s.t. g(x,y) = c$$</p><p>这里画出$z=f(x,y)$的等高线：<img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1364139753,865873880&amp;fm=27&amp;gp=0.jpg" alt="log01"></p><p>绿线标出的是约束$g(x,y)=c$的点的轨迹。蓝线是$f(x,y)$的等高线。箭头表示斜率，和等高线的法线平行。从梯度的方向上来看，显然有$d1&gt;d2$。绿色的线是约束，也就是说，只要正好落在这条绿线上的点才可能是满足要求的点。如果没有这条约束，$f(x,y)$的最小值应该会落在最小那圈等高线内部的某一点上。<font color="red">而现在加上了约束，最小值点应该在哪里呢？</font>显然应该是在f(x,y)的等高线正好和约束线相切的位置，因为如果只是相交意味着肯定还存在其它的等高线在该条等高线的内部或者外部，使得新的等高线与目标函数的交点的值更大或者更小，<font color="red">只有到等高线与目标函数的曲线相切的时候，可能取得最优值。</font></p><p>如果我们对约束也求梯度$∇g(x,y)$，则其梯度如图中绿色箭头所示。很容易看出来，要想让目标函数$f(x,y)$的等高线和约束相切，则他们切点的梯度一定在一条直线上。即：$\partial f(x,y)=\lambda（\partial g(x,y)-C) $其中λ可以是任何非0实数。</p><p>一旦求出$\lambda$的值，将其带入下式，易求在无约束极值和极值所对应的点。</p><p>$$F(x,y)=f(x,y)+\lambda(g(x,y)-c)$$</p><p>这就是拉格朗日函数的由来。</p><h2>不等式约束问题</h2><p>考虑一般形式的优化问题：$$Min\quad f(x) \ s.t. \quad h(x)=0 \ \quad g(x) \geq 0$$</p><p>由上式，对于一个不等式约束$g_j(x)\leqslant 0$，如果在$x^{<em>}$处$g_j(x)= 0$，那么称该不等式约束是$x^{</em>}$处的起作用约束；如果在$x^{*}$ 处 $g_j(x)\geq 0$，那么称该约束是处的不起作用约束。按惯例，把等式约束$h_i(x)=0$当作总是起作用的约束。</p><p>由此，定义不等式约束下的拉格朗日函数L，则L表达式为：$$L(X,\lambda,\mu)=f(X)+\sum_{j==1}^{p}\lambda_jh_j(X)+\sum_{k=1}^{q}\mu_kg_k(X)$$</p><p>其中f(x)是原目标函数，$h_j(x)$是第j个等式约束条件，$\lambda _j$是对应的约束系数，$g_k$是不等式约束，$\mu_k$是对应的约束系数。</p><p>常用的方法是KKT条件，同样地，把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$L(a, b, x)= f(x) + a<em>g(x)+b</em>h(x)$</p><p>KKT条件是说最优值必须满足以下条件：</p><ol><li>$\frac{\partial L }{\partial x_i}=0$对x求导为零；</li><li>h(x) =0;</li><li>a*g(x) = 0;</li></ol><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为$g(x)&lt;=0$，如果要满足这个等式，必须a=0或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><h3>KKT的推导：</h3><p>首先不加证明的给出对偶问题结论：$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)=\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p><img src="http://images2015.cnblogs.com/blog/520787/201509/520787-20150901140604513-1723209246.jpg" alt="log02"></p><p>参考资料：</p><ol><li>Edwin K.P.Chong  and Stanisslaw H.Zak 最优化导论（第四版）</li><li><a href="http://blog.csdn.net/xianlingmao/article/details/7919597" target="_blank" rel="noopener">http://blog.csdn.net/xianlingmao/article/details/7919597</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>广义线性模型(Generalized Linear Model)</title>
      <link href="/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B(Generalized%20Linear%20Model).html"/>
      <content type="html"><![CDATA[<h2>广义线性模型(Generalized Linear Model)</h2><p>本文沿接接着上节的指数分布族,文章中注了引入指数分布族的概念是为了说明广义线性模型。</p><h2>概念</h2><p>广义线性模型（generalized linear model, GLM)是简单最小二乘回归（OLS)的扩展,在广义线性模式中，假设每个变量的观测值 $Y$ 来自某个指数族分布。 该分布的平均数 $\mu$ 可由与该点独立的 $X$ 解释：$$E(y)=\mu=g(\theta^Tx)$$</p><p>其中$E(y)$为 $y$ 的期望值，$\theta^T x$是由未知待估计参数$\theta$与已知变数 $X$ 构成的线性估计式，$g$ 则为链接函数。在此模式下,$y$ 的方差 $V$ 可表示为：$$Var(y)=V(y)=V(g(\theta ^Tx))$$一般假设 $V$ 可视为一指数族随机变数的函数。未知参数 $\theta$ 通常会以最大似然、贝叶斯方法估计。</p><h2>例证</h2><p><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1524553806/2018_04_15-01.png" alt="log01"><img src="https://res.cloudinary.com/ulsonhu/image/upload/v1524553806/2018_04_15-02.png" alt="log02"></p><p>参考此例：$\eta$ 与伯努利分布中的参数 $\varphi$ 的关系是 $\text{Logistic}$ 函数，再通过推导可以得到 $\text{Logistic}$ 回归。见下文推导示例。</p><p>通过此例，我们可以推想，$\eta$以不同的映射函数与其他概率分布函数中的参数发生联系，从而得到不同的模型，广义线性模型正是将指数族分布中的所有成员都作为线性模型的扩展，通过非线性的连接函数映射到其他空间从而大大扩大了线性模型可解决的问题。</p><h3>假设条件</h3><p>下面我们看看GLM的形式话定义，GLM的三个假设：</p><ol><li>$y|x;\theta～ExpFamily(\eta)$：给定样本 $x$ 与参数 $\theta$,样本分类 $y$ 服从指数分布族中的某个分布</li><li>给定一个 $x$ ，我们需要的目标函数为$h_\theta(x)=E\left[ T(y)|x\right]$</li><li>$\eta=\theta^Tx$</li></ol><h3>上例推导</h3><p>依据三个假设，我们可以推导出logistic模型与最小二乘模型。Logistic模型的推导过程如下：$$h_\theta(x)=E\left[ T(y)|x\right] =E\left[ y|x\right]=\mu=\eta=\theta^Tx$$</p><p>其中，将$\eta$与原始概率分布中的参数联系起来的函数成为正则相应函数，如$\varphi=\frac{1}{1+e^(-\eta)},\mu=\eta$即是正则响应函数。正则响应函数的逆称为正则关联函数。</p><p>所以，<font color="blue">对于广义线性模型，需要决策的是选用什么样的分布</font>，当选取高斯分布时，我们可以得到最小二乘模型，当选取伯努利分布时，我们得到logistic模型，这里所说的模型是假设函数 $h$ 的形式。</p><p>同样，可以将Logistic函数做拉伸变换，可以得到新的连接函数</p><p>$$\varphi=\frac{1}{1+e^{-\lambda\eta}}$$</p><h3>总结</h3><p>总计来说，广义线性模型通过假设一个概率分布函数，得到不同的模型，而之前讨论的梯度下降法、牛顿法都是为了求取线性模型中的<strong>线性部分 $(\theta ^Tx)$ 的参数 $\theta$ 的</strong>。</p><blockquote><p>GLM是NLM的直接推官，它不仅可以用于连续数据，更重要的是或它的根本价值在于可用于离散数据。其中1983年，P.McCullagh &amp; J.A.Nelder合著世界上第一本GLM的专著。</p></blockquote><p>参考链接：</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E7%BE%A9%E7%B7%9A%E6%80%A7%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/廣義線性模型</a></li><li><a href="http://blog.csdn.net/stdcoutzyx/article/details/9207047" target="_blank" rel="noopener">http://blog.csdn.net/stdcoutzyx/article/details/9207047</a></li><li>张尧庭(1995). 线性模型与广义线性模型</li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MCMC与Gibbs采样</title>
      <link href="/MCMC%E4%B8%8EGibbs%E9%87%87%E6%A0%B7.html"/>
      <content type="html"><![CDATA[<h2>随机模拟</h2><p>  随机模拟(或者统计模拟)方法有一个很酷的别名是蒙特卡罗方法(Monte Carlo Simulation)。这个方法的发展始于20世纪40年代，和原子弹制造的曼哈顿计划密切相关，当时的几个大牛，包括乌拉姆、冯.诺依曼、费米、费曼、Nicholas Metropolis， 在美国洛斯阿拉莫斯国家实验室研究裂变物质的中子连锁反应的时候，开始使用统计模拟的方法,并在最早的计算机上进行编程实现。</p><a id="more"></a><img src="https://cos.name/wp-content/uploads/2013/01/simulation.jpg" width="50%" height="50%"><div align="center">simulation随机模拟与计算机</div><p>  现代的统计模拟方法最早由数学家乌拉姆提出，被Metropolis命名为蒙特卡罗方法，蒙特卡罗是著名的赌场，赌博总是和统计密切关联的，所以这个命名风趣而贴切，很快被大家广泛接受。被不过据说费米之前就已经在实验中使用了，但是没有发表。说起蒙特卡罗方法的源头，可以追溯到18世纪，布丰当年用于计算$\pi$的著名的投针实验就是蒙特卡罗模拟实验。统计采样的方法其实数学家们很早就知道，但是在计算机出现以前，随机数生成的成本很高，所以该方法也没有实用价值。随着计算机技术在二十世纪后半叶的迅猛发展，随机模拟技术很快进入实用阶段。对那些用确定算法不可行或不可能解决的问题，蒙特卡罗方法常常为人们带来希望。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/monte-carlo-simulation.jpg" alt="log2"></p><div align="center">monte-carlo-simulation蒙特卡罗方法</div><p>  <font color="blue">统计模拟中有一个重要的问题就是给定一个概率分布 $p(x)$ ，我们如何在计算机中生成它的样本。</font>一般而言均匀分布 $Uniform(0,1)$的样本是相对容易生成的。通过线性同余发生器可以生成伪随机数，我们用确定性算法生成[0,1]之间的伪随机数序列后，这些序列的各种统计指标和均匀分布 $Uniform(0,1)$ 的理论计算结果非常接近。这样的伪随机序列就有比较好的统计性质，可以被当成真实的随机数使用。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/sampling.png" alt="">生成一个概率分布的样本</p><p>  而我们常见的概率分布，无论是连续的还是离散的分布，都可以基于$Uniform(0,1)$的样本生成。例如正态分布可以通过著名的 Box-Muller 变换得到。</p><p><strong>[Box-Muller 变换]</strong>：如果随机变量 $U1,U2$独立且$U1,U2\sim Uniform[0,1]$</p><p>$$Z_0 = \sqrt{-2\ln U_1} cos(2\pi U_2) \\ Z_1 = \sqrt{-2\ln U_1} sin(2\pi U_2)$$则 $Z_0,Z_1$独立且服从标准正态分布。</p><p>其它几个著名的连续分布，包括<strong>指数分布、$Gamma$ 分布、$t$ 分布、$F$ 分布、$Beta$ 分布、$Dirichlet$ 分布</strong>等等,也都可以通过类似的数学变换得到；离散的分布通过均匀分布更加容易生成。更多的统计分布如何通过均匀分布的变换生成出来，大家可以参考统计计算的书，其中 Sheldon M. Ross 的《统计模拟》是写得非常通俗易懂的一本。</p><p>不过我们并不是总是这么幸运的，当$p(x)$的形式很复杂，或者$p(x)$ 是个高维的分布的时候，样本的生成就可能很困难了。 譬如有如下的情况</p><ul><li>$p(x)=\frac{\tilde{p}(x)}{\int\tilde{p}(x)}dx $,而$\tilde{p}(x)$我们是可以计算的，但是底下的积分式无法显式计算。</li><li>$p(x,y)$是一个二维的分布函数，这个函数本身计算很困难，但是条件分布 $p(x|y),p(y|x)$的计算相对简单;如果 $p(x)$是高维的，这种情形就更加明显。</li></ul><p>此时就需要使用一些更加复杂的随机模拟的方法来生成样本。而本节中将要重点介绍的 <strong>MCMC(Markov Chain Monte Carlo)和 Gibbs Sampling算法</strong>就是最常用的一种，这两个方法在现代贝叶斯分析中被广泛使用。要了解这两个算法，我们首先要对马氏链的平稳分布的性质有基本的认识。</p><h2>马氏链及其平稳分布</h2><p>马氏链的数学定义很简单</p><p>$$P(X_{t+1}=x|X_t, X_{t-1}, \cdots) =P(X_{t+1}=x|X_t)$$</p><p>也就是状态转移的概率只依赖于前一个状态。</p><p>我们先来看马氏链的一个具体的例子。社会学家经常把人按其经济状况分成3类：下层(lower-class)、中层(middle-class)、上层(upper-class)，我们用1,2,3 分别代表这三个阶层。社会学家们发现决定一个人的收入阶层的最重要的因素就是其父母的收入阶层。如果一个人的收入属于下层类别，那么他的孩子属于下层收入的概率是 $0.65$, 属于中层收入的概率是 $0.28$, 属于上层收入的概率是 $0.07$。事实上，从父代到子代，收入阶层的变化的转移概率如下</p><p><img src="https://cos.name/wp-content/uploads/2013/01/table-1.jpg" alt="log3"></p><p>使用矩阵的表示方式，转移概率矩阵记为$$P =\begin{bmatrix}0.65 &amp; 0.28 &amp; 0.07 \\0.15 &amp; 0.67 &amp; 0.18 \\0.12 &amp; 0.36 &amp; 0.52 \\\end{bmatrix}$$</p><p>假设当前这一代人处在下层、中层、上层的人的比例是概率分布向量$ \pi_0=[\pi_0(1), \pi_0(2), \pi_0(3)]$那么他们的子女的分布比例将是 $\pi_{1}=\pi_{0}P$, 他们的孙子代的分布比例将是 $\pi_{2} = \pi_{1}P=\pi_{0}P^2$第 $n$ 代子孙的收入分布比例将是$\pi_{n} = \pi_{n-1}P = \pi_{0}P^n$假设初始概率分布为$\pi_{0}=[0.21,0.68,0.11]$,则我们可以计算前n代人的分布状况如下</p><p><img src="https://cos.name/wp-content/uploads/2013/01/table-2.jpg" alt="log2"></p><p>我们发现从第7代人开始，这个分布就稳定不变了，这个是偶然的吗？我们换一个初始概率分布$\pi _0=[0.75,0.15,0.1]$试试看，继续计算前n代人的分布状况如下<img src="https://cos.name/wp-content/uploads/2013/01/table-3.jpg" alt="log3">我们发现，到第9代人的时候, 分布又收敛了。最为奇特的是，两次给定不同的初始概率分布，最终都收敛到概率分布 $\pi=[0.286,0.489,0.225]$，也就是说收敛的行为和初始概率分布 $\pi_0$ 无关。这说明这个收敛行为主要是由概率转移矩阵$P$决定的。我们计算一下 $P_n$$$P^{20} = P^{21} = \cdots = P^{100} = \cdots = \begin{bmatrix} 0.286 &amp; 0.489 &amp; 0.225 \\ 0.286 &amp; 0.489 &amp; 0.225 \\ 0.286 &amp; 0.489 &amp; 0.225 \\ \end{bmatrix}$$我们发现，当 $n$ 足够大的时候，这个$P_n$矩阵的每一行都是稳定地收敛到$\pi=[0.286,0.489,0.225]$这个概率分布。自然的，这个收敛现象并非是我们这个马氏链独有的，而是绝大多数马氏链的共同行为，关于马氏链的收敛我们有如下漂亮的定理：</p><h3>马氏链定理：</h3><p>如果一个非周期马氏链具有转移概率矩阵$P$,且它的任何两个状态是<strong>连通</strong>的，那么$\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n$存在且与 $i$ 无关，记$\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n = \pi(j)$, 我们有</p><ol><li><p>$\displaystyle \lim_{n \rightarrow \infty} P^n =\begin{bmatrix} \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \\ \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ \end{bmatrix}$</p></li><li><p>$\displaystyle \pi(j) = \sum_{i=0}^{\infty}\pi(i)P_{ij}$</p></li><li><p>$\pi$是方程$\pi P=\pi $的唯一非负解其中,$$\pi = [\pi(1), \pi(2), \cdots, \pi(j),\cdots ], \\ \sum_{i=0}^{\infty} \pi_i = 1$$</p></li></ol><p>$\pi$ 称为马氏链的平稳分布。</p><p>这个马氏链的收敛定理非常重要，所有的 MCMC(Markov Chain Monte Carlo) 方法都是以这个定理作为理论基础的。 定理的证明相对复杂，一般的随机过程课本中也不给证明，所以我们就不用纠结它的证明了，直接用这个定理的结论就好了。我们对这个定理的内容做一些解释说明：</p><ol><li>该定理中马氏链的状态<strong>不要求有限</strong>，可以是有无穷多个的；</li><li>定理中的“非周期“这个概念我们不打算解释了，因为我们遇到的绝大多数马氏链都是非周期的；</li><li>两个状态 $i,j$ 是连通并非指 $i$ 可以直接一步转移到 $j,(P_{i,j} &gt;0)$ ,而是指 $i$ 可以通过有限的 $n$ 步转移到达$j(P_{ij}^n&gt;0)$。<strong>马氏链的任何两个状态是连通</strong>的含义是指存在一个 $n$ ,使得矩阵$P_n$ 中的任何一个元素的数值都大于零。</li><li>我们用 $X_i$ 表示在马氏链上跳转第 $i$ 步后所处的状态，如果 $\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n = \pi(j)$存在，很容易证明以上定理的第二个结论。由于</li></ol><p>$$P(X_{n+1}=j) \\ =\sum_{i=0}^\infty P(X_n=i) P(X_{n+1}=j|X_n=i) \\  = \sum_{i=0}^\infty P(X_n=i) P_{ij} $$</p><p>上式两边取极限就得到$\displaystyle \pi(j) = \sum_{i=0}^{\infty}\pi(i)P_{ij}$</p><p>从初始概率分布$\pi_0$出发，我们在马氏链上做状态转移，记$x_i$的概率分布为$\pi_i$, 则有</p><p>$$X_0 \sim \pi_0(x) \\ X_i \sim \pi_i(x), \\ \pi_i(x) = \pi_{i-1}(x)P = \pi_0(x)P^n$$</p><p>由马氏链收敛的定理, 概率分布$\pi_i(x)$将收敛到平稳分布$\pi(x)$。假设到第$n$步的时候马氏链收敛，则有</p><p>$$ X_0 \sim \pi_0(x) \\ X_1 \sim \pi_1(x) \\ \cdots \\ X_n \sim \pi_n(x)=\pi(x) \\ X_{n+1} \sim \pi(x) \\ X_{n+2} \sim \pi(x) \\ \cdots $$</p><p>所以 $X_n,X_{n+1},X_{n+2},\cdots \sim \pi(x)$都是同分布的随机变量，当然他们并不独立。如果我们从一个具体的初始状态 $x_0$开始,沿着马氏链按照概率转移矩阵做跳转，那么我们得到一个转移序列 $x_0,x_1,x_2,\cdots,x_n,x_{n+1},\cdots,$ 由于马氏链的收敛行为， $x_n,x_{n+1},\cdots$都将是平稳分布$\pi(x)$的样本。</p><h2>Markov Chain Monte Carlo</h2><p>  对于给定的概率分布 $p(x)$ ,我们希望能有便捷的方式生成它对应的样本。由于马氏链能收敛到平稳分布， 于是一个很的漂亮想法是：<font color="red">如果我们能构造一个转移矩阵为$P$的马氏链，使得该马氏链的平稳分布恰好是$p(x)$, 那么我们从任何一个初始状态 $x_0$ 出发沿着马氏链转移, 得到一个转移序列 $x_0,x_1,x_2,\cdots x_n,x_{n+1},\cdots$， 如果马氏链在第 $n$ 步已经收敛了，于是我们就得到了$\pi(x)$的样本$x_n,x_{n+1},\cdots$。</font></p><p>  这个绝妙的想法在1953年被 Metropolis想到了，为了研究粒子系统的平稳性质， Metropolis 考虑了物理学中常见的波尔兹曼分布的采样问题，首次提出了基于马氏链的蒙特卡罗方法，即Metropolis算法，并在最早的计算机上编程实现。Metropolis 算法是首个普适的采样方法，并启发了一系列 MCMC方法，所以人们把它视为随机模拟技术腾飞的起点。 Metropolis的这篇论文被收录在《统计学中的重大突破》中， Metropolis算法也被遴选为二十世纪的十个最重要的算法之一。</p><p>  我们接下来介绍的MCMC 算法是 Metropolis 算法的一个改进变种，即常用的 Metropolis-Hastings 算法。由上一节的例子和定理我们看到了，马氏链的收敛性质主要由转移矩阵$P$决定, 所以基于马氏链做采样的关键问题是如何构造转移矩阵$P$,使得平稳分布恰好是我们要的分布$p(x)$。如何能做到这一点呢？我们主要使用如下的定理。</p><h3>定理：细致平稳条件</h3><p>如果非周期马氏链的转移矩阵 $P$ 和分布 $\pi(x)$ 满足</p><p>$$ \pi(i)P_{ij} = \pi(j)P_{ji} \quad \text{for all}\quad i,j$$</p><p>则 $\pi(x)$ 是马氏链的平稳分布，上式被称为细致平稳条件(detailed balance condition)。</p><p>其实这个定理是显而易见的，因为细致平稳条件的物理含义就是<strong>对于任何两个状态 $i,j$ ,从 $i$ 转移出去到 $j$  而丢失的概率质量，恰好会被从 $j$ 转移回 $i$ 的概率质量补充回来，所以状态 $i$ 上的概率质量$\pi(i)$是稳定的，从而$\pi(x)$是马氏链的平稳分布</strong>。数学上的证明也很简单，由细致平稳条件可得</p><p>$$\sum_{i=1}^\infty \pi(i)P_{ij} =\sum_{i=1}^\infty \pi(j)P_{ji} = \pi(j) \sum_{i=1}^\infty P_{ji} = \pi(j) \\ \Rightarrow \pi P = \pi$$</p><p>由于$\pi$是方程 $\pi P=\pi $的解，所以$\pi $是平稳分布。</p><p>假设我们已经有一个转移矩阵为 $Q$ 马氏链($q(i,j)$表示从状态 $i$ 转移到状态$j$的概率，也可以写为 $q(j|i)$) 显然，通常情况下</p><p>$$p(i) q(i,j) \neq p(j) q(j,i)$$</p><p>也就是细致平稳条件不成立，所以$p(x)$不太可能是这个马氏链的平稳分布。我们可否对马氏链做一个改造，使得细致平稳条件成立呢？譬如，我们引入一个 $\alpha(i,j)$, 我们希望</p><p>$$p(i) q(i,j)\alpha(i,j) = p(j) q(j,i)\alpha(j,i)  \quad (*) $$</p><p>$$\alpha(i,j)= p(j) q(j,i),\quad \alpha(j,i) = p(i) q(i,j)$$</p><p>于是$(*)$式就成立了。所以有</p><p>$$p(i)\underbrace{q(i,j)\alpha(i,j)}_{Q^{’}(i,j)} = p(j)\underbrace{q(j,i)\alpha(j,i)}_{Q^{’}(j,i)}, (**)$$</p><p>于是我们把原来具有转移矩阵 $Q$ 的一个很普通的马氏链，改造为了具有转移矩阵 $Q’$ 的马氏链，而 $Q’$ 恰好满足细致平稳条件，由此马氏链 $Q’$ 的平稳分布就是$p(x)$.</p><p>在改造 $Q$ 的过程中引入的 $\alpha(i,j)$称为接受率，物理意义可以理解为在原来的马氏链上，<strong>从状态 $i$ 以$q(i,j)$ 的概率转跳转到状态 $j$ 的时候，我们以$\alpha (i,j)$的概率接受这个转移，于是得到新的马氏链$Q’$的转移概率为$q(i,j)\alpha(i,j)$。</strong></p><p><img src="https://cos.name/wp-content/uploads/2013/01/mcmc-transition.jpg" alt=""><font align="center">马氏链转移和接受概率 </font></p><p>假设我们已经有一个转移矩阵$Q$(对应元素为$q(i,j)$), 把以上的过程整理一下，我们就得到了如下的用于采样概率分布$p(x)$的算法。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/mcmc-algo-1.jpg" alt="">上述过程中 $p(x),q(x|y)$ 说的都是离散的情形，事实上即便这两个分布是连续的，以上算法仍然是有效，于是就得到更一般的连续概率分布 $p(x)$的采样算法，而 $q(x|y)$ 就是任意一个连续二元概率分布对应的条件分布。</p><p>  以上的 MCMC 采样算法已经能很漂亮的工作了，不过它有一个小的问题：马氏链$Q$在转移的过程中的接受率 $\alpha(i,j)$ 可能偏小，这样采样过程中马氏链容易原地踏步，拒绝大量的跳转，这使得马氏链遍历所有的状态空间要花费太长的时间，收敛到平稳分布$p(x)$的速度太慢。有没有办法提升一些接受率呢?</p><p>假设 $\alpha(i,j)=0.1,\alpha(j,i)=0.2$, 此时满足细致平稳条件，于是</p><p>$$p(i)q(i,j)\times 0.1 = p(j)q(j,i) \times 0.2$$</p><p>上式两边扩大5倍，我们改写为$$p(i)q(i,j) \times 0.5 = p(j)q(j,i) \times 1$$</p><p>看，我们提高了接受率，而细致平稳条件并没有打破！这启发我们可以把细致平稳条件 $(**)$ 式中的$\alpha(i,j),\alpha(j,i)$同比例放大，使得两数中最大的一个放大到1，这样我们就提高了采样中的跳转接受率。所以我们可以取</p><p>$$\alpha(i,j) = \min \{\frac{p(j)q(j,i)}{p(i)q(i,j)},1 \}$$</p><p>于是，经过对上述 MCMC 采样算法中接受率的微小改造，我们就得到了如下教科书中最常见的 Metropolis-Hastings 算法。<img src="https://cos.name/wp-content/uploads/2013/01/mcmc-algo-2.jpg" alt="log03"></p><p>  对于分布 $p(x)$,我们构造转移矩阵 $Q’$ 使其满足细致平稳条件</p><p>$$p(x) Q’(x\rightarrow y) = p(y) Q’(y\rightarrow x)$$</p><p>此处$x$并不要求是一维的，对于高维空间的$p(x)$，如果满足细致平稳条件</p><p>$$p(\mathbf{x}) Q’(\mathbf{x}\rightarrow \mathbf{y}) = p(\mathbf{y}) Q’(\mathbf{y}\rightarrow \mathbf{x})$$那么以上的 Metropolis-Hastings 算法一样有效。</p><h2>Gibbs Sampling</h2><p>  对于高维的情形，由于接受率$\alpha$的存在(通常$\alpha&lt;1$), 以上 Metropolis-Hastings 算法的效率不够高。能否找到一个转移矩阵$Q$使得接受率$\alpha=1$呢？我们先看看二维的情形，假设有一个概率分布 $p(x,y)$, 考察 $x$ 坐标相同的两个点$A(x_1,y_1),B(x_1,y_2)$，我们发现</p><p>$$p(x_1,y_1)p(y_2|x_1) = p(x_1)p(y_1|x_1)p(y_2|x_1) \\ p(x_1,y_2)p(y_1|x_1) = p(x_1)p(y_2|x_1)p(y_1|x_1)$$</p><p>所以得到</p><p>$$ p(x_1,y_1)p(y_2|x_1) = p(x_1,y_2)p(y_1|x_1)  \quad (***) $$</p><p>即$p(A)p(y_2|x_1) = p(B)p(y_1|x_1)$</p><p><img src="https://cos.name/wp-content/uploads/2013/01/gibbs-transition.png" alt="">平面上马氏链转移矩阵的构造</p><p>$Q(A\rightarrow B) = p(y_B|x_1) \quad \text{if} \quad x_A=x_B=x_1 \\ Q(A\rightarrow C) = p(x_C|y_1) \quad \text{if} \quad y_A=y_C=y_1 \\ Q(A\rightarrow D) = 0 \quad ,\text{others}$</p><p>有了如上的转移矩阵$Q$, 我们很容易验证对平面上任意两点$X,Y$ 满足细致平稳条件</p><p>$$p(X)Q(X\rightarrow Y) = p(Y) Q(Y\rightarrow X)$$</p><p>于是这个二维空间上的马氏链将收敛到平稳分布 $p(x,y)$ 。而这个算法就称为 Gibbs Sampling 算法,是 Stuart Geman 和Donald Geman 这两兄弟于1984年提出来的，之所以叫做Gibbs Sampling 是因为他们研究了Gibbs random field, 这个算法在现代贝叶斯分析中占据重要位置。<img src="https://cos.name/wp-content/uploads/2013/01/gibbs-algo-1.jpg" alt=""><img src="https://cos.name/wp-content/uploads/2013/01/two-stage-gibbs.png" alt=""></p><h3>Gibbs Sampling 算法中的马氏链转移</h3><p>  以上采样过程中，如图所示，马氏链的转移只是轮换的沿着坐标轴 $x$ 轴和 $y$ 轴做转移，于是得到样本$(x_0,y_0), (x_0,y_1), (x_1,y_1), (x_1,y_2),(x_2,y_2), \cdots$马氏链收敛后，最终得到的样本就是 $p(x,y)$的样本，而收敛之前的阶段称为 burn-in period。额外说明一下，我们看到教科书上的 Gibbs Sampling 算法大都是坐标轴轮换采样的，但是这其实是不强制要求的。最一般的情形可以是，在 $t$ 时刻，可以在 $x$ 轴和 $y$ 轴之间随机的选一个坐标轴，然后按条件概率做转移，马氏链也是一样收敛的。轮换两个坐标轴只是一种方便的形式。</p><p>  以上的过程我们很容易推广到高维的情形，对于$(***)$式，如果 $x_1$ 变为多维情形 $\mathbf{x_1}$，可以看出推导过程不变，所以细致平稳条件同样是成立的</p><p>$ p(\mathbf{x_1},y_1)p(y_2|\mathbf{x_1}) = p(\mathbf{x_1},y_2)p(y_1|\mathbf{x_1}) $此时转移矩阵 $Q$ 由条件分布 $p(y|x_1)$定义。上式只是说明了一根坐标轴的情形，和二维情形类似，很容易验证对所有坐标轴都有类似的结论。所以$n$维空间中对于概率分布$ p(x_1,x_2,\cdots ,x_n)$ 可以如下定义转移矩阵</p><ol><li>如果当前状态为$(x_1,x_2,\cdots ,x_n)$，马氏链转移的过程中，只能沿着坐标轴做转移。沿着 $x_i$这根坐标轴做转移的时候，转移概率由条件概率 $p(x_i|x_1, \cdots, x_{i-1}, x_{i+1}, \cdots, x_n)$定义；</li><li>其它无法沿着单根坐标轴进行的跳转，转移概率都设置为 0。</li></ol><p>于是我们可以把Gibbs Smapling 算法从采样二维的$p(x,y)$推广到采样 $n$ 维的 $p(x_1,x_2,\cdots,x_n)$</p><p><img src="https://cos.name/wp-content/uploads/2013/01/gibbs-algo-2.jpg" alt=""></p><p>以上算法收敛后，得到的就是概率分布$p(x_1,x_2,\cdots ,x_n)$的样本，当然这些样本并不独立，但是我们此处要求的是采样得到的样本符合给定的概率分布，并不要求独立。同样的，在以上算法中，坐标轴轮换采样不是必须的，可以在坐标轴轮换中引入随机性，这时候转移矩阵 $Q$ 中任何两个点的转移概率中就会包含坐标轴选择的概率，而在通常的 Gibbs Sampling 算法中，坐标轴轮换是一个确定性的过程，也就是在给定时刻 $t$ ，在一根固定的坐标轴上转移的概率是1。</p><blockquote><p>转载自<a href="https://cos.name/2013/01/lda-math-mcmc-and-gibbs-sampling/" target="_blank" rel="noopener">统计之都</a></p></blockquote>]]></content>
      
      <categories>
          
          <category> 机器学习相关 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指数分布族</title>
      <link href="/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E6%97%8F.html"/>
      <content type="html"><![CDATA[<p>指数分布族是指可以表示为指数分布的概率分布。指数分布形式如下：$$P(y;\eta)=b(y)exp(\eta^{T}T(y)-\alpha(\eta))$$其中，$\eta$成为分布的自然参数；$T(y)$是充分统计量，通常$T(y)=y$。当$a、b、T$参数都固定的时候，就定义了一个以 $\eta$ 为参数的指数函数族。</p><p>实际上，大多数概率分布都可以表示成上面公式给出的形式：</p><ol><li>伯努利分布：对0、1问题进行建模</li><li>多项式分布：对K个离散结果的事件建模</li><li>泊松分布：对计数过程进行建模</li><li>伽马分布与指数分布：对间隔的正数进行建模</li><li>Beta分布：对小数进行建模</li><li>Dirichlet分布：对小数进行建模</li><li>Wishart分布：对协方差进行建模</li><li>高斯分布</li></ol><h2>示例</h2><p>我们将高斯分布与伯努利分布表示成指数分布族的形式。</p><h3>伯努利分布</h3><p>伯努利分布是对$0、1$问题进行建模，特可以表示成如下形式：</p><p>$$P(y;\varphi)=\varphi^y(1-\varphi)^{1-y} \quad y\in{0,1}$$</p><p>$$P(y;\varphi) = \varphi^y(1-\varphi)^{1-y} \\=exp(\log \varphi^y(1-\varphi)^{1-y}) \\=exp(y\log \varphi+(1-y)\log(1-\varphi)) \\=exp(y\log \frac{\varphi}{1-\varphi}+\log(1-\varphi))$$</p><p>将伯努利分布表示成如下形式，对比指数族分布公示</p><p>$$b(y)=1 \\T(y)=1 \\\eta = \frac{\varphi}{1-\varphi} \Rightarrow \varphi=\frac{1}{1+e^{-\eta} } \\\alpha(\eta)=-\log(1-\varphi)=\log(1+e^{\eta})$$</p><p>其中可以看到，$\eta$的形式为logistic函数，这是因为logistic模型对问题的先验概率估计是伯努利分布的缘故。</p><h3>高斯分布</h3><p>  高斯分布可以推导出线性模型，由线性模型的假设函数可知，高斯分布的方差与假设函数无关，因而为简便计算，我们将方差设为1，即使不这样做，最后的结果也是作为一个系数而已，高斯分布转换为指数分布形式的推导过程如下：</p><p><img src="http://img.blog.csdn.net/20170226102549656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>我们最终一样可以把高斯分布以指数分布族函数的形式表示。</p><h2>后记</h2><ol><li>这里说明指数分布族的目的，是为了说明关于线性模型(Generalized Linear Model).</li><li>凡是符合指数分布族的随机变量，都可以用广义线性模型(GLM)进行分析。</li></ol><h3>备注</h3><p>指数分布族的<strong>无记忆性</strong>，教科书上所说的无记忆性（Memoryless Property，又称遗失记忆性）。这表示如果一个随机变量呈指数分布，它的条件概率遵循：$$P(T&gt;s+t;T&gt;t)=P(T&gt;s),\quad \text{for all} \quad s,t&gt;0 $$有兴趣的同学可以深入理解一下。</p>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矩阵分解相关知识回顾</title>
      <link href="/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE.html"/>
      <content type="html"><![CDATA[<h2>特征值与特征向量</h2><p>设A是数域F上的n阶矩阵，如果存在数域F中的一个数$\lambda$与数域上F的非零向量$\overrightarrow{\alpha}$，使得：$A\overrightarrow{\alpha}=\lambda \overrightarrow{\alpha}$则称$\lambda$为A的一个特征值(根)(eigenvalue)，称$\overrightarrow{\alpha}$为A的属于特征值$\lambda$的特征向量(eigenvector)。</p><p>显然从上式可以看出，$A\overrightarrow{\alpha} \overrightarrow{\alpha}$平行。</p><p>将上式做一下变换：$A\overrightarrow{\alpha}=\lambda \overrightarrow{\alpha}$$A\overrightarrow{\alpha}-\lambda \overrightarrow{\alpha}=0$$A\overrightarrow{\alpha}-\lambda E\overrightarrow{\alpha}=0$$(A−\lambda E)\overrightarrow{\alpha}=0$$(\lambda E-A)\overrightarrow{\alpha}=0$</p><p>称：$\lambda E−A$为A的特征矩阵行列式$f(\lambda )=|\lambda E−A|$为A的特征多项式$|\lambda E−A|=0$为A的特征方程$(\lambda E−A)\overrightarrow{x}=\overrightarrow{0}$是A关于该λ的齐次线性方程组</p><h2>矩阵对角化</h2><p>设n阶方阵A存在n个线性无关的特征向量$\overrightarrow{ x_{i} }$，将这n个特征向量$\overrightarrow {x_{i} }$组成方阵S(也称为特征向量矩阵），则有：<img src="http://img.blog.csdn.net/20170225194650882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">这个式子称为$A$的$SΛS^{−1}$分解，或特征分解(Eigendecomposition)，或A的对角化。</p><p>根据这个式子可以知道：当方阵$A$可以被分解为某个矩阵$S$乘以某个对角矩阵$\Lambda$再乘以矩阵$S^{−1}$时，就是一次特征分解。</p><p>可以对角化的前提是$A$有$n$个线性无关的特征向量。$A$有$n$个线性无关的特征向量的前提是，所有的$\lambda$都不重复（没有重根）。</p><h2>LU分解</h2><p>设$A$是一个方块矩阵。A的$LU$分解是将它分解成如下形式：$A=LU$其中$L$和$U$分别是下三角矩阵和上三角矩阵。</p><p>例如对于一个 $3*3$的矩阵，就有</p><p><img src="http://img.blog.csdn.net/20170225191810280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="null"></p><p>一个$LDU$分解是一个如下形式的分解：$A=LDU$其中$D$是对角矩阵，$L$和$U$是单位三角矩阵（对角线上全是1的三角矩阵）。</p><p>一个$LUP$分解是一个如下形式的分解：$A=LUP$其中$L$和$U$仍是三角矩阵，$P$是一个置换矩阵。</p><p>一个充分消元的$LU$分解为如下形式：$PAQ=LU$</p><h3>存在性</h3><p>一个可逆矩阵可以进行$LU$分解当且仅当它的所有子式都非零。如果要求其中的$L$矩阵（或$U$矩阵）为单位三角矩阵，那么分解是唯一的。同理可知，矩阵的$LDU$可分解条件也相同，并且总是唯一的。</p><h2>奇异值分解</h2><p>假设M是一个m×n阶矩阵，其中的元素全部属于域K，也就是实数域或复数域。如此则存在一个分解使得$M=U\sum V^{*}$其中U是m×m阶酉矩阵；$\sum$是m×n阶非负实数对角矩阵；而$V^{*}$，即V的共轭转置，是n×n阶酉矩阵。这样的分解就称作$M$的奇异值分解。</p><h3>几何解释</h3><p>首先，我们来看一个只有两行两列的简单矩阵。第一个例子是对角矩阵<img src="http://img.blog.csdn.net/20170225201907278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log00">从几何的角度，矩阵可以描述为一个变换：用矩阵乘法将平面上的点（x, y）变换成另外一个点（3x, y）：</p><p><img src="http://img.blog.csdn.net/20170225201947559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01">这种变换的效果如下：平面在水平方向被拉伸了3倍，在竖直方向无变化。<img src="http://img.blog.csdn.net/20170225202039887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>$2*2$矩阵奇异值分解的几何实质是：对于任意$2*2$矩阵，总能找到某个正交网格到另一个正交网格的转换与矩阵变换相对应。</p><p>用向量解释这个现象：选择适当的正交的单位向量$v_1$和$v_2$，向量$Mv_1$和$Mv_2$也是正交的。<img src="http://img.blog.csdn.net/20170225201208758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log05"></p><p>奇异值分解的魅力在于任何矩阵都可以找到奇异值。</p><p>参考链接：</p><ol><li><a href="http://www.ams.org/samplings/feature-column/fcarc-svd" target="_blank" rel="noopener">http://www.ams.org/samplings/feature-column/fcarc-svd</a></li><li><a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="noopener">https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html</a></li></ol>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Mathematic </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数理统计学：世纪末的回顾与展望</title>
      <link href="/%E6%95%B0%E7%90%86%E7%BB%9F%E8%AE%A1%E5%AD%A6%EF%BC%9A%E4%B8%96%E7%BA%AA%E6%9C%AB%E7%9A%84%E5%9B%9E%E9%A1%BE%E4%B8%8E%E5%B1%95%E6%9C%9B.html"/>
      <content type="html"><![CDATA[<blockquote><p>作者：陈希孺</p></blockquote><h2>一、20世纪数理统计学发展概述</h2><p>20世纪，特别是其上半叶，是数理统计学发展史上一个辉煌的时代。从现代数理统计学框架的建立到发展为一个成熟的学科，是在这个时期完成的。20世纪初，数理统计学面临一个转折点，意思是它必须有新的突破才能获得进一步发展的契机。20世纪早期一批以费歇尔(R.A.Fisher)为首的统计学大师成功地应对了这个局面，创造了非凡的业绩。按照国际上一些知名统计学家的看法，20世纪末数理统计学发展的态势，与世纪初颇有相似的地方。人们在呼唤“21世纪的费歇尔(Fisher)”。当然，广义地说，这也是每一位数理统计工作者所肩负的任务。中国作为一个世界大国，年轻一代的数理统计学者应该也有条件在这方面作出自己的贡献。为了更清楚阐述上文的意思，需要对数理统计学的历史作一个简短的回顾。按目前数理统计学界公认的看法，数理统计学是“收集和分析带随机性的数据的科学和艺术”。以笔者的看法，这个内涵规定了它是一个中立性的工具。“中立”的意思是指这门学科不带任何社会的、政治的或意识形态上的倾向性，因而也不存在它自成学派或从属于何学派的问题。有一种看法认为社会经济统计学与数理统计学是“大统计学”中的两个对立的学派。笔者认为这种看法值得商榷。的确，在社会经济统计学中该不该使用数理统计方法，在哪些问题上或者在何种程度上应否使用数理统计方法，是可能存在不同意见的。如果说由于对这些问题的看法不同而有学派存在，那还算言之成理。但这些问题与数理统计学无关：数理统计学只是一种工具，谁如觉得这个工具对他有用，就可以使用它——当然在使用中必须遵守这门学科的规范，否则就可能产生误导公众及提供错误的决策依据的后果。历史上（部分地直到如今）数理统计方法曾遭到一些批评和怀疑，一定程度上与上述情况有关。数理统计学起源于何时？这是一个无法也不必做出定论的问题。有的学者把英国学者格朗特(John Graunt)的著作《关于死亡公报的自然和政治观察》发表的年份1662年定为这门学科的诞生之日，恐怕也只能算是一家之见。实际情况是，可以说直到20世纪初，并不存在一门统一的数理统计学科，而中是在各实用领域中的学者因工作上的需要而分头发展了一些分析数据的方法，即统计方法。</p><p>最主要的有3 个方面：</p><ul><li><p>一是天文和测地学中因误差分析问题而导致最小二乘法和正态误差的发明。起初，人们认为“误差分析”与“统计分析”是根本不同的两回事：前者的数据是对一个对象多次测量所得；后者的数据则是对多个对象各测量一次所得。按现今的数理统计学框架，我们容易认识这是一回事，但在当时则不然。到19世纪中、后期，经过凯特勒、盖尔顿等在社会学和生物学方面的实际工作，以及埃其渥斯(Edgeworth)、卡尔·皮尔逊(Karl Pearson)等的数学理论工作，终于把二者统一起来，并在20世纪得到发扬光大。直到如今，<font color="red">线性模型——最小二乘法——正态误差</font>这个体系下所发展的方法，在相当大的程度上仍占据了应用统计方法中的主导地位。所以有人说，天文学是数理统计学的母亲。</p></li><li><p>第二个方面是人口学。前文提到的格朗特(John Graunt)的著作是一个重要例子。这个方向发展了离散数据统计，即以二项分布(Binomial)和泊松分布(Possion)为代表的统计方法。另一个重要之点是它在19世纪即开始孕育了抽样调查的思想。这也在20世纪得到发扬光大，成为现今统计方法中的重要组成部分。有的统计史学家评说：19世纪的统计就是频率分析(Frequency analysis)。那是因为，当时处理误差分析的一套工具尚未被视为属于统计方法的范畴。</p></li><li><p>最后一个方面是生物学，特别是遗传学。英国学者盖尔顿在1874年到1890年间到工作，引进了相关和回归的思想。其重大意义在于它开创了分析多维数据的统计方法。此前的统计方法都是单指标性的，不能顾及指标间的相互关系。而在实用问题中一般涉及多个彼此相依的指标，孤立地分析单个指标无法得出符合实际的结论。盖尔顿的工作经过埃其渥斯(Edgeworth)、卡尔·皮尔逊(Karl Pearson)和约尔在数学上的整理，到20世纪又经过费歇尔(Fisher)等一批学者的深化，直到目前仍不失为应用统计方法中的重镇和理论统计学中的主流方向之一。</p></li></ul><p>有人把上面粗略描述的，大体上到19世纪末为止的统计学的发展图景作了一个小结，归纳为以下3点：（1）统计方法是基于实用的需要，在不同领域中分头发展的。（2 ）没有专职的（以统计学为主业的）统计学家。对统计方法作出重大贡献的人，其主要身份是某个其他领域的学者，这在公认是现代数理统计学的奠基者费歇尔(Fisher)和卡尔·皮尔逊身上还可以看出来。（3）统计学没有一个严整的学科框架。</p><p>费歇尔(Fisher)传记的作者J.F.Box在谈到20世纪初期统计学状况时曾提到， 当时在人们的意识上连参数与统计量都没有严格区分开。有的学者提到，当时在统计方法的工具袋里已有了一些积累，包括最小二乘法（平均值可视为其特例）、方差、频率、二项分布、误差理论和正态分布、相关回归、矩估计、皮尔逊曲线族以及稍后的Student $t$分布等。 但它们是一些不连贯的片段，缺乏一个完整体系。</p><p>所以，在20世纪初年，摆在数理统计学面前的重大问题是建立一个理论（数学）上的框架。它不仅能包容已有的成果，而且还要对未来努力的方向起指引的作用。如大家所知道的，这个任务由以费歇尔(Fisher)为代表的一班统计学大师出色地完成了。这些统计学大师中除费歇尔(Fisher)外，还可以算上皮尔逊（Karl Pearson）、奈曼（Neyman）及较晚的瓦尔德(Wald)。至于卡尔·皮尔逊，有一种看法认为它是“旧统计”的押阵大将。但平心而论，他的工作，尤其是1900年发表的关于拟合优度检验的论文，对“新统计”的诞生有着不可低估的影响具有划时代的意义。至于费歇尔(Fisher)，其贡献更是全方位的：在理论方面，他分别于1921年和1925年发表的论文《理论统计学的数学基础》和《点估计理论》，奠定了统计学的大体上沿用至今数学框架；在方法的层面，他提出的似然估计、试验设计与方差分析以及一大批小样本抽样分布的结果，迄今仍有着重大的影响。其业绩在20世纪统计界确实无人可比。所以美国统计学家埃夫龙(Bradley Efron)在1996年一篇论文中把他比作“统计学的凯撒”。</p><p>前文提到，临近20世纪末，数理统计学发展的态势，颇有与世纪初相似之处。这一点要联系到20世纪下半叶数理计学的发展状况来讨论。</p><p>1940年，以克拉美(Cramer)的《统计学的数学方法》一书的出版为标志，数理统计学被公认为已形成一门严整的数学学科——应当注意的是：这一点固然与费歇尔(Fisher)等人为统计学制定了合适的数学框架有关，更本质的原因在于统计学中的“数据”已超脱了其实际含义：一组数据如假定来自正态总体，则与此有关的方法（如$t$区间估计、$F$检验等）都可以使用，而无须顾及数据从何而来。正如数学中人们说$1＋2＝3$， 而不必顾及这1、2、3是什么一样。数理统计学一经数学化，就有其自身的发展规律，一般认为，一个数学分支中新问题的来源，有“外生”和“内生”两种。前者是因外部的需要，一般是实际应用中的需要所提出的问题，而后者则是由学科的“自我扩张”引起的问题，不必有其实际背景。如前所说，在较早的时期（约在20世纪30年代或放宽一些到50年代），数理统计学与实用紧密结合，所研究的问题以“外生”性的为主。此后，情况有了很大变化：相当大部分的统计学理论研究转向“内生”性的问题，以“在预设的模型下寻求符合某种准则的最优解“及“大样本理论”两个方向为代表。应当指出的是：并非说沿着这此方向所作的工作全无实际意义。有些工作（主要在较早时期）是以往比较粗糙的结果的完善。<font color="blue">例如有关极大似然估计的渐近性质，费歇尔(Fisher)在1925年关于点估计的论文中就有初步的讨论。</font>到五、六十年代，在数学上得到更完满的发展。这类工作兼有理论和实用两方面的意义。有的在优化理论框架下得出的结果，如算术平均值或更一般地最小二乘估计在种种条件下的优良性质的结果，虽则对应用统计方法无所增添，但深化了我们对这些重要方法性质的了解，也是很有意义的。至于大样本理论，其大量的繁琐结果可说已趋于末流——既无理论上的数学美，又对分析数据不起什么作用。但也不可否认，其中也颇有些富有实际意义的结果，特别是<strong>非参数统计</strong>有关的一些大样本结果，为在免除正态假定下进行数据分析提供了可用的替代方法。虽然可举出以上这些有利情况，但不能不承认，<font color="blue">从总体上说，由这些“内生”问题产生的结果，多数是与数据分析没多大关系，</font>从纯数学的角度看也缺乏深度。这种情况引起了不少统计学家的忧虑和反思，以至有所谓“统计学危机”的呼声。</p><p>以上的简略描述表明，数理统计学在20世纪下半叶，理论上缺乏有意义的、突破性的进展。实用的或方法层面上的情况如何？应该说有不小的成绩。其中一部分得力于功能强大的计算机，它使一些需要大规模计算的方法能付诸实用，从而大大拓展了统计方法的应用面。在方法本身的研究上也有不少进展。不久前出版的一本论述“统计学中的突破”的著作，列举了到1980年为止统计学方面的40项“突破”，就其内容看（如<em>赤池弘次的AIC准则， 维尔考克森的秩和检验之类</em>）大都是<strong>局部范围内的方法性的成果</strong>，并非有全局意义的“突破”。统计学家休伯1997年在北京的一次讲演，认为近几十年来数理统计学只有3 项值得一提的重要成果：其一是他自己发展的稳健统计（这概念可追溯到费歇尔(Fisher)在1920年的一项关于比较绝对平均差和标准差的优劣的工作），另有埃夫龙(Bradley Efron)在1979年提出的“自助法”（bootstrap）和生存分析。 若情况果真如此，则20世纪下半叶统计学的成绩可说是很暗淡了。依笔者所见，情况要乐观一些，比如回归分析和多元分析中诸多的理论和方法进展、模型选择、试验设计、生存分析、贝叶斯统计等方面，都颇有一些富有实用意义的成果。</p><p>但不容否认的是，20世纪下半叶数理统计学方面的成就，主要限于若干局部性的、具体问题的方法性的层面上，全局性的、涉及根本的统计思想的成果，绝无仅有，拿一句人文科学讲座中常提到的套话来形容，可说是“学问家凸显，思想家淡出”。</p><p>以上种种情况使不少统计学家认为，统计学又面临一个新的突破的形势，或者也可以说，到了一个需要变革的时期，这与20世纪初的情况有其相似之处。</p><h2>二、数理统计学未来的发展</h2><p>这种突破会指向何方？要采取怎样的措施以有利于促成这种突破或变革？自20世纪60年代以来，不少学者，通过在有关会议上发表讲演或在刊物上发表论文，表达了各自的看法。有些看法有很大的一致性，例如主张统计学要回到以前那种重视联系实际的传统；主张“推倒围墙”，即重视与其他学科的交流和渗透；主张在统计教育上实行与此相应的变革等。在预测未来发展的主流上，则多有分歧。下面对一些较有影响的观点择要介绍一下。</p><ol><li>数据分析。美国资深统计学家图基在1962年发表了一篇题为《数据分析的未来》的长文，大约“数据分析”一词即起源于此文。这是第一次由一个极有影响的统计学家对当时的数理统计学发展状况作出反思并提出一种变革的方向，因此有重要的意义。直到今天，该文所表述的观点还经常得到统计学家们的征引。</li></ol><p>此文主要的精神是对当时统计界流行的以模型为出发点的做法提出反思，主张让数据多起作用。模型应当从分析数据中产生而不应让数据去曲合预设的模型。为此他主张对现行统计学的根基“用概率刻画统计推断的不确定性”作出松动——概率只是作为一种工具而非基础，适合使用时则用，不合用时就不用。提出这一主张与打破“以模型为出发点”或“预设模型”有关：没有一个充分简化的模型，就无法对统计推断的概率性质作深入探讨，以致一些“为发表文章而作研究”的工作不能不预设模型。除此以外图基还提出了一些原则性的主张。如果研究有现实意义的新问题，在更现实的条件下研究老问题，把统计学定位为一门科学而非数学——这意味着实用性优先于推理的严格性等等。图基及其支持者以后在一些文章和专著中进行一步阐发了他们的主张。所有这些人们现在将其归在尚未成形的“数据分析”的名目下。</p><p>笔者认为，虽然目前讲图基的主张在统计学界的支持率还不能算是很高，但由于以下两个情况，在未来可能发展为一个很有影响的思潮，并在相当程度上改变现行统计学的面貌。一是功能强大的计算机的广泛使用；二是在各个领域里不断提出的带有复杂结构数据的问题，<strong>如高维模拟仿真、模式识别、图像和信号处理、人工智能、神经网络、数据采掘（data mining）等</strong>。由于数据的随机性，这类问题在一定程度上和统计学有关，又因其复杂性使概率方法难于充分有效地使用，因此可能需要某种“折衷”的办法：既考虑到数据的大量性和复杂性而不能拘泥于一定的概率模式，又能使因数据的随机性而产生结论的不确定性有着某种科学的评价标准。也许这是一个使现行统计学产生“突破”的地方？</p><ol start="2"><li>“边缘学科”。如前所说，在19世纪末之前，统计学尚未成为一个今天意义下的独立学科，其发展是为应付现实的需要，结合其他学科来进行的。近若干年来，这个发展模式受到一些有影响的统计学家的推崇，认为有可能是将来的主流模式。统计学家休伯1997年在北京的一次讲演中，把统计学发展的历程画成一条螺旋线而非直线，意谓其发展不是直线式的，而是可能具有某种“回归”的性质或我们常说的“螺旋式进展”——当然是在提高的基础上回归而非简单重复。他还发表了一个“盛世危言”式的见解：如果统计学家的研究成果脱离实际应用的状况得不到改变，则这种形式的统计学将走向消亡，我们将像以往那样回到各个学科去发展适用的统计方法。这类方法不必具有通用的性质（比如像回归分析、方差分析这类统计方法，都具有很广的通用性）。</li></ol><p>他描述的这种图景眼下大概还不会成为现实——相信“通用的”统计方法仍有很大的发展余地，数理统计学作为一门独立学科的地位还没有动摇的迹象，但其思想则颇有可取之处。“通用方法”的发展也不可能是纯数学思维、闭门造车式的。如盖尔顿——皮尔逊发明的相关回归、费歇尔(Fisher)发明的方差分析这类“通用”方法，是结合像遗传学和农业试验的需要而得到。一位有名的华人生物统计学家曾指出搞统计必须结合一个area，也是这个意思。另一位美籍华人学者李景均（<a href="http://C.C.Li" target="_blank" rel="noopener">C.C.Li</a>）教授因研究群体遗传学的需要而发明被称为“路径分析”（path ananlysis）的统计方法，曾应某刊物之约发表长达80余页的专题论文，成为该领域国际公认的权威。其方法不止适用于遗传学。他并不以数学见长，如果投身到统计学的纯理论研究，也许不一定能做出达到这个水平的成就。总之，历史和现实都证明了：统计学和其他学科结合发展是一个正确的方向，也极可能成为未来发展的主流之一。</p><ol start="3"><li>贝叶斯统计。频率学派和贝叶斯学派的对立是20世纪数理统计学发展中一道亮丽的风景线。临到世纪末，早期那种情绪性的对立局面似乎已逐渐消退。原因之一是早期那些大师都已去世或淡出舞台，后继者不一定那么执着于“纯哲学”式的争论。也因为经过几十年的实践，统计学界大体上有了一种共识：至少在参数统计的范围内，这两个学派所达致的结论，所提供的方法基本相似。另外在局部范围而言，两派的方法也确实各有短长。英国老牌的贝叶斯派统计学家在近年的一次访谈中预言，21世纪将是贝叶斯统计一统天下的局面。在另一个场合中他把时间具体化到2020年。这后一点看来不像会成为现实。但近年来统计刊物上发表的一些学者的见解，确给笔者这样一个印象，即贝叶斯学派正在取得上风。这有多方面的原因，不在此细论。其中一个因素可能是：在对20世纪统计学的状况进行反思时，几乎所有的负面因素都与频率学派有牵涉，如过分的数学化而形成“两张皮”的现象。其中尤以将统计问题归结为最优化数学问题的见解倍受非议，有人讥之为“错误问题的正确解答”。</li></ol><p>如果贝叶斯统计真成为主流，在未来世纪它的主攻方向如何？有的学者也对此发表了见解。</p><p>如所周知，贝叶斯学派有“主观”和“客观”两个系统。<strong>主观贝叶斯学派</strong>认为先验分布的选择纯是使用者个人的事，不可能也不应该去寻求某种公认的、“客观”的选择。进一步的引伸是统计推断纯粹是主观行为，不可能用一种科学标准去规范它。学者们认为，这一学派会有其存在余地。它主要适用于经济决策中。在这种问题中，决策主体的条件和掌握信息资源的不同当然会影响其做出的决策，不可能是统一的标准。但是在科学研究（以寻求客观真理为目标）性质的问题中，或一般地说，在主观因素影响较少的问题中，这种思维模式恐难于为人们所接受。</p><p><strong>客观贝叶斯学派</strong>主张的核心在于给先验分布的选定制定一种大家都遵守的“客观”规则，而不由人随意地主观选定。这里所谓“客观”，不应理解为在频率意义下与实际情况符合——即同类问题大量出现而按参数值的频率去确定先验分布（果真有这个情况，问题可纳入频率学派的体系下）。因为在绝大多数情况下，问题是一次性的，不存在按这种方式决定先验分布的可能。因此，真正的贝叶斯派所持的立场是：先验分布的选取纯粹因为它是统计推断工作得以完成的一个必须的成分，不存在它与现实符合与否的“客观性”问题。客观贝叶斯学派源起于贝叶斯本人，后曾被拉普拉斯广泛使用，所以也有人把它称为拉普拉斯学派（相应地，主观贝叶斯学派有时被称为芬内迪—赛瓦奇学派）。其时公认的先验分布是根据“同等无知”原则而确定的均匀分布。后来的学者用稍广一些的“无信息先验分布”来取代它。费歇尔(Fisher)早就指出过这样确定先验分布的一个问题，即随着参数取法的不同会导致不同的先验分布。针对这一点杰弗里斯（ Sir Harold Jeffreys,）引进了一种选择先验分布的方法，可以避免这个困难，但仍不是能很令人满意。例如对二项分布$B(n,\theta）$的参数$\theta（0\leq\theta\leq1)$，按“同等无知”原则取先验密度 $p(\theta)＝1$ ，而按杰弗里斯（Sir Harold Jeffreys）的方法则应为 $p(\theta)＝(\theta(1-\theta))\cdot \frac{-1}{2} $。从实用的角度看，这个选择似乎不比$p(\theta)＝1$ 更有吸引力。有些学者认为，21世纪统计学的一个动向是<font color="blue">“频率学派与客观贝叶斯学派的合流”</font>。</p><p>而在这个进程中，有两个问题是主要的：<font color="blue">一是研究更合理的制定先验分布的准则。</font>这里“合理”的含义恐怕主要不是某种抽象的理论标准，而是看在这个体制下所作出的统计推断的合理性即在应用上的有效性。在此，已有的大批“经过考验的”成果会成为一个重要的参照标准。<font color="blue">另一个问题是在非参数模型之下，亦即<strong>在函数空间</strong>中如何确定先验分布。</font>早在20世纪70年代有人作过尝试，引进狄利克雷分布(Dirchlet Distribution)去定义非参数先验分布，后来也没有值得注意的进一步发展。这个问题无疑是一个富有挑战性的困难问题。</p><p>从广义的意义说，费歇尔(Fisher)在1930年提出的“信任推断”可纳入贝叶斯学派(Bayesian)的体系内。费歇尔(Fisher)一贯不赞成先验分布的提法，但却接受了贝叶斯学派的核心思想——由样本产生一个关于参数的分布，这在贝叶斯学派中称为后验分布。费歇尔(Fisher)提出“信任推断”的客观效果等同于一种不要先验分布的贝叶斯统计。由于一些内在的困难，几十年以来沿着这个方向没有取得多少进展，不少统计学家把费歇尔(Fisher)的主张看作他诸多成就之下的一个引人注目的失败。不过仍有少数学者，如费雷塞，坚持在这个领域工作。最近关于这个问题的兴趣有复活的趋势。有人甚至预言，费歇尔(Fisher)在20世纪提出的这个倍受冷落的概念，很可能在21世纪开花结果。</p><p>以上所论的是一些属于大的趋势方面的问题。至于更具体领域中可能的进展，也有学者讨论。如<font color="red">模型选择，基于似然函数和条件推断的结构；离散和非线性多元分析；不完全数据分析；（广义的）经验贝叶斯方法；定性、不回答和缺落数据的处理等。</font>因篇幅关系均不一一细论。</p><p>笔者总的看法是：虽则20世纪末统计学发展的态势确有某种与世纪初相似的地方，但仍有着根本的不同。这种不同表现在世纪初时数理统计学的学科框架尚未建立，而目前已在相对成熟阶段上走了相当一段距离。局部性的重要成就时有发生，而全局性的甚至根本改变本学科面貌的那种突破，在可预见的将来不大可能发生：“21世纪的费歇尔(Fisher)”产生的时机还未到来。</p>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数理统计 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化算法篇之梯度法</title>
      <link href="/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AF%87%E4%B9%8B%E6%A2%AF%E5%BA%A6%E6%B3%95.html"/>
      <content type="html"><![CDATA[<p>  我们在接触到具体的机器学习算法前，其实很有必要对优化问题进行一些了解。随着学习的深入，越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。</p><a id="more"></a><p>  最常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度方向法等。在大学课程中，数值分析是计算机或数学相关专业一门比较重要的一门课程，笔者也在大学时自学过相关课程，其介绍的诸多对理论的计算机实现方法，对现在的学习依然发挥着很大的作用。</p><p>当然优化算法只是数值分析课程中涉及一部分内容，这一节主要介绍和回顾梯度下降法</p><h2>梯度下降法</h2><p>  梯度下降法是最为常见的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。在一般情况下，其解不能保证是全局最优解，梯度下降法的速度也未必是最快的。</p><p>  假设$f(x)$是$R^n$上具有一阶连续偏导数的函数，需要求解的无约束最优化问题是：</p><p>$${min}_{x\in R^n}：\quad f(x)$$</p><p>  梯度下降法是一种迭代算法，选取适当的初值$x_0$,反复迭代，更新$x_{i}$的值，进行目标函数的极小化，直至收敛。<img src="http://img.my.csdn.net/uploads/201302/13/1360748597_8621.jpg" alt="梯度方向"></p><p>  由于我们都知道梯度方向$∇f(x)$是函数增长最快的方向，那么自然而然的想到负梯度方向就是函数值下降最快的方向了。因此，我们以负梯度方向作为极小化的下降方向，在迭代的每一步，以负梯度方向来更新$x$的值，从而达到减小函数值目的，这种方法就是梯度下降法。</p><p>  由于$f(x)$具有一阶连续偏导数，若第k次迭代值为$x_k$，则可将$f(x)$在$x_k$处进行一阶泰勒展开：$$f(x)=f(x^{(k)})+g_k^T(x−x^{(k)})$$这里，(方便推广，使用矩阵形式）$$g_k=g(x^{(k)})=∇f(x^{(k)})g_k=g(x^{(k)})=∇f(x^{(k)})$$为$f(x)$在$x_K$的梯度。第$K+1$次迭代值$x_{k+1}$：即$$x_{k+1}=x_{k}+λ_k*p_k$$其中，$p_k$是搜索方向，梯度法中$p_k=-∇f(x)$，取负梯度方向$p_k=−∇f(x^{(k)}),{\lambda_k}$是步长，有时候我们也叫学习率，这个值可以由一维搜索确定，目的在于得到最合适的步长，即${\lambda _k}$使得</p><p>$$Min:\quad \varphi(\lambda)=f(x^{(k)}+λ_kp^{(k)})$$</p><h3>算法过程：</h3><p>1）确定当前位置的损失函数的梯度，对于$(\theta_i)$,其梯度表达式如下：</p><p>$$(\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n))$$</p><p>2）用步长乘以损失函数的梯度，得到当前位置下降的距离，即$(\alpha\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n))$对应于前面登山例子中的某一步。</p><p>3）确定是否所有的$(\theta_i)$,梯度下降的距离都小于$\varepsilon$，如果小于$\varepsilon$则算法终止，当前所有的$\theta_i,(i=0,1,…n)$即为最终结果。否则进入步骤4.</p><p>4）更新所有的$\theta$，对于$\theta_i$，其更新表达式如下。更新完毕后继续转入步骤1.</p><p>$\theta_i = \theta_i – \alpha\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n)$</p><h3>举例</h3><p>下面用线性回归的例子来具体描述梯度下降。假设我们的样本是$(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_n)$,损失函数如前面先决条件所述：</p><p>$$f(\theta_0, \theta_1…, \theta_n) = \sum\limits_{i=0}^{m}(h_\theta(x_0, x_1, …x_n) – y_i)^2$$。</p><p>则在算法过程步骤1中对于$\theta_i$ 的偏导数计算如下：</p><p>$$\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n)= \frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) – y_j)x_i^{j}$$</p><p>由于样本中没有$x_0$上式中令所有的$x_0^{j}$为1.</p><p>步骤4中$\theta_i$的更新表达式如下：</p><p>$$\theta_i = \theta_i – \alpha\frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) – y_j)x_i^{j}$$</p><p>从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加$\frac{1}{m}$ 是为了好理解。由于步长也为常数，他们的乘机也为常数，所以这里$\alpha\frac{1}{m}$可以用一个常数表示。</p><p>梯度下降法的搜索迭代示意图如下图所示:<img src="http://images2015.cnblogs.com/blog/743682/201511/743682-20151108163643227-650396065.png" alt="梯度下降法的搜索迭代示意图如下图所示"></p><p>参考书籍：</p><blockquote><p>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</p></blockquote>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化算法篇之牛顿法</title>
      <link href="/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%9B%E9%A1%BF%E6%B3%95.html"/>
      <content type="html"><![CDATA[<p>  我们在接触具体的机器学习算法前，其实很有必要对优化问题进行一些介绍。随着学习的深入，笔者越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。</p><a id="more"></a><p>  最常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度方向法等。在大学课程中，数值分析是计算机或数学相关专业一门比较重要的一门课程，笔者也在大学时自学过相关课程，其介绍的诸多对理论的计算机实现方法，对现在的学习依然发挥着很大的作用。当然优化算法只是数值分析课程中涉及一部分内容，这一节主要介绍和回顾牛顿法。</p><h2>牛顿法</h2><p>  上节介绍的梯度下降法（最速下降法）只用到了目标函数的一阶导数，牛顿法是一种二阶优化算法，相对于梯度下降算法收敛速度更快。首先，选择一个接近函数$f(x)$零点的$x_0$，计算相应的$f(x_0)$ 和切线斜率$f ’ (x_0)$。然后我们计算穿过点$(x_0,  f(x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $X$轴的交点的$x$坐标，也就是求如下方程的解：$f(x_0)+f’(x_0)*(x-x_0)=0$我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x) = 0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示：</p><p>$$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$  牛顿法是基于当前位置的切线来确定下一次的位置，所以牛顿法又被很形象地称为是&quot;切线法&quot;。牛顿法的搜索路径（二维情况）如下图所示：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif?_=4751804" alt="newton"></p><h4>缺点</h4><p>牛顿法也有很大的缺点，就是每次计算都需要计算Hessian矩阵的逆，因此计算量较大。</p><h3>拟牛顿法</h3><p>  拟牛顿法在一定程度上解决了牛顿法计算量大的问题。其本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它<strong>使用正定矩阵来近似Hessian矩阵的逆</strong>，从而简化了运算的复杂度。（在多变量的情况下，如果目标矩阵的Hessain矩阵非正定，牛顿法确定的搜索方向并不一定是目标函数下降的方向）<br>  拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><h4>拟牛顿法的Matlab实现：</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#函数名：quasi_Newton(f,x0,error), </span><br><span class="line">#参数：f:待求梯度函数   x0:初始点   error：允许误差 </span><br><span class="line">#主程序： </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>=<span class="title">quasi_Newton</span><span class="params">(f,x0,error)</span> </span></span><br><span class="line">     [a,b]=<span class="built_in">size</span>(x0); </span><br><span class="line">     G0=<span class="built_in">eye</span>(b); </span><br><span class="line">     initial_gradient=gradient_my(f,x0,b); </span><br><span class="line">     norm0=<span class="number">0</span>; </span><br><span class="line">     norm0=initial_gradient*initial_gradient'; </span><br><span class="line">     syms step_zzh; </span><br><span class="line">     A=[x0]; </span><br><span class="line">     search_direction=-initial_gradient; </span><br><span class="line">     x=x0+step_zzh*search_direction; </span><br><span class="line">     f_step=subs(f,findsym(f),x); </span><br><span class="line">     best_step=golden_search(f_step,<span class="number">-15</span>,<span class="number">15</span>); </span><br><span class="line">     x_1=x0+best_step*search_direction; </span><br><span class="line">     A=[A;x_1]; </span><br><span class="line">     k=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> norm0&gt;error </span><br><span class="line">     ox=x_1-x0; </span><br><span class="line">     og=gradient_my(f,x_1,b)-initial_gradient; </span><br><span class="line">     G1=G0+(ox'*ox)/(ox*og')-(G0*og'*og*G0)/(og*G0*og'); </span><br><span class="line">     <span class="keyword">if</span>  k+<span class="number">1</span>==b </span><br><span class="line">         new_direction=-gradient_my(f,x_1,b); </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         new_direction=-(G1*(gradient_my(f,x_1,b))')'; </span><br><span class="line">     <span class="keyword">end</span> </span><br><span class="line">     x=x_1+step_zzh*new_direction; </span><br><span class="line">     f_step=subs(f,findsym(f),x); </span><br><span class="line">     best_step=golden_search(f_step,<span class="number">-15</span>,<span class="number">15</span>) </span><br><span class="line">     x_2=x_1+best_step*new_direction </span><br><span class="line">     A=[A;x_2]; </span><br><span class="line">     initial_gradient=gradient_my(f,x_1,b); </span><br><span class="line">     norm0=initial_gradient*initial_gradient'; </span><br><span class="line">     x0=x_1;x_1=x_2; </span><br><span class="line">     G0=G1; </span><br><span class="line">     k=k+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 数理统计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用AngularJS写框架</title>
      <link href="/%E7%94%A8AngularJS%E5%86%99%E6%A1%86%E6%9E%B6.html"/>
      <content type="html"><![CDATA[<h2>1. 模块的定义和加载</h2><h3>1.1 模块的定义</h3><a id="more"></a><p>  先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？</p><p>  我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。</p><p>  考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。</p><p>  JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？</p><p>  在很多传统高级语言里，变量作用域的边界是大括号，在{}里面定义的变量，作用域不会传到外面去，但我们的JavaScript大人不是这样的，他的边界是function。所以我们这段代码，i仍然能打出值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure><p>  那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。</p><p>  我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过： C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！” Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！” C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！</p><p>啊，我们发现了什么，既然无法避免全局的作用域，那与其让100个function都全局，不如只让一个来全局，其他的都由它管理。</p><p>本来我们打算自己当上帝的，现在只好改行先当个工商局长。你想开店吗？先来注册，不然封杀你！于是良民们纷纷来注册。店名叫什么，从哪进货，卖什么的，一一登记在案，为了方便下面的讨论，我们连进货的过程都让工商局管理起来。</p><p>店名，指的就是这里的模块名，从哪里进货，代表它依赖什么其他模块，卖什么，表示它对外提供一些什么特性。</p><p>好了，考虑到我们的这个注册管理机构是个全局作用域，我们还得把它挂在window上作为属性，然后再用一个function隔离出来，要不然，别人也定义一个同名的，就把我们覆盖掉了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//register a module</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这个module方法内部，应当怎么去实现呢？我们的module应当有一个地方存储，但存储是要在工商局内部的，不是随便什么人都可以看到的，所以，这个存储结构也放在工商局同样的作用域里。</p><p>用什么结构去存储呢？工商局备案的时候，店名不能跟已有的重复，所以我们发现这是用map的很好场景，考虑到JavaScript语言层面没有map，我们弄个Object来存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">window</span>.thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!moduleMap[name]) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    dependencies: dependencies,</span><br><span class="line">                    factory: factory</span><br><span class="line">                &#125;;</span><br><span class="line">                moduleMap[name] = <span class="built_in">module</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> moduleMap[name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在，模块的存储结构就搞好了。</p><h3>1.2 模块的使用</h3><p>  存的部分搞好了，我们来看看怎么取。现在来了一个商家，卖木器的，他需要从一个卖钉子的那边进货，卖钉子的已经来注册过了，现在要让这个木器厂能买到钉子。现在的问题是，两个商家处于不同的作用域，也就是说，它们互相不可见，那通过什么方式，我们才能让他们产生调用关系呢？</p><p>  个人解决不了的问题还是得靠政府，有困难要坚决克服，没有困难就制造困难来克服。现在困难有了，该克服了。商家说，我能不能给你我的进货名单，你帮我查一下它们在哪家店，然后告诉我？这么简单的要求当然一口答应下来，但是采用什么方式传递给你呢？这可犯难了。</p><p>我们参考AngularJS框架，写了一个类似的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"A"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module A</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"B"</span>, [<span class="string">"A"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module B</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看这段代码特别在哪里呢？模块A的定义，毫无特别之处，主要看模块B。它在依赖关系里写了一个字符串的A，然后在工厂方法的形参写了一个真真切切的A类型。嗯？这个有些奇怪啊，你的A类型要怎么传递过来呢？其实是很简单的，因为我们声明了依赖项的数组，所以可以从依赖项，挨个得到对应的工厂方法，然后创建实例，传进来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = moduleMap[name];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">module</span>.entity) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">module</span>.dependencies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (moduleMap[<span class="built_in">module</span>.dependencies[i]].entity) &#123;</span><br><span class="line">                args.push(moduleMap[<span class="built_in">module</span>.dependencies[i]].entity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                args.push(<span class="keyword">this</span>.use(<span class="built_in">module</span>.dependencies[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">module</span>.entity = <span class="built_in">module</span>.factory.apply(noop, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里面递归获取了依赖项，然后当作参数，用这个模块的工厂方法来实例化了一下。这里我们多做了一个判断，如果模块工厂已经执行过，就缓存在entity属性上，不需要每次都创建。以此类推，假如一个模块有多个依赖项，也可以用类似的方式写，毫无压力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"D"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A, B, C</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module D</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意了，D模块的工厂，实参的名称未必就要是跟依赖项一致，比如，以后我们代码较多，可以给依赖项和模块名称加命名空间，可能变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"foo.D"</span>, [<span class="string">"foo.A"</span>, <span class="string">"foo.B"</span>, <span class="string">"foo.C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A, B, C</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module D</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码仍然可以正常运行。我们来做另外一个测试，改变形参的顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"A"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"a"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"B"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"C"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"D"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">B, A, C</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> B + A + C;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> D = thin.use(<span class="string">"D"</span>);</span><br><span class="line">alert(D);</span><br></pre></td></tr></table></figure><p>试试看，我们的D打出什么结果呢？结果是&quot;abc&quot;，所以说，模块工厂的实参只跟依赖项的定义有关，跟形参的顺序无关。我们看到，在AngularJS里面，并非如此，实参的顺序是跟形参一致的，这是怎么做到的呢？</p><p>我们先离开代码，思考这么一个问题：如何得知函数的形参名数组？对，我们是可以用func.length得到形参个数，但无法得到每个形参的变量名，那怎么办呢？</p><p>AngularJS使用了一种比较极端的办法，分析了函数的字面量。众所周知，在JavaScript中，任何对象都隐含了toString方法，对于一个函数来说，它的toString就是自己的实现代码，包含函数签名和注释。下面我贴一下AngularJS里面的这部分代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FN_ARGS = <span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</span><br><span class="line"><span class="keyword">var</span> FN_ARG_SPLIT = <span class="regexp">/,/</span>;</span><br><span class="line"><span class="keyword">var</span> FN_ARG = <span class="regexp">/^\s*(_?)(\S+?)\1\s*$/</span>;</span><br><span class="line"><span class="keyword">var</span> STRIP_COMMENTS = <span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">annotate</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $inject,</span><br><span class="line">      fnText,</span><br><span class="line">      argDecl,</span><br><span class="line">      last;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn == <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!($inject = fn.$inject)) &#123;</span><br><span class="line">      $inject = [];</span><br><span class="line">      fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>);</span><br><span class="line">      argDecl = fnText.match(FN_ARGS);</span><br><span class="line">      forEach(argDecl[<span class="number">1</span>].split(FN_ARG_SPLIT), <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        arg.replace(FN_ARG, <span class="function"><span class="keyword">function</span>(<span class="params">all, underscore, name</span>)</span>&#123;</span><br><span class="line">          $inject.push(name);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      fn.$inject = $inject;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(fn)) &#123;</span><br><span class="line">    last = fn.length - <span class="number">1</span>;</span><br><span class="line">    assertArgFn(fn[last], <span class="string">'fn'</span>);</span><br><span class="line">    $inject = fn.slice(<span class="number">0</span>, last);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertArgFn(fn, <span class="string">'fn'</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $inject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个代码也不长，重点是类型为function的那段，首先去除了注释，然后获取了形参列表字符串，这段正则能获取到两个结果，第一个是全函数的实现，第二个才是真正的形参列表，取第二个出来split，就得到了形参的字符串列表了，然后按照这个顺序再去加载依赖模块，就可以让形参列表不对应于依赖项数组了。</p><p>AngularJS的这段代码很强大，但是要损耗一些性能，考虑到我们的框架首要原则是简单，甚至可以为此牺牲一些灵活性，我们不做这么复杂的事情了。</p><h3>1.3 模块的加载</h3><p>  到目前为止，我们可以把多个模块都定义在一个文件中，然后手动引入这个js文件，但是如果一个页面要引用很多个模块，引入工作就变得比较麻烦，比如说，单页应用程序（SPA）一般比较复杂，往往包含数以万计行数的js代码，这些代码至少分布在几十个甚至成百上千的模块中，如果我们也在主界面就加载它们，载入时间会非常难以接受。但我们可以这样看：主界面加载的时候，并不是用到了所有这些功能，能否先加载那些必须的，而把剩下的放在需要用的时候再去加载？</p><p>所以我们可以考虑<strong>万能的AJAX</strong>，从服务端获取一个js的内容，然后……，怎么办，你当然说不能eval了，因为据说eval很evil啦，但是它evil在哪里呢？主要是破坏全局作用域啦，怎么怎么，但是如果这些文件里面都是按照我们规定的模块格式写，好像也没有什么在全局作用域的……，好吧。</p><p>算了，我们还是用最简单的方式了，就是**动态创建script标签，然后设置src，添加到document.head里，然后监听它们的完成事件，做后续操作。**真的很简单，因为我们的框架不需要考虑那么多种情况，不需要AMD，不需要require那么麻烦，用这框架的人必须按照这里的原则写。</p><p>  所以，说真的我们这里没那么复杂啦，要是你们想看更详细原理的不如去看这个，解释得比我好哎：<a href="http://coolshell.cn/articles/9749.html#jtss-tsina" target="_blank" rel="noopener">JavaScript装载与执行</a></p><p>[补一段，@Franky 大神指出了这篇文章中一些不符合现状的地方，我把它也贴在这里，供读者参考]</p><blockquote><p>很多观点都是 史蒂夫那本老书上的观点. 和那时候同期产生的一些数据和资料…所以显得不少东西说的太想当然了… 譬如script标签的加载和执行会阻塞后面资源的加载和执行之类的.说的过于肯定了. 比如chrome7+就开始逐渐改进的 预加载机制 就分 head 里的资源, body里的资源 .两个资源是否跨界三种情形. 不提这些浏览器. 我们看看ie10也同样改进了 死循环10秒 这后面的图片能被提前加载. 就更不用说其他A级浏览器的丰富的优化策略了. 所以还是建议博主, 别拿几年前的老资料作为依据.尤其这些数据是用来说明更新速度像在赛跑一样的各个浏览器了.</p><p>关于 defer , 似乎史蒂夫的老书上是这么说的么? 显然没有测试全非ie浏览器的各个版本.或者是他测试数据的时候ff某大版本的几个beta子版本还没出现?</p><p>其次是就你的加载器提到的预加载策略. 你有测过所有浏览器用object预加载可能涉及到的问题么(比如chrome,8,9的预加载的会话级别的资源类型缓存bug). 抛开这个问题不谈,假设你预加载到一半,用户再次触发了加载.你觉得这种情况如果频繁发生.是否合适? 你的预加载策略连script.onload状态都无法测知,进一步优化的可能性就消失了. 考虑下为什么seajs 的 umd要设计成那个样子?</p><p>最后吐槽下你的代码. 有注意到你用 document.body.appendChild 来向DOM中插入脚本. 我的建议是 永远不要这样做.除非你可以无视ie6用户.以及ie7缺失某些补丁的子版本.</p><p>你可以选择body 可以.但请用insertBefore. 但在某些极端情况下.这仍然会发生问题. 最佳实践是 head.insertBefore 向其第一个子节点插入.(你甚至无需检测是否存在子节点. 这个api会在没有子节点的时候,行为同appendChild). 而更加稳妥的情况是. 如果注入script. 发现document.head还没有被构建时. 可以自己造一个. 这才是一个通用加载器要做到的程度…</p></blockquote><p>我也偷懒了，只是贴一下代码，顺便解释一下，界面把所依赖的js文件路径放在数组里，然后挨个创建script标签，src设置为路径，添加到head中，监听它们的完成事件。在这个完成时间里，我们要做这么一些事情：在fileMap里记录当前js文件的路径，防止以后重复加载，检查列表中所有文件，看看是否全部加载完了，如果全加载好了，就执行回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>: <span class="function"><span class="keyword">function</span> (<span class="params">pathArr, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> path = pathArr[i];</span><br><span class="line">        <span class="keyword">if</span> (!fileMap[path]) &#123;</span><br><span class="line">            <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">            node.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">            node.async = <span class="string">'true'</span>;</span><br><span class="line">            node.src = path + <span class="string">'.js'</span>;</span><br><span class="line">            node.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fileMap[path] = <span class="literal">true</span>;</span><br><span class="line">                head.removeChild(node);</span><br><span class="line">                checkAllFiles();</span><br><span class="line">            &#125;;</span><br><span class="line">            head.appendChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkAllFiles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allLoaded = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fileMap[pathArr[i]]) &#123;</span><br><span class="line">                allLoaded = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allLoaded) &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>1.4 小结</h3><p>到此为止，我们的简易框架的模块定义系统就完成了。完整的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fileMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!moduleMap[name]) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    dependencies: dependencies,</span><br><span class="line">                    factory: factory</span><br><span class="line">                &#125;;</span><br><span class="line">                moduleMap[name] = <span class="built_in">module</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> moduleMap[name];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        use: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">module</span> = moduleMap[name];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">module</span>.entity) &#123;</span><br><span class="line">                <span class="keyword">var</span> args = [];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">module</span>.dependencies.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (moduleMap[<span class="built_in">module</span>.dependencies[i]].entity) &#123;</span><br><span class="line">                        args.push(moduleMap[<span class="built_in">module</span>.dependencies[i]].entity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        args.push(<span class="keyword">this</span>.use(<span class="built_in">module</span>.dependencies[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">module</span>.entity = <span class="built_in">module</span>.factory.apply(noop, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.entity;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>: <span class="function"><span class="keyword">function</span> (<span class="params">pathArr, callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> path = pathArr[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!fileMap[path]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">                    node.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">                    node.async = <span class="string">'true'</span>;</span><br><span class="line">                    node.src = path + <span class="string">'.js'</span>;</span><br><span class="line">                    node.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        fileMap[path] = <span class="literal">true</span>;</span><br><span class="line">                        head.removeChild(node);</span><br><span class="line">                        checkAllFiles();</span><br><span class="line">                    &#125;;</span><br><span class="line">                    head.appendChild(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">checkAllFiles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> allLoaded = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fileMap[pathArr[i]]) &#123;</span><br><span class="line">                        allLoaded = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (allLoaded) &#123;</span><br><span class="line">                    callback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.thin = thin;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"constant.PI"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"shape.Circle"</span>, [<span class="string">"constant.PI"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">pi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Circle.prototype = &#123;</span><br><span class="line">        area : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pi * <span class="keyword">this</span>.r * <span class="keyword">this</span>.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"shape.Rectangle"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.l = l;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Rectangle.prototype = &#123;</span><br><span class="line">        area: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.l * <span class="keyword">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Rectangle;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"ShapeTypes"</span>, [<span class="string">"shape.Circle"</span>, <span class="string">"shape.Rectangle"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">Circle, Rectangle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        CIRCLE: Circle,</span><br><span class="line">        RECTANGLE: Rectangle</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"ShapeFactory"</span>, [<span class="string">"ShapeTypes"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">ShapeTypes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getShape: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> shape;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"CIRCLE"</span>: &#123;</span><br><span class="line">                    shape = <span class="keyword">new</span> ShapeTypes[type](<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"RECTANGLE"</span>:  &#123;</span><br><span class="line">                    shape = <span class="keyword">new</span> ShapeTypes[type](<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ShapeFactory = thin.use(<span class="string">"ShapeFactory"</span>);</span><br><span class="line">alert(ShapeFactory.getShape(<span class="string">"CIRCLE"</span>, <span class="number">5</span>).area());</span><br><span class="line">alert(ShapeFactory.getShape(<span class="string">"RECTANGLE"</span>, <span class="number">3</span>, <span class="number">4</span>).area());</span><br></pre></td></tr></table></figure><p>在这个例子里定义了四个模块，每个模块只需要定义自己所直接依赖的模块，其他的可以不必定义。也可以来这里看测试链接：<a href="http://xufei.github.io/thin/demo/demo.0.1.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/demo.0.1.html</a></p><h2>2. 数据绑定</h2><h3>2.1 数据绑定的原理</h3><p>数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。</p><p>在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。</p><p>先看数据到界面上的的绑定，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input vm-value=&quot;name&quot;/&gt;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Tom&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们给name重新赋值，<a href="http://person.name" target="_blank" rel="noopener">person.name</a> = “Jerry”，怎么才能让界面得到变更？</p><p>从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = newName;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    gender: <span class="number">5</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>[key] = value;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者合并两个方法，只判断是否传了参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<a href="http://xn--person-op0jjj079gsvv8ray18m049c.name" target="_blank" rel="noopener">赋值的时候就是person.name</a>(“Tom”)，取值的时候就是var name = <a href="http://person.name" target="_blank" rel="noopener">person.name</a>()了。</p><p>有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。</p><p>在C#等一些语言里，有一种东西叫做存取器，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private string name;</span><br><span class="line"></span><br><span class="line">    public string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候，<a href="http://person.Name" target="_blank" rel="noopener">person.Name</a> = “Jerry”，就会调用到set里，相当于是个方法。</p><p>这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an accessor property to the object.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = value;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>赋值的时候，<a href="http://person.name" target="_blank" rel="noopener">person.name</a> = “Tom”，取值的时候，var name = <a href="http://person.name" target="_blank" rel="noopener">person.name</a>，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。</p><p>现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。</p><p>再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。</p><h3>2.2 数据绑定的实现</h3><p>我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseElement</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.attributes.length; i++) &#123;</span><br><span class="line">        parseAttribute(element.attributes[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.children.length; i++) &#123;</span><br><span class="line">        parseElement(element.children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？</p><p>我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。</p><p>因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.define(<span class="string">"Person"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Tom"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype = &#123;</span><br><span class="line">        growUp: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>模型方面都准备好了，现在来看界面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。</p><p>好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？</p><p>当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseElement</span>(<span class="params">element, vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> model = vm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.getAttribute(<span class="string">"vm-model"</span>)) &#123;</span><br><span class="line">        model = bindModel(element.getAttribute(<span class="string">"vm-model"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.attributes.length; i++) &#123;</span><br><span class="line">        parseAttribute(element, element.attributes[i], model);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.children.length; i++) &#123;</span><br><span class="line">        parseElement(element.children[i], model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindModel</span>(<span class="params">modelName</span>) </span>&#123;</span><br><span class="line">    thin.log(<span class="string">"model"</span> + modelName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> model = thin.use(modelName, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> model();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的：</p><ul><li>init，用于绑定初始化方法</li><li>click，用于绑定点击</li><li>value，绑定变量</li><li>enable和disable，绑定可用状态</li><li>visible和invisible，绑定可见状态</li></ul><p>然后就可以实现我们parseAttribute函数了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseAttribute</span>(<span class="params">element, attr, model</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (attr.name.indexOf(<span class="string">"vm-"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> type = attr.name.slice(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"init"</span>:</span><br><span class="line">                bindInit(element, attr.value, model);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"value"</span>:</span><br><span class="line">                bindValue(element, attr.value, model);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">                bindClick(element, attr.value, model);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"enable"</span>:</span><br><span class="line">                bindEnable(element, attr.value, model, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"disable"</span>:</span><br><span class="line">                bindEnable(element, attr.value, model, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"visible"</span>:</span><br><span class="line">                bindVisible(element, attr.value, model, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"invisible"</span>:</span><br><span class="line">                bindVisible(element, attr.value, model, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"element"</span>:</span><br><span class="line">                model[attr.value] = element;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。</p><p>这么多绑定，不打算都讲，用bindValue函数来说明一下吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindValue</span>(<span class="params">element, key, vm</span>) </span>&#123;</span><br><span class="line">    thin.log(<span class="string">"binding value: "</span> + key);</span><br><span class="line"></span><br><span class="line">    vm.$watch(key, <span class="function"><span class="keyword">function</span> (<span class="params">value, oldValue</span>) </span>&#123;</span><br><span class="line">        element.value = value || <span class="string">""</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    element.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm[key] = element.value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    element.onpaste = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm[key] = element.value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。</p><p>在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。</p><p>接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。</p><p>然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Binder = &#123;</span><br><span class="line">    $watch: <span class="function"><span class="keyword">function</span> (<span class="params">key, watcher</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.$watchers[key]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$watchers[key] = &#123;</span><br><span class="line">                value: <span class="keyword">this</span>[key],</span><br><span class="line">                list: []</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> oldValue = <span class="keyword">this</span>.$watchers[key].value;</span><br><span class="line">                    <span class="keyword">this</span>.$watchers[key].value = val;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$watchers[key].list.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.$watchers[key].list[i](val, oldValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.$watchers[key].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.$watchers[key].list.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindModel</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    thin.log(<span class="string">"binding model: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> model = thin.use(name, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> model().extend(Binder);</span><br><span class="line">    instance.$watchers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？</p><p>先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。</p><p>同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。</p><p>嗯，我们是不是可以试一下了？来写个代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Simple binding demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"binding"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"xu.fei@outlook.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../js/thin.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"test.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"test.Person"</span> <span class="attr">vm-init</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    thin.define(<span class="string">"test.Person"</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.name = <span class="string">"Tom"</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.age = <span class="number">5</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        Person.prototype = &#123;</span></span><br><span class="line"><span class="javascript">            init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.name = <span class="string">"Jerry"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.age = <span class="number">3</span>;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            growUp: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.age++;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> Person;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者访问这里：<a href="http://xufei.github.io/thin/demo/simple-binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/simple-binding.html</a></p><p>以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。</p><p>我们还有一个更实际一点的例子，结合了另外一个系列里面写的简单DataGrid控件，做了一个很基础的人员管理界面：<a href="http://xufei.github.io/thin/demo/binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/binding.html</a></p><h3>2.3 小结</h3><p>到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。</p><p>注意Object.defineProperty仅在Chrome等浏览器中可用，IE需要9以上才比较正常。在司徒正美的avalon框架中，巧妙使用VBScript绕过这一限制，利用vbs的property和两种语言的互通，实现了低版本IE的兼容。我们这个框架的目标不是兼容，而是为了说明原理，所以感兴趣的朋友可以去看看avalon的源码。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解异步</title>
      <link href="/%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5.html"/>
      <content type="html"><![CDATA[<p>JavaScript编程几乎总是伴随着异步操作，传统的异步操作会在操作完成之后，使用回调函数传回结果，而回调函数中则包含了后续的工作。这也是造成异步编程困难的主要原因：</p><a id="more"></a><h2>前述</h2><p><strong>我们一直习惯于“线性”地编写代码逻辑，但是大量异步操作所带来的回调函数，会把我们的算法分解地支离破碎。</strong></p><p>此时我们不能用if来实现逻辑分支，也不能用while/for/do来实现循环，更不用说异步操作之间的组合、错误处理以及取消操作了。因此也就诞生了如jQuery Deferred这样的辅助类库。</p><p>我们常见的异步操作：</p><ul><li>定时器setTimeout</li><li>postmessage</li><li>WebWorkor</li><li>CSS3 动画</li><li>XMLHttpRequest</li><li>HTML5的本地数据</li><li>…</li></ul><p>JavaScript要求在与服务器进行交互时要用异步通信，如同AJAX一样。因为是异步模型，所以在调用Transaction游览器提供的本地数据接口时候类似AJAX（这里我是假设），浏览器自己有内部的XHR方法异步处理，但是此时的JS代码还是会同步往下执行，其实就是无阻塞的代码。</p><p>**问题：**因为无阻塞，代码在发送AJAX这个请求后会继续执行，那么后续的操作如果依赖这个数据的就会出错了，所以这里就需要等待AJAX返回，才能执行后续操作。</p><p>因为异步而导致流程不正确，或者说我们的应用在某个程度上依赖第三方API的数据，那么就会面临一个共同的问题：</p><p>我们无法获悉一个API响应的延迟时间，应用程序的其他部分可能会被阻塞，直到它返回结果。Deferreds 的引入对这个问题提供了一个更好的解决方案，它是非阻塞的，并且与代码完全解耦。</p><p>当然异步操作也可以提供一个类似于成功回调，失败回调的通知接口。</p><p>JS是单线程语言，就简单性而言，把每一件事情（包括GUI事件和渲染）都放在一个线程里来处理是一个很好的程序模型，因为这样就无需再考虑线程同步这些复杂问题。</p><p>另一方面，他也暴露了应用开发中的一个严重问题，单线程环境看起来对用户请求响应迅速，但是当线程忙于处理其它事情时，就不能对用户的鼠标点击和键盘操作做出响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器改变流程</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    show(<span class="number">2</span>)&#125;, <span class="number">0</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行异步动画</span></span><br><span class="line"><span class="comment">//因为代码的执行是按照从上至下</span></span><br><span class="line"><span class="comment">//但是由于加入了动画，动画形成了异步，所以实际的改变值必须等动画完成才能得到</span></span><br><span class="line"><span class="comment">//但是同步逻辑3其实已经运行，所以3要等待2结束才可以</span></span><br><span class="line">$(<span class="string">"#go"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> block = $(<span class="string">"#block"</span>);</span><br><span class="line">show(<span class="string">'1.动画流程代码开始,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">block.animate(&#123;</span><br><span class="line">width       : <span class="string">"70%"</span>,</span><br><span class="line">opacity     : <span class="number">0.4</span>,</span><br><span class="line">marginLeft  : <span class="string">"0.6in"</span>,</span><br><span class="line">fontSize    : <span class="string">"3em"</span>,</span><br><span class="line">borderWidth : <span class="string">"10px"</span>,</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">show(<span class="string">'2.动画执行结束束,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">show(<span class="string">'3.动画流程代码结束,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">$(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Deferred</h2><h3>Deferred是什么</h3><p>前端项目的开发，不仅仅涉及到同步的概念，而且还会经常穿插各种异步的处理。一些大的操作，比如远程获取数据，操作一个大数据处理，这时候是不能马上获取到数据的。假设我们发送一个AJAX请求到接受到数据需要10秒钟，那么从发送到接受数据这个时间段中，前端的处理时间其实是空闲，但是对于开发者来说这种时间是不能浪费了，所以我们可以在10秒钟做很多同步的处理，同时等待异步的数据返回。所以我们需要监听这个回调的数据在成功的时候能够获取到，或者设计一个返回后触发处理的机制，当然原生的JavaScript对这个机制几乎是没有的。为了优化这个形成统一的异步处理方案，jQuery就开始设计了一个Deferred异步模型。</p><p>Deferred 提供了一个抽象的非阻塞的解决方案（如异步请求的响应），它创建一个promise对象，其目的是在未来某个时间点返回一个响应。简单来说就是一个异步/同步回调函数的处理方案。</p><p><code>$.Deferred</code>在jQuery代码内部有四个模块被使用，分别是“<strong>promise方法”、“DOM ready”、“Ajax模块”及“动画模块</strong>”。</p><p>看看jQuery中的最常用的AJAX处理：</p><p><strong>一：Ajax的改造</strong></p><p>传统的jQuery的AJAX操作的传统写法(1.5版之前)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"aaron.html"</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="string">"成功！"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"失败！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。</p><p>在1.5版本后通过新的Deferred引入就改成了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">"aaron.html"</span>)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"成功"</span>); &#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"出错"</span>); &#125;);</span><br></pre></td></tr></table></figure><p>把传参的回调，换成了链式的写法，这样可读性更高了。在jquery 1.5版后，通过$.ajax返回的不是XHR对象了，而是经过包装的Deferred对象，所以就具有promise的一些规范。当然这种写法到底是怎么做的，我们在后续的教程中会详细的讲解到。</p><p><strong>二：提供一种方法来执行一个或多个对象的回调函数</strong></p><p>在实际开发中，我们可能要发送多个异步的请求操作，我们需要等所有的异步都处理完毕后，才能继续下一个动作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aaron1"</span>&gt;</span>运行案例一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aaron2"</span>&gt;</span>运行案例二<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//提供一种方法来执行一个或多个对象的回调函数</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//在实际开发中，我们可能要发送多个异步的请求操作，我们需要等所有的异步都处理完毕后，才能继续下一个动作</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//案例一</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task1</span>(<span class="params">name, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    fn(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 500)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task2</span>(<span class="params">name, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    fn(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 1000)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//任务数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> taskNuns = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> num = <span class="number">2</span>; <span class="comment">//2个任务</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">      show(<span class="string">'任务都完成了'</span>,$(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    num--;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#aaron1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//常规处理</span></span></span><br><span class="line"><span class="javascript">  task1(<span class="string">'任务一'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task1'</span>, $(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    taskNuns()</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  task2(<span class="string">'任务二'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task2'</span>, $(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    taskNuns();</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="comment">//========================分割线============================================</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//案例二</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//通过Deferred改进</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task3</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred();</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task3执行完毕'</span>,$(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">    dtd.resolve(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 500)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> dtd;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task4</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred();</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task4执行完毕'</span>,$(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">    dtd.resolve(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 1000)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> dtd;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#aaron2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  $.when(task3(<span class="string">'task1'</span>), task4(<span class="string">'task2'</span>)).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'when处理成功'</span>, $(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data, ele</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  (ele || $(<span class="string">"body"</span>)).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们这里要涉及一个等待的处理。我们自己要做一个计时器，每一个任务执行完毕后，都要触发一次任务的检测。当最后一个调用完毕了，我们就可以执行后面的动作，当前这里的写法也会有些问题，比如错误的时候没有处理。同样的功能，我们换成Deferred就会很简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when($.ajax(&quot;a1.html&quot;), $.ajax(&quot;a2.html&quot;))</span><br><span class="line">　　.done(function()&#123; alert(&apos;2次回调都正确返回了&apos;) &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&apos;出错了&apos;); &#125;);</span><br></pre></td></tr></table></figure><p>这段代码的意思是：先执行两个操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&quot;a1.html&quot;)</span><br><span class="line">$.ajax(&quot;a2.html&quot;)</span><br></pre></td></tr></table></figure><p>如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p><p><strong>三：可以混入任意的对象接口中</strong></p><p>jQuery的Deferred最好用的地方，就是模块化程度非常高，可以任意配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function task(name) &#123;</span><br><span class="line">  var dtd = $.Deferred();</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    dtd.resolve(name)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">  return dtd;</span><br><span class="line">&#125;</span><br><span class="line">$.when(task(&apos;任务一&apos;), task(&apos;任务二&apos;)).done(function() &#123;</span><br><span class="line">  alert(&apos;成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>把需要处理的异步操作，用Deferred对象给包装一下，然后通过when方法收集异步的操作，最后再返回出done的成功，这样的处理太赞了！</p><p>所以说，Deferred的引入，为处理事件回调提供了更加强大并且更灵活的编程模型。</p><h3>认识$.Deferred的接口</h3><p>大多情况下，promise作为一个模型，提供了一个在软件工程中描述延时（或将来）概念的解决方案。它背后的思想我们已经介绍过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是执行一个方法，然后阻塞应用程序等待结果返回，而是返回一个promise对象来满足未来值。</span><br></pre></td></tr></table></figure><p>这样看来，Promise/A只是一种规范，Deferred可以看作这种规范的具体实现，旨在提供通用的接口，用来简化异步编程难度，说白了就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个可链式操作的对象，提供多个回调函数的注册，以及回调列队的回调，并转达任何异步操作成功或失败的消息。</span><br></pre></td></tr></table></figure><p>jQuery.Deferred()背后的设计理念来自 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">CommonJS Promises/A</a> , <code>jQuery.Deferred()</code>基于这个理念实现，但并没有完全遵循其设计， 它代表了一种可能会长时间运行而且不一定必须完整的操作的结果，简单的描述下规范中定义的“Promise”。</p><p>promise模式在任何时刻都处于以下三种状态之一：</p><ul><li>未完成（unfulfilled）</li><li>已完成（resolved）</li><li>拒绝（rejected）</li></ul><p>CommonJS Promise/A 标准这样定义的，promise对象上的then方法负责添加针对已完成和拒绝状态下的处理函数。then方法会返回另一个promise对象，这样可以形成“管道”风格。</p><p>看看jQuery的Deferred源码中对动作接口的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],</span><br><span class="line">[ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],</span><br><span class="line">[ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]</span><br></pre></td></tr></table></figure><p>Deferred中定义的动作是非常多的，抽象的看其实可以类似一种观察者模式的实现。</p><p>观察者模式中的订阅方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Done (操作完成)</span><br><span class="line">Fail (操作失败)</span><br><span class="line">Progress (操作进行中</span><br></pre></td></tr></table></figure><p>观察中模式中的发布方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve（解决）</span><br><span class="line">reject（拒绝）</span><br><span class="line">notify（通知）</span><br></pre></td></tr></table></figure><p>而且还提供了可以定义运行时的this对象的fire，fireWith，所以扩展了3个可以定义上下文的的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveWith</span><br><span class="line">rejectWith</span><br><span class="line">notifyWith</span><br></pre></td></tr></table></figure><p>所以按照这样的规范，我们的使用就应该是这样：见代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="aaron1"&gt;例一:基本用法&lt;/</span>button&gt;</span><br><span class="line">&lt;button id=<span class="string">"aaron2"</span>&gt;例二:过滤器&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="aaron3"&gt;例三:promise方法&lt;/</span>button&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例一</span></span><br><span class="line">$(<span class="string">"#aaron1"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构建一个deferred对象</span></span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred();</span><br><span class="line">  <span class="comment">// 给deferred注册一个成功后的回调通知</span></span><br><span class="line">  dtd.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    show(<span class="string">'成功'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 开始执行一段代码</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dtd.resolve(); <span class="comment">// 改变deferred对象的执行状态</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例二：过滤器</span></span><br><span class="line"><span class="keyword">var</span> filterResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defer = $.Deferred(),</span><br><span class="line">    filtered = defer.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  defer.resolve(<span class="number">5</span>);</span><br><span class="line">  filtered.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    show(<span class="string">"Value is ( 2*5 = ) 10: "</span> + value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="string">"#aaron2"</span>).on(<span class="string">"click"</span>, filterResolve)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例三：实现promise方法</span></span><br><span class="line">$(<span class="string">"#aaron3"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      show(<span class="string">"你好 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    defer = $.Deferred();</span><br><span class="line">  <span class="comment">// 设置一个promise</span></span><br><span class="line">  defer.promise(obj);</span><br><span class="line">  <span class="comment">//解决一个deferred</span></span><br><span class="line">  defer.resolve(<span class="string">"慕课网"</span>);</span><br><span class="line">  obj.done(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    obj.hello(name);</span><br><span class="line">  &#125;).hello(<span class="string">"Aaron"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3>$.Deferred的设计</h3><p>由于1.7版本后<code>$.Callbacks从Deferred</code>中抽离出去了，目前版本的Deferred.js代码不过150行，而真正$.Deferred的实现只有100行左右，实现的逻辑是相当犀利的。</p><p>因为Callback被剥离出去后，整个Deferred就显得非常的精简，代码直接通过extend扩展到静态接口上，对于extend的继承这个东东，在之前就提及过jQuery如何处理内部jQuery与<code>init</code>相互引用<code>this</code>的问题，所以当<code>jQuery.extend</code>只有一个参数的时候，其实就是对jQuery静态方法的一个扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">   Deferred:function(func)&#123;</span><br><span class="line">        ...省略代码....</span><br><span class="line">        return deferred</span><br><span class="line">   &#125;,</span><br><span class="line">   when:function(func)&#123;</span><br><span class="line">      ...省略代码....</span><br><span class="line">      return deferred.promise();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们来具体看看2个静态方法内部都干了些什么?</p><p>Deferred整体结构：右边代码所示。</p><p>Deferred就是一个简单的工厂方法，有两种方式使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $.Deferred（）</span><br><span class="line">$.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>内部其实是严重依赖$.Callbacks对象，Callbacks就是用来储存deferred依赖的数据的。</p><p>因为done、fail、progress就是jQuery.Callbacks(“once memory”)所有对应的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = jQuery.Callbacks(<span class="string">"once memory"</span>)</span><br><span class="line">promise[<span class="string">'done'</span>] = list.add;</span><br></pre></td></tr></table></figure><p>deferred定义了一系列的接口，堪称一绝，100多行的代码，精练的有些过分。</p><p>Deferred方法内部建议了2个对象，一个是deferred外部接口对象，一个是内部promise对象。</p><p>promise对象解释是一个受限的对象, 这就是所谓的受限制的deferred对象，因为相比之前， 返回的deferred不再拥有resolve(With), reject(With), notify(With)这些能改变deferred对象状态并且执行callbacklist的方法了,只能是then、done、fali等方法。</p><p>其内部通过tuples数组，存储了所有的接口API，通过遍历把所有的接口一次都挂到内部promise与deferred对象上。</p><p>其中定义了done、fail以及progress这几个方法，其实就是Callbacks回调函数中的add方法，用与push外部的的数据，保存在队列上。</p><p>我们通过resolve、reject以及notify其实也就是处理Callbacks中的队列列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// jQuery. Deferred主要处理：</span></span><br><span class="line"><span class="string">//     显而易见Deferred是个工厂类，返回的是内部构建的deferred对象</span></span><br><span class="line"><span class="string">//     tuples 创建三个$.Callbacks对象，分别表示成功，失败，处理中三种状态</span></span><br><span class="line"><span class="string">//     创建了一个promise对象，具有state、always、then、primise方法</span></span><br><span class="line"><span class="string">//     扩展primise对象生成最终的Deferred对象，返回该对象</span></span><br><span class="line"><span class="string">//     primise对象就是一个受限对象，只读</span></span><br><span class="line"><span class="string">var Deferred = function(func) &#123;</span></span><br><span class="line"><span class="string">  var tuples = [</span></span><br><span class="line"><span class="string">    //1 动作</span></span><br><span class="line"><span class="string">    //2 侦听器</span></span><br><span class="line"><span class="string">    //3 最终状态</span></span><br><span class="line"><span class="string">    //后面的操作将是围绕这些接口处理</span></span><br><span class="line"><span class="string">    ["</span>resolve<span class="string">", "</span>done<span class="string">", jQuery.Callbacks("</span>once memory<span class="string">"), "</span>resolved<span class="string">"],</span></span><br><span class="line"><span class="string">    ["</span>reject<span class="string">", "</span>fail<span class="string">", jQuery.Callbacks("</span>once memory<span class="string">"), "</span>rejected<span class="string">"],</span></span><br><span class="line"><span class="string">    ["</span>notify<span class="string">", "</span>progress<span class="string">", jQuery.Callbacks("</span>memory<span class="string">")]</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  state = "</span>pending<span class="string">",</span></span><br><span class="line"><span class="string">  //扩展的primise对象</span></span><br><span class="line"><span class="string">  promise = &#123;</span></span><br><span class="line"><span class="string">    state: function() &#123;&#125;,</span></span><br><span class="line"><span class="string">    always: function() &#123;&#125;,</span></span><br><span class="line"><span class="string">    then: function( /* fnDone, fnFail, fnProgress */ ) &#123;&#125;,</span></span><br><span class="line"><span class="string">    promise: function(obj) &#123;&#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  deferred = &#123;&#125;;</span></span><br><span class="line"><span class="string">  //定义管道风格的接口pipe</span></span><br><span class="line"><span class="string">  promise.pipe = promise.then;</span></span><br><span class="line"><span class="string">  //逐个添加所有的接口到deferred对象上</span></span><br><span class="line"><span class="string">  jQuery.each(tuples, function(i, tuple) &#123;</span></span><br><span class="line"><span class="string">    deferred[tuple[0]] = function() &#123;</span></span><br><span class="line"><span class="string">      deferred[tuple[0] + "</span>With<span class="string">"](this === deferred ? promise : this, arguments);</span></span><br><span class="line"><span class="string">      return this;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    deferred[tuple[0] + "</span>With<span class="string">"] = list.fireWith;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">  //转成成promise对象</span></span><br><span class="line"><span class="string">  promise.promise(deferred);</span></span><br><span class="line"><span class="string">  //如果传递的参数是函数，直接运行</span></span><br><span class="line"><span class="string">  if (func) &#123;</span></span><br><span class="line"><span class="string">    func.call(deferred, deferred);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return deferred;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//when就是一个合集的处理</span></span><br><span class="line"><span class="string">//可以收集多个异步操作，合并成功后处理</span></span><br><span class="line"><span class="string">//同时也可以绑定Promise 对象的其它方法，如 defered.then</span></span><br><span class="line"><span class="string">//所以when内部必须要创建一个deferred对象</span></span><br><span class="line"><span class="string">var when = function(subordinate /* , ..., subordinateN */ ) &#123;</span></span><br><span class="line"><span class="string">  var i = 0,</span></span><br><span class="line"><span class="string">    resolveValues = slice.call(arguments),</span></span><br><span class="line"><span class="string">    length = resolveValues.length,</span></span><br><span class="line"><span class="string">    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</span></span><br><span class="line"><span class="string">    updateFunc = function(i, contexts, values) &#123;</span></span><br><span class="line"><span class="string">      return function(value) &#123;&#125;;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    progressValues, progressContexts, resolveContexts;</span></span><br><span class="line"><span class="string">  if (length &gt; 1) &#123;</span></span><br><span class="line"><span class="string">    progressValues = new Array(length);</span></span><br><span class="line"><span class="string">    progressContexts = new Array(length);</span></span><br><span class="line"><span class="string">    resolveContexts = new Array(length);</span></span><br><span class="line"><span class="string">    for (; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="string">      if (resolveValues[i] &amp;&amp; jQuery.isFunction(resolveValues[i].promise)) &#123;</span></span><br><span class="line"><span class="string">        resolveValues[i].promise()</span></span><br><span class="line"><span class="string">          .done(updateFunc(i, resolveContexts, resolveValues))</span></span><br><span class="line"><span class="string">          .fail(deferred.reject)</span></span><br><span class="line"><span class="string">          .progress(updateFunc(i, progressContexts, progressValues));</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        --remaining;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return deferred.promise();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h2>Deferred的执行流程</h2><p>用下面的例子分析（见右侧代码编辑器）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defer = $.Deferred();</span><br><span class="line">defer.resolve(<span class="number">5</span>);</span><br><span class="line">defer.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> filtered = defer.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">filtered.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这里有几个关键的问题：</p><p>1、defer延时对象通过resolved触发done成功回调，调用在添加done之前，那么靠什么延时处理？</p><p>2、为什么defer.then对象返回的给filtered.done的数据可以类似管道风格的顺序叠加给后面的done处理？</p><p>一般来说，javascript要实现异步的收集，就需要“等待”，比如defer.resolve(5)虽然触发了，但是done的处理还没添加，我们必须要等待done、then等方法先添加了后才能执行了resolve，那么常规的的用法就是在resolve内部用setTimeout 0，image.onerror行成一个异步的等待操作处理。</p><p>但是jQuery很巧妙的绕过了这个收集方式，</p><p>defer.resolve(5)方法实际就是触发了callback回到函数的fireWith方法，这样可以接受一个上下文deferred与参数5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments);</span><br></pre></td></tr></table></figure><p>之前 done | fail | progress方法都是通过jQuery.Callbacks(“once memory”) 或 jQuery.Callbacks(“memory”)生成的。</p><p>实际上在Callback源码fire方法有一句 memory = options.memory &amp;&amp; data;这样就很巧妙的缓存当前参数5的值，提供给下一个使用，这个就是then，pipe链式数据的一个基础了，此刻的操作，我们把memory保存了这个数据的值。</p><p>重点来了，下一个defer.done的操作也是走的add的处理，把done的回调函数加入到list队列中的之后，接着就会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// With memory, if we're not firing then</span></span><br><span class="line"> <span class="comment">// we should call right away</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (memory) &#123;</span><br><span class="line">  firingStart = start;</span><br><span class="line">  fire(memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为memory在上一个resolve操作的时候，缓存了5了，所以memory的判断显示是为真的，所以立刻就触发了fire(memory)的代码了，所以就算触发的循序与添加的循序不一致，也不会导致错误。 而且jquery很巧妙的避免了异步收集的问题，这样处理更可靠了。可见回调函数模块就是为Deferred模块量身定做的了。</p><p>第二个问题，是关于then，pipe管道风格的处理，这样也是一个很复杂的设计，在后面一章就提到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defer = $.Deferred();</span><br><span class="line">  <span class="comment">//先执行成功</span></span><br><span class="line">  defer.resolve(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">//后添加</span></span><br><span class="line">  defer.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">"&lt;li&gt;defer.done的值是："</span> + value + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//实现一个管道方法</span></span><br><span class="line">  <span class="keyword">var</span> filtered = defer.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//接受上一个值，叠加处理</span></span><br><span class="line">  filtered.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">"&lt;li&gt;filtered.done ( 2*5 = ) 10: "</span> + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="string">"button"</span>).on(<span class="string">"click"</span>, filterResolve);</span><br></pre></td></tr></table></figure><h2>Deferred源码剖析(上)</h2><p>Deferred对接口的设计别出心裁，不是常规的直接定义的，我们可以看tuples这个数组的定义。</p><p><strong>Deferred</strong><strong>自身则围绕这三组数据进行更高层次的抽象</strong></p><ul><li>触发回调函数列表执行(函数名)</li><li>添加回调函数（函数名）</li><li>回调函数列表（jQuery.Callbacks对象）</li><li>Deferred最终状态（第三组数据除外）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuples = [</span><br><span class="line">  <span class="comment">// action, add listener, listener list, final state</span></span><br><span class="line">  [<span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span>],</span><br><span class="line">  [<span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span>],</span><br><span class="line">  [<span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里抽象出2组阵营：</p><p><strong>1组：回调方法/事件订阅</strong></p><p><code>done、fail、progress</code></p><p><strong>2组：通知方法/事件发布</strong><code>resolve、reject、notify、resolveWith、rejectWith、notifyWith</code></p><p>Tuples元素集，其实是把相同有共同特性的代码的给合并成一种结构，然后来一次处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//代码请看右边代码区域</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于Tuples的3条数据集是分2部分处理的：</p><p><strong>第一部分将回调函数存入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise[ tuple[<span class="number">1</span>] ] = list.add;</span><br></pre></td></tr></table></figure><p>其实就是给promise赋予3个回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.done = $.Callbacks(<span class="string">"once memory"</span>).add</span><br><span class="line">promise.fail = $.Callbacks(<span class="string">"once memory"</span>).add</span><br><span class="line">promise.progressl = $.Callbacks(<span class="string">"memory"</span>).add</span><br></pre></td></tr></table></figure><p>如果存在Deferred最终状态，默认会预先向doneList，failList中的list添加三个回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stateString) &#123;</span><br><span class="line">  list.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    state = stateString;</span><br><span class="line">  &#125;, tuples[i ^ <span class="number">1</span>][<span class="number">2</span>].disable, tuples[<span class="number">2</span>][<span class="number">2</span>].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个小技巧：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">按位异或运算符</a></p><p>所以实际上第二个传参数是1、0索引对调了，所以取值是failList.disable与doneList.disable。</p><p><strong>通过stateString有值这个条件，预先向doneList,failList中的list添加三个回调函数，分别是:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doneList : [changeState, failList.disable, processList.lock]</span><br><span class="line">failList : [changeState, doneList.disable, processList.lock]</span><br></pre></td></tr></table></figure><p>changeState 改变状态的匿名函数，deferred的状态，分为三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)；不论deferred对象最终是resolve（还是reject），在首先改变对象状态之后，都会disable另一个函数列表failList(或者doneList)；然后lock processList保持其状态，最后执行剩下的之前done（或者fail）进来的回调函数。</p><p>所以第一步最终都是围绕这add方法：</p><ul><li>done/fail/是list.add也就是<a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#add" target="_blank" rel="noopener">callbacks.add</a>，将回调函数存入回调对象中。</li></ul><p><strong>第二部分很简单，给Deferred对象扩充6个方法：</strong></p><ul><li><p>resolve/reject/notify 是 <a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith" target="_blank" rel="noopener">callbacks.fireWith</a>，执行回调函数；</p></li><li><p>resolveWith/rejectWith/notifyWith 是 <a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith" target="_blank" rel="noopener">callbacks.fireWith</a> 队列方法引用。</p></li></ul><p>最后合并promise到Deferred。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">promise.promise( deferred );</span><br><span class="line">jQuery.extend( obj, promise );</span><br></pre></td></tr></table></figure><p>所以最终通过工厂方法Deferred构建的异步对象带的所有的方法了，return内部的deferred对象了。</p><h3>测试Deferred代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button&gt;测试Deferred&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//内部deferred对象</span></span><br><span class="line">      <span class="keyword">var</span> deferred = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//定义的基本接口</span></span><br><span class="line">      <span class="comment">//Callbacks(once memory)的用法，就是只执行一次，并且保持以前的值</span></span><br><span class="line">      <span class="comment">// 每个元组分别包含一些与当前deferred相关的信息: </span></span><br><span class="line">      <span class="comment">// 分别是：触发回调函数列表执行(函数名)，添加回调函数（函数名），回调函数列表（jQuery.Callbacks对象），deferred最终状态（第三组数据除外）</span></span><br><span class="line">      <span class="comment">// 总体而言，三个元组会有对应的三个callbacklist对应于doneList, failList, processList</span></span><br><span class="line">      <span class="keyword">var</span> tuples = [</span><br><span class="line">        [<span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span>],</span><br><span class="line">        [<span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span>],</span><br><span class="line">        [<span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>)]</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//deferred的状态，三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)</span></span><br><span class="line">      <span class="comment">//其实就是tuples最后定义的</span></span><br><span class="line">      <span class="keyword">var</span> state = <span class="string">"pending"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//内部promise对象,作用：</span></span><br><span class="line">      <span class="comment">//1：通过promise.promise( deferred );混入到deferred中使用</span></span><br><span class="line">      <span class="comment">//2：可以生成一个受限的deferred对象，</span></span><br><span class="line">      <span class="comment">//   不在拥有resolve(With), reject(With), notify(With)这些能改变deferred对象状态并且执行callbacklist的方法了</span></span><br><span class="line">      <span class="comment">//   换句话只能读，不能改变了</span></span><br><span class="line">      <span class="comment">//扩展</span></span><br><span class="line">      <span class="comment">//  done fail pipe process </span></span><br><span class="line">      <span class="keyword">var</span> promise = &#123;</span><br><span class="line">        state: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        always: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        then: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        promise: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend(obj, promise) : promise;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//管道接口,API别名</span></span><br><span class="line">      promise.pipe = promise.then;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//遍历tuples</span></span><br><span class="line">      <span class="comment">//把定义的接口混入到deferred中</span></span><br><span class="line">      jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> list = tuple[<span class="number">2</span>],</span><br><span class="line">          stateString = tuple[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 给上面的promise对象添加done，fail，process方法</span></span><br><span class="line">          <span class="comment">// 分别引用三个不同 jQuery.Callbacks("once memory")对象的add方法，在初始化就构建成了对象</span></span><br><span class="line">          <span class="comment">// 向各自的回调函数列表list（各自闭包中）中添加回调函数，互不干扰</span></span><br><span class="line">          <span class="comment">// promise = &#123;</span></span><br><span class="line">          <span class="comment">//    done:</span></span><br><span class="line">          <span class="comment">//    fail:</span></span><br><span class="line">          <span class="comment">//    process</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line">          promise[tuple[<span class="number">1</span>]] = list.add;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stateString) &#123;</span><br><span class="line">          list.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            state = stateString;</span><br><span class="line">          &#125;, tuples[i ^ <span class="number">1</span>][<span class="number">2</span>].disable, tuples[<span class="number">2</span>][<span class="number">2</span>].lock);</span><br><span class="line">        &#125;</span><br><span class="line">        deferred[tuple[<span class="number">0</span>]] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          deferred[tuple[<span class="number">0</span>] + <span class="string">"With"</span>](<span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        deferred[tuple[<span class="number">0</span>] + <span class="string">"With"</span>] = list.fireWith;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//混入方法</span></span><br><span class="line">      promise.promise(deferred);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> deferred;</span><br><span class="line">    &#125;</span><br><span class="line">  $(<span class="string">"button"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dtd = Deferred();</span><br><span class="line">    <span class="comment">// 给deferred注册一个成功后的回调通知</span></span><br><span class="line">    dtd.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       $(<span class="string">'body'</span>).append(<span class="string">'&lt;li&gt;Deferred成功&lt;/li&gt;'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 开始执行一段代码</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      dtd.resolve(); <span class="comment">// 改变deferred对象的执行状态</span></span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h2>Deferred源码剖析(下)</h2><p>在上一节中构建了deferred对象，实现了done/fail/process和resolve/reject/notify等方法，但是最重要的then,pipe管道接口我们还没有实现，我们考虑下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dfd = $.Deferred()</span><br><span class="line">dfd.then(<span class="function"><span class="keyword">function</span>(<span class="params">preVale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * preVale   <span class="comment">//4</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">preVale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span> * preVale   <span class="comment">//12</span></span><br><span class="line">&#125;)</span><br><span class="line">dfd.resolve(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>then就是pipe，我们可以想象是一个管道，可以对回调模式使用瀑布模型。如案例所示，下一个回调都能取到上一个回调的值，这样一直可以叠加往后传递。</p><p>不难看出管道的风格就是链式的操作，每一个链上的结果都会反馈后下一个链，那么这个链式是不是传统的返回自身这个对象this呢？</p><p>常规的办法通过数组处理：右侧代码所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aDeferred</span>(<span class="params">）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="regexp">//</span>代码右侧代码</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>这样的结构当然是很简陋的，这里我们最终有一个本质的问题没有解决，jQuery中的then的返回还有可能是另一个新的异步模型对象,如ajax，因此还能实现done，fail,always,then等方法。所以采用简陋的数组的方式保存状态是很肤浅的了。</p><p>这时候jQuery采取了对象保存处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以把每一次的then操作，当做是创建一个新的deferred对象，那么每一个对象都够保存自己的状态与各自的处理方法。通过一个办法把所有的对象操作都串联起来，这就是then或者pipe管道设计的核心思路了。</span><br></pre></td></tr></table></figure><p>看jQuery的<strong>then</strong>结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">then: <span class="function"><span class="keyword">function</span>(<span class="params"> <span class="regexp">/* fnDone, fnFail, fnProgress */</span> </span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;</span><br><span class="line">         <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params">newDefer</span>) </span>&#123;</span><br><span class="line">                   jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">                            deferred[tuple[<span class="number">1</span>]](<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                         <span class="comment">// deferred[ done | fail | progress ]                   </span></span><br><span class="line">                    &#125;);</span><br><span class="line">               &#125;);</span><br><span class="line">         &#125;).promise()</span><br></pre></td></tr></table></figure><p>其实在内部创建了一个新的Deferred对象，不过这里的不同是通过传递一个回调函数，参数是newDefer，其实Deferred内部就是为了改变下上下文this为deferred，然后传递deferred给这个回调函数了，所以newDefer就指向内部的deferred对象了。</p><p>那么对象之间如何关联？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//取出参数</span></span><br><span class="line">  <span class="keyword">var</span> fn = jQuery.isFunction(fns[i]) &amp;&amp; fns[i];</span><br><span class="line">  <span class="comment">// deferred[ done | fail | progress ] for forwarding actions to newDefer</span></span><br><span class="line">  <span class="comment">// 添加done fail progress的处理方法</span></span><br><span class="line">  <span class="comment">// 针对延时对象直接做了处理</span></span><br><span class="line">  deferred[tuple[<span class="number">1</span>]](<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> returned = fn &amp;&amp; fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (returned &amp;&amp; jQuery.isFunction(returned.promise)) &#123;</span><br><span class="line">      returned.promise()</span><br><span class="line">        .done(newDefer.resolve)</span><br><span class="line">        .fail(newDefer.reject)</span><br><span class="line">        .progress(newDefer.notify);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newDefer[tuple[<span class="number">0</span>] + <span class="string">"With"</span>](<span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [returned] : <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把then的方法通过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deferred.done</span><br><span class="line">deferred.fail</span><br><span class="line">deferred.progress</span><br></pre></td></tr></table></figure><p>加入到上一个对象的各自的执行队列中保存了。这样就实现了不同对象之间的关联调用。</p><p>同样如果then返回的是一个promise对象（ajax）的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (returned &amp;&amp; jQuery.isFunction(returned.promise)) &#123;</span><br><span class="line">  returned.promise()</span><br><span class="line">    .done(newDefer.resolve)</span><br><span class="line">    .fail(newDefer.reject)</span><br><span class="line">    .progress(newDefer.notify);</span><br></pre></td></tr></table></figure><p>也可以直接处理了。</p><h3>模拟的代码测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;button&gt;模拟的代码测试&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  //使用$.Deferred</span><br><span class="line">  var dfd = $.Deferred()</span><br><span class="line">  dfd.then(function(preVale) &#123;</span><br><span class="line">    return 2 * preVale; </span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    return 3 * preVale </span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&apos;&lt;li&gt;使用$.Deferred代码结果:&apos;+ preVale +&apos;&lt;/li&gt;&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  dfd.resolve(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //简单模拟</span><br><span class="line">  function aDeferred() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    return &#123;</span><br><span class="line">      then: function(fn) &#123;</span><br><span class="line">        arr.push(fn)</span><br><span class="line">        return this;</span><br><span class="line">      &#125;,</span><br><span class="line">      resolve: function(args) &#123;</span><br><span class="line">        var returned;</span><br><span class="line">        arr.forEach(function(fn, i) &#123;</span><br><span class="line">          var o = returned || args;</span><br><span class="line">          returned = fn(o)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">  var d = aDeferred();</span><br><span class="line">  d.then(function(preVale) &#123;</span><br><span class="line">    return 2 * preVale //4</span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    return 3 * preVale //4</span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&apos;&lt;li&gt;模拟代码结果:&apos;+ preVale +&apos;&lt;/li&gt;&apos;)</span><br><span class="line">  &#125;);</span><br><span class="line">  d.resolve(2)</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3>when方法的设计</h3><p>when也是一个非常有用的方法，常用于合并多个异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when(d1,d2,d3,d4......).done(function(v1, v2,v3...) &#123;</span><br><span class="line">    //等待所有异步加载完毕后执行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用法很简单，把所有的异步丢到when中，when会处理所有的结果。当然d1,d2,d3都是有规范的，都是通过Deferred产生的。</p><p>如果向 <code>jQuery.when()</code> 传入延迟对象，那么会返回它的 Promise 对象(延迟方法的一个子集)。可以继续绑定 Promise 对象的其它方法，例如， <code>defered.then</code> 。当延迟对象已经被解决（resolved）或被拒绝(rejected）（通常是由创建延迟对象的最初代码执行的），那么就会调用适当的回调函数。例如，由 <code>jQuery.ajax()</code> 返回的 jqXHR 对象是一个延迟对象，可以向下面这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when($.ajax(<span class="string">"test.aspx"</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class="line">  alert(jqXHR.status); <span class="comment">// alerts 200</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过模拟的代码，可以很简单的分析整个流程：</p><ol><li><p>传递了多个异步对象，然后遍历每个异步对象给每一个对象绑定done、fail、progess方法，无非就是监听每一个异步的状态（成功，失败），如果是完成了自然会激活done方法。</p></li><li><p>updateFunc是监听方法，通过判断异步对象执行的次数来决定是不是已经完成了所有的处理或者是失败处理</p></li><li><p>因为<code>when也要形成异步操作，</code>比如when().done()，<code>所以内部必须新建一个</code>jQuery.Deferred()对象，用来给后面链式调用。</p></li><li><p>此刻监听所有异步对象(d1,d2…)的updateFunc的处理都完毕了，会给一个正确的通知给when后面的done方法，因为done是通过第三步jQuery.Deferred()创建的，所以此时就需要发送消息到这个上面，即：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred.resolveWith(contexts, values);</span><br></pre></td></tr></table></figure><ol start="5"><li>内部的jQuery.Deferred()因为外部绑定了when().done(),所以done自然就收到了updateFunc给的消息了，可以继续之后的操作了。</li></ol><p>所以整个执行流程就是这样简单，我们通过右边最简单的模拟出这个效果。</p><p>整个when的设计其实最终还是依赖了jQuery.Deferred内部处理的机制，一层套一层。当然jQuery的异步设计逻辑也确实很复杂，需要思维跳转很活跃，某一个时间在这里，下一个片段又要另一个地方去了，不是按照同步代码这样执行的。需要大家有一定的空间跳跃力了。</p><h3>when代码测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"http://img.mukewang.com/down/541f6ff70001a0a500000000.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button&gt;$.when代码测试&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;when模拟的代码测试&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$('button').eq(0).click(function() &#123;</span></span><br><span class="line"><span class="string">  var d1 = new $.Deferred();</span></span><br><span class="line"><span class="string">  var d2 = new $.Deferred();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function()&#123;</span></span><br><span class="line"><span class="string">    d1.resolve("</span>$.when代码测试Fish<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;,500)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function()&#123;</span></span><br><span class="line"><span class="string">    d2.resolve("</span>$.when代码测试Pizza<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;,1000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$.when(d1, d2).done(function(v1, v2) &#123;</span></span><br><span class="line"><span class="string">  show(v1); // "</span>Fish<span class="string">"</span></span><br><span class="line"><span class="string">  show(v2); // "</span>Pizza<span class="string">"</span></span><br><span class="line"><span class="string">&#125;);  </span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">ul</span></span><br><span class="line"><span class="string">$('button').eq(1).click(function() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  var d1 = new $.Deferred();</span></span><br><span class="line"><span class="string">  var d2 = new $.Deferred();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function() &#123;</span></span><br><span class="line"><span class="string">    d1.resolve("</span>when模拟:Fish<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;, 500)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function() &#123;</span></span><br><span class="line"><span class="string">    d2.resolve("</span>when模拟:Pizza<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;, 1000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  function when(d1, d2) &#123;</span></span><br><span class="line"><span class="string">    var i = 0,</span></span><br><span class="line"><span class="string">      resolveValues = [].slice.call(arguments),</span></span><br><span class="line"><span class="string">      length = resolveValues.length;</span></span><br><span class="line"><span class="string">    var len = length;</span></span><br><span class="line"><span class="string">    //收集resolve值</span></span><br><span class="line"><span class="string">    var values = [];</span></span><br><span class="line"><span class="string">    var deferred = jQuery.Deferred();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function updateFunc(value) &#123;</span></span><br><span class="line"><span class="string">      values.push(value);</span></span><br><span class="line"><span class="string">      if (len === 1) &#123;</span></span><br><span class="line"><span class="string">        deferred.resolveWith('contexts', values);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      len--</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for (; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="string">      resolveValues[i].done(updateFunc)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return deferred;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  when(d1, d2).done(function(v1, v2) &#123;</span></span><br><span class="line"><span class="string">    show(v1); // "</span>Fish<span class="string">"</span></span><br><span class="line"><span class="string">    show(v2); // "</span>Pizza<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt; </span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解回调函数</title>
      <link href="/%E7%90%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0.html"/>
      <content type="html"><![CDATA[<p>主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。</p><a id="more"></a><p>函数是第一类对象，这是javascript中的一个重要的概念。意味着函数可以像对象一样按照第一类管理被使用，所以在javaScript中的函数：</p><p>**☑ **  能“存储”在变量中</p><p>** ☑**   能作为函数的实参被传递</p><p>**☑ **  能在函数中被创建</p><p>** ☑**   能从函数中返回</p><p><strong>百科里面是这么解释的：</strong></p><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应。</p><p>因此从上面可以看出来，回调本质上是一种设计原则，并且jQuery的设计原则遵循了这个模式。</p><p>在后端的编程语言中，传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入和一个输出。简单的理解函数本质上就<strong>是输入和输出之间实现过程的映射</strong>。</p><p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用。</p><p><strong>jQuery中遍地都是回调的设计：</strong></p><p><strong>异步回调：</strong></p><p>事件句柄回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(callback);</span><br><span class="line">$(document).on(‘click’,callback)</span><br></pre></td></tr></table></figure><p>Ajax异步请求成功失败回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;aaron.html&quot;,</span><br><span class="line">  context: document</span><br><span class="line">&#125;).done(function() &#123; </span><br><span class="line">        //成功执行</span><br><span class="line">&#125;).fail(function() &#123;</span><br><span class="line">        //失败执行</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>动画执行完毕回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#clickme&apos;).click(function() &#123;</span><br><span class="line">    $(&apos;#book&apos;).animate(&#123;</span><br><span class="line">        opacity: 0.25,</span><br><span class="line">        left: &apos;+=50&apos;,</span><br><span class="line">        height: &apos;toggle&apos;</span><br><span class="line">    &#125;, 5000, function() &#123;</span><br><span class="line">        // Animation complete.</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上都是jQuery的回调直接运用，运用基本都是将匿名函数作为参数传递给了另一个函数或方法。而且以上都有一个特点，执行的代码都是异步的。</p><p><strong>同步回调：</strong></p><p>当然回调不仅仅只是处理异步，一般同步(很耗时的任务)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p><p>一个同步(阻塞)中使用回调的例子，目的是在test1代码执行完成后执行回调callback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var test1 = function(callback) &#123;</span><br><span class="line">    //执行长时间操作</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line">test1(function() &#123;</span><br><span class="line">    //执行回调中的方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>所以理解回调函数最重要的2点：</strong></p><p>1、一个回调函数作为参数传递给另一个函数是，我们仅仅传递了函数定义。我们并没有在参数中执行函数。我们并不传递像我们平时执行函数一样带有一对执行小括号()的函数</p><p>2、回调函数并不会马上被执行，它会在包含它的函数内的某个特定时间点被“回调”。</p><h2>回调的灵活运用</h2><p>我们经常会这样使用函数回调：</p><p><strong>☑</strong>  事件触发通知</p><p><strong>☑</strong>  资源加载通知</p><p><strong>☑</strong>  定时器延时</p><p><strong>☑</strong>  ajax、动画通知等等。</p><p>以上都是很单一的事件监听回调的处理方式，但是jQuery把回调函数的用法设计成一个更高的抽像，用于解耦与分离变化。</p><p>如何理解这个设计？我们看下面的例子。</p><p><strong>例子一：</strong></p><p>jQuery针对Dom的处理提供了append、prepend、before、after等方法的处理，这几个方法的特征：</p><p>1、参数的传递可以是HTML字符串、DOM元素、元素数组或者jQuery对象</p><p>2、为了优化性能针对节点的处理需要生成文档碎片</p><p>可见几个方法都是需要实现这2个特性的，那么我们应该如何处理？</p><p><strong>高层接口：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">before: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">after: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>.nextSibling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>底层实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">domManip: <span class="function"><span class="keyword">function</span>(<span class="params">args, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Flatten any nested arrays</span></span><br><span class="line">    args = concat.apply([], args);</span><br><span class="line">    <span class="comment">// We can't cloneNode fragments that contain checked, in WebKit</span></span><br><span class="line">    <span class="keyword">if</span> (isFunction ||</span><br><span class="line">        <span class="comment">//多参数处理</span></span><br><span class="line">        self.domManip(args, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l) &#123;</span><br><span class="line">        <span class="comment">//生成文档碎片</span></span><br><span class="line">        fragment = jQuery.buildFragment(args, <span class="keyword">this</span>[<span class="number">0</span>].ownerDocument, <span class="literal">false</span>, <span class="keyword">this</span>);</span><br><span class="line">        callback.call(<span class="keyword">this</span>[i], node, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察下jQuery的实现，通过抽象出一个domManip方法，然后在这个方法中处理共性，合并多个参数的处理与生成文档碎片的处理，然后最终把结果通过回调函数返回给每一个调用者。</p><p><strong>例子二：</strong></p><p>在很多时候需要控制一系列的函数顺序执行。那么一般就需要一个队列函数来处理这个问题。</p><p>我们看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Ulson(List, callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        var task;</span><br><span class="line">        if (task = List.shift()) &#123;</span><br><span class="line">            task(); //执行函数</span><br><span class="line">        &#125;</span><br><span class="line">        if (List.length &gt; 0) &#123; //递归分解</span><br><span class="line">            arguments.callee(List)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 25)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">Ulson([</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;a&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;b&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;c&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">], function() &#123;</span><br><span class="line">    alert(&apos;callback&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 分别弹出 ‘a’ , ‘b’ ,&apos;c&apos;,’callback</span><br></pre></td></tr></table></figure><p>传入一组函数参数，靠递归解析，分个执行，其实就是靠setTimeout可以把函数加入到队列末尾才执行的原理，这样的写法就有点就事论事了，聚合对象完全是一个整体，无法再次细分出来，所以我们需要一种方案，用来管理分离每一个独立的对象。</p><p><strong>我们换成jQuery提供的方式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;a&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;b&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.fire(); //输出结果: &apos;a&apos; &apos;b&apos;</span><br></pre></td></tr></table></figure><p>是不是便捷很多了，代码又很清晰，所以Callbacks它是一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。</p><p>那么我们使用回调函数，总的来说<strong>弱化耦合</strong>，让调用者与被调用者分开，调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件的被调用函数。</p><h2>理解观察者模式</h2><p>讲解jQuery回调对象之前，我们有必要先理解其背后的设计思想 - “观察者模式”。</p><p>观察者模式 (pub/sub) 的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。观察者也被叫作订阅者（Subscriber），它指向被观察的对象，既被观察者（Publisher 或 subject)。当事件发生时，被观察者（Publisher）就会通知观察者（subscriber）。</p><p><strong>观察者的使用场合</strong></p><p>观察者的使用场合就是：<strong>当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式</strong>。先看官网的demo这个例子，涉及到了 add 与 fire方法，熟悉设计模式的童鞋呢，一眼就能看出，其实又是基于发布订阅（Publish/Subscribe）的观察者模式的设计。</p><p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统，将 $.Callbacks 作为一个队列。</p><p><strong>我们来模拟常规下最简单的实现：</strong></p><p>JS里对观察者模式的实现是通过回调来实现的，我们来先定义一个Observable对象，其内部包含了2个方法：订阅add方法与发布fire方法，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用add开始订阅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(1)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用fire开始发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.fire(); // 1, 2</span><br></pre></td></tr></table></figure><p><strong>设计的原理：</strong></p><p>开始构建一个存放回调的数组，如<code>this.callbacks= []</code>添加回调时，将回调push进this.callbacks，执行则遍历this.callbacks执行回调，也弹出1跟2了。当然这只是简洁的设计，便于理解，整体来说设计的思路代码都是挺简单的，那么我们从简单的设计深度挖掘下这种模式的优势。</p><p>注意：如果没有做过复杂交互设计，或者大型应用的开发者，可能一开始无法理解这模式的好处，就简单的设计而言用模式来处理问题，有点把简单的问题复杂化。我们不是为了使用模式而使用的。</p><p><strong>组件开发为了保证组件可以在不同的项目中都适用，其必须是对其常用功能抽象出来加以实现，绝不会包含具体的业务逻辑而某一特定的项目使用者在其业务场景中使用组件时不可避免的要加入不同场景的业务逻辑。</strong></p><h2>模式的实际运用</h2><p>在进行组件开发中，为了保证组件可以在不同的类似项目场景中都能适用，那么就必须是对其常用功能抽象出来加以实现。</p><p>我们来看看具体的实际用处：</p><p>假设一段ajax的请求，成功后通过done返回结果数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"test.html"</span>,</span><br><span class="line">  context: <span class="built_in">document</span>.body</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//data数据的处理</span></span><br><span class="line">  $(<span class="string">'aaron1'</span>).html(data.a)</span><br><span class="line">  $(<span class="string">'aaron2'</span>).html(data.b)</span><br><span class="line">  $(<span class="string">'aaron3'</span>).html(data.c)</span><br><span class="line">  <span class="comment">//其余处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>咋一看好像都挺好，没什么问题，但是仔细观察我们会发现所有的逻辑是不是都写在done方法里面，这样确实是无可厚非的，但是问题就是逻辑太复杂了。Done里面有数据处理、html渲染、还可能有其它不同场景的业务逻辑。这样如果是换做不同的人去维护代码，增加功能就会显得很混乱而且没有扩展性。那么观察者模式能很好的解决了这个的问题。</p><p>我们优化下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">    pocessData()</span><br><span class="line">    pocessHtml()</span><br><span class="line">    pocessOther()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessData() &#123;</span><br><span class="line">    //处理数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessHtml() &#123;</span><br><span class="line">    $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">    $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">    $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessOther() &#123;</span><br><span class="line">    //处理其他逻辑</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处是，分离出各种的业务函数，从而降低了代码之间的耦合度，但是这样代码写法几乎就是“就事论事”的处理，达不到<strong>抽象复用</strong>。</p><p>那么我们用之前的观察者模式加工一下上面的代码：（这只是伪代码，用于理解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessData</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">  $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">  $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessOther</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">  Observable.fire(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>设计该模式背后的主要动力是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称为观察者，而被观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者并且可能经常以事件对象的形式传递消息。</p><p>总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;fn(data);&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    arg.successful(arg.data+ <span class="string">',返回获取到后台的数据'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用add开始订阅：</span></span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_one: '</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_two: '</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一段ajax请求，成功后处理</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  data:<span class="string">'Hello'</span>,</span><br><span class="line">  successful:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    Observable.fire(data); <span class="comment">//触发动作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2>jQuery回调对象</h2><p>jQuery.Callbacks一般开发者接触的很少，虽然jQuery向开发者提供了外部接口调用，但是$.Callbacks()模块的开发目的是为了给内部$.ajax() 和 $.Deferred()模块提供统一的基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p><p>jQuery.Callbacks是jquery在1.7版本之后加入的，是从1.6版中的_Deferred对象中抽离的，主要用来进行函数队列的add、remove、fire、lock等操作，并提供once、memory、unique、stopOnFalse四个option进行一些特殊的控制。</p><p>这个函数常见的应用场景是事件触发机制，也就是设计模式中的观察者模式的发布、订阅机制，目前Callbacks对象用于queue、ajax、Deferred对象中，本小节主要是一些简单的例子去理解的使用。</p><p>我们看官网提供的demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将上述两个方法作为回调函数，并添加到 $.Callbacks 列表中，并按下面的顺序调用它们:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line"><span class="comment">// outputs: foo!</span></span><br><span class="line">callbacks.fire(<span class="string">"foo!"</span>);</span><br><span class="line">callbacks.add(fn2);</span><br><span class="line"><span class="comment">// outputs: bar!, fn2 says: bar!</span></span><br><span class="line">callbacks.fire(<span class="string">"bar!"</span>)</span><br></pre></td></tr></table></figure><p>这样做的结果是，当构造复杂的回调函数列表时，将会变更很简单。可以根据需要，很方面的就可以向这些回调函数中传入所需的参数。</p><p>上面的例子中，我们使用了 $.Callbacks() 的两个方法: .add() 和 .fire()。 .add() 和 .fire() .add() 支持添加新的回调列表, 而.fire() 提供了一种用于处理在同一列表中的回调方法的途径。</p><p>另一种方法是$.Callbacks 的.remove()方法，用于从回调列表中删除一个特定的回调。下面是.remove()使用的一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">// outputs: foo!</span><br><span class="line">callbacks.fire( &quot;foo!&quot; );</span><br><span class="line">callbacks.add( fn2 );</span><br><span class="line">// outputs: bar!, fn2 says: bar!</span><br><span class="line">callbacks.fire( &quot;bar!&quot; );</span><br><span class="line">callbacks.remove( fn2 );</span><br><span class="line">// only outputs foobar, as fn2 has been removed.</span><br><span class="line">callbacks.fire( &quot;foobar&quot; );</span><br></pre></td></tr></table></figure><p>这个运用内部就是观察者模式的一种设计实现，只是相对比较复杂。我们看看jQuery的回调函数到底为哪些模块服务？</p><p>异步队列模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deferred: function(func) &#123;</span><br><span class="line">  var tuples = [</span><br><span class="line">    // action, add listener, listener list, final state</span><br><span class="line">    [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">    [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">    [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">  ]，………….</span><br></pre></td></tr></table></figure><p>队列模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_queueHooks: function(elem, type) &#123;</span><br><span class="line">  var key = type + &quot;queueHooks&quot;;</span><br><span class="line">  return data_priv.get(elem, key) || data_priv.access(elem, key, &#123;</span><br><span class="line">    empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() &#123;</span><br><span class="line">      data_priv.remove(elem, [type + &quot;queue&quot;, key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ajax模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax: function(url, options) &#123;</span><br><span class="line">  //省略代码</span><br><span class="line">  deferred = jQuery.Deferred(),</span><br><span class="line">  completeDeferred = jQuery.Callbacks(&quot;once memory&quot;)</span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现jQuery.Callbacks还提供“once memory”等参数用来处理：</p><p>☑  once: 确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)。</p><p>☑  memory: 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p><p>☑  unique: 确保一次只能添加一个回调(所以在列表中没有重复的回调)。</p><p>☑  stopOnFalse: 当一个回调返回false 时中断调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks(<span class="string">'once'</span>);</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'a'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'b'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.fire(); <span class="comment">//输出结果: 'a' 'b'</span></span><br><span class="line">callbacks.fire(); <span class="comment">//未执行</span></span><br></pre></td></tr></table></figure><p>once的作用是使callback队列只执行一次。</p><p>最后，我们大概知道这个是干嘛用的了，可以开始上正菜了。</p><h2>jQuery回调模块结构</h2><p>整个$.Callbacks的源码很少，它是一个工厂函数，使用函数调用（非new，它不是一个类）创建对象，它有一个可选参数flags用来设置回调函数的行为，对外的接口也就是self的返回。</p><p>jQuery.Callbacks()的API列表如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callbacks.add()        ：回调列表中添加一个回调或回调的集合。</span><br><span class="line">callbacks.disable()    ：禁用回调列表中的回调。</span><br><span class="line">callbacks.disabled()   ：确定回调列表是否已被禁用。 </span><br><span class="line">callbacks.empty()      ：从列表中删除所有的回调。</span><br><span class="line">callbacks.fire()       ：用给定的参数调用所有的回调。</span><br><span class="line">callbacks.fired()      ：访问给定的上下文和参数列表中的所有回调。 </span><br><span class="line">callbacks.fireWith()   ：访问给定的上下文和参数列表中的所有回调。</span><br><span class="line">callbacks.has()        ：确定列表中是否提供一个回调。</span><br><span class="line">callbacks.lock()       ：锁定当前状态的回调列表。</span><br><span class="line">callbacks.locked()     ：确定回调列表是否已被锁定。</span><br><span class="line">callbacks.remove()     ：从回调列表中的删除一个回调或回调集合。</span><br></pre></td></tr></table></figure><p>源码结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.Callbacks = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?</span><br><span class="line">        (optionsCache[options] || createOptions(options)) :</span><br><span class="line">        jQuery.extend(&#123;&#125;, options);</span><br><span class="line">    <span class="comment">//实现代码</span></span><br><span class="line">    fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    self = &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        has: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;&#125;,</span><br><span class="line">        empty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disable: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disabled: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        lock: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        locked: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fireWith: <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;&#125;,</span><br><span class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fired: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个结构要分三部分：</p><p>☑   Options参数缓存</p><p>☑   内部fire触发器的设计</p><p>☑   外部</p><p><strong>参数的缓存设计</strong></p><p>Callbacks是可以是接受的字符串的组合传参数，可以使用空格分割，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var opts = &apos;unique memory&apos;;</span><br><span class="line">var object = &#123;&#125;</span><br><span class="line">jQuery.each(opts.match(/\S+/g) || [], function(_, flag) &#123;</span><br><span class="line">  object[flag] = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的操作其实是不需要重复的，所以我们可以设计一个缓存池，用来储存重复的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var optionsCache = &#123;&#125;;</span><br><span class="line">function createOptions(options) &#123;</span><br><span class="line">  var object = optionsCache[options] = &#123;&#125;;</span><br><span class="line">  jQuery.each(options.match(rnotwhite) || [], function(_, flag) &#123;</span><br><span class="line">    object[flag] = true;</span><br><span class="line">  &#125;);</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们传递参数的时候，如果参数是字符串，我们可以直接从optionsCache缓存中去查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = typeof options === &quot;string&quot; ?</span><br><span class="line">        ( optionsCache[ options ] || createOptions( options ) ) :</span><br><span class="line">        jQuery.extend( &#123;&#125;, options );</span><br></pre></td></tr></table></figure><p><strong>接口的设计：</strong></p><p>通过学习了观察者模式的思路，我们知道callback需要在内部维护着一个list的队列数组，用于保存订阅的对象数据。同时也需要提供了add、remove、fire等订阅、发布、删除类似的接口。</p><p>那么我们代码是不是很简单是就是把订阅对象给push给内部list列表？</p><p>实现思路就是: 构建一个存放回调的数组，如<code>var list = []</code>，通过闭包使这条回调数组保持存在。添加回调时，将回调push进list，执行则遍历list执行回调。</p><p>后面几节我们会通过简单的模拟实现去剖析设计的思路。</p><h2>默认回调对象设计</h2><p>不传入任何参数，调用add的时候将函数add到内部的list中，调用fire的时候顺序触发list中的回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says:&apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks();</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">console.log(&apos;........&apos;)</span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;)</span><br></pre></td></tr></table></figure><p>结果就是按照顺序叠加触发，如下列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn1 says:foo </span><br><span class="line">………………………</span><br><span class="line">fn1 says:bar </span><br><span class="line">fn2 says bar</span><br></pre></td></tr></table></figure><p>这种就是最简单的处理了，可以直接模拟，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks() &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      list.forEach(function(fn) &#123;</span><br><span class="line">        fn(args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>once的设计</h2><p>这一小节我们来讲一下once。</p><p>once的作用确保回调列表只执行（.fire()）一次(像一个递延 Deferred)，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val)&#123;</span><br><span class="line">    console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br></pre></td></tr></table></figure><p>结果你会发现cbs.fire(‘foo’)只执行了一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo  //只显示一次</span><br></pre></td></tr></table></figure><p>once定义是很明确的，确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)，所以针对这种once的处理可以有多种不同的途径实现。</p><p>1、add的时候抛弃</p><p>2、在fire的时候抛弃多个。</p><p>但是jQuery是在执行第一个fire的时候直接给清空list列表了，然后在add的地方给判断下list是否存在，从而达到这样的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        list.forEach(function(fn) &#123;</span><br><span class="line">          fn(args);</span><br><span class="line">        &#125;)</span><br><span class="line">        if (options === &apos;once&apos;) &#123;</span><br><span class="line">          list = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在fire之后，判断参数是否为once，直接把list给清理掉，所以之后的所有fire都被抛弃掉了，而从达到了once的效果。</p><p><strong>jQuery.Callbacks的处理</strong></p><p>在fire中调用了 self.disable(); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 禁用回调列表中的回调。</span><br><span class="line">disable: function() &#123;</span><br><span class="line">    list = stack = memory = undefined;</span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>memory的设计</h2><p>memory：保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p><p>回调函数是从异步队列Deferred分离出来的，所以很多的接口设计都是为了契合Deferred接口，memory用的很多，这个缓存的设计这里提及一下</p><p>主要是用来实现deferred的异步收集与pipe管道风格的数据传递的，具体在Deferred有详解，这里大概了解下作用范围。</p><p>memory这个有点不好理解，我们还是通过列子说明下，看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var cbs = Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn3(val) &#123;</span><br><span class="line">  console.log(&apos;fn3 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cbs = $.Callbacks(&apos;memory&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line"></span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line">cbs.add(fn3);</span><br><span class="line">cbs.fire(&apos;aaron&apos;);</span><br></pre></td></tr></table></figure><p>结果可以看出，我们在执行cbs.add(fn2);的时候，此时除了把fn2添加到了回调队列之外而且还立刻执行了这个方法，唯一的区别就是，参数是用的之前的。所以解释就叫“<strong>保持以前的值</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo </span><br><span class="line">.......... </span><br><span class="line">fn2 says foo </span><br><span class="line">fn1 says bar </span><br><span class="line">fn2 says bar </span><br><span class="line">.......... </span><br><span class="line">fn3 says bar </span><br><span class="line">fn1 says aaron </span><br><span class="line">fn2 says aaron </span><br><span class="line">fn3 says aaron</span><br></pre></td></tr></table></figure><p>所以这个<code>memory</code>设计需要解决的问题就是：</p><p>1：如何取到上一个参数</p><p>2：add后如何执行</p><p>看看我们实现的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callbacks</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = [];</span><br><span class="line">  <span class="keyword">var</span> self;</span><br><span class="line">  <span class="keyword">var</span> firingStart;</span><br><span class="line">  <span class="keyword">var</span> memory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fire</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    memory = options === <span class="string">'memory'</span> &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || <span class="number">0</span>;</span><br><span class="line">    firingStart = <span class="number">0</span>;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    <span class="keyword">for</span> (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> start = list.length;</span><br><span class="line">      list.push(fn)</span><br><span class="line">      <span class="keyword">if</span> (memory) &#123;</span><br><span class="line">        firingStart = start; <span class="comment">//获取最后一值</span></span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   fire: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先add之后要能触发fire的动作，所以我们把fire作为内部的一个私有方法实现_fire，比较合逻辑，这样外部的fire只是一个门面方法的调用。</p><p>私有变量memory缓存这上一个参数的属性，我们靠firingStart用来定位最后通过add增加的回调数据的索引。在遍历的时候直接通过firingStart的起始索引定位，然后传递memory的参数，而且实现这种“保持以前的值”的设计。</p><h2>unique的设计</h2><p>Unique：确保一次只能添加一个回调(所以在列表中没有重复的回调)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var callbacks = $.Callbacks( &quot;unique&quot; );</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.add( fn1 ); // repeat addition</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.fire( &quot;foo&quot; );</span><br></pre></td></tr></table></figure><p>结果：过滤了相同的add操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo</span><br></pre></td></tr></table></figure><p>过滤重复的比较简单，因为是数组的保存方式，我们可以在入口处通过indexOf判断即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>stopOnFalse</h2><p>stopOnFalse: 当一个回调返回false 时中断调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var callbacks = $.Callbacks(&quot;stopOnFalse&quot;);</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line">callbacks.fire(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">callbacks.add(fn2);</span><br><span class="line">callbacks.fire(&quot;bar&quot;);</span><br></pre></td></tr></table></figure><p>结果虽然fn1被添加到了回调列表，但是因为fn1返回了false，那么意思之后的回调都不会被调用了。如果还有fn3，在f2上返回false，fn3也将不会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p></p><p>这个设计我们只要控制好函数返回的处理的布尔值，通过这个值用来判断是否需要下一个遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex =</span><br><span class="line">      firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是几种单独的处理情况的用法，我们可以看到jQuery都是组合使用的，最常见的就是</p><p>jQuery.Callbacks(“once memory”)的组合了，其实以上的思路都讲解过了，无非就是组合起来的时候要考虑一些判断了。</p>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JQuery源码解读 02-对象构建</title>
      <link href="/JQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2002-%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA.html"/>
      <content type="html"><![CDATA[<h2>对象简介</h2><p>面向对象(OOP)的语言都有一个特点，它们都会有类的这一概念，通过类可以抽象出创建具体相同方法与属性的对象。但是ECMAScript中是没有类的概念的，因此它的对象与基于类的语言如java的定义是有所不同的。</p><a id="more"></a><p>在JavaScript世界中函数作为“一等公民”，它不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值、传参、返回，这样的函数也称之为第一级函数。不仅如此，而且还可以通过操作符new来充当类的构造器。</p><p>函数在充当类的构造器时，原型prototype是一个重要的概念。prototype是构造函数的一个属性, 该属性指向一个对象。而这个对象将作为该构造函数所创建的所有实例的基引用(base reference), 可以把对象的基引用想像成一个自动创建的隐藏属性。 当访问对象的一个属性时, 首先查找对象本身, 找到则返回；若不, 则查找基引用指向的对象的属性(如果还找不到实际上还会沿着原型链向上查找,  直至到根)。 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到。</p><p>类一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ajQuery() &#123;</span><br><span class="line">    this.name = &apos;jQuery&apos;;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">var a = new ajQuery()</span><br><span class="line">var b = new ajQuery()</span><br><span class="line">var c = new ajQuery()</span><br></pre></td></tr></table></figure><p>类二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function ajQuery() &#123;</span><br><span class="line">    this.name = &apos;jQuery&apos;</span><br><span class="line">&#125;</span><br><span class="line">ajQuery.prototype = &#123;</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new ajQuery()</span><br><span class="line">var b = new ajQuery()</span><br><span class="line">var c = new ajQuery()</span><br></pre></td></tr></table></figure><p>类一与类二产生的结构几乎是一样的，而本质区别就是：类二new产生的a、b、c三个实例对象共享了原型的sayName方法，这样的好处节省了内存空间，类一则是要为每一个实例复制sayName方法，每个方法属性都占用一定的内存的空间，所以如果把所有属性方法都声明在构造函数中，就会无形的增大很多开销，这些实例化的对象的属性一模一样，都是对this的引用来处理。除此之外类一的所有方法都是拷贝到当前实例对象上。类二则是要通过scope连接到原型链上查找，这样就无形之中要多一层作用域链的查找了。</p><p>jQuery对象的构建如果在性能上考虑，所以就必须采用原型式的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery = function( selector, context ) &#123;</span><br><span class="line">    return new jQuery.fn.init( selector, context );</span><br><span class="line">&#125;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init：function()&#123;</span><br><span class="line">    return this</span><br><span class="line">&#125;,</span><br><span class="line">    jquery: version,</span><br><span class="line">    constructor: jQuery,</span><br><span class="line">    ………………</span><br><span class="line">&#125;</span><br><span class="line">var a = $() ;</span><br></pre></td></tr></table></figure><p>使用原型结构，性能上是得到了优化，但是ajQuery类这个结构与目标jQuery的结构的还是有很大不一致：</p><p>☑   没有采用new操作符；</p><p>☑   return返回的是一个通过new出来的的对象 。</p><p><a href="https://github.com/JsAaron/jQuery" target="_blank" rel="noopener">所有案例的github下载地址</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ajQuery()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'jQuery'</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.prototype = &#123;</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ajQuery()</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery的写法</span></span><br><span class="line"><span class="keyword">var</span> $jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> $jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$jQuery.fn = $jQuery.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'aaron'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">constructor</span>: $jQuery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var $a = $jQuery();</span><br><span class="line">show('$jQuery的调用')</span><br><span class="line">show($a);</span><br></pre></td></tr></table></figure><h2>分离构造器</h2><p>通过new操作符构建一个对象，一般经过四步：</p><p><strong>A.创建一个新对象</strong></p><p><strong>B.将构造函数的作用域赋给新对象（所以this就指向了这个新对象）</strong></p><p><strong>C.执行构造函数中的代码</strong></p><p><strong>D.返回这个新对象</strong></p><p>最后一点就说明了，我们只要返回一个新对象即可。其实new操作符主要是把原型链跟实例的this关联起来，这才是最关键的一点，所以我们如果需要原型链就必须要new操作符来进行处理。否则this则变成window对象了。</p><p>我们来剖析下jQuery的这个结构,以下是我们常见的类式写法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">//实例化时，返回自身对象,返回后可以调用方法[链式调用]</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">    selectorName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.selector;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">var a = new $$('aaa');  //实例化</span><br><span class="line">a.selectorName() //aaa //得到选择器名字</span><br></pre></td></tr></table></figure><p>首先改造jQuery无new的格式，我们可以通过instanceof判断this是否为当前实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> ajQuery))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ajQuery(selector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意千万不要像下面这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var $$ = ajQuery = function(selector) &#123;</span><br><span class="line">    this.selector = selector;</span><br><span class="line">    return new ajQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line">Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><p>这样会无限递归自己，从而造成死循环并且溢出。</p><p>jQuery为了避免出现这种死循环的问题，采取的手段是把原型上的一个init方法作为构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var $$ = ajQuery = function(selector) &#123;</span><br><span class="line">    //把原型上的init作为构造器</span><br><span class="line">    return new ajQuery.fn.init( selector );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">    name: &apos;aaron&apos;,</span><br><span class="line">    init: function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;,</span><br><span class="line">    constructor: ajQuery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实解决了循环递归的问题，但是又问题来了，init是ajQuery原型上作为构造器的一个方法，那么其this就不是ajQuery了，所以this就完全引用不到ajQuery的原型了，所以这里通过new把init方法与ajQuery给分离成2个独立的构造器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见写法</span></span><br><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">selectorName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.selector;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">var a = new $$('aaa');  //实例化</span><br><span class="line"></span><br><span class="line">//得到选择器名字</span><br><span class="line">//aaa</span><br><span class="line">$("#test").html( a.selectorName() )</span><br></pre></td></tr></table></figure><h3>Q&amp;A</h3><h4>为什么init作为构造函数可以解决递归循环</h4><h4>return new jQuery.fn.init(selector);为什么不会出现递归循环</h4><p>最佳回答</p><p>去看一下new的过程，new的创建过程分为四步：</p><p>（1）创建一个新对象</p><p>（2）将构造函数的作用域赋值给新的对象</p><p>（3）执行构造函数的代码</p><p>（4）返回新对象</p><p>题目总的代码 return 返回的是一个对象，当然不会产生循环调用</p><h2>静态与实例方法共享设计</h2><p>保留上一节分割出2个构造器的疑问，我们先看看jQuery在接口的设计：</p><p><strong>遍历方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.aaron&quot;).each()   //作为实例方法存在</span><br><span class="line">$.each()             //作为静态方法存在</span><br></pre></td></tr></table></figure><p>这是最常见的遍历方法，第一条语句是给有指定的上下文调用的，就是(&quot;.aaron&quot;)获取的DOM合集，第二条语句$.each()函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次都会传递一个数组索引和相应的数组值作为参数。本质上来说2个都是遍历，那么我们是不是要写2个方法呢？</p><p>我们来看看jQuery的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype = &#123;</span><br><span class="line">    each: function( callback, args ) &#123;</span><br><span class="line">        return jQuery.each( this, callback, args );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例方法取于静态方法，换句话来说这是静态与实例方法共享设计，静态方法挂在jQuery构造器上，原型方法挂在哪里呢？</p><p>我们上节不是讲了内部会划分一个新的构造器init吗？jQuery通过new原型prototype上的init方法当作构造器，那么init的原型链方法就是实例的方法了，所以jQuery通过2个构造器划分2种不同的调用方式一种是静态，一种是原型。</p><p>方法是共享的，并且实例方法取于静态方法，2个构造器是完全隔离的 ,这个要如何处理？</p><p><strong>看看jQuery给的方案：</strong></p><p>画龙点睛的一处<code>init.prototype = jQuery.fn</code>，把jQuery.prototype原型的引用赋给jQuery.fn.init.prototype的原型，这样就把2个构造器的原型给关联起来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">        name: <span class="string">'aaron'</span>,</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.selector = selector; <span class="comment">//表示疑问???循环调用问题</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn.init.prototype = ajQuery.fn</span><br></pre></td></tr></table></figure><p>这段代码就是整个结构设计的最核心的东西了，有这样的一个处理，整个结构就活了！不得不佩服作者的设计思路，别具匠心。</p><p>看看init的的构造图：</p><p><a href="http://img.mukewang.com/540905880001daac05540230.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/540905880001daac05540230.jpg" alt="img"></a></p><p>通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。</p><h2>方法链式调用的实现</h2><p>jQuery的核心理念是Write less,Do more(写的更少,做的更多)，那么链式方法的设计与这个核心理念不谋而合。那么从深层次考虑这种设计其实就是一种Internal DSL。</p><p>DSL是指Domain Specific Language，也就是用于描述和解决特定领域问题的语言。</p><p>我们看一段链式代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input[type="button"]'</span>)</span><br><span class="line">    .eq(<span class="number">0</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'点击我!'</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">1</span>)</span><br><span class="line">.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'input[type="button"]:eq(0)'</span>).trigger(<span class="string">'click'</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">2</span>)</span><br><span class="line">.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.aa'</span>).hide(<span class="string">'slow'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.aa'</span>).show(<span class="string">'slow'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看这个代码的结构，我们或多或少都能猜到其含义：</p><p>☑  找出type类型为button的input元素</p><p>☑  找到第一个按钮，并绑定click事件处理函数</p><p>☑  返回所有按钮，再找到第二个</p><p>☑  为第二个按钮绑定click事件处理函数</p><p>☑  为第三个按钮绑定toggle事件处理函数</p><p>那么可见jQuery的Internal DSL形式带来的好处——编写代码时，让代码更贴近作者的思维模式；阅读代码时，让读者更容易理解代码的含义；应用DSL可以有效的提高系统的可维护性（缩小了实现模型和领域模型的距离，提高了实现的可读性）和灵活性，并且提供开发的效率。</p><p>jQuery的这种管道风格的DSL链式代码，总的来说：</p><p>☑  节约JS代码；</p><p>☑  所返回的都是同一个对象，可以提高代码的效率。</p><p>通过简单扩展原型方法并通过<code>return this</code>的形式来实现跨浏览器的链式调用。利用JS下的简单工厂方法模式，来将所有对于同一个DOM对象的操作指定同一个实例。</p><p>这个原理就超简单了,如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aQuery().init().name()</span><br></pre></td></tr></table></figure><p>分解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = aQuery();</span><br><span class="line">a.init()</span><br><span class="line">a.name()</span><br></pre></td></tr></table></figure><p>把代码分解一下，很明显实现链式的基本条件就是要实例对象先创建好，调用自己的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aQuery.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们如果需要链式的处理，只需要在方法内部方法当前的这个实例对象this就可以了，因为返回当前实例的this，从而又可以访问自己的原型了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。但是这种方法有一个问题是：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。</p><p>虽然Javascript是无阻塞语言，但是他并不是没阻塞，而是不能阻塞，所以他需要通过事件来驱动，异步来完成一些本需要阻塞进程的操作，这样处理只是同步链式，除了同步链式还有异步链式，异步链式jQuery从1.5开始就引入了<strong>Promise,jQuery.Deferred</strong>后期再讨论。</p><h2>插件接口的设计</h2><p>如果jQuery没有插件接口的设计，那么他就像个光杆司令没有兵，就是没有手下，只有自己一个封闭的城堡。因此jQuery城堡需要设计一个大门 - 插件接口，从而打开大门开始招兵买马。当然jQuery除了获得“开发者社区”的大力支持外，也有很多大公司纷纷对它投出了橄榄枝，这也是它成功的关键。</p><p>基于插件接口设计的好处也是颇多的，其中一个最重要的好处是把扩展的功能从主体框架中剥离出去，降低了框架的复杂度。接口的设计好比电脑上的配件如：CPU、内存、硬盘都是作为独立的模块分离出去了，但是主板提供模块的接口，例如支持串口的硬盘，我只要这个硬盘的接口能插上，甭管是500G还是1000G的容量的硬盘，都能使用。所以在软件设计中插件接口的提供把独立的功能与框架以一种很宽松的方式松耦合。</p><p>从之前的分析中我们可以知道jQuery对象的原理，所以一般来说，<strong>jQuery插件的开发分为两种：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☑  一种是挂在jQuery命名空间下的全局函数，也可称为静态方法；</span><br><span class="line"></span><br><span class="line">☑  另一种是jQuery对象级别的方法，即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法。</span><br></pre></td></tr></table></figure><p>提供的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.extend(target, [object1], [objectN])</span><br></pre></td></tr></table></figure><p>接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    removeData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    removeData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jQuery的主体框架就是之前提到的那样，通过<strong>工厂模式</strong>返回一个内部的init构造器生成的对象。但是根据一般设计者的习惯，如果要为jQuery添加静态方法或者实例方法从封装的角度讲是应该提供一个统一的接口才符合设计的。</p><p>jQuery支持自己扩展属性，这个对外提供了一个接口，jQuery.fn.extend()来对对象增加方法，从jQuery的源码中可以看到，jQuery.extend和jQuery.fn.extend其实是同指向同一方法的不同引用。</p><p>这里有一个设计的重点，通过调用的上下文，我们来确定这个方法是作为静态还是实例处理，在javascript的世界中一共有四种上下文调用方式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☑  jQuery.extend调用的时候上下文指向的是jQuery构造器</span><br><span class="line"></span><br><span class="line">☑  jQuery.fn.extend调用的时候上下文指向的是jQuery构造器的实例对象了</span><br></pre></td></tr></table></figure><p>通过extend()函数可以方便快速的扩展功能，不会破坏jQuery的原型结构，jQuery.extend = jQuery.fn.extend = function(){…}; 这个是连等，也就是2个指向同一个函数，怎么会实现不同的功能呢？这就是<strong>this</strong>力量了！</p><p>fn与jQuery其实是2个不同的对象，在之前有讲解：jQuery.extend 调用的时候，this是指向jQuery对象的(jQuery是函数，也是对象)，所以这里扩展在jQuery上。而jQuery.fn.extend 调用的时候，this指向fn对象，jQuery.fn 和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象。这里增加的是原型方法，也就是对象方法了。所以jQuery的API中提供了以上2个扩展函数。</p><p>jQuery的extend代码实现比较长，我们简单说一下重点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">aAron.extend = aAron.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options, src, copy,</span><br><span class="line">        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        length = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个参数，就是对jQuery自身的扩展处理</span></span><br><span class="line">    <span class="comment">//extend,fn.extend</span></span><br><span class="line">    <span class="keyword">if</span> (i === length) &#123;</span><br><span class="line">        target = <span class="keyword">this</span>; <span class="comment">//调用的上下文对象jQuery/或者实例</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//从i开始取参数,不为空开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">                copy = options[name];</span><br><span class="line">                <span class="comment">//覆盖拷贝</span></span><br><span class="line">                target[name] = copy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我来讲解一下上面的代码：因为extend的核心功能就是通过扩展收集功能（类似于mix混入），所以就会存在收集对象（target）与被收集的数据，因为jQuery.extend并没有明确实参，而且是通过arguments来判断的，所以这样处理起来很灵活。arguments通过判断传递参数的数量可以实现函数重载。其中最重要的一段<code>target = this</code>，通过调用的方式我们就能确实当前的this的指向，所以这时候就能确定target了。最后就很简单了，通过for循环遍历把数据附加到这个target上了。当然在这个附加的过程中我们还可以做<strong>数据过滤、深拷贝</strong>等一系列的操作了。</p><h2>回溯处理的设计</h2><p>接下来了解jQuery对DOM进行遍历背后的工作机制，这样可以在编写代码时有意识地避免一些不必要的重复操作，从而提升代码的性能。</p><p><strong>关于jQuery对象的包装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var $aaron = $(&quot;aaron&quot;);</span><br></pre></td></tr></table></figure><p>通过对sizzle的分析，我们可以得知Query选择器最终都是通过DOM接口实现取值的, 但是通过jQuery处理后返回的不仅仅只有DOM对象，而是一个包装容器，返回jQuery对象：$aaron。</p><p>我们来看一下代码：</p><p><img src="http://img.mukewang.com/54090d3400019da004300314.jpg" alt="img"></p><p><strong>在jQuery</strong>对象中<strong><strong>有个prevObject</strong></strong>对象，这个是干嘛用的呢?</p><p>如果你想知道prevObject是做什么的，咱们首先得先来了解一下jQuery对象栈，jQuery内部维护着一个jQuery对象栈。每个遍历方法都会找到一组新元素（一个jQuery对象），然后jQuery会把这组元素推入到栈中。</p><p>而每个jQuery对象都有三个属性：context、selector和prevObject，其中的prevObject属性就指向这个对象栈中的前一个对象，而通过这个属性可以回溯到最初的DOM元素集中。</p><p>为了方便理解，我们做几个简单的测试：</p><p>下面有一个父元素ul,嵌套了一个li节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;aaron&quot;&gt;</span><br><span class="line">    parent</span><br><span class="line">    &lt;li&gt;child&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>我们现给li绑定一个事件，这个很简单，找到ul下面的li，绑定即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var aaron = $(&quot;#aaron&quot;);</span><br><span class="line">    aaron.find(&apos;li&apos;).click(function()&#123;</span><br><span class="line">        alert(1);     //1</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>此时我又想给父元素绑定一个事件，我们是不是又要在aaron上绑定一次事件呢？是的，上面代码通过find处理后，此时的上下文是指向每一个li了,所以必须要重新引用aaron元素（li的父元素），然后再绑定click事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron.click(function()&#123;</span><br><span class="line">      alert(2);     //1</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>这样会不会很麻烦，所以jQuery引入一个简单的内部寻址的机制，可以回溯到之前的Dom元素集合，通过end()方法可以实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaron.find(<span class="string">'li'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">&#125;).end().click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jQuery为我们操作这个内部对象栈提供个非常有用的2个方法</p><p>.end()</p><p>.addBack()</p><p>这里需要指出来可能有些API上是andSelf，因为就Query的api是这样写的，andSelf现在是.addBack()的一个别名。在jQuery1.8和更高版本中应使用.addBack()</p><p>源码其实也是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.andSelf = jQuery.fn.addBack;</span><br></pre></td></tr></table></figure><p>调用第一个方法只是简单地弹出一个对象（结果就是回到前一个jQuery对象）。第二个方法更有意思，调用它会在栈中回溯一个位置，然后把两个位置上的元素集组合起来，并把这个新的、组合之后的元素集推入栈的上方。</p><p>利用这个DOM元素栈可以减少重复的查询和遍历的操作，而减少重复操作也正是优化jQuery代码性能的关键所在。</p><h2>end与addBack</h2><p>大多数jQueryDOM遍历方法来操作jQuery对象实例，并创建一个新的对象，匹配一个不同的DOM元素集合。当发生这种情况时，实际上是新的元素集合被压入到对象内部维护的栈中。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end()进行出栈操作，来返回栈中的前一个状态。</p><p>假设页面上有几个列表项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"second"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>end()方法主要用于jQuery的链式属性中。当没有使用链式用法时，我们通常只是调用变量名上的前一个对象，所以我们不需要操作栈。</p><p>使用end()时，我们可以一次性调用所有需要的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;).end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>链式的原理就是要返回当前操作的上下文。</p><p>下面的代码是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;).find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>上面的代码因为上下文被切换了，所以执行find(‘bar’)时就出错了。</p><p>下面的代码是正确的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;,&apos;red&apos;).end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>首先在链式用法中只在第一个列表中查找样式为 foo 的项目，并将其背景色变成红色。然后end()返回调用find()之前的状态。因此，第二次 find() 将只会查找 <ul class="first"> 中的 ‘.bar’，而不是继续在<li class="foo">中进行查找，结果是将匹配到的元素的背景色变成绿色。上述代码的最终结果是：第一个列表中的第 1 和第 3 个列表项的背景色有颜色，而第二个列表中的任何项目都没有背景色。</li></ul></p><p><strong>总的来说：end方法就是回溯到上一个Dom合集,因此对于链式操作与优化，这个方法还是很有意义的。</strong></p><p><strong>源码实现</strong></p><p>既然是回溯到上一个DOM合集，那么肯定end方法中返回的就是一个jQuery对象了，所以我们看源码其实就是返回prevObject对象了，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">end: function() &#123;</span><br><span class="line">     return this.prevObject || this.constructor(null);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>prevObject在什么情况下会产生？</strong></p><p>在构建jQuery对象的时候，通过pushStack方法构建，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    find: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...........................省略................................</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过sizzle选择器，返回结果集</span></span><br><span class="line">        jQuery.find(selector, self[i], ret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed because $( selector, context ) becomes $( context ).find( selector )</span></span><br><span class="line">        ret = <span class="keyword">this</span>.pushStack(len &gt; <span class="number">1</span> ? jQuery.unique(ret) : ret);</span><br><span class="line">        ret.selector = <span class="keyword">this</span>.selector ? <span class="keyword">this</span>.selector + <span class="string">" "</span> + selector : selector;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过jQuery.find后得到了结果ret这个就是通过纯的DOM节点，那么如果变成一个jQuery对象呢？</p><p>接着我们看pushStack对象，作用就通过新的DOM元素去创建一个新的jQuery对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pushStack: function( elems ) &#123;</span><br><span class="line">    // Build a new jQuery matched element set</span><br><span class="line">    var ret = jQuery.merge( this.constructor(), elems );</span><br><span class="line"></span><br><span class="line">    // Add the old object onto the stack (as a reference)</span><br><span class="line">    ret.prevObject = this;</span><br><span class="line">    ret.context = this.context;</span><br><span class="line"></span><br><span class="line">    // Return the newly-formed element set</span><br><span class="line">    return ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>流程解析：</strong></p><p>1、首先构建一个新的jQuery对象，因为constructor是指向构造器的，所以这里就等同于调用jQuery()方法了，返回了一个新的jQuery对象；</p><p>2、然后用jQuery.merge语句把elems节点合并到新的jQuery对象上；</p><p>3、最后给返回的新jQuery对象添加prevObject属性，我们看到prevObject其实还是当前jQuery的一个引用罢了，所以也就是为什么通过prevObject能取到上一个合集的原因了。</p><h2>仿栈与队列的操作</h2><p>jQuery既然是模仿的数组结构，那么肯定会实现一套类数组的处理方法，比如常见的栈与队列操作push、pop、shift、unshift、求和、遍历循环each、排序及筛选等一系的扩展方法。</p><p>jQuery对象栈是一个便于Dom的查找，提供的一系列方法，jQuery可以是集合元素，那么我们怎么快速的找到集合中对应的目标元素呢？</p><p>jQuery提供了.get()、:index()、 :lt()、:gt()、:even()及 :odd()这类索引值相关的选择器，他们的作用可以过滤他们前面的匹配表达式的集合元素，筛选的依据就是这个元素在原先匹配集合中的顺序。</p><p>我们来分别看一下这几个选择器的实现原理:</p><p>get方法–是通过检索匹配jQuery对象得到对应的DOM元素，如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get: function(num) &#123;</span><br><span class="line">    return num != null ?</span><br><span class="line">    // Return just the one element from the set</span><br><span class="line">    (num &lt; 0 ? this[num + this.length] : this[num]) :</span><br><span class="line">    // Return all the elements in a clean array</span><br><span class="line">    slice.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，因为jQuery查询出来的是一个数组的DOM集合，所以就可以按照数组的方法通过下标的索引取值，当然如果num的值超出范围，比如小于元素数量的负数或等于或大于元素的数量的数，那么它将返回undefined。 假设我们页面上有一个简单的无序列表，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li id=&quot;foo&quot;&gt;foo&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;bar&quot;&gt;bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果指定了index参数，.get()则会获取单个元素，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( $( &quot;li&quot; ).get( 0 ) );</span><br></pre></td></tr></table></figure><p>由于索引 index 是以 0 开始计数的，所以上面代码返回了第一个列表项<code>foo</code>。</p><p>然而，这种语法缺少某些 .get() 所具有的附加功能，比如可以指定索引值为负值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( $( &quot;li&quot; ).get(-1) );</span><br></pre></td></tr></table></figure><p>负的索引值表示从匹配的集合中从末尾开始倒数，所以上面这个例子将会返回列表中最后一项：<code>bar</code>。</p><p>由于是数组的关系，所以我们有几个快速方法，比如头跟尾的取值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first: function() &#123;</span><br><span class="line">    return this.eq( 0 );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">last: function() &#123;</span><br><span class="line">    return this.eq(-1);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>get与eq的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.eq()  减少匹配元素的集合，根据index索引值，精确指定索引对象。</span><br><span class="line">.get() 通过检索匹配jQuery对象得到对应的DOM元素。</span><br></pre></td></tr></table></figure><p><strong>同样是返回元素，那么eq与get有什么区别呢？</strong></p><p>eq返回的是一个jQuery对象，get返回的是一个DOM对象。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( &quot;li&quot; ).get( 0 ).css(&quot;color&quot;, &quot;red&quot;); //错误</span><br><span class="line">$( &quot;li&quot; ).eq( 0 ).css(&quot;color&quot;, &quot;red&quot;); //正确</span><br></pre></td></tr></table></figure><p>get方法本质上是把jQuery对象转换成DOM对象，但是css属于jQuery构造器的，DOM是不存在这个方法的，如果需要用jQuery的方法，我们必须这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var li = $( &quot;li&quot; ).get( 0 );</span><br><span class="line">$( li ).css(&quot;color&quot;, &quot;red&quot;); //用$包装</span><br></pre></td></tr></table></figure><p>取出DOM对象li，然后用$再次包装，使之转变成jQuery对象，才能调用css方法，这样要分2步写太麻烦了，所以jQuery给我们提供了一个便捷方法eq()。</p><p>eq()的实现原理就是在上面代码中的把eq方法内部转成jQuery对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eq: function( i ) &#123;</span><br><span class="line">    var len = this.length,</span><br><span class="line">        j = +i + ( i &lt; 0 ? len : 0 );</span><br><span class="line">    return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );</span><br></pre></td></tr></table></figure><p>上面实现代码的逻辑就是跟get是一样的，区别就是通过了pushStack产生了一个新的jQuery对象。</p><p>jQuery的考虑很周到，通过eq方法只能产生一个新的对象，但是如果需要的是一个合集对象要怎么处理？因此jQuery便提供了一个slice方法：</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.slice( start [, end ] )</span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><p>根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。</p><p>因为是数组对象，意味着我们可以用silce来直接取值了，所以针对合集对象我们可以这样写代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = []</span><br><span class="line">arr.push( this.slice(start[,end]) )     </span><br><span class="line">this.pushStack（arr）</span><br></pre></td></tr></table></figure><p>这个this指的是jQuery对象，因为jQuery对象是数组集合，所以我们可以通过原生的silce方法直接取到集合数，然后通过包装处理即可了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice: function() &#123;</span><br><span class="line">    return this.pushStack( slice.apply( this, arguments ) );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>迭代器</h2><p><strong>迭代器是一个框架的重要设计。我们经常需要提供一种方法顺序用来处理聚合对象中各个元素，而又不暴露该对象的内部，这也是设计模式中的迭代器模式(Iterator)。</strong></p><p>jQuery中的$.each方法就是一个典型的迭代器，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.each([<span class="number">52</span>, <span class="number">97</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">  alert(index + <span class="string">': '</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">$( <span class="string">"li"</span> ).each(<span class="function"><span class="keyword">function</span>(<span class="params"> index </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( index + <span class="string">": "</span><span class="string">" + $(this).text() );</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><p>针对迭代器，这里有几个特点：</p><p>☑ 访问一个聚合对象的内容而无需暴露它的内部。</p><p>☑ 为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</p><p>☑ 遍历的同时更改迭代器所在的集合结构可能会导致问题。</p><p>简单的说：封装实现，然后迭代器的聚合对象不用关心迭代的过程，从而符合SRP原则。</p><p>抛开jQuery的each方法，我们自己实现一个有简单的迭代器功能的代码：</p><p>1、简单回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> length = obj.length;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        callback(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">each(arr, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就满足了迭代模式的设计原则，对于集合内部结果常常变化各异，我们不想暴露其内部结构，但又想让客户代码透明地访问其中的元素，通过回调把逻辑给解耦出来。但是这样的处理其实太简单了，我们还要考虑至少四种情况：</p><p>☑ 聚合对象，可能是对象，字符串或者数组等类型</p><p>☑ 支持参数传递</p><p>☑ 支持上下文的传递</p><p>☑ 支持循环中退出</p><p>我们简单的修改一下上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function each(obj, callback, context, arg) &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    var value;</span><br><span class="line">    var length = obj.length;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">        callback.call(context || null, obj[i], arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">each(arr, function(name, arg) &#123;</span><br><span class="line">    console.log(name, arg ,this);</span><br><span class="line">&#125;, this, &apos;aaa&apos;)</span><br></pre></td></tr></table></figure><p>当然根据回调的处理，从而判断是否要立刻中断这个循环，从而节约性能，也是很简单的，我们可以通过获取处理的返回值来处理，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function each(obj, callback, context, arg) &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    var value;</span><br><span class="line">    var length = obj.length;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">        value = callback.call(context || null, obj[i], arg);</span><br><span class="line">        if (value === false) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见只要通过回调函数callback返回的ture/false的布尔值结果就可以来判断当前是否要强制退出循环。</p><h2>jQuery的each迭代器</h2><p>jQuery的each方法从使用上就要分2种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☑ $.each()函数</span><br><span class="line">☑ $(selector).each()</span><br></pre></td></tr></table></figure><p>$.each()函数和$(selector).each()是不一样的，后者是专门用来遍历一个jQuery对象的，是为jQuery内部服务的。</p><p>$.each()函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次传递一个数组索引和相应的数组值作为参数。（该值也可以通过访问this关键字得到，但是JavaScript始终将this值作为一个Object，即使它是一个简单的字符串或数字值。）该方法返回其第一个参数，这是迭代的对象。</p><p>jQuery的实例方法最终也是调用的静态方法，我们在之前就解释过jQuery的实例与原型方法共享的设计。</p><p>其中each的实例方法如下：</p><p>可见内部是直接调用的静态方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">each: function(callback, args) &#123;</span><br><span class="line">    return jQuery.each(this, callback, args);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>jQuery.each静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">obj, callback, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        length = obj.length,</span><br><span class="line">        isArray = isArraylike(obj);</span><br><span class="line">    <span class="keyword">if</span> (args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">                value = callback.apply(obj[i], args);</span><br><span class="line">                <span class="keyword">if</span> (value === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                value = callback.apply(obj[i], args);</span><br><span class="line">                <span class="keyword">if</span> (value === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>实现原理几乎一致，只是增加了对于参数的判断。对象用for in遍历，数组用for遍历。</p><p>jQuery可以是多个合集数组DOM，所以在处理的时候经常就针对每一个DOM都要单独处理，所以一般都需要调用this.each 方法，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dequeue: function( type ) &#123;</span><br><span class="line">        return this.each(function() &#123;</span><br><span class="line">            jQuery.dequeue( this, type );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>迭代器除了单纯的遍历，在jQuery内部的运用最多的就是接口的<strong>抽象合并</strong>，相同功能的代码功能合并处理：</p><p>例如一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">    class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(&#123;</span><br><span class="line">    mouseenter: &quot;mouseover&quot;,</span><br><span class="line">    mouseleave: &quot;mouseout&quot;,</span><br><span class="line">    pointerenter: &quot;pointerover&quot;,</span><br><span class="line">    pointerleave: &quot;pointerout&quot;</span><br><span class="line">&#125;, function( orig, fix ) &#123;</span><br><span class="line">    //处理的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JQuery源码解读 01</title>
      <link href="/JQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2001.html"/>
      <content type="html"><![CDATA[<h2>简介</h2><p>从整体入手理解架构，再深入攻破每个依赖模块，包括回调函数、异步加载、数据缓存、动画队列最后整体分析：选择器、DOM处理、AJAX、动画模块、事件</p><a id="more"></a><h2>jQuery设计理念</h2><p>引用百科的介绍：</p><p>jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理<strong>HTML（标准通用标记语言下的一个应用）、events、实现动画效果</strong>，并且方便地为网站提供<strong>AJAX交互</strong>。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p><p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！</p><p><strong>简洁的API:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.on</span><br><span class="line">$.css</span><br><span class="line">$.ajax</span><br><span class="line">….</span><br></pre></td></tr></table></figure><p><strong>优雅的链式:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax( <span class="string">"example.php"</span> )</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"success"</span>); &#125;)</span><br><span class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"error"</span>); &#125;)</span><br><span class="line">    .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"complete"</span>); &#125;);</span><br></pre></td></tr></table></figure><p><strong>强大的选择器：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div, span, p.myClass"</span> )</span><br><span class="line">$(<span class="string">"div span:first-child"</span>)</span><br><span class="line">$(<span class="string">"tr:visible"</span>)</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><strong>便捷的操作：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).removeClass(<span class="string">"myClass noClass"</span>).addClass(<span class="string">"yourClass"</span>);</span><br><span class="line">$(<span class="string">"ul li:last"</span>).addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span><span class="string">"item-"</span> + index;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'.container'</span>).append($(<span class="string">'h2'</span>));</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><strong>为什么要做jQuery源码解析？</strong></p><p>虽然jQuery的文档很完善，潜意识降低了前端开发的入门的门槛，要实现一个动画随手拈来，只要简单的调用一个animate方法传递几个执行的参数即可，但如果要我们自己实现一个定制的动画呢？我们要考虑的问题太多太多了，浏览器兼容、各种属性的获取、逻辑流程、性能等等，这些才是前端开发的基础核心。</p><p>如果我们只知道使用jQuery，而不知道其原理，那就是“知其然,而不知其所以然”，说了这么多，那就赶快跟着慕课网进入“高大上”之旅吧，深入来探究jQuery的内部架构！</p><h2>jQuery整体架构</h2><p>任何程序代码不是一开始就复杂的，成功也不是一躇而蹴的，早期jQuery的作者John Resig在2005年提议改进Prototype的“Behaviour”库时，只是想让其使用更简单才发布新的jQuery框架。起初John Resig估计也没料想jQuery会如此的火热。我们可以看到从发布的第一个1.0开始到目前最新的2.1.1其代码膨胀到了9000多行，它兼容CSS3，还兼容各种浏览器，jQuery使用户能更方便地处理DOM、事件、实现动画效果，并且方便地为网站提供AJAX交互。</p><p>1、最新jQuery2.1.1版本的结构：</p><p>1、最新jQuery2.1.1版本的结构：代码请查看右侧代码编辑器（1-24行）</p><p>2、jQuery的模块依赖网：</p><p>2、jQuery的模块依赖网： <a href="http://img.mukewang.com/53fa8fec0001754806930473.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fa8fec0001754806930473.jpg" alt="img"></a></p><p>jQuery一共13个模块，从2.1版开始jQuery支持通过AMD模块划分，jQuery在最开始发布的1.0版本是很简单的，只有CSS选择符、事件处理和AJAX交互3大块。其发展过程中，有几次重要的变革：</p><ul><li>1.2.3 版发布，引入数据缓存，解决循环引用与大数据保存的问题</li><li>1.3 版发布，它使用了全新的选择符引擎Sizzle，在各个浏览器下全面超越其他同类型JavaScript框架的查询速度，程序库的性能也因此有了极大提升</li><li>1.5 版发布，新增延缓对像(Deferred Objects)，并用deferred重写了Ajax模块</li><li>1.7 版发布，抽象出回调对象，提供了强大的的方式来管理回调函数列表。</li></ul><p>每一次大的改进都引入了一些新的机制、新的特性，通过这些新的机制就造就了如今jQuery库，一共13个模块，模块不是单一的，比如jQuery动画，都会依赖异步队列、动画队列、回调队列与数据缓存模块等。</p><p>jQuery抽出了所有可复用的特性，分离出单一模块，通过组合的用法，不管在设计思路与实现手法上jQuery都是非常高明的。</p><h3>五大块：</h3><p>jQuery按我的理解分为五大块，选择器、DOM操作、事件、AJAX与动画，那么为什么有13个模块？因为jQuery的设计中最喜欢的做的一件事，就是抽出共同的特性使之“模块化”，当然也是更贴近S.O.L.I.D五大原则的“单一职责SRP”了，遵守单一职责的好处是可以让我们很容易地来维护这个对象，比如，当一个对象封装了很多职责的时候，一旦一个职责需要修改，势必会影响该对象的其它职责代码。通过解耦可以让每个职责更加有弹性地变化。</p><p>我们来看看jQuery文档针对业务层的Ajax的处理提供了一系列的门面接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.ajaxComplete()</span><br><span class="line">.ajaxError()</span><br><span class="line">.ajaxSend()</span><br><span class="line">.ajaxStart()</span><br><span class="line">.ajaxStop()</span><br><span class="line">.ajaxSuccess()</span><br></pre></td></tr></table></figure><p>底层接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax()</span><br><span class="line">jQuery.ajaxSetup()</span><br></pre></td></tr></table></figure><p>快捷方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jQuery.get()</span><br><span class="line">jQuery.getJSON()</span><br><span class="line">jQuery.getScript()</span><br><span class="line">jQuery.post()</span><br></pre></td></tr></table></figure><h3>jQuery接口的设计原理</h3><p>业务逻辑是复杂多变的，jQuery的高层API数量非常多，而且也非常的细致，这样做可以更友好的便于开发者的操作，不需要必须在一个接口上重载太多的动作。我们在深入内部看看Ajax的高层方法其实都是统一调用了一个静态的jQuery.ajax方法，</p><p>在jQuery.ajax的内部实现是非常复杂的，首先ajax要考虑异步的处理与回调的统一性，所以就引入了异步队列模块（Deferred）与回调模块（Callbacks）, 所以要把这些模块方法在ajax方法内部再次封装成、构建出一个新的jQXHR对象，针对参数的默认处理，数据传输的格式化等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">    factory(global);</span><br><span class="line">&#125;(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">window, noGlobal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;&#125;;</span><br><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line"><span class="comment">// 回调系统</span></span><br><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="comment">// 数据缓存</span></span><br><span class="line"><span class="comment">// 队列操作</span></span><br><span class="line"><span class="comment">// 选择器引</span></span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="comment">// 节点遍历</span></span><br><span class="line"><span class="comment">// 文档处理</span></span><br><span class="line"><span class="comment">// 样式操作</span></span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="comment">// 事件体系</span></span><br><span class="line"><span class="comment">// AJAX交互</span></span><br><span class="line"><span class="comment">// 动画引擎</span></span><br><span class="line"><span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2>立即调用表达式</h2><p>任何库与框架设计的第一个要点就是解决<strong>命名空间与变量污染</strong>的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p>jQuery的立即调用函数表达式的写法有三种：</p><p><strong>写法1：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, factory</span>) </span>&#123;</span><br><span class="line">    factory(<span class="built_in">window</span>)</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">//jQuery的调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>可以看出上面的代码中嵌套了2个函数，而且把一个函数作为参数传递到另一个函数中并且执行，这种方法有点复杂，我们简化一下写法：</p><p><strong>写法2：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jQuery = factory();</span><br></pre></td></tr></table></figure><p>上面的代码效果和方法1是等同的，但是这个factory有点变成了简单的<strong>工厂方法模式</strong>，需要自己调用，不像是一个单例的jQuery类，所以我们需要改成“自执行”，而不是另外调用。</p><p><strong>写法3：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>从上面的代码可看出，自动初始化这个函数，让其只构建一次。详细说一下这种写法的优势：</p><p><strong>1、</strong> <strong>window</strong>和<strong>undefined</strong>都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。</p><p><strong>2、<strong>undefined也是同样的道理，其实这个</strong>undefined</strong>并不是JavaScript数据类型的undefined，而是一个普普通通的变量名。只是因为没给它传递值，它的值就是undefined，undefined并不是JavaScript的保留字。</p><p>关于留言，为什么要传递undefined？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。</span><br></pre></td></tr></table></figure><p>我们看一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'ulson'</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">  alert(<span class="literal">undefined</span>);<span class="comment">//IE8 'ulson'</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>IE8存在这个问题，当然，大部分浏览器都是不能被修改的</p><p>如果函数调用不传递，参数默认就是undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//undefined</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p></p><p>####jQuery为什么要创建这样的一个外层包裹，其原理又是如何？</p><p>这里要区分2个概念一个是匿名函数，一个是自执行。顾名思义，匿名函数，就是没有函数名的函数，<strong>也就是不存在外部引用</strong>。但是是否像下面代码实现呢：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是错了，声明了它但是又不给名字又没有使用，所以在语法上错误的，那么怎么去执行一个匿名的函数呢？</p><p>要调用一个函数，我们必须要有方法定位它、引用它。所以，我们要取一个名字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表），那么这小括号能把我们的表达式组合分块，并且每一块（也就是每一对小括号），都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的，就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。</p><p>最后，我们回到写法1看看jQuery利用写法3的写法，然后把整个函数作为参数传递给另外一个函数，主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码，看看jQuery的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = global.document ?</span><br><span class="line">        factory(global, <span class="literal">true</span>) :</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!w.document) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"jQuery requires a window with a document"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> factory(w);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory(global);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：全局变量是魔鬼, 匿名函数可以有效的保证在页面上写入JavaScript，而不会造成全局变量的污染，通过小括号，让其加载的时候立即初始化，这样就形成了一个单例模式的效果从而只会执行一次。</p><h2>jQuery的类数组对象结构</h2><h4>为什么是类数组对象呢？</h4><p>很多人迷惑的jQuery为什么能像数组一样操作，通过对象get方法或者直接通过下标0索引就能转成DOM对象。</p><p>首先我们看jQuery的入口都是统一的$, 通过传递参数的不同，实现了9种方法的<strong>重载</strong>：</p><ol><li>jQuery([selector,[context]])</li><li>jQuery(element)</li><li>jQuery(elementArray)</li><li>jQuery(object)</li><li>jQuery(jQuery object)</li><li>jQuery(html,[ownerDocument])</li><li>jQuery(html,[attributes])</li><li>jQuery()</li><li>jQuery(callback)</li></ol><p>9种用法整体来说可以分三大块：选择器、dom的处理、dom加载。</p><p>换句话说jQuery就是为了获取DOM、操作DOM而存在的。所以为了更方便这些操作，让<strong>节点与实例对象</strong>通过一个桥梁给关联起来，jQuery内部就采用了一种叫“类数组对象”的方式作为存储结构，所以我们即可以像对象一样处理jQuery操作，也能像数组一样可以使用<strong>push、pop、shift、unshift、sort、each、map</strong>等类数组的方法操作jQuery对象了。</p><p><strong>jQuery对象可用数组下标索引是什么原理？</strong></p><p>通过<code>$(&quot;.Class&quot;)</code>构建的对象结构如下所示：</p><p><a href="http://img.mukewang.com/53fad4240001c7b805050236.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fad4240001c7b805050236.jpg" alt="img"></a></p><p><a href="http://img.mukewang.com/53fad4240001c7b805050236.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fad4240001c7b805050236.jpg" alt="img"></a>整个结构很明了，通过对象键值对的关系保存着属性，原型保存着方法。我们来简单的模拟一个这样的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://img.mukewang.com/down/540812440001e40e00000000.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">div&#123;<span class="attr">width</span>: <span class="number">30</span>px;height: <span class="number">10</span>px;float:left;&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;title&gt;data_structure&lt;/</span>title&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button id="test1"&gt;jQuey[0]&lt;/</span>button&gt;</span><br><span class="line">&lt;button id=<span class="string">"test2"</span>&gt;jQuey.get&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="test3"&gt;aQuery[0]&lt;/</span>button&gt;</span><br><span class="line">&lt;button id=<span class="string">"test4"</span>&gt;aQuery.get&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;p id="book"&gt;book&lt;/</span>p&gt;</span><br><span class="line">&lt;div id=<span class="string">"show1"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div id=<span class="string">"show2"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div id=<span class="string">"show3"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;div id=<span class="string">"show4"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//强制为对象</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> aQuery)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> aQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="regexp">/[^#].*/</span>.exec(selector)[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">0</span>] = elem;</span><br><span class="line"><span class="keyword">this</span>.context = <span class="built_in">document</span>;</span><br><span class="line"><span class="keyword">this</span>.selector = selector;</span><br><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是一个dom元素,可以把代码放到Google Chrome下运行</span></span><br><span class="line"><span class="comment">//按F12通过调试命令 console.log() 打印出对象</span></span><br><span class="line">$(<span class="string">"#test1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show1'</span>).append($(<span class="string">'#book'</span>)[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show2'</span>).append($(<span class="string">'#book'</span>).get(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show3'</span>).append(aQuery(<span class="string">"#book"</span>)[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test4"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show4'</span>).append(aQuery(<span class="string">"#book"</span>).get(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>以上是模拟jQuery的对象结构，通过aQuery方法抽象出了对象创建的具体过程，这也是软件工程领域中的广为人知的设计模式-工厂方法。</p><h3>jQuery的无new构建原理</h3><p>函数<strong>aQuery()<strong>内部首先保证了必须是通过</strong>new</strong>操作符构建。这样就能保证当前构建的是一个带有<strong>this</strong>的实例对象，既然是对象我们可以把所有的属性与方法作为对象的<strong>key</strong>与<strong>value</strong>的方式给映射到<strong>this</strong>上，所以如上结构就可以模拟出jQuery的这样的操作了，即可通过索引取值，也可以链式方法取值，但是这样的结构是有很大的缺陷的，每次调用<strong>ajQuery</strong>方法等于是创建了一个新的实例，那么类似<strong>get</strong>方法就要在每一个实例上重新创建一遍，性能就大打折扣，所以jQuery在结构上的优化不仅仅只是我们看到的，除了实现类数组结构、方法的原型共享，而且还实现方法的静态与实例的共存，这是我们之后将会重点分析的。</p><h2>jQuery中ready与load事件</h2><p>jQuery有3种针对文档加载的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//document ready 简写</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>一个是ready一个是load，这两个到底有什么区别呢？</strong></p><p>ready与load谁先执行：</p><p>ready与load谁先执行：大家在面试的过程中，经常会被问到一个问题：ready与load那一个先执行，那一个后执行？答案是<strong>ready先执行，load后执行</strong>。</p><p><strong>DOM文档加载的步骤：</strong></p><p><strong>DOM文档加载的步骤：</strong>要想理解为什么ready先执行，load后执行就要先了解下DOM文档加载的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 解析HTML结构。</span><br><span class="line">(2) 加载外部脚本和样式表文件。</span><br><span class="line">(3) 解析并执行脚本代码。</span><br><span class="line">(4) 构造HTML DOM模型。//ready</span><br><span class="line">(5) 加载图片等外部文件。</span><br><span class="line">(6) 页面加载完毕。//load</span><br></pre></td></tr></table></figure><p>从上面的描述中大家应该已经理解了吧，ready在第（4）步完成之后就执行了，但是load要在第（6）步完成之后才执行。</p><p><strong>结论：</strong></p><p>ready与load的区别就在于资源文件的加载，ready构建了基本的DOM结构，所以对于代码来说应该越快加载越好。在一个高速浏览的时代，没人愿意等待答案。假如一个网站页面加载超过4秒，不好意思，你1/4的用户将面临着流失，所以对于框架来说用户体验是至关重要的，我们应该越早处理DOM越好，我们不需要等到图片资源都加载后才去处理框架的加载，图片资源过多load事件就会迟迟不会触发。</p><p>我们看看jQuery是如何处理文档加载时机的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ready.promise = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !readyList ) &#123;</span><br><span class="line">        readyList = jQuery.Deferred();</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">document</span>.readyState === <span class="string">"complete"</span> ) &#123;</span><br><span class="line">            <span class="comment">// Handle it asynchronously to allow scripts the opportunity to delay ready</span></span><br><span class="line">            setTimeout( jQuery.ready );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, completed, <span class="literal">false</span> );</span><br><span class="line">            <span class="built_in">window</span>.addEventListener( <span class="string">"load"</span>, completed, <span class="literal">false</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readyList.promise( obj );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>jQuery的ready是通过promise给包装过的，这也是jQuery擅长的手法，统一了回调体系，以后我们会重点谈到。</p><p>可见jQuery兼容的具体策略**：针对高级的浏览器，我们当前很乐意用DOMContentLoaded事件了，省时省力。**</p><p><strong>那么旧的IE如何处理呢？</strong></p><p>继续看jQuery的方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ensure firing before onload, maybe late but safe also for iframes</span></span><br><span class="line"><span class="built_in">document</span>.attachEvent( <span class="string">"onreadystatechange"</span>, completed );</span><br><span class="line"><span class="comment">// A fallback to window.onload, that will always work</span></span><br><span class="line"><span class="built_in">window</span>.attachEvent( <span class="string">"onload"</span>, completed );</span><br><span class="line"><span class="comment">// If IE and not a frame</span></span><br><span class="line"><span class="comment">// continually check to see if the document is ready</span></span><br><span class="line"><span class="keyword">var</span> top = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    top = <span class="built_in">window</span>.frameElement == <span class="literal">null</span> &amp;&amp; <span class="built_in">document</span>.documentElement;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ( top &amp;&amp; top.doScroll ) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">doScrollCheck</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !jQuery.isReady ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Use the trick by Diego Perini</span></span><br><span class="line">                <span class="comment">// http://javascript.nwbox.com/IEContentLoaded/</span></span><br><span class="line">                top.doScroll(<span class="string">"left"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                <span class="keyword">return</span> setTimeout( doScrollCheck, <span class="number">50</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// detach all dom ready events</span></span><br><span class="line">            detach();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// and execute any waiting functions</span></span><br><span class="line">            jQuery.ready();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果浏览器存在 <code>document.onreadystatechange</code> 事件，当该事件触发时，如果 <code>document.readyState=complete</code> 的时候，可视为 DOM 树已经载入。不过，这个事件不太可靠，比如当页面中存在图片的时候，可能反而在 onload 事件之后才能触发，换言之，它只能正确地执行于页面不包含二进制资源或非常少或者被缓存时作为一个备选吧。</p><h4>针对IE的加载检测</h4><p>DOMContent文章参考：<a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/" target="_blank" rel="noopener">JS、CSS以及img对DOMContentLoaded事件的影响</a>Diego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用，详情可见http://javascript.nwbox.com/IEContentLoaded/。原理就是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在上述中间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。结论：所以总的来说当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了。</p><p>这都是我们在第一时间内处理ready加载的问题，如果ready在页面加载完毕后呢？</p><p>jQuery就必须针对这样的情况跳过绑定了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">document</span>.readyState === <span class="string">"complete"</span> ) &#123;</span><br><span class="line">     <span class="comment">// Handle it asynchronously to allow scripts the opportunity to delay ready</span></span><br><span class="line">     setTimeout( jQuery.ready );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接通过查看readyState的状态来确定页面的加载是否完成了。这里会给一个定时器的最小时间后去执行，主要保证执行的正确。</p><h2>jQuery多库共存处理</h2><p>多库共存换句话说可以叫无冲突处理。</p><p>总的来说会有2种情况会遇到：</p><ol><li><p>$太火热，jQuery采用$作为命名空间，不免会与别的库框架或者插件相冲突。</p></li><li><p>jQuery版本更新太快，插件跟不上，导致不同版本对插件的支持度不一样。</p></li></ol><p>出于以上的原因，jQuery给出了解决方案–– noConflict函数。</p><p>引入jQuery运行这个noConflict函数将变量$的控制权让给第一个实现它的那个库，确保jQuery不会与其他库的$对象发生冲突。</p><p>在运行这个函数后，就只能使用jQuery变量访问jQuery对象。例如，在要用到$(“aaron”)的地方，就必须换成jQuery(“aaron”)，因为$的控制权已经让出去了。</p><p>使用DEMO：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line"><span class="comment">// 使用 jQuery</span></span><br><span class="line">jQuery(<span class="string">"aaron"</span>).show();</span><br><span class="line"><span class="comment">// 使用其他库的 $()</span></span><br><span class="line">$(<span class="string">"aaron"</span>).style.display = ‘block’;</span><br></pre></td></tr></table></figure><p>这个函数必须在你导入jQuery文件之后，并且在导入另一个导致冲突的库之前使用。当然也应当在其他冲突的库被使用之前，除非jQuery是最后一个导入的。</p><p>由于比较简单，我们直接上代码解说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Var _jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line">    _$ = <span class="built_in">window</span>.$;</span><br><span class="line"></span><br><span class="line">jQuery.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"> deep </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.$ === jQuery ) &#123;</span><br><span class="line">        <span class="built_in">window</span>.$ = _$;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> ( deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery ) &#123;</span><br><span class="line">        <span class="built_in">window</span>.jQuery = _jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们需要同时使用jQuery和其他JavaScript库，我们可以使用 $.noConflict()把$的控制权交给其他库。旧引用的$ 被保存在jQuery的初始化; noConflict() 简单的恢复它们。</p><p>通过类似swap交换的概念，先把之前的存在的命名空间给缓存起来，通过对比当前的命名空间达到交换的目的，首先，我们先判断下当前的的$空间是不是被jQuery接管了，如果是则让出控制权给之前的_$引用的库，如果传入deep为true的话等于是把jQuery的控制权也让出去了。    如果不通过noConflict处理的话其后果可想而知，香喷喷的$大家都“觊觎已久”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://img.mukewang.com/down/540812440001e40e00000000.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>多库共存<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aaron"</span>&gt;</span>测试noConflict效果<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#aaron"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.noConflict(); <span class="comment">//让出控制权</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!$) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"使用noConflict后，$不存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (jQuery) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"使用noConflict后，jQuery存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//通过闭包隔离出$</span></span></span><br><span class="line"><span class="javascript">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> ($) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"通过闭包隔离后，转为局部变量$存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)(jQuery);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    jQuery(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
