<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>JUMP少年周刊-最全漫画排行榜</title>
      <link href="/2018/02/24/JUMP%E5%B0%91%E5%B9%B4%E5%91%A8%E5%88%8A-%E6%9C%80%E5%85%A8%E6%BC%AB%E7%94%BB%E6%8E%92%E8%A1%8C%E6%A6%9C/"/>
      <content type="html"><![CDATA[<p>其中，一些台词我们仍记忆犹新诸如</p><p>龟–派--汽–功  $\quad \Rightarrow $ 七龙珠<br>你已经死了      $\quad \Rightarrow $北斗神拳<br>教练我想打篮球！ $\quad \Rightarrow $灌篮高手<br>燃烧吧，小宇宙   $\quad \Rightarrow $圣斗士星矢<br>海贼王，我当定了 $\quad \Rightarrow $One Peice<br></p><p>JUMP的连载原则：把在十话内没有得到读者青睐的漫画统统砍掉，并要求高人气作品不准完结，要不顾剧情发展的连载下去。虽然，这样的的条款压抑了创作者空间，但是作为一个企业来说，JUMP以这样的原则给我们呈现了数不清的优秀作品，也获得了巨大的商业成功，稳居日本漫画龙头地位。</p><table><thead><tr><th style="text-align:center">排行</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th><th style="text-align:center">漫画</th><th style="text-align:center">作者</th><th style="text-align:center">连载年度</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>香蕉时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>奇异果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"><em>芒果时代</em></td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center">No.1</td><td style="text-align:center"><strong>破廉耻学园</strong></td><td style="text-align:center">永井 豪</td><td style="text-align:center">1968-1972</td><td style="text-align:center"><strong>七龙珠</strong></td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1984-1995</td><td style="text-align:center"><strong>海贼王</strong></td><td style="text-align:center">尾田荣一郎</td><td style="text-align:center">2000-2013</td></tr><tr><td style="text-align:center">No.2</td><td style="text-align:center">根性青蛙</td><td style="text-align:center">吉泽保美</td><td style="text-align:center">1970-1976</td><td style="text-align:center">筋肉人</td><td style="text-align:center">蚵仔煎</td><td style="text-align:center">1979-1987</td><td style="text-align:center"><strong>全职猎人</strong></td><td style="text-align:center">富坚 义博</td><td style="text-align:center">1998-</td></tr><tr><td style="text-align:center">No.3</td><td style="text-align:center"><strong>乌龙派出所</strong></td><td style="text-align:center">秋本 治</td><td style="text-align:center">1976-2016</td><td style="text-align:center"><strong>灌篮高手</strong></td><td style="text-align:center">井上 雄彦</td><td style="text-align:center">1990-1996</td><td style="text-align:center"><strong>火影忍者</strong></td><td style="text-align:center">岸本 齐史</td><td style="text-align:center">1999-2013</td></tr><tr><td style="text-align:center">No.4</td><td style="text-align:center">魔投手</td><td style="text-align:center">梶原一骑</td><td style="text-align:center">1971-1974</td><td style="text-align:center"><strong>北斗神拳</strong></td><td style="text-align:center">武论尊</td><td style="text-align:center">1983-1988</td><td style="text-align:center"><strong>美食的俘虏</strong></td><td style="text-align:center">岛袋 光年</td><td style="text-align:center">2008-2016</td></tr><tr><td style="text-align:center">No.5</td><td style="text-align:center"><strong>男儿当大将</strong></td><td style="text-align:center">本宫</td><td style="text-align:center">1968-1973</td><td style="text-align:center">城市猎人</td><td style="text-align:center">北条司</td><td style="text-align:center">1985-1991</td><td style="text-align:center">死神</td><td style="text-align:center">久保 带人</td><td style="text-align:center">2001-2016</td></tr><tr><td style="text-align:center">No.6</td><td style="text-align:center">阿拉蕾</td><td style="text-align:center">鸟山 明</td><td style="text-align:center">1980-1984</td><td style="text-align:center"><strong>足球小将</strong></td><td style="text-align:center">高桥 阳一</td><td style="text-align:center">1981-1988</td><td style="text-align:center"><strong>棋魂</strong></td><td style="text-align:center">堀田由美</td><td style="text-align:center">1999-2003</td></tr><tr><td style="text-align:center">No.7</td><td style="text-align:center">魔神z</td><td style="text-align:center">永井 豪</td><td style="text-align:center">1972-1973</td><td style="text-align:center">High School！奇面组</td><td style="text-align:center">新泽基荣</td><td style="text-align:center">1982-1987</td><td style="text-align:center">游戏王</td><td style="text-align:center">高桥和希</td><td style="text-align:center">1996-2004</td></tr><tr><td style="text-align:center">No.8</td><td style="text-align:center">Play Ball</td><td style="text-align:center">千叶昭雄</td><td style="text-align:center">1973-1978</td><td style="text-align:center"><strong>Jo-Jo奇妙冒险</strong></td><td style="text-align:center">荒木飞吕彦</td><td style="text-align:center">1987-2004</td><td style="text-align:center">银魂</td><td style="text-align:center">空知 英秋</td><td style="text-align:center">2004-至今</td></tr><tr><td style="text-align:center">No.9</td><td style="text-align:center"><strong>猫眼三姐妹</strong></td><td style="text-align:center">北条司</td><td style="text-align:center">1981-1984</td><td style="text-align:center">橙路</td><td style="text-align:center">松本泉</td><td style="text-align:center">1984-1987</td><td style="text-align:center">黑子的篮球</td><td style="text-align:center">藤卷忠俊</td><td style="text-align:center">2009-2014</td></tr><tr><td style="text-align:center">No.10</td><td style="text-align:center">赛道之狼</td><td style="text-align:center"></td><td style="text-align:center">1975-1979</td><td style="text-align:center">幽游白书</td><td style="text-align:center">富坚义博</td><td style="text-align:center">1990-1993</td><td style="text-align:center"><strong>网球王子</strong></td><td style="text-align:center">许斐刚</td><td style="text-align:center">1999-2008</td></tr><tr><td style="text-align:center">No.11</td><td style="text-align:center"><strong>料理人味平</strong></td><td style="text-align:center">牛次郎</td><td style="text-align:center">1973-1977</td><td style="text-align:center">浪客剑心</td><td style="text-align:center">和月 伸宏</td><td style="text-align:center">1994-1999</td><td style="text-align:center">死亡笔记</td><td style="text-align:center">大场</td><td style="text-align:center">2004-2006</td></tr><tr><td style="text-align:center">No.12</td><td style="text-align:center">东大一直线</td><td style="text-align:center">小林</td><td style="text-align:center">1976-1979</td><td style="text-align:center"><strong>圣斗士星矢</strong></td><td style="text-align:center">车田 正美</td><td style="text-align:center">1986-1990</td><td style="text-align:center">暗杀教室</td><td style="text-align:center">松井 优征</td><td style="text-align:center">2012</td></tr><tr><td style="text-align:center">No.13</td><td style="text-align:center">天际球团</td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center">铁拳对钢拳</td><td style="text-align:center">森田真法</td><td style="text-align:center">1988-1997</td><td style="text-align:center">家庭教师HITMAN REBORN</td><td style="text-align:center">天野明</td><td style="text-align:center">2004-1012</td></tr><tr><td style="text-align:center">No.14</td><td style="text-align:center">厕所博士</td><td style="text-align:center"></td><td style="text-align:center">1970-1977</td><td style="text-align:center">魁！！男塾</td><td style="text-align:center">宫下亚喜罗</td><td style="text-align:center">1985-1991</td><td style="text-align:center"><strong>通灵王</strong></td><td style="text-align:center">武井 宏之</td><td style="text-align:center">1998-2004</td></tr><tr><td style="text-align:center">No.15</td><td style="text-align:center">眼睛蛇</td><td style="text-align:center">寺泽 武一</td><td style="text-align:center">1978-1984</td><td style="text-align:center">电影少女</td><td style="text-align:center">桂 正和</td><td style="text-align:center">1989-1992</td><td style="text-align:center">Bobobo-bo Bo-bobo</td><td style="text-align:center">泽井 磐夫</td><td style="text-align:center">2001-2007</td></tr><tr><td style="text-align:center">No.16</td><td style="text-align:center">杜宾刑警</td><td style="text-align:center">武论尊</td><td style="text-align:center">1975-1979</td><td style="text-align:center">幻法小魔星</td><td style="text-align:center">江川 达也</td><td style="text-align:center">1988-1992</td><td style="text-align:center"><strong>草莓100%</strong></td><td style="text-align:center">河下 水希</td><td style="text-align:center">2002-2005</td></tr><tr><td style="text-align:center">No.17</td><td style="text-align:center">停止！！云雀</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1981-1983</td><td style="text-align:center">秀逗泰山</td><td style="text-align:center">德弘正也</td><td style="text-align:center">1988-1995</td><td style="text-align:center">出包王女</td><td style="text-align:center">矢吹 健太郎</td><td style="text-align:center">2006-2009</td></tr><tr><td style="text-align:center">No.18</td><td style="text-align:center">热拳本色</td><td style="text-align:center">车田 正美</td><td style="text-align:center">1977-1981</td><td style="text-align:center">灵异教师神眉</td><td style="text-align:center"></td><td style="text-align:center">1993-1999</td><td style="text-align:center">ROOKIES</td><td style="text-align:center">森田</td><td style="text-align:center">1998-2003</td></tr><tr><td style="text-align:center">No.19</td><td style="text-align:center">赤脚的元</td><td style="text-align:center">中泽 磐治</td><td style="text-align:center">1973-1974</td><td style="text-align:center">银牙</td><td style="text-align:center">高桥义广</td><td style="text-align:center">1983-1987</td><td style="text-align:center">光速蒙面侠21</td><td style="text-align:center">村田雄介</td><td style="text-align:center">2002-2009</td></tr><tr><td style="text-align:center">No.20</td><td style="text-align:center">前进！！海盗</td><td style="text-align:center">江口 寿史</td><td style="text-align:center">1997-1980</td><td style="text-align:center">顺带着稀里糊涂</td><td style="text-align:center"></td><td style="text-align:center">1985-1989</td><td style="text-align:center">搞怪吹笛手</td><td style="text-align:center">臼田京介</td><td style="text-align:center">2000-2010</td></tr></tbody></table><blockquote><p>表格注：JUMP于2012年连载的人气漫画诸如：<strong>排球少年、食戟之灵</strong>等优秀作品暂未列入排行榜。</p></blockquote><p>曾作为JUMP三台柱的“死神、火影、海贼王”，但是死神火影的正式完结时人气相当低迷，海贼王也可以看到，目前尾田休刊次数增加不少。目前JUMP少年周刊可以说迎来了一个低迷时期。</p><p>于2008年连载的《美食俘虏》，JUMP虽有意提拔其为台柱，甚至把主角请到《海贼王》中客串，但目前看来依然扶不起。目前连载中算是资深的《银魂》也是准备暖身进入最终章。2014年人气漫画，《黑子的篮球》完结。2016年，三台柱中《死神》、《火影忍者》完结，超人气作品《暗杀教室》完结，《食戟之灵》进入新篇章后人气也随之下滑。</p><p>目前，发展看好的有优秀运动向排球漫画《排球少年》，于2014年连载的《我的英雄学院》也一直维持着相当高的人气。</p><p>说了这么多还是希望，海贼王不要烂尾 &gt;_&lt;||</p>]]></content>
      
      
        <tags>
            
            <tag> JUMP周刊 </tag>
            
            <tag> 漫画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本科计量经济学之回炉重造篇</title>
      <link href="/2018/02/22/%E6%9C%AC%E7%A7%91%E8%AE%A1%E9%87%8F%E7%BB%8F%E6%B5%8E%E5%AD%A6%E4%B9%8B%E5%9B%9E%E7%82%89%E9%87%8D%E9%80%A0%E7%AF%87/"/>
      <content type="html"><![CDATA[<p>本文基于本科的计量经济学课程，主要涉及宏微观、高等数学、线性代数、统计学相关知识。<br>学完我们需要掌握的主要内容包括计量经济学中基本假设及违背基本假设的处理；横截面、面板数据的分析与处理；基础时间序列分析与预测</p><p>参考书籍为</p><ul><li><a href="https://book.douban.com/subject/4717098/" target="_blank" rel="noopener">李子奈.计量经济学</a></li><li><a href="https://book.douban.com/subject/5068097/" target="_blank" rel="noopener">伍德里奇.计量经济学导论</a></li></ul><h2>1 基本假设篇</h2><p>通常在实际研究的计量经济学问题中，完全满足回归的基本假设的情况并不多见。不满足基本假定的情况。称为<strong>违背基本假定</strong>，其情况主要包括:</p><ol><li>随机干扰项存在异方差</li><li>随机干扰项的序列相关（或称自相关）</li><li>解释变量之间的多重共线</li><li>解释变量为随机变量，存在内生性</li></ol><h3>1.1 异方差性</h3><p>线性模型的基本假设中有$Var(\mu|x_1,x_2,\cdots,x_k)=d$，即<strong>随机干扰项的方差不因自变量的不同而不同</strong>。表现在现实的经济生活中，以消费水平受到收入水平的影响为例。$C = b_0 + b_1 * Y + \mu$,对于收入水平Y较低的群众而言，消费情况的变化是比较小的，但是对于收入水平较大的群体而言，其消费水平的变化差异可能就非常大了。用公式表示，即为$var(\mu|x_1,x_2,\cdots,x_k) = f(x_i,d)$</p><h3>1.2 数据异方差性的后果</h3><ol><li>导致参数估计无效，在估计的有效性中，利用了$Ε（\mu '\mu）= d^2I$这条同方差的假设,但是现在d与X是相关的，不能直接拿出来</li><li>参数显著性检验失去意义（显著性检验中，是要用到随机干扰项的误差的，由于异方差性，使用最小二乘法得出来的参数的方差并不是其真实方差了）</li><li>模型预测失效。（模型预测也是要用到随机干扰项的方差的）</li></ol><h3>1.3 检验异方差</h3><ol><li><p><strong>图示检验</strong>（使用Y-X散点图，或者$e^2~X$散点图进行判断，如果呈现一条水平线则是不存在异方差，否则，可能存在），这种方法的问题是：判断并不准确，是否算是水平线还是复杂性的异方差无法判断</p></li><li><p><strong>帕克（Park）检验与戈里瑟检验</strong>。 对样本残差平方$e_i^2$与X之间进行检验。设定模型$e_i^2\sim f(X)+\mu $,如果$e_i^2$与X之间存在显著的相关性，则原模型存在异方差性。<strong>该检验存在的问题</strong>：模型$e_i^2\sim f(X)+\mu $的函数形式和变量选择存在不确定性，而且，该模型本身自己也可能存在异方差性</p></li><li><p><strong>G-Q（Goldfeld-Quandt）检验</strong>:</p></li></ol><ul><li>a.按照某一个被认为可能存在异方差性的变量将样本进行从小到大的排序；</li><li>b.将样本分成两个部分，一个部分自变量大，一个部分自变量小；</li><li>c.对这两个样本分别进行回归，得到各自的残差平方和，在同方差的假设下，这两个残差平方和的大小应当是差异不大的；</li><li>使用上面得出的残差平方和构建F统计量。</li></ul><p><strong>方法的问题</strong>:只能检验单调递增还是单调递减型方差，并且可能需要对各个解释变量进行轮流实验。</p><ol start="4"><li><strong>怀特检验进行辅助回归</strong>：$e_i^2 \sim b_0 + b_1x_1 + b_2x_2 + b_3x_1x_2 + b_4x_1^2 + b_5x_2^2 + \mu $，可以证明，在同方差的假设下，从该辅助回归得到的$R^2$与样本容量的积，渐近服从自由度为辅助回归方程中解释变量个数的卡方分布 $nR^2 \sim \chi^2(k)$ 。WLS加权最小二乘法思想就是将不稳定的方差转换为稳定的方差乘以一个不稳定的函数。通过变换，使得模型变为同方差的情况。</li></ol><p>  假设我们已经知道了随机误差项的方差和自变量之间的关系:$var(\mu_i)=E(\mu_i^2)=d_i^2=f(X_{i,j}) \cdot q^2$(而不是在无异方差的情况下的 $var(\mu |X)=q^2$ )。那么，我们可以使用$\sqrt{f(X_{ij})}$去除以原模型，使得变化后的模型称为无异方差的情况。注：公式中$j$为变量的标号, $i$为样本的标号。 变化后的模型如下：</p><p>$$ Y_i / \sqrt{f(X_{ij})} = b_0 / \sqrt{f(X_{ij})} + b_1x_1 / \sqrt{f(X_{ij})} + \cdots + b_k  x_k / \sqrt{f(X_{ij})} + u_i/\sqrt(f(X_{ij}))$$</p><p>注意到这里，每个变量$X_{ij}$除以的都是其相对应的$f(X_{ij})$. 上面模型，异方差就是不存在的了，便可以用加权后的模型对参数进行估计。现在的问题是，如何对权重$f(x_{ij})$进行估计呢？</p><p>观察可以发现，等式左边可以用样本残差$e_i^2$来代替，等式左边$f(X_{ij})$中有$j$个参数，$q^2$为另一个参数。两边取对数，能够将等式转换为线性模型进行估计。接着就是使用帕克检验的方法，进行各种形式的尝试。从而估计出$f(X_{ij})$的形式 。</p><h3>1.4 异方差稳健标准误法</h3><p><strong>加权最小二乘法</strong>的关键是要寻找模型中随机扰动项$\mu $的方差与解释变量间的适当的函数形式，而这并非一件容易的事。</p><p>如果很难找到的话，可以用异方差的稳健标准误方法，进行替代。 <font color="red">在有异方差的情况下，参数估计仍然是无偏的，但是参数估计的方差和标准差会与传统的有所区别，从而无法保证估计的有效性，但并不影响估计的无偏性和一致性。</font>那么我们仍然采用普通的最小二乘估计量，但是在进行参数检验的时候使用修正后的相应方差。（至于参数的有效性无法满足的问题，并不关注）</p><ol><li>在无异方差下，参数估计的方差为$var(b|X) = d^2 (x’x)^{-1}$，在有异方差下，则为 $var(b) =　(x’x)^{-1}x’D(x’x)^{-1}x’$,这里$D$为$n*1$的向量。使用普通最小二乘法估计的残差平方$e_i^2$形成的向量$e’e$作为向量D的代表。怀特证明了这种做法是对$var(b) =　(x’x)^{-1} * x’ * D * (x’x)^{-1} * x’$的一致估计。</li><li>当存在异方差时，异方差稳健标准误法虽然不能得到有效的参数估计，但是由于得到了普通最小二乘估计量的正确的方差估计，使得以估计量方差为基础的各项检验不再失效，是消除异方差性不良后果的主要手段。</li></ol><h2>2 序列相关性</h2><h3>2.1 序列相关的含义</h3><p>  在经典的线性模型假设中，有<font color="red">随机干扰项独立，即互不相关的假设。</font>这个假设的意思是说，对于造成结果而言，不能由自变量解释到的那部分随机干扰项是独立的。<font color="blue">例如</font>，有两块相邻的水田，其各自产量与施肥量，日照量等有关。但两块水田产量的随机因素之间是不存在关系的，不会因为这块水田随机因素大，那块也大。</p><p>用公式描述，就是：$Cov(\mu _i, \mu _j)=0$， i和j是观测样本。序列相关则意味着样本之间随机因素是具有相关性的，上面例子中，有些无法观测到的对水田产量的因素，例如土壤肥力如果是随机干扰项的话，那么毫无疑问相邻两块土地之间的随机干扰项是具有相关性的。</p><p>通常，由于样本中有$n$个随机干扰项，如果仅存在$E（\mu _i,\mu _{i+1}）\neq 0$，那么称之为一阶自相关，一阶自相关是比较常见的序列相关问题。<font color="blue">例如</font>：一个人的素质可能与他的朋友的素质是相关的，但是与其朋友的朋友的素质之间，相关性就可以忽略了；或者我们可以理解为，一个人素质与其朋友的朋友之间的关系，事实上是通过其朋友来传导的。那么，这样我们就可以将多阶自相关的问题，通过一阶自相关来理解了。</p><p>因此，为了能够便于理解和进行计算，我们通常都进行一阶自相关的研究。我们将一阶自相关用公式表述为：$\mu _i = p*\mu <em>{i+1} + e</em>{i -1}  &lt; p$</p><p>一般经验而言，对于采用时间序列数据作样本的计量经济学问题，由于在不同样本点上解释变量以外的其它因素（随机干扰项）在时间上的连续性，或者说惯性，往往会导致序列相关性。</p><h3>2.2 序列相关性的后果</h3><ol><li><p><strong>参数估计非有效</strong>：在有效性的证明中利用了 $E(uu’) = d^2I$, 但是现在这个条件是无法满足了。所以有效性便不再满足。</p></li><li><p><strong>变量的显著性检验失去意义：</strong>随机干扰项向量的协方差矩阵不再是 $d^2I$，因此原本的参数分布和显著性t检验也不再满足。</p></li><li><p><strong>模型的预测失效：</strong>原因同变量显著性检验失去意义。</p></li></ol><h3>2.3 检验序列相关</h3><ol><li><p><strong>图示法</strong>： 使用OLS的样本残差作为随机干扰项的估计，画出$e_t$和$e_{t-1}$之间的散点图，看二者之间是否存在明显的相关性。该方法存在主观性和不确定性。</p></li><li><p><strong>回归检验法</strong>： 对$e_t$和$e_{t-1}$进行回归检验，看二者之间是否存在显著的关系。</p></li><li><p><strong>DW检验</strong>：构造一个统计量，服从DW分布，然后再使用DW准则进行检验。（用的较少，局限性很大）</p></li><li><p><strong>拉格朗日乘数（LM）检验</strong>：将模型转换为受约束的回归方程即$Y_i=b_0+b_1*x_{i1}+b_2*x_{i2}+\cdots+b_k*x_{ik}+p_1*u_{i-1}+p_2*u_{i-2}+\cdots+p_k*u_{i-k}+e_k$。检验约束条件$H_0：p_1=p_2=\cdots =p_k=0$(k可以自行决定)，再使用检验模型约束条件的LM统计量检验该约束条件即可。</p></li></ol><h3>2.4 如何补救序列相关</h3><p>补救序列相关与补救异方差一样,存在两种思路:</p><ul><li>一就是变换原模型为不存在序列相关的模型,再用OLS来进行估计,即为广义最小二乘法(GLS)和广义差分法（GDM）;</li><li>另一条途径是仍然采用OLS的估计参数，但是对参数估计量的方差或者标准差进行修正。</li></ul><h4>2.4.1 广义最小二乘法</h4><p>  广义最小二乘，是具有普遍意义的最小二乘，普通最小二乘和加权最小二乘是它的特例。<font color="red">广义最小二乘是不需要同方差性和无序列相关的假设的。</font>它将随机变量的协方差矩阵不再表示为 $d^2I$这样的形式， 而是用$cov(u,u’) = p^2 * W$来表示。其中 $W = DD’$.进一步的，变换模型为 $D^{-1}*Y = D^{-1} * X_b + D^{-1}*u$, 该模型便不再有异方差和序列相关，可以对其使用OLS进行估计。（李子奈《计量经济学》pp.127）</p><p>  广义最小二乘法真正的难题是如何去估计协方差矩阵$W$，在序列自相关的情况下，若只有$n$个样本点，要对$\frac{n*(n-1)}{2} + k +2$ 个参数进行估计是几乎不可能的。因此，只能是说对随机干扰项自相关的结构事先给出必要的假设。一般而言，我们假设随机干扰项是一阶自相关的：即$\mu _t = p\mu _{t-1} + e$，对该模型进行估计，便可以得到协方差矩阵W以及权重矩阵D 。</p><h4>2.4.2 广义差分法</h4><p>  广义差分法实质上就是广义最小二乘法，不过是损失了部分样本观测值，具体可见《计量经济学》（李子奈）pp.129。</p><p>随机干扰项相关系数的估计：无论是使用广义最小二乘法还是广义差分法，都需要知道不同样本点之间随机干扰项的相关系数$r_1,r_2\cdots r_p$等，必须对其进行估计，即对$u_t = r_1 * u_{t-1} + r_2 * u_{t-2} + …+ r_p * u_{t-p} + e_t$进行估计。但是事实上$\mu <em>{t}$是无法观测到的，我们只能使用$e</em>{t}$来对其进行近似的估计。</p><p>具体方法为，先使用OLS对原始模型进行估计，对$e_{t},e_{t-1}\cdots e_{t-p}$之间进行线性估计得出随机干扰项的相关系数。再将其带入到广义差分法或者广义最小二乘法中，得到新的$e_{t},e_{t-1}\cdots e_{t-p}$,再次进行估计，得出他们的相关系数，重复上述步骤，直到$e_{t},e_{t-1}\cdots e_{t-p}$的值趋于稳定。我们称该方法为<strong>科克伦-奥科特（Cochrane-Orcutt）迭代法</strong>。</p><p><strong>序列相关稳健标准误法</strong>存在序列相关时，OLS估计的无偏性和一致性仍然是有的，但是有效性无法保证，因此，我们可以对随机干扰项的协方差进行修正，在进行显著性检验时使用改修正的稳健标准误。具体公式过于冗长，可参考《计量经济学》（李子奈）pp.130</p><h3>2.5 虚假序列相关问题</h3><p>  若模型设定中遗漏了重要的解释变量，从而导致了序列相关的出现，我们称之为<strong>虚假序列相关</strong>。我们在处理序列相关问题时，应当要将虚假序列相关的可能性先排除掉，即排除掉遗漏变量的可能。如何避免出现模型设定的偏误问题呢？那就是在开始时建立一个“一般”的模型，然后逐渐剔除缺失不显著的变量。</p><h2>3 多重共线性</h2><p>共线性是指自变量之间存在较大的相关性，导致$|X’X| \neq 0$，从而$(X’X)^{-1}$对角线上的元素较大，随机干扰项的协方差矩阵$d^2(X’X)^{-1}$对角线上的元素也较大，导致一系列的不良后果。主要包括：</p><ol><li>完全共线性下，估计量不存在，完全共线性下$|X’X|=0$，$X’X$没有逆，OLS没法得出参数估计量。</li><li>普通最小二乘法方差变大，导致通过样本计算出来的t值比较小$(X’X）^{-1}$在t统计量的分母中，导致t统计量较小），由于样本本身的共线性问题，导致了t检验的不可靠。同时，也会使得因变量区间预测的“区间”变大，使得预测失去意义，模型不能进行外推。</li><li>参数估计量的经济含义不合理。若$X_1，X_2$之间存在共线性，那么二者其中一个可以由另一个表征出来。他们各自的参数估计量不再代表本身的经济意义，而是代表二者对被解释变量的共同影响。<strong>经验告诉我们，在多元线性回归模型的估计中，如果出现了参数估计值的经济意义明显不合理的情况，应该首先怀疑是否存在多重共线性</strong>。</li></ol><h3>3.1 造成多重共线性的原因</h3><ol><li>经济变量相关的共同趋势。这在时间序列样本中情况比较多。</li><li>滞后变量的引入。例如,居民消费$C$受到总收入以及前期的消费$C_{t-1}$的影响，但是毫无疑问的，前期的消费$C_{t-1}$会影响到当期的收入$Y_{t}$。所以模型中毫无疑问会出现共线性的问题。在这样一种情况下，$Y_{t}$的参数$b_{1}$就不再代表收入对消费的影响了，而是$Y_{t}$与$C_{t-1}$对$C_{t}$的共同影响，二者的参数经济意义不明了。所以可能会出现不合常理的参数估计值。</li><li>样本资料的限制。由于社会科学采用的数据是“社会实验”得出，而并非是控制实验得出，所以自变量样本是不受控制的，某些变量之间可能总是会存在一些共线性。例如时间序列样本就算是这种情况。</li></ol><h3>3.2 多重共线性的检验</h3><p><strong>对两个解释变量</strong>：可以通过解释变量的样本协方差矩阵，发现解释变量之间的两两相关性，对于相关性非常高的两个解释变量，可能存在共线性的问题。</p><p><strong>对多个解释变量之间的相关性</strong>：所谓多个解释变量相关就是如$x_1 = x_2 + x_3 + x_4$这种。使用综合统计检验，如果在OLS下，模型的$R^2$与$F$值较大，但是各参数检验的$t$值较小，说明各解释变量对$Y$的联合线性作用显著。但从较小的$t$值，我们可以估计到，可能存在共线性，从而使得解释变量对$Y$的独立作用不能分辨，故$t$检验不显著。</p><h3>3.3 判别多重共线性的范围</h3><p>知道模型有多重共线性，进一步的，我们希望能够将引起多重共线性的变量找出来，以进一步地对模型进行调整。</p><p>具体的方法有判定系数检验法和逐步回归法。</p><ol><li><p>判定系数检验法：使模型中每个解释变量分别以其余解释变量为解释变量进行回归计算,即 $X_{i} \sim x_{1} + x_{2}+\cdots +x_{i-1} + x_{i+1}+\cdots +x_{k}$。如果发现该模型的判定系数$R^2$较大，则说明该解释变量$x_{i}$能够用其它解释变量表征出来。至于如何判定$R^2$是否足够大，我们可以做$F$检验。</p></li><li><p>逐步回归法：</p></li></ol><ul><li>先做$Y$与各$X_i$分别一元线性回归，找出$R^2$最大的那个$X_i$，以该一元线性回归为基础；</li><li>逐个引入解释变量，观察拟合优度（修正后的拟合优度）的变化（也可以使用AIC准侧），如果拟合优度变化显著，则说明该变量是一个独立解释变量，如果拟合优度变化不显著，说明该解释变量可以用其它变量的线性组合替代，也就是说它与其它变量之间存在共线性关系。</li></ul><h3>3.4 克服多重共线性的办法</h3><ol><li><p><strong>排除引起共线性的变量</strong>：这种方法可能存在的问题是，某变量本来是应当存在于模型当中的，只是由于样本的问题，使得该变量显示出共线性。剔除掉该变量将会导致回归模型在进行预测时的准确性下降。如果换一组样本，可能共线性的情况就不再存在了。因此，是否真的应当剔除掉变量应当还要进行实际经济模型或者实际意义进行考虑。如果某个变量是具有非常明显的经济意义的，那么即使该变量存在共线性，也不能轻易剔除掉。</p></li><li><p><strong>差分法</strong>：常用于时间序列数据中，使用自变量和因变量的增量作为回归的变量。这是由于变量增量的相关性毫无疑问肯定是要比变量本身的相关性弱的。</p></li><li><p><strong>岭回归与LASSO</strong>：可参见<a href="http://www.cnblogs.com/pingzeng/p/5040911.html" target="_blank" rel="noopener">多重共线性的解决方法之——岭回归与LASSO</a></p></li></ol><h2>4 随机解释变量问题 （内生性问题）</h2><p>  计量经济假设中，我们是假设自变量是确定变量，是非随机的。<s>所谓是确定变量，我们可以用科学实验中的对照实验来进行说明，<font color="blue">例如</font>：判断不同的水分条件对粮食产量的影响时，我们将控制其它对产量有影响的变量，如光照，土壤，种子等，仅仅使得水分条件不一样，进而判断水分条件对产量的影响。在这种实验中，水分是可以进行人为控制的确定变量，我们称这种实验为“对照实验”。</s></p><p><s>然而，由于伦理和实际操作上的种种不可行，经济学家是不可能拿整个社会来做实验的。例如不能故意控制某个地方的公共投资高，另一个地方的公共投资低，从而判断政府公共投资对收入的影响。经济学家只能使用既有的现实社会运行数据，通过判断不同公共投资地区的GDP的不同来判断公共投资的影响，经济学家称这种为“自然实验”。 但是，事实上，公共投资却并不是完全的确定性的，它并不是政府主动控制想投入多少就投入多少，其大小毫无疑问是受到地方财政收入的约束的。从这个角度上来说，也就是GDP越高的地方，毫无疑问也就能够投入越多的公共投资。</s></p><p><s><font color="red">那么公共投资与GDP的因果关系就变得非常复杂了，到底公共投资是因？还是GDP是因呢？我们称这种情况为随机解释变量问题：即解释变量无法控制，是具有随机性的。</font></s></p><p>  随机解释变量问题可以分为3种不同的情况：</p><ol><li>随机解释变量$X_i$与随机干扰项$\mu $独立： $cov(X_{i},\mu ) = E(X_{i}\mu )= E(X_{i})*E(\mu )=0$，这种情况，随机解释变量问题对模型的估计不会产生影响。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期无关但是异期相关： $cov(X_{i}, \mu _{i-s}) \neq 0$，这种情况，得到的参数估计量是有偏的，但是却是一致的（可以从OLS估计量的形式中推出来）。</li><li>随机解释变量$X_i$与随机干扰项$\mu $同期先关：这种情况得到的参数估计量有偏且非一致。</li></ol><h3>4.1 引起内生性问题的通常理由</h3><ol><li>经济模型中因变量滞后项的引用，通常会造成随机解释变量异期相关。</li><li>存在互为因果的模型，例如上文所述公共投资与GDP。</li></ol><h3>4.2 随机解释变量的解决方法</h3><h4>4.2.1 工具变量</h4><p>工具变量是指该变量与随机解释变量之间存在较高的相关性，而且对随机解释变量的解释能力也非常高（$R^2$比较大），但是该解释变量与模型的随机干扰项不相关，与被解释变量也不相关。即满足：</p><ul><li>工具变量必须外生，即$Cov(z,\mu )=0$。</li><li>工具变量必须与内生变量$x$相关，即$Cov(z,x) \neq 0$。</li></ul><h4>4.2.2 工具变量的估计</h4><p>应该根据常识及经济理论判断$Cov(z,\mu )$是否合理。</p><p>我们可以检验$Cov(z,x )\neq 0$是否成立,即检验在$H_0:\pi_1 = 0$在$x=\pi_0+\pi_1 z+v$,这称作第一阶段回归</p><p>假设简单回归情形$y=\beta_0+\beta_1 x+\mu$，并给定我们假设$Cov(z,y)=\beta_1 Cov(z,x)+Cov(z,\mu )$</p><p>于是解出$\beta_1=\frac{Cov(z,x)}{Cov(z,x)}$，得到$\beta_1$估计量$$\hat{\beta_1}=\frac{\sum_{i=1}^n(z_i-z)(y_i - \bar{y})}{\sum_{i=1}^n(z_i-\bar{z})(x_i - x)}$$</p><p>为了进行推断，我们需要计算统计量和置信区间的标准误。通常的方法是增加一个同方差假设</p><p>$E(\frac{\mu^2}{z})=\sigma2=Var(\mu )$得出，$$Var(\hat{\beta_1})=\frac{\sigma^2}{n\sigma_x^2 \rho_{x,z}^2} \\ se(\hat{\beta_1})=\frac{\hat{\sigma}^2}{ SST_{x}R_{x,z}^2}$$</p><blockquote><p>未完待续 loading…</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 经济学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>网站迁移(hexo)</title>
      <link href="/2018/02/20/%E7%BD%91%E7%AB%99%E8%BF%81%E7%A7%BB-hexo/"/>
      <content type="html"><![CDATA[<p>由于wordpress访问速度太慢，懒得折腾XD，把一些博客文章迁移到新博客上。目前使用Github Page + Hexo的方案比较流行，留作日常记录。</p><div align="center">The end</div>]]></content>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>2017年(Lunar Year)读书与看剧</title>
      <link href="/2018/02/15/Lunar_Year/"/>
      <content type="html"><![CDATA[<a id="more"></a><h3>读书（文学类）</h3><ul><li>加缪. 《鼠疫》</li><li>朱光潜.《西方美学史》 <em>读的慢，忘的快</em></li><li>乔治·奥威尔. 《1984》</li><li>乔治·奥威尔. 《动物农庄》</li><li>艾玛·拉金《在缅甸寻找乔治·奥威尔》</li><li>凯鲁亚克. 《在路上》</li><li>白先勇 《台北人》</li><li>尤瓦尔·赫拉利 《人类简史:从动物到上帝》</li><li>尤瓦尔, 赫拉利. 《未来简史》</li><li>斯蒂芬·茨威格. 《人类群星闪耀时》</li><li>尼古拉斯·斯帕克思. 《分手信》</li><li>卡勒德·胡赛尼. 《群山回唱》</li><li>费孝通. 《乡土中国》</li></ul><h3>读书（自我提高及工具书）</h3><ul><li>李忠秋. 《结构思考力》</li><li>尼尔·布朗《学会提问》</li><li>布鲁克·诺埃尔·摩尔《批判性思维》</li><li>读自我提高类书籍本意在于提升自身逻辑思考能力，上面几本书能够很好的达到目的。</li><li>Johnson. 实用多元统计分析.</li><li>RobertV.Hogg. 数理统计学导论</li><li>张维迎. 博弈论与信息经济学</li><li>Nasrabadi, Nasser M. “Pattern recognition and machine learning.”</li></ul><h3>看剧</h3><ul><li>《怦然心动》- 纯爱类影片，学会从整体审视生活</li><li>《时空恋旅人》 - 看完觉得幸福了一辈子</li><li>《饮食男女》 - 人之大欲，不过饮食男女</li><li>《闻香识女人》 - 善良、正直，是走得多远都不能丢弃的道德品质</li><li>《海边的曼彻斯特》 - 每个人都是一座孤独的岛</li><li>《东京爱情故事》 - 爱情是个很难说的事儿吧，thank you，赤名莉香</li><li>《白色巨塔》- 过程正义与结果正义</li><li>《NANA》 - 主题曲很好听</li><li>《熔炉》 - 不想评论，谢谢</li><li>《聚焦》 - 同上</li><li>《两杆大烟枪》 - 同《低俗小说》《疯狂的石头》，贵在叙事方式</li><li>《傲慢与偏见》、《罗马假日》、《南丁格尔》、《乱世佳人》还说什么，都是经典，无论看几遍，都能品出味道来.</li></ul><div align="center">和子由渑池怀旧 .苏轼<br>人生到处知何似，应似飞鸿踏雪泥。<br>泥上偶然留指爪，鸿飞那复计东西。<br>老僧已死成新塔，坏壁无由见旧题。<br>往日崎岖还知否，路长人困蹇驴嘶。<br></div>]]></content>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MacOS下使用python的多版本方案</title>
      <link href="/2018/01/01/MacOS%E4%B8%8B%E4%BD%BF%E7%94%A8python%E7%9A%84%E5%A4%9A%E7%89%88%E6%9C%AC%E6%96%B9%E6%A1%88/"/>
      <content type="html"><![CDATA[<h2>背景</h2><p>MacOS系统本身自带python，但是版本仍然停留在python2.7。私以为python2与python3语言差别比较大，python3额外一些新特性如**“通配符**，字典可排序，统一的Unicode编码”**等，都值得去尝试。为此，保证电脑上两个版本都能共存是很必要的。</p><h2>方案一：使用pyenv兼容多版本</h2><p>pyenv 是轻量的Python版本管理器，帮助你在电脑上建立多个版本的python环境，并提供方便的切换方法。pyenv-virtualenv 是 pyenv的扩展工具（类Unix系统上），可以搭建虚拟且独立的python环境，可以使每个项目环境与其他项目独立开来，保持环境的干净，解决包冲突问题。</p><h3>1. 使用Mac OSX的 Homebrew 安装</h3><p>Homebrew作为OS X上强大的包管理器，为系统软件提供了非常方便的安装方式，独特式的解决了包的依赖问题，并不再需要烦人的sudo，一键式编译，无参数困扰，安装Homebrew：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~$ curl -L https://raw.githubusercontent.com/yyuu/pyenv-installer/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><p>安装完成后，根据提示将如下语句加入到 <code>～/.bash_profile</code> 或<code>~/.bashrc</code> 中:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">port PYENV_ROOT=&quot;$HOME/.pyenv&quot;</span><br><span class="line">export PATH=&quot;$PYENV_ROOT/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot; # 这句可以不加</span><br></pre></td></tr></table></figure><h3>2. pyenv 常用命令</h3><p>使用 <code>pyenv commands</code> 显示所有可用命令</p><h4>python 安装与卸载</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv install 2.7.3   # 安装python</span><br><span class="line">~$ pyenv uninstall 2.7.3 # 卸载python</span><br></pre></td></tr></table></figure><h4>python切换</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv global 2.7.3  # 设置全局的 Python 版本，通过将版本号写入 ~/.pyenv/version 文件的方式。</span><br><span class="line">~$ pyenv local 2.7.3 # 设置 Python 本地版本，通过将版本号写入当前目录下的 .python-version 文件的方式。通过这种方式设置的 Python 版本优先级较 global 高。</span><br></pre></td></tr></table></figure><h4>python优先级</h4><p><strong>shell &gt; local &gt; global</strong></p><p>pyenv 会从当前目录开始向上逐级查找 .python-version 文件，直到根目录为止。若找不到，就用 global 版本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">~$ pyenv shell <span class="number">2.7</span><span class="number">.3</span> <span class="comment"># 设置面向 shell 的 Python 版本，通过设置当前 shell 的 PYENV_VERSION 环境变量的方式。</span></span><br><span class="line"><span class="comment"># 这个版本的优先级比 local 和 global 都要高。–unset 参数可以用于取消当前 shell 设定的版本。</span></span><br><span class="line">~$ pyenv shell --unset</span><br><span class="line">~$ pyenv rehash  <span class="comment"># 创建垫片路径（为所有已安装的可执行文件创建 shims，如：~/.pyenv/versions/*/bin/*，因此，每当你增删了 Python 版本或带有可执行文件的包（如 pip）以后，都应该执行一次本命令）</span></span><br></pre></td></tr></table></figure><h2>方案二：使用Anaconda包管理多版本python</h2><p>Anaconda 是 Python 的一个发行版，如果把 Python 比作 Linux，那么 Anancoda 就是 CentOS 或者 Ubuntu。它解决了Python开发者的两大痛点。</p><ul><li>提供包管理，功能类似于 pip，Windows 平台安装第三方包经常失败的场景得以解决。</li><li>提供虚拟环境管理，功能类似于 virtualenv，解决了多版本Python并存问题。###1. 下载 Anaconda直接在官网下载最新版本的 <a href="https://www.continuum.io/downloads" target="_blank" rel="noopener">https://www.continuum.io/downloads</a> 安装包， 选择对应Python版本的安装包，下载完成后直接安装，安装过程选择默认配置即可，大约需要1.8G的磁盘空间。</li></ul><p>conda 是 Anaconda 下用于包管理和环境管理的命令行工具，是 pip 和 vitualenv 的组合。安装成功后 conda 会默认加入到环境变量中，因此可直接在命令行窗口运行 <code>conda</code> 命令，命令帮助可通过<code>conda -h</code>查看。如果你熟悉 virtualenv，那么上手 conda 非常容易，不熟悉 virtulenv 的也没关系，它提供的命令就几个，非常简单。我们可以利用 conda 的虚拟环境管理功能在 Python2 和 Python3 之间自由切换。</p><h3>2. 多版本切换</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># 基于 python2.7 创建一个名为py2_env 的环境</span><br><span class="line">conda create --name py2_env python=2.7</span><br><span class="line"></span><br><span class="line"># 基于 python3.6 创建一个名为py3_env 的环境</span><br><span class="line">conda create --name py3_env python=3.6 </span><br><span class="line"></span><br><span class="line"># 激活python环境</span><br><span class="line">activate py3_env  # windows</span><br><span class="line">source activate py3_env # linux/mac</span><br><span class="line"></span><br><span class="line"># 切换到python3</span><br><span class="line">activate py3_env</span><br></pre></td></tr></table></figure><h3>3. 包管理</h3><p>conda 的包管理功能是对 pip 的一种补充，如果当前已经激活了某个Python环境，那么就可以在当前环境开始安装第三方包。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># 安装 numpy </span><br><span class="line">conda install numpy</span><br><span class="line"># 查看已安装的包</span><br><span class="line">conda list </span><br><span class="line"># 包更新</span><br><span class="line">conda update numpy</span><br><span class="line"># 删除包</span><br><span class="line">conda remove numpy</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Mac </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Python字符串处理拾掇</title>
      <link href="/2017/04/20/Python%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A4%84%E7%90%86%E6%8B%BE%E6%8E%87/"/>
      <content type="html"><![CDATA[<p>Python 字符串操作（string替换、删除、截取、复制、连接、比较、查找、包含、大小写转换）</p><p>一、去空格及特殊符号</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s.strip().lstrip().rstrip(<span class="string">','</span>)</span><br></pre></td></tr></table></figure><p>二、复制字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># strcpy(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strcpy'</span></span><br><span class="line">sStr2 = sStr1</span><br><span class="line">sStr1 = <span class="string">'strcpy2'</span></span><br><span class="line">print(sStr2)</span><br></pre></td></tr></table></figure><p>三、连接字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strcat(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strcat'</span></span><br><span class="line">sStr2 = <span class="string">'append'</span></span><br><span class="line">sStr1 += sStr2</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>四、查找字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strchr(sStr1,sStr2)</span></span><br><span class="line"><span class="comment"># &lt; 0 为未找到</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'s'</span></span><br><span class="line">nPos = sStr1.index(sStr2)</span><br><span class="line">print(nPos)</span><br></pre></td></tr></table></figure><p>五、比较字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strcmp(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'strchr'</span></span><br><span class="line">sStr2 = <span class="string">'strch'</span></span><br><span class="line">print(cmp(sStr1,sStr2))</span><br></pre></td></tr></table></figure><p>六、扫描字符串是否包含指定的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strspn(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'12345678'</span></span><br><span class="line">sStr2 = <span class="string">'456'</span></span><br><span class="line"><span class="comment">#sStr1 and chars both in sStr1 and sStr2</span></span><br><span class="line">print(len(sStr1 <span class="keyword">and</span> sStr2))</span><br></pre></td></tr></table></figure><p>七、字符串长度</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlen(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'strlen'</span></span><br><span class="line">print(len(sStr1))</span><br></pre></td></tr></table></figure><p>八、将字符串中的大小写转换</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strlwr(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'JCstrlwr'</span></span><br><span class="line">sStr1 = sStr1.upper()</span><br><span class="line"><span class="comment">#sStr1 = sStr1.lower()</span></span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>九、追加指定长度的字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncat(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">sStr2 = <span class="string">'abcdef'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 += sStr2[<span class="number">0</span>:n]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十、字符串指定长度比较</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncmp(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">sStr2 = <span class="string">'123bc'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">print( cmp(sStr1[<span class="number">0</span>:n],sStr2[<span class="number">0</span>:n]))</span><br></pre></td></tr></table></figure><p>十一、复制指定长度的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strncpy(sStr1,sStr2,n)</span></span><br><span class="line">sStr1 = <span class="string">''</span></span><br><span class="line">sStr2 = <span class="string">'12345'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 = sStr2[<span class="number">0</span>:n]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十二、将字符串前n个字符替换为指定的字符</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strnset(sStr1,ch,n)</span></span><br><span class="line">sStr1 = <span class="string">'12345'</span></span><br><span class="line">ch = <span class="string">'r'</span></span><br><span class="line">n = <span class="number">3</span></span><br><span class="line">sStr1 = n * ch + sStr1[<span class="number">3</span>:]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十三、扫描字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strpbrk(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'cekjgdklab'</span></span><br><span class="line">sStr2 = <span class="string">'gka'</span></span><br><span class="line">nPos = <span class="number">-1</span></span><br><span class="line"><span class="keyword">for</span> c <span class="keyword">in</span> sStr1:</span><br><span class="line">    <span class="keyword">if</span> c <span class="keyword">in</span> sStr2:</span><br><span class="line">        nPos = sStr1.index(c)</span><br><span class="line">        <span class="keyword">break</span></span><br><span class="line">print( nPos)</span><br></pre></td></tr></table></figure><p>十四、翻转字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strrev(sStr1)</span></span><br><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr1 = sStr1[::<span class="number">-1</span>]</span><br><span class="line">print(sStr1)</span><br></pre></td></tr></table></figure><p>十五、查找字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strstr(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'abcdefg'</span></span><br><span class="line">sStr2 = <span class="string">'cde'</span></span><br><span class="line">print(sStr1.find(sStr2))</span><br></pre></td></tr></table></figure><p>十六、分割字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#strtok(sStr1,sStr2)</span></span><br><span class="line">sStr1 = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">sStr2 = <span class="string">','</span></span><br><span class="line">sStr1 = sStr1[sStr1.find(sStr2) + <span class="number">1</span>:]</span><br><span class="line">print(sStr1)</span><br><span class="line"><span class="comment">#或者</span></span><br><span class="line">s = <span class="string">'ab,cde,fgh,ijk'</span></span><br><span class="line">print(s.split(<span class="string">','</span>))</span><br></pre></td></tr></table></figure><p>十七、连接字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">delimiter = <span class="string">','</span></span><br><span class="line">mylist = [<span class="string">'Brazil'</span>, <span class="string">'Russia'</span>, <span class="string">'India'</span>, <span class="string">'China'</span>]</span><br><span class="line">print(delimiter.join(mylist))</span><br><span class="line">PHP 中 addslashes 的实现</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addslashes</span><span class="params">(s)</span>:</span></span><br><span class="line">    d = &#123;<span class="string">'"'</span>:<span class="string">'\\"'</span>, <span class="string">"'"</span>:<span class="string">"\\'"</span>, <span class="string">"\0"</span>:<span class="string">"\\\0"</span>, <span class="string">"\\"</span>:<span class="string">"\\\\"</span>&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">''</span>.join(d.get(c, c) <span class="keyword">for</span> c <span class="keyword">in</span> s) </span><br><span class="line">s = <span class="string">"John 'Johny' Doe (a.k.a. \"Super Joe\")\\\0"</span></span><br><span class="line">print(s)</span><br><span class="line">print( addslashes(s))</span><br></pre></td></tr></table></figure><p>十八、只显示字母与数字</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">OnlyCharNum</span><span class="params">(s,oth=<span class="string">''</span>)</span>:</span></span><br><span class="line">    s2 = s.lower();</span><br><span class="line">    fomart = <span class="string">'abcdefghijklmnopqrstuvwxyz0123456789'</span></span><br><span class="line">    <span class="keyword">for</span> c <span class="keyword">in</span> s2:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> c <span class="keyword">in</span> fomart:</span><br><span class="line">            s = s.replace(c,<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line"> </span><br><span class="line">print(OnlyStr(<span class="string">"a000 aa-b"</span>))</span><br></pre></td></tr></table></figure><p>十九、截取字符串</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">str = ’<span class="number">0123456789</span>′</span><br><span class="line"><span class="keyword">print</span> str[<span class="number">0</span>:<span class="number">3</span>] <span class="comment">#截取第一位到第三位的字符</span></span><br><span class="line"><span class="keyword">print</span> str[:] <span class="comment">#截取字符串的全部字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">6</span>:] <span class="comment">#截取第七个字符到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-3</span>] <span class="comment">#截取从头开始到倒数第三个字符之前</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">2</span>] <span class="comment">#截取第三个字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-1</span>] <span class="comment">#截取倒数第一个字符</span></span><br><span class="line"><span class="keyword">print</span> str[::<span class="number">-1</span>] <span class="comment">#创造一个与原字符串顺序相反的字符串</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:<span class="number">-1</span>] <span class="comment">#截取倒数第三位与倒数第一位之前的字符</span></span><br><span class="line"><span class="keyword">print</span> str[<span class="number">-3</span>:] <span class="comment">#截取倒数第三位到结尾</span></span><br><span class="line"><span class="keyword">print</span> str[:<span class="number">-5</span>:<span class="number">-3</span>] <span class="comment">#逆序截取，具体啥意思没搞明白？</span></span><br></pre></td></tr></table></figure><p>二十、直接贴过来</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">str = <span class="string">"Hello My friend"</span></span><br><span class="line"><span class="comment"># 字符串是一个整体。如果你想直接修改字符串的某一部分，是不可能的。</span></span><br><span class="line"><span class="comment"># 但我们能够读出字符串的某一部分。</span></span><br><span class="line"><span class="comment"># 子字符串的提取</span></span><br><span class="line">str[:<span class="number">6</span>]</span><br><span class="line"><span class="comment"># 字符串包含判断操作符：in，not in</span></span><br><span class="line"><span class="string">"He"</span> <span class="keyword">in</span> str</span><br><span class="line"><span class="string">"she"</span> <span class="keyword">not</span> <span class="keyword">in</span> str</span><br><span class="line"></span><br><span class="line"><span class="comment"># string模块，还提供了很多方法，如</span></span><br><span class="line">S.find(substring, [start [,end]]) <span class="comment">#可指范围查找子串，返回索引值，否则返回-1</span></span><br><span class="line">S.rfind(substring,[start [,end]]) <span class="comment">#反向查找</span></span><br><span class="line">S.index(substring,[start [,end]]) <span class="comment">#同find，只是找不到产生ValueError异常</span></span><br><span class="line">S.rindex(substring,[start [,end]])<span class="comment">#同上反向查找</span></span><br><span class="line">S.count(substring,[start [,end]]) <span class="comment">#返回找到子串的个数</span></span><br><span class="line"></span><br><span class="line">S.lowercase()</span><br><span class="line">S.capitalize()      <span class="comment">#首字母大写</span></span><br><span class="line">S.lower()           <span class="comment">#转小写</span></span><br><span class="line">S.upper()           <span class="comment">#转大写</span></span><br><span class="line">S.swapcase()        <span class="comment">#大小写互换</span></span><br><span class="line"></span><br><span class="line">S.split(str, <span class="string">' '</span>)   <span class="comment">#将string转list，以空格切分</span></span><br><span class="line">S.join(list, <span class="string">' '</span>)   <span class="comment">#将list转string，以空格连接</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理字符串的内置函数</span></span><br><span class="line">len(str)                <span class="comment">#串长度</span></span><br><span class="line">cmp(<span class="string">"my friend"</span>, str)   <span class="comment">#字符串比较。第一个大，返回1</span></span><br><span class="line">max(<span class="string">'abcxyz'</span>)           <span class="comment">#寻找字符串中最大的字符</span></span><br><span class="line">min(<span class="string">'abcxyz'</span>)           <span class="comment">#寻找字符串中最小的字符</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># string的转换</span></span><br><span class="line">            </span><br><span class="line">float(str) <span class="comment">#变成浮点数，float("1e-1")  结果为0.1</span></span><br><span class="line">int(str)        <span class="comment">#变成整型，  int("12")  结果为12</span></span><br><span class="line">int(str,base)   <span class="comment">#变成base进制整型数，int("11",2) 结果为2</span></span><br><span class="line">long(str)       <span class="comment">#变成长整型，</span></span><br><span class="line">long(str,base)  <span class="comment">#变成base进制长整型，</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 字符串的格式化（注意其转义字符，大多如C语言的，略）</span></span><br><span class="line">str_format % (参数列表) <span class="comment">#参数列表是以tuple的形式定义的，即不可运行中改变</span></span><br><span class="line">&gt;&gt;&gt;<span class="keyword">print</span> <span class="string">""</span>%s<span class="string">'s height is %dcm" % ("My brother", 180)</span></span><br><span class="line"><span class="string">          #结果显示为 My brother'</span>s height <span class="keyword">is</span> <span class="number">180</span>cm</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>写在大三下学期</title>
      <link href="/2017/03/22/%E5%86%99%E5%9C%A8%E5%A4%A7%E4%B8%89%E4%B8%8B%E5%AD%A6%E6%9C%9F/"/>
      <content type="html"><![CDATA[<p>  大学时光经不起回味，一眨眼的时间，大学生生活已经步入尾声，随之而来的就该是毕业季的伤感了。步入大三的同学们，都在为步入”社会“摩拳擦掌，该考研的考研，该工作的工作。即使是平时班上最不爱学习的，也时不时开始向人打听起公务员考试的相关事宜了 :blush: :blush:</p><a id="more"></a><h2>时代的浪潮已经拍到了我们这代人的脚下</h2><p>  每每看到知乎上“大三了，考研还来得及吗？”，“大三了，学计算机还来得及吗？”诸如此类的问题，总也庆幸自己两年多的时间做了一些事读了一些书，但我知道自己做的还远远远远不够看。大三的生活，伴着毕业的步伐，来的匆匆。自己的学年论文加上向老师申请的论文，学的懵懂的专业课，还得挤出时间来为考研蓄力，冷不丁还夹带点感情的纠结。Flag ～</p><p>时光总是匆匆的催人老，情爱总是让人烦恼。</p><iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="//music.163.com/outchain/player?type=2&id=394467&auto=0&height=66"></iframe><h2>写博客的初衷</h2><p>  大脑的存储空间是有限的，为了让新知识进来，你就得把暂时用不上旧知识遗忘掉。但是，自己当时花了那么多宝贵时间，一步一步摸索着过来所接触到的总结过的知识点，就这样被遗忘，或者被藏在某本笔记本的角落是在太可惜。当你怀着一颗热忱的心去进入一个领域，你只有从宏观上清楚了行业整体，从微观上把握住各个知识点原理，才算得上入门选手。</p><p>  为此，记录下来并且可查可复习非常重要，这也就是Blog能为我提供的。</p><p><em>性格决定你做怎样的选择，你的选择决定你怎样的人生。生命只有一次，而且它正在以不可逆转的姿态向前推进。你可以去旅行，可以朝九晚五地上班，还可以不顾一切地去创业。只是，千万不要选择平庸的人生。</em></p><blockquote><p>黄色的树林里分出两条路，可惜我不能同时去涉足，我在那路口久久伫立，我向着一条路极目望去，直到它消失在丛林深处。</p></blockquote><blockquote><p>但我选了另外一条路，它荒草萋萋，十分幽寂，显得更诱人，更美丽；虽然在这条小路上，很少留下旅人的足迹。</p></blockquote><blockquote><p>那天清晨落叶满地，两条路都未经脚印污染。啊，留下一条路等改日再见！但我知道路径延绵无尽头，恐怕我难以再回返。</p></blockquote><blockquote><p>也许多少年后在某个地方，我将轻声叹息将往事回顾：一片树林里分出两条路——而我选择了人迹更少的一条，从此决定了我一生的道路。——罗伯特·弗罗斯特《未选择的路》</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>「如何高效的学习」读书笔记</title>
      <link href="/2017/03/22/%E5%A6%82%E4%BD%95%E9%AB%98%E6%95%88%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<p>《如何高效学习》从学习的战略上指导学习知识的策略抛出整体性学习的概念，以及结构、模型、高速公路的观点;详细分析了学习的顺序和信息的分类。以战术的方式分解学习的各种战术，如快速阅读、笔记流、比喻法、内在化、联想法、图表法、挂钩法、信息压缩、知识应用、模型纠错等。下面是我阅读时写下的感想，比较少的书摘。</p><a id="more"></a><h3>1. 类比</h3><p>首先，类比是一个推理方法。<br>其次，类比是把两个具有相似或者相同特征的对象进行推理它们具有其他相似或相同特征的方法。</p><h3>2. 概括</h3><p>   读书，将核心用词语总结概括，是最好的学习习惯，只有这样，知识才真正理解，被你加工，通过联想、概括出自己的观点和想法，知识才被刚刚固化，为了知识更加牢固，还需要将知识进行实践运用，知识最好的实践方式就是传播，传播有时候会收到很多不同意见。相互碰撞，如果你能简单轻松的让他们理解并认可你的观点，说明你基本吃透这个知识点。他们当中的不同声音会让你更加容易固化你的知识点，尝试让他们也信服你如果你是正确的。</p><h3>3. 知识纵向拓展</h3><p>   知识纵向拓展，寻根究底。如学习企业管理知识，企业管理包含了财务、人事等管理，那么财务管理是怎样的，人事管理又是怎样的?再深入财务和人事管理里面的各种细节。结合自己所在公司，思考为什么要这样管理，自己公司是这样管理的吗?别人公司是怎样管理的，自己公司和别的公司管理上有什么差别，如何改进?这就是深度拓展，不断深挖细节。</p><h3>4. 知识横向拓展</h3><p>   知识横向拓展，昨天在印象笔记整理文章的时候，正好看到营销这个词，于是就把各类营销词汇整理了一番，方便以后学习归档，如病毒营销、邮件营销、关系营销、内容营销、事件营销等等，可能里面多个营销方式有很多共同点，分别找出来，也有不同点把它们区别开，这些营销方式适合什么场景下使用，适合企业的什么阶段使用，需要哪些辅助工作才能完成，成本多少?这就是横向拓展，通过知识与知识的联系发现他们共同点和不同点，找出他们的差异化，其实横向拓展和纵向拓展是不会绝对分开，当你开始比较的时候，大脑其实就进入了深度拓展和横向拓展，多思考多关联多实践多PK。</p><h3>5. 结构：理解就是结构高度发达完善的结果。</h3><p>   理解的重要性，一个人看书是否学到东西，看他的笔记和读后感就知道，如果这个人笔记和读后感总结都是勾画的原作者的文字，这是较少理解，不够深入，最差的理解是读书笔记和读后感都没有的，也是最差的学习方式，刚刚说的这些话都是错误的!<br>   真正理解，是可以通过结构化思维表达出来。理解帮忙我们把知识结构化，总感觉这里翻译的有问题，只有理解后的知识才便于储存，便于在大脑里结构化。怎么来理解呢?举个例子<br>   当我们阅读&quot;理解就是结构高度发达完善的结果&quot;的时候，如果很快就弄懂了这句话，这句话可能就相当于电脑内存中的一行数据，当我们阅过这句话，看到下段文字的时候这句话已经从内存中消失。但恰巧我读到时候，有意识觉得这里可以写点什么，就反复读了几遍，理解是结构发达的结果，理解是名词，结构发达是短语，结果是名词是产出物，正确说法是因为〖怎么样〗所以〖造成这个结果〗，那么就应该是因为理解所以造成结构发达的结果。修改后：结构高度发达完善就是理解的结果。<br>   有点咬文嚼字，扯远了，当我开始纠结这句话，大脑其实在高速运转，调动了我大脑磁盘里的相关信息来帮助我理解这句话，并做出推断。然后这句话就会固化在我的大脑磁盘里，不是一闪而过的内存数据，同时我刚刚调用过的知识再次被激活得以运用，知识就是越来应用的，不用就不属于你的知识。<br>   我不敢说解释得很明白，希望你们能够看到我对一字一句的理解，以及我狭小硬盘储存的不是特别完善的知识结构是如何被调用的。<br>   我在这里有意的写笔记是为了培养以后习惯性的思考。</p><h3>6. 模型：模型就像是结构的种子，是一座建筑的地基和框架，是知识最核心的概念，在此基础上将引伸出全部的知识。</h3><p>   先回顾，整体性学习的三个重要概念：结构，模型，高速公路。<br>   当我读完模型这一小节，我的脑子里浮现出类似原子的东西，在黑色的空间里自由漂浮，每个原子并不孤立，它们之间有一条耀眼的类似光线的&quot;脐带&quot;互相交错连接，这条连接线经常是一团亮斑从原子这头快速移动到另一头，所以看整体非常耀眼，其实这就是知识的传递与连接。<br>   现在看来，模型就是知识的最小结构，知识的结构由无数的模型和连接组成，我不知道我理解的连接是不是笔者的高速路公路，带着问题继续往下读，等待犹如开奖的那一惊心动魄。</p><h3>7. 高速公路：结构与结构之间的联系。</h3><p>   高速公路的比喻用得非常精准，这是城际之间的快速通道，是连接结构与结构之间的线路。这条线路传递和连接的知识(不是知识点，模型才是知识点)将以光速进行传递，也就是我们常说的一念之间。<br>   结构是模型的集合，模型与模型之间相互交错连接，结构与结构之间交错连接。知识点互相关联，知识互相连接交错。完美的一幅图画，黑暗的空间，一个个大型的分子，分子是若干原子的集合，是原子的仓库，不断有新的原子增加或者删除，我能清晰的透过分子的透薄如水的墙壁看到原子瞬间增加和破灭的过程，每个原子其中的若干连接线突然断裂，它在瞬间被孤立最后立即消亡，这是一个正常情况无法看到感知到的过程。分子的存亡和原子的存活方式完全不一样，只要有一个原子存在，依靠这类原子组成的分子就不会死亡。</p><h3>8. 结构分类</h3><p>   成熟结构、感知结构、生活经验、关系结构、基础数学结构</p><h3>9. 学习顺序</h3><p>   获取、理解、拓展、纠错、应用，测试伴随以上每一步，总结自省伴随以上每一步。</p><h3>10. 信息获取</h3><p>   信息获取，信息大爆炸的今天我们随时都能接触到海量信息，信息获取渠道非常丰富，百度、百科、知道、知乎、各类APP、新闻网站、社交媒体、自媒体等等，所以我们要提高信息获取的手段和筛选方法。<br></p><ul><li>订阅，订阅自己关注的内容或则话题</li><li>筛选，使用印象笔记或有道云笔记以及剪藏功能，把自己粗读有价值的信息收集整理，记得设置标签，方便以后索引。</li><li>(3) 定时整理笔记工具里的内容，整理成文章总结，将信息进行归类。总结的时候可以根据内容进行发散联想，拓展更广的话题，写下来整理成文章，这就是你的学习所得。</li></ul><h3>11. 信息获取方法</h3><p>   精简信息、增加信息获取的数量和信息来源、提高阅读速度效率</p><h3>12. 信息拓展方法</h3><p>   深度拓展、纵向拓展、横向拓展</p><h3>13.信息获取小结</h3><p>   一句话概括，通过不同手段获取知识，不断理解深入研究，拓展和联想相关知识，不断纠错判断，沉淀正确的知识并实践应用。<br>   拓展知识有三个方法，深度拓展、横向拓展、纵向拓展，深度拓展又可以理解为背景拓展，主要了解知识形成的背景、原因和过程，深度拓展和纵向理解容易造成误会，所以固化背景拓展最佳。<br>   关于信息获取每一步的测试单独说下：</p><ul><li>获取——是否看过听过，如果看过比较了解可以略过，进入初期筛选</li><li>理解——真的明白了知识点的含义了吗?是否可以用最简单的语言和比喻解释清楚</li><li>拓展——知识背景如何，相关知识有哪些，存在什么关系</li><li>纠错——哪些知识点、观点是错误的，正确的是什么?为什么它是错的</li><li>运用——这些知识如何运用到现实生活?有什么意义和价值?</li></ul><h3>14. 信息分类</h3><p>   随意信息、观点信息、过程信息、具体信息、抽象信息</p><h3>15. 挂钩法</h3><p>   刚刚我做了一个关于挂钩法有趣的小实验，用了大概二十秒钟记住8件东西，缺了两样，但是我觉得挂钩法依然非常有效。<br>   这几样东西分别是：</p><table><thead><tr><th style="text-align:center">培根</th></tr></thead><tbody><tr><td style="text-align:center">鸡蛋</td></tr><tr><td style="text-align:center">葡萄酒</td></tr><tr><td style="text-align:center">电池</td></tr><tr><td style="text-align:center">泡泡糖</td></tr><tr><td style="text-align:center">牛奶</td></tr><tr><td style="text-align:center">信封</td></tr><tr><td style="text-align:center">菠菜</td></tr><tr><td style="text-align:center">咖啡</td></tr><tr><td style="text-align:center">番茄</td></tr></tbody></table><p>   然后在一边分别把他们列出来。我是这样记忆的，时不时我上班会去早餐店买一份叫培根煎饼的早餐，里面有培根、鸡蛋、生菜、沙拉酱或者番茄酱或则辣椒酱，我就把生菜巧妙替换成菠菜，煎饼比较干那么肯定得来杯牛奶，营养又健康，和牛奶一样的饮品(联想法)有我平时最爱喝的咖啡，最近我还在学习做牛扒，家里一直缺红酒，红酒也是装逼利器哟，吃完早餐喝完咖啡，心里还想着牛扒红酒高逼格的美食，也该进入工作状态(继续挂钩)，打开邮件(映射信封)，查看有没有工作方面的事情，一边嚼着同事给的口香糖，其实我从不买泡泡糖那种口香糖，太甜越嚼越没味道，回到家吃了这么多好吃的肯定担心自己胖了没就需要称称，恰好，电子称没电了，一直拖着没去买电池。   写了好长时间了啊，实际上就是脑子里一瞬间的联想和挂钩。</p><h3>16. 内在化</h3><p>   通过将信息转化为更容易想象的形式，你可以为知识建立广泛的联系</p><h3>17. 内化与内在化</h3><p>   本文用词稍微不太严谨，前面提到的是内在化，这里提的是内化。</p><ul><li>知识内化，是企业管理的重要组成部分，按字面意思理解就是知识的内部消化吸收再创新。</li><li>知识内在化，我又只有闭眼冥想我那黑暗的知识空间，存在无数的知识分子和原子，当我获得新的知识点(原子)的时候就会通过光速连接(本书中的高速公路)找到适合该原子归类的仓库(分子)，如果这不是简单的知识点本身可以独立成新的知识，会自动产生一个分子并包含最少一个原子，这个分子与刚刚通过的光速连接那端的分子自动连接建立索引，便于以后快速搜索及时反馈。继续扩展下内化的过程是不是和搜索引擎很像，检索新的网页(信息收集)然后通过算法判断是否索引或者更新快照(理解、纠错)，蜘蛛沿着网页入口进行纵向和横向爬行(拓展)然后重复算法的判断，合格的网页进行存储并排序展示给用户(应用)。</li></ul><h3>18. 学习的战略战术</h3><p>   简单说战略指导思想，战术指导方法。学习知识的战略指导你把知识融会贯通，运用到现实生活和工作中，学习知识的战术指导你如何去学习。</p><ul><li>获取知识：快速阅读、笔记流</li><li>联系观点：比喻法、内在化、图表法</li><li>随意信息处理：联想法、挂钩法、信息压缩</li><li>知识拓展：知识应用、模型纠错、以项目为基础学习</li></ul><h3>19. 笔记流</h3><p>   &quot;一次学会&quot;表示你在学习时要全神贯注地听老师讲课，而不是忙着做细致漂亮的笔记，等到课下再学。工作中，尤其是会议，用关键词记录，会议后整理，效率高。<br>   一旦你写下了一个观点，下一步就是在这个观点和其他观点之间画上一些箭头呈现出相互关联的关系，形成一张观点网络。</p><h3>20. 读书笔记</h3><p>   写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</p><h3>21. 费曼技巧</h3><ul><li>选择要学习的内容</li><li>以老师的身份学习</li><li>疑惑时返回学习</li><li>用简单直白和比喻去解释知识点</li></ul><h3>22. 提高效率</h3><ul><li>健康身心</li><li>聪明学习</li><li>不拖延</li><li>批处理碎片信息</li><li>坚持做清单、写日子</li></ul><h3>23. 自我教育</h3><ul><li>养成阅读习惯</li><li>设定学习目标写读书笔记是最好的练习方式，把勾画的重点和自己的观点整理出来，在通过词汇概括，用一句话吧所有重点以词汇的方式串联起来，再分别详细介绍每个词汇背后的观点，以及引用的文摘，可用图表辅助概括总结比较零散的结构。</li></ul>]]></content>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
            <tag> 阅读 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SVM支持向量机</title>
      <link href="/2017/02/27/SVM%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
      <content type="html"><![CDATA[<blockquote><p>通俗来讲，SVM是一种二类分类模型，其基本模型定义为特征空间上的间隔最大的线性分类器，其学习策略便是间隔最大化，最终可转化为一个凸二次规划问题的求解。</p></blockquote><a id="more"></a><h2>从线性回归讲起</h2><p>SVM主要是用来做分类工作，诸如文本分类，图像分类，生物序列分析和生 物数据挖掘， 手写字符识别等领域都有很多的应用。</p><p>对分类最简单的即线性分类器用X表示数据点，Y表示类别（二分类中，y取1或-1），一个线性分类器的目标是在数据空间中找到一个分隔平面,这个分隔平面方程可以表示为：$$\omega^{T}x+b=0$$为使目标函数值在-1到1之间，我们使用Logistic函数作为假设函数。</p><p>假设函数：</p><p>$$h_\theta(x)=g(\theta^{T}x)=\frac{1}{1+e^(-\theta^{T}x)}, \quad h_\theta(x)\in(0,1)$$</p><p>其中，x是n维特征向量，所以假设函数就是y=1的概率：</p><p>$$P(y=1|x;\theta)=h_\theta(x) \ P(y=0|x;\theta)=1-h_\theta(x)$$</p><p>从而，有$h_\theta(x)&gt;0.5$就是y=1的类，反之属于y=0的类。接下来，将结果中y = 0 和 y = 1 替换为 y =-1，y = 1，然后将$\theta^Tx= \theta_0x_0+\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$中的$x_0$替换 为 b，最后将后面的$\theta_1x_1+\theta_2x_2+\cdots+\theta_nx_n(x_0=1)$替换为$\omega^Tx$，也就是说除了 y 由 y = 0 变为 y =1 外，线性分类函数跟 Logistic 回归的形式化表示$h_\theta(x)=g(\theta^Tx)=g(\omega^Tx+b)$没区别。<img src="http://img.blog.csdn.net/20170226133437427?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><h3>函数间隔与几何间隔</h3><p>在超平面 $\omega^{T} x + b = 0$ 确定的情况下，$|\omega^{T} x + b|$ 能够表示点 x 到距离超平面的远近 ，而通过观察 $\omega^{T} x + b$的符号与类标记 y 的符号是否一致可判断分类是否正确，所以，可以用 $y(\omega^{T} x + b)$ 的正负性来判定或表示分类的正确性。</p><p>给定的训练数据集T和超平面w,b)，定义超平面(w,b)关于样本点(xi,yi)的函数间隔为：$$\hat{\gamma}=y(\omega^{T}x+b)=y(f(x))$$但这样定义的函数间隔有问题，即如果成比例的改变 w 和 b（如将它们改成 2w 和 2b），则函数间隔的值 f(x) 却变成了原来的 2 倍（虽然此时超平面没有改变），所以只 有函数间隔还远远不够。</p><p>平面法向单位化的函数间隔，即几何间隔$$\gamma=\frac{\omega^{T}x+b}{||\omega||}=\frac{f((x)}{||\omega||}$$假定对于一个点 x ，令其垂直投影到超平面上的对应点为 $x_0$ ，w 是垂直于超平面 的一个向量， 为样本 x 到分类间隔的距离，如图所示。<img src="http://img.blog.csdn.net/20170226134808933?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log"></p><p>从上述的定义可以看出：几何间隔就是函数间隔除以 $∥\omega∥$，而且函 数间隔 $y(w ^T x + b) = yf(x)$ 实际上就是 $|f(x)|$，只是人为定义的一个间隔度量，而几何 间隔 $|f(x)|/∥\omega∥$ 才是直观上的点到超平面的距离。</p><h2>最大间隔分类器</h2><p>对一个数据点进行分类， SVM的思想是当超平面离数据点的“间隔”越大， 分类的确信度 （conﬁdence）也越大。<img src="http://img.blog.csdn.net/20170226135127419?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>定义目标函数：<img src="http://img.blog.csdn.net/20170226135744814?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p>回顾一下几何间隔的定义 $\tilde{\gamma}=y\gamma = \frac{hat{\gamma}}{∥\omega∥}$ 可知， 如果令函数间隔 $\hat{\gamma}$等于 1， 则有$\tilde{\gamma}=\frac{1}{∥w∥}$ 且 $y_i (\omega ^T x_i + b) \geq1; \quad i = 1; \cdots; n$</p><p>从而上述目标函数转化成了：</p><p>$$ max\quad \frac{1}{||w||} ;\ s.t. y_i (w^{T} x_i + b)\geq1;\quad i = 1, \cdots,n$$</p><p>这个目标函数便是在相应的约束条件$y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$条件下，最大化这个 $\frac{1}{||w||}$ 值，而 $\frac{1}{||w||}$便是几何间隔$\tilde{\gamma}$。</p><h2>拉格朗日乘子法</h2><p>由于求 $\frac{1}{||w||}$ 的最大值相当于求 $\frac{1}{2}||w||^2$ 的最小值，所以上述目标函数等价于</p><p>$$ min\quad \frac{1}{2}||w||^2 ; \ s.t. y_i (w^T x_i + b) \geq1;\quad i = 1, \cdots,n$$</p><p>因为现在的目标函数是二次的，约束条件是线性的，所以它是一个凸二次规划问题。这个问题可以用现成的 QP (Quadratic Programming) 优化包进行求解。一言以蔽之：在一定的约束条件下，目标最优，损失最小。</p><p>此外，由于这个问题的特殊结构，还可以通过拉格朗日对偶性（Lagrange Duality） 变换到对偶变量 (dual variable) 的优化问题， 即通过求解与原问题等价的对偶问题 （dual problem）得到原始问题的最优解，这就是线性可分条件下支持向量机的对偶算 法，这样做的优点在于：一者对偶问题往往更容易求解；二者可以自然的引入核函数， 进而推广到非线性分类问题。</p><p>那什么是拉格朗日对偶性呢？简单来讲，通过给每一个约束条件加上一个拉格朗日乘子（Lagrange multiplier），定义拉格朗日函数</p><p>$$L(\omega,b,\alpha)= \frac{1}{2}||w||^2-\sum_{i=1}^{n}\alpha_i(y_i(w_i^Tx_i+b)-1)$$</p><p>原问题是极小极大问题:$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)$$</p><p>原始问题的对偶问题，是极大极小问题:$$\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p>将拉格朗日函数$L(w,b,\alpha)$分别对w，b求偏导并令其为0,</p><p><img src="http://img.blog.csdn.net/20170226142614206?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log00"></p><p>将上式带入拉格朗日函数$L(w,b,\alpha)$中，得到：</p><p><img src="http://img.blog.csdn.net/20170226142712754?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"></p><p>继续求$\underset{w,b}{min}L(w,b,\alpha)$对$\alpha$的极大值:</p><p><img src="http://img.blog.csdn.net/20170226142934391?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>整理目标函数，求解出最优的$\alpha^{*}$<img src="http://img.blog.csdn.net/20170226172322298?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>上式为一般的含不等式约束问题，存在最优化解法的必要和充分条件即KKT条件（详情可查看<a href="http://blog.csdn.net/touristman5/article/details/57418552" target="_blank" rel="noopener">等式约束与不等式约束问题</a>）：为方便理解，我们把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$$L(a,b,x)=f(x)+a∗g(x)+b∗h(x)$$</p><p>KKT条件是说最优值必须满足以下条件：</p><ol><li>$\frac{\partial{L}}{\partial{x_i}}=0$对x求导为零；</li><li>$h(x) =0;$</li><li>$a*g(x) = 0;$</li></ol><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为$g(x)&lt;=0$，如果要满足这个等式，必须$\alpha=0$或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><p>所谓 支撑向量Supporting Vector 也在这里显示出来——事实上，所有非 Supporting Vector 所对应的系数都是等于零的，因此对于新点的内积计算实际上 只要针对少量的“支持向量”而不是所有的训练数据即可。</p><h3>核函数</h3><p>对于线性不可分的情况，可以使用核函数，将输入空间映射到特征空间（通俗说来是从低维空间映射到高维空间），从而使得原本线性不可分的样本可以在特征空间可分。</p><p><img src="http://img.blog.csdn.net/20170226174650918?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log04"></p><p>在实际应用中，往往依赖先验领域知识才能选择有效的核函数####常见的核函数有</p><ul><li>多项式核函数：$$K(x_1,x_2)=(\left \langle x_1,x_2  \right \rangle)^d$$</li><li>高斯核函数：$$K(x_1,x_2)=exp^ { \frac{||x_1-x_2||}{2\sigma^2} } $$</li></ul><p>参考链接：</p><ol><li>统计学习方法，李航著，清华大学出版社，2012年</li><li><a href="http://blog.csdn.net/v_july_v/article/details/7624837" target="_blank" rel="noopener">http://blog.csdn.net/v_july_v/article/details/7624837</a></li><li><a href="http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html" target="_blank" rel="noopener">http://www.cnblogs.com/zjgtan/archive/2013/09/03/3298213.html</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 统计学 </tag>
            
            <tag> Machine Learning </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用Tensflow写简单的神经网络</title>
      <link href="/2017/02/25/%E7%94%A8Tensflow%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
      <content type="html"><![CDATA[<p>TensorFlow是一个采用数据流图（data flow graphs），用于数值计算的开源软件库。节点（Nodes）在图中表示数学操作，图中的线（edges）则表示在节点间相互联系的多维数据数组，即张量（tensor）。它灵活的架构让你可以在多种平台上展开计算，例如台式计算机中的一个或多个CPU（或GPU），服务器，移动设备等等。</p><a id="more"></a><p><img src="http://tensorfly.cn/images/tensors_flowing.gif" alt="log00"></p><p>根据上图，可以看出一个简单神经网络所具有的模块结构，首先输入层(Input Layer)，接受相关的结构化化数据；其次是隐藏层(Hidden Layer)，隐藏层主要加权运算，通过激活函数达到拟合线性非线性函数的目的；最后有输出层(Output Layer)，其结果成为下一次迭代的初始值。</p><p>一个的单层神经网络如下：<img src="http://hahack.com/images/ann2/w4eQd.png" alt="log01"></p><p>就此，我们用Tensorflow实现一个单层神经网络，参考代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/python  </span></span><br><span class="line"><span class="comment"># -*- coding: utf-8 -*-  </span></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义神经网络层</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_layer</span><span class="params">(inputs,in_size,out_size,activation_function=None)</span>:</span></span><br><span class="line">    Weights = tf.Variable(tf.random_normal([in_size,out_size]))</span><br><span class="line">    biases = tf.Variable(tf.zeros([<span class="number">1</span>,out_size])+<span class="number">0.1</span>)</span><br><span class="line">    Wx_plus_b = tf.matmul(inputs,Weights)+biases</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> activation_function <span class="keyword">is</span> <span class="keyword">None</span>:</span><br><span class="line">        outputs = Wx_plus_b</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        outputs = activation_function(Wx_plus_b)</span><br><span class="line">    <span class="keyword">return</span> outputs</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义数据</span></span><br><span class="line">x_d = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">300</span>)[:,np.newaxis]</span><br><span class="line">noise = np.random.normal(<span class="number">0</span>,<span class="number">0.05</span>,x_d.shape)</span><br><span class="line">y_d = np.square(x_d) - <span class="number">0.5</span> + noise</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义placeholder，可以更方便</span></span><br><span class="line">xs = tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">1</span>])</span><br><span class="line">ys = tf.placeholder(tf.float32,[<span class="keyword">None</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加隐藏层</span></span><br><span class="line">layer1 = add_layer(xs,<span class="number">1</span>,<span class="number">10</span>,activation_function = tf.nn.relu)</span><br><span class="line">predict = add_layer(layer1,<span class="number">10</span>,<span class="number">1</span>,activation_function = <span class="keyword">None</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 定义损失函数</span></span><br><span class="line">loss = tf.reduce_mean(tf.reduce_sum(tf.square(ys - predict),reduction_indices=[<span class="number">1</span>]))</span><br><span class="line">train_step = tf.train.GradientDescentOptimizer(<span class="number">0.3</span>).minimize(loss)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 初始化</span></span><br><span class="line"><span class="comment"># init = tf.initialize_all_variables() no long valid from</span></span><br><span class="line"><span class="comment"># 2017-03-02 if using tensorflow &gt;= 0.12</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> int((tf.__version__).split(<span class="string">'.'</span>)[<span class="number">1</span>]) &lt; <span class="number">12</span>:</span><br><span class="line">    init = tf.initialize_all_variables()</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    init = tf.global_variables_initializer()</span><br><span class="line">sess = tf.Session()</span><br><span class="line">sess.run(init)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出结果</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="comment"># 训练</span></span><br><span class="line">    sess.run(train_step, feed_dict=&#123;xs: x_d, ys: y_d&#125;)</span><br><span class="line">    <span class="keyword">if</span> i % <span class="number">50</span> == <span class="number">0</span>:</span><br><span class="line">        <span class="comment"># to see the step improvement</span></span><br><span class="line">        print(sess.run(loss, feed_dict=&#123;xs: x_d, ys: y_d&#125;))</span><br></pre></td></tr></table></figure><p>单机运行结果如下：<img src="http://img.blog.csdn.net/20170225020607154?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log2"></p><blockquote><p>[1]参考链接：<a href="https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13" target="_blank" rel="noopener">https://www.youtube.com/watch?v=S9wBMi2B4Ss&amp;list=PLXO45tsB95cKI5AIlf5TxxFPzb-0zeVZ8&amp;index=13</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Python </tag>
            
            <tag> Machine Learning </tag>
            
            <tag> TensorFlow </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>唐璜节选</title>
      <link href="/2017/02/23/%E5%94%90%E7%92%9C%E8%8A%82%E9%80%89/"/>
      <content type="html"><![CDATA[<p>   诗歌能做到以更简练、更摄人心魄的精准语言与我们的灵魂直接沟通。</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">生命激荡着青葱的希望</span><br><span class="line">爱意伴随着激情的火焰</span><br><span class="line">美食、酒神，都是爱情的风帆</span><br><span class="line">——唐璜-「七」岩穴奇情</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">生命的美好不能束缚他，死亡的狰狞也不能毁灭它</span><br><span class="line">来自他的母亲—摩尔人赋予她刚强的性格</span><br><span class="line">他将彻底面对世界</span><br><span class="line">乐园和荒漠，没有第三条路</span><br><span class="line"></span><br><span class="line">希腊的少女曾用哀歌，咏叹海黛的爱</span><br><span class="line">迁居的岛民，也曾在漫漫长夜将这一切讲述</span><br><span class="line">夜色大海静，传说流万古</span><br><span class="line">孤岛痴女情，唯有诗人知</span><br><span class="line">——唐璜-「十六」伤逝</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">爱情犹如鸦片，不用太多</span><br><span class="line">一口便让人迷醉</span><br><span class="line">除了泪水情人的眼睛什么都能汲取</span><br><span class="line">尤其是生命的泉水</span><br><span class="line"></span><br><span class="line">这已经足够，爱情虚无飘渺</span><br><span class="line">它因自私而起，又因自私结束</span><br><span class="line">还有一种爱情只是一时的热忱</span><br><span class="line">把自己的脆弱与孤独的美相结合</span><br><span class="line">点缀那一颗疯狂的无法遏制的心</span><br><span class="line">如果没有这种美，热情也就消失</span><br><span class="line">——唐璜-「三十二」女皇的恩宠</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 文字 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>共轭先验</title>
      <link href="/2017/02/18/%E5%85%B1%E8%BD%AD%E5%85%88%E9%AA%8C/"/>
      <content type="html"><![CDATA[<blockquote><p>定义：如果先验分布和似然函数可以使得先验分布和后验分布有相同的形式，那么就称先验分布与似然函数是共轭的。</p></blockquote><a id="more"></a><p>读数理统计学导论时，遇到过共轭先验的概念。  贝叶斯判别准则中，分别假设了先验分布$p(\theta)$，后验分布$p(\theta|X)$，以及$p(X), p(X|\theta)$似然函数。</p><p>贝叶斯定理可以写作：$$P(\theta|X)=\frac{P(\theta)P(X|\theta)}{P(X)}$$</p><p>即 「后验分布 =先验分布 * 似然函数 / P(X)」</p><p>  之所以采用共轭先验的原因是可以使得先验分布和后验分布的形式相同，这样一方面合符人的直观（它们应该是相同形式的；另外一方面是可以形成一个先验链，即现在的后验分布可以作为下一次计算的先验分布，如果形式相同就可以形成一个链条。为了使得先验分布和后验分布的形式相同，我们定义：如果先验分布和似然函数可以使得先验分布和后验分布有相同的形式，那么就称先验分布与似然函数是共轭的。所以共轭是指：先验分布和似然函数共轭。</p><h3>例子：</h3><p>共轭先验通常可以由分布的pdf或pmf来确定。</p><p>考虑二项模型：$$p(x)={n \choose x}q^{x}(1-q)^{n-x}$$</p><p>写成以q为参数的函数形式：$$f(q)\propto q^{a}(1-q)^{b}$$</p><p>通常这个函数应该还缺少一个乘数因子，以保证pdf的积分值为1。</p><p>这个乘数项是a，b的函数。写作下面的形式$$p(q)={q^{\alpha -1}(1-q)^{\beta -1} \over \mathrm {B} (\alpha ,\beta )}$$</p><p>可以看出，乘上的$\mathrm {B} (\alpha ,\beta )$作为归一化常熟存在，根据上面定义，可得二项分布的共轭分布族是<strong>贝塔分布。</strong></p><p>  与共轭先验对应的概念是共轭分布族(Conjugate family of distribution),所谓共轭分布族是指参数$\theta$的后验pdf与作为先验的分布族是相同的，则称此类先验pdf关于具有pdf$f(x|\theta),\theta \in \Omega$的分布族为共轭分布。</p><p>  例如，给定$\theta$时随机变量X的pmf是均值为$\theta$的泊松分布。若我们选取伽马先验，由贝叶斯定理计算出后验也是伽马分布族。则称，伽马分布族构成这种泊松模型的共轭先验类。</p><p>参考资料：</p><ol><li>Pattern Recognition and Machine Learning ,  M. Bishop</li><li>数理统计学导论 ,Robert V.Hogg</li><li>Conjugate prior - Wikipedia</li></ol>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全局优化算法之粒子群算法</title>
      <link href="/2017/02/05/%E5%85%A8%E5%B1%80%E6%90%9C%E7%B4%A2%E7%AE%97%E6%B3%95%E4%B9%8B%E7%B2%92%E5%AD%90%E7%BE%A4%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<h2>序言</h2><p>  前面讨论过一些迭代算法，包括牛顿法、梯度方法、共轭梯度方法和拟牛顿法，能够从初始点出发，产生一个迭代序列。很多时候，迭代序列只能收敛到局部极小点。因此，为了保证算法收敛到全局最小点，有时需要在全局极小点附近选择初始点。此外，这些方法需要计算目标函数。</p><p>  全局优化算法又称现代启发式算法，是一种具有全局优化性能、通用性强且适合于并行处理的算法。这种算法一般具有严密的理论依据，而不是单纯凭借专家经验，理论上可以在一定的时间内找到最优解或近似最优解。遗传算法属于智能优化算法之一。</p><p>  常用的全局优化算法有： 遗传算法 、模拟退火算法、禁忌搜索算法、粒子群算法、蚁群算法。</p><h2>PSO算法</h2><p>  粒子群算法（Particle swarm optimization）是由James Kennedy &amp;<a href="http://www.engr.iupui.edu/~eberhart/" target="_blank" rel="noopener">Russell Eberhart</a>提出。区别于上节讨论的模拟退火算法，粒子群算法并不是只更新单个迭代点，而是更新一组迭代点，称为群。群中每个点称为粒子。可将群视为一个无序的群体，其中的每个成员都在移动，意在形成聚集，但移动方向是随机的。</p><p>  具体来说，求取目标函数在$\mathbb{R}^n$上极小点的过程。</p><ol><li>在$\mathbb{R}^n$随机产生一组数据点，为每个点赋予一个速度，构成一个速度向量。这些点视为粒子所在的位置，以指定速度在运动。</li><li>针对每个数据点计算对应的目标函数值，基于计算结果，产生一组新的数据点，赋予新的运动速度。</li></ol><p>  其每个粒子都持续追踪到目前为止最好的位置，称到目前为止最好的位置为Pbest，全局最好为止Gbest。基于粒子的个体最好位置和群的群的全局最优位置，调整各粒子的运动速度，实现粒子的“交互“。即在每次迭代中，产生两个随机数，分别作为pbest和gbest的权重，以此构成pbest和gbest的一个组合值，分别称为速度项和随机项，再加上加权后的原有速度，可以实现对原有速度的更新。</p><p>  目标函数在$\mathbb{R}^n$中，由种群数m组成粒子群，其中第i个粒子在d维的位置为$x_{id}$，其飞行速度为$v_{id}$，该粒子当前搜索的最优位置为，整个粒子群当前位置为，更新公式如下：$$v_{id}^{t+1}=v_{id}^{t}+c_1r_1(P_{id}-x_{id}+c_2r_2(P_{gd}-x_{id}))\quad (1) \ x_{id}^{t+1}=x_{id}{t}+v_{id}^{t+1} \quad \quad(2)$$</p><p>$r_1、r_2$是服从U(0,1)分布的随机数，学习因子$c_1、c_2$为非负常数，通常取$c_1=c_2=2$，$v_id \in [v_{min},v_{max}],v_{max}$是自设定的常数，迭代终止条件为预设的最大迭代数或预定的最小适应度阈值。</p><p>Matlab代码示例：</p><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">%% 该代码为基于PSO的函数极值寻优</span></span><br><span class="line"><span class="comment">%</span></span><br><span class="line"><span class="comment">%% 清空环境</span></span><br><span class="line">clc</span><br><span class="line">clear</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 参数初始化</span></span><br><span class="line"><span class="comment">%粒子群算法中的两个参数</span></span><br><span class="line">c1 = <span class="number">1.49445</span>;</span><br><span class="line">c2 = <span class="number">1.49445</span>;</span><br><span class="line"></span><br><span class="line">maxgen=<span class="number">500</span>;   <span class="comment">% 进化次数  </span></span><br><span class="line">sizepop=<span class="number">100</span>;   <span class="comment">%种群规模</span></span><br><span class="line"></span><br><span class="line">Vmax=<span class="number">1</span>;</span><br><span class="line">Vmin=<span class="number">-1</span>;</span><br><span class="line">popmax=<span class="number">5</span>;</span><br><span class="line">popmin=<span class="number">-5</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">%% 产生初始粒子和速度</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:sizepop</span><br><span class="line">    <span class="comment">%随机产生一个种群</span></span><br><span class="line">    pop(<span class="built_in">i</span>,:)=<span class="number">5</span>*rands(<span class="number">1</span>,<span class="number">2</span>);    <span class="comment">%初始种群</span></span><br><span class="line">    V(<span class="built_in">i</span>,:)=rands(<span class="number">1</span>,<span class="number">2</span>);  <span class="comment">%初始化速度</span></span><br><span class="line">    <span class="comment">%计算适应度</span></span><br><span class="line">    fitness(<span class="built_in">i</span>)=fun(pop(<span class="built_in">i</span>,:));   <span class="comment">%染色体的适应度</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 个体极值和群体极值</span></span><br><span class="line">[bestfitness bestindex]=min(fitness);</span><br><span class="line">zbest=pop(bestindex,:);   <span class="comment">%全局最佳</span></span><br><span class="line">gbest=pop;    <span class="comment">%个体最佳</span></span><br><span class="line">fitnessgbest=fitness;   <span class="comment">%个体最佳适应度值</span></span><br><span class="line">fitnesszbest=bestfitness;   <span class="comment">%全局最佳适应度值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">%% 迭代寻优</span></span><br><span class="line"><span class="keyword">for</span> <span class="built_in">i</span>=<span class="number">1</span>:maxgen</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:sizepop</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%速度更新</span></span><br><span class="line">        V(<span class="built_in">j</span>,:) = V(<span class="built_in">j</span>,:) + c1*<span class="built_in">rand</span>*(gbest(<span class="built_in">j</span>,:) - pop(<span class="built_in">j</span>,:)) + c2*<span class="built_in">rand</span>*(zbest - pop(<span class="built_in">j</span>,:));</span><br><span class="line">        V(<span class="built_in">j</span>,<span class="built_in">find</span>(V(<span class="built_in">j</span>,:)&gt;Vmax))=Vmax;</span><br><span class="line">        V(<span class="built_in">j</span>,<span class="built_in">find</span>(V(<span class="built_in">j</span>,:)&lt;Vmin))=Vmin;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%种群更新</span></span><br><span class="line">        pop(<span class="built_in">j</span>,:)=pop(<span class="built_in">j</span>,:)+<span class="number">0.5</span>*V(<span class="built_in">j</span>,:);</span><br><span class="line">        pop(<span class="built_in">j</span>,<span class="built_in">find</span>(pop(<span class="built_in">j</span>,:)&gt;popmax))=popmax;</span><br><span class="line">        pop(<span class="built_in">j</span>,<span class="built_in">find</span>(pop(<span class="built_in">j</span>,:)&lt;popmin))=popmin;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%适应度值</span></span><br><span class="line">        fitness(<span class="built_in">j</span>)=fun(pop(<span class="built_in">j</span>,:)); </span><br><span class="line">   </span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> <span class="built_in">j</span>=<span class="number">1</span>:sizepop</span><br><span class="line">        </span><br><span class="line">        <span class="comment">%个体最优更新</span></span><br><span class="line">        <span class="keyword">if</span> fitness(<span class="built_in">j</span>) &lt; fitnessgbest(<span class="built_in">j</span>)</span><br><span class="line">            gbest(<span class="built_in">j</span>,:) = pop(<span class="built_in">j</span>,:);</span><br><span class="line">            fitnessgbest(<span class="built_in">j</span>) = fitness(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">%群体最优更新</span></span><br><span class="line">        <span class="keyword">if</span> fitness(<span class="built_in">j</span>) &lt; fitnesszbest</span><br><span class="line">            zbest = pop(<span class="built_in">j</span>,:);</span><br><span class="line">            fitnesszbest = fitness(<span class="built_in">j</span>);</span><br><span class="line">        <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">end</span> </span><br><span class="line">    yy(<span class="built_in">i</span>)=fitnesszbest;    </span><br><span class="line">        </span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="comment">%% 结果分析</span></span><br><span class="line">plot(yy)</span><br><span class="line">title(<span class="string">'最优个体适应度'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);</span><br><span class="line">xlabel(<span class="string">'进化代数'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);ylabel(<span class="string">'适应度'</span>,<span class="string">'fontsize'</span>,<span class="number">12</span>);</span><br></pre></td></tr></table></figure><p>参考论文：</p><ol><li>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</li><li><a href="http://www.jos.org.cn/1000-9825/18/861.pdf" target="_blank" rel="noopener">一种更简化更高效的粒子群算法</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全局优化算法之遗传算法</title>
      <link href="/2017/02/03/%E5%85%A8%E5%B1%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E9%81%97%E4%BC%A0%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<h2>全局优化算法概述</h2><p>前面讨论过一些迭代算法，包括牛顿法、梯度方法、共轭梯度方法和拟牛顿法，能够从初始点出发，产生一个迭代序列。很多时候，<font color="blue">迭代序列只能收敛到局部极小点。</font>因此，为了保证算法收敛到全局最小点，有时需要在全局极小点附近选择初始点。此外，这些方法需要计算目标函数。</p><a id="more"></a><p>全局优化算法又称现代启发式算法，是一种具有全局优化性能、通用性强且适合于并行处理的算法。这种算法一般具有严密的理论依据，而不是单纯凭借专家经验，理论上可以在一定的时间内找到最优解或近似最优解。遗传算法属于智能优化算法之一。</p><p>常用的全局优化算法有：遗传算法 、模拟退火算法、禁忌搜索算法、粒子群算法、蚁群算法。</p><h3>1、染色体编码</h3><p>实际上遗传算法并不是直接针对约束集中的点进行操作，而是针对这些点的编码后再进行相关变异交叉等操作。具体说来，如约束集$\omega$中的点24映射为一个字符串集合-- 11000，这些字符串全部都是等长的，称为染色体。基本遗传算法（SGA）使用二进制串进行编码。</p><h3>2、适应度函数</h3><p>遗传算法对一个个体（解）的好坏用适应度函数值来评价，适应度函数值越大，解的质量越好。适应度函数是遗传算法进化过程的驱动力，也是进行自然选择的唯一标准，它的设计应结合求解问题本身的要求而定。</p><h3>3、选择和进化步骤</h3><p>在选择步骤中，利用选择操作构造一个新的种群$M(k)$，使其个体数量与种群相等，种群中个体数量称为个体容量，用N表示，M是在P的基础上进行随机处理后得到的，即M中的每个个体以概率<font size="3">$$\frac{f(x^{(k)})}{F(k)}$$</font>等于$P(k)$中的$x^{(k)}$，其中，<font size="3">$F(k)=\sum f(x_{i}^{(k)})$</font>，指的是对整个P进行求和，也就是说，染色体被选中的概率与其适应度函数值大小成正比。</p><h4>轮盘赌选择方法：</h4><img src="http://hi.csdn.net/attachment/201101/12/8394323_1294826341f6bF.jpg" width="50%" height="50%"><p>轮盘赌选择法可用如下过程模拟来实现：</p><ol><li>在［0, 1］内产生一个均匀分布的随机数r。</li><li>若r≤q(1),则染色体x(1)被选中。</li><li>若$q(k-1)&lt; r ≤ q(k)$,其中(2≤k≤N), 则染色体x(k)被选中。其中的qi称为染色体$x_i (i=1, 2, \cdots, n)$的积累概率, 其计算公式为</li></ol><p>$$q_i=\sum_{j=1}^{i}P_j$$</p><p>得到积累概率为：</p><img src="http://hi.csdn.net/attachment/201101/12/8394323_129482634014NA.jpg" width="50%" height="50%"><p>轮盘赌选择方法的实现步骤:</p><ol><li>计算群体中所有个体的适应度值；</li><li>计算每个个体的选择概率；</li><li>计算积累概率；</li><li>采用模拟赌盘操作（即生成0到1之间的随机数与每个个体遗传到下一代群体的概率进行匹配）来确定各个个体是否遗传到下一代群体中。</li></ol><h3>4、交叉算子</h3><p>交叉运算，是指对两个相互配对的染色体依据交叉概率，按某种方式相互交换其部分基因，从而形成两个新的个体。</p><p>交叉运算是遗传算法区别于其他进化算法的重要特征，它在遗传算法中起关键作用，是产生新个体的主要方法。基本遗传算法（SGA）中交叉算子采用单点交叉算子。</p><p>单点交叉运算</p><p><img src="http://hi.csdn.net/attachment/201101/12/8394323_1294826338NWUh.jpg" alt="log02"></p><h3>5、变异算子</h3><ul><li>变异运算，是指改变个体编码串中的某些基因值，从而形成新的个体。</li><li>变异运算是产生新个体的<strong>辅助方法</strong>，决定遗传算法的局部搜索能力，保持种群多样性。</li><li>交叉运算和变异运算的相互配合，共同完成对搜索空间的全局搜索和局部搜索。</li><li>基本遗传算法（SGA）中变异算子采用基本位变异算子。</li></ul><p>基本位变异算子是指对个体编码串随机指定的某一位或某几位基因作变异运算。对于二进制编码符号串所表示的个体，若需要进行变异操作的某一基因座上的原有基因值为0，则将其变为1；反之，若原有基因值为1，则将其变为0 。</p><p><img src="http://hi.csdn.net/attachment/201101/12/8394323_129482633872s3.jpg" alt="log03"></p><div align="center">基本位变异算子的执行过程</div><p><font color="red"><strong>交叉和变异操作目的在于创建一个新的种群，使得新种群目标函数的平均值能够大于上一代种群。总的说来，遗传算法就是针对种群迭代开展交叉和变异操作，产生新种群，直到满足预定的停止条件。</strong></font></p><p>Matlab示例：</p><p>选择适应度函数为：$f(x) = x + 10sin(5x) + 7cos(4x)$函数图像为</p><p><img src="http://img.blog.csdn.net/20170227193922105?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log04"></p><p>运行结果为：</p><p><img src="http://img.blog.csdn.net/20170227193901589?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log05"></p><p>最优个体为： 10101111011111011</p><p>最优值为：24.8554</p><p>相关Matlab代码参考：<a href="https://github.com/yanshengjia/artificial-intelligence/tree/master/genetic-algorithm-for-functional-maximum-problem/src" target="_blank" rel="noopener">Github地址</a></p><ol><li>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</li><li><a href="http://blog.csdn.net/v_JULY_v/article/details/6132775" target="_blank" rel="noopener">http://blog.csdn.net/v_JULY_v/article/details/6132775</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>全局优化算法之模拟退火算法</title>
      <link href="/2017/02/03/%E5%85%A8%E5%B1%80%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E4%B9%8B%E6%A8%A1%E6%8B%9F%E9%80%80%E7%81%AB%E7%AE%97%E6%B3%95/"/>
      <content type="html"><![CDATA[<h2>序言</h2><p>前面讨论过一些迭代算法，包括牛顿法、梯度方法、共轭梯度方法和拟牛顿法，能够从初始点出发，产生一个迭代序列。很多时候，迭代序列只能收敛到局部极小点。因此，为了保证算法收敛到全局最小点，有时需要在全局极小点附近选择初始点。此外，这些方法需要计算目标函数。</p><a id="more"></a><p>全局优化算法又称现代启发式算法，是一种具有全局优化性能、通用性强且适合于并行处理的算法。这种算法一般具有严密的理论依据，而不是单纯凭借专家经验，理论上可以在一定的时间内找到最优解或近似最优解。遗传算法属于智能优化算法之一。</p><p>常用的全局优化算法有：遗传算法 、模拟退火算法、禁忌搜索算法、粒子群算法、蚁群算法。</p><h2>1、随机搜索算法</h2><p>模拟退火算法是一种随机搜索算法，随机搜索方法也称作概率搜索算法，这很好理解，是一种能够在优化问题的可行集中随机采样，逐步完成搜索的算法。German首次将模拟退火算法应用在凸显处理领域。<a href="http://www.stat.cmu.edu/~acthomas/724/Geman.pdf" target="_blank" rel="noopener">论文地址</a>后续有时间我可以是这翻译一下。</p><h3>朴素随机搜索算法步骤：</h3><ol><li>令$K=0$，选定初始点$x^{(0)}\in \Omega$</li><li>从$N(x^{(k)})$中随机选定一个备选点$z^{(k)}$</li><li>如果$f(z^{(k)}) &lt; f(x^{(k)})$,则令$x^{(k+1)}=z_{(k)}$，否则$x^{(k+1)}=x_{(k)}$</li><li>如果满足停止条件，则停止迭代</li><li>令$k=k+1$，回到第2步</li></ol><p>算法分析：朴素随机搜索算法面临的问题在于领域$N(x^{(k)})$的设计，一方面要保证领域足够大，否则算法可能会在局部点&quot;卡住&quot;；但如果使领域太大的话，会使得搜索过程变得很慢。另一种，对领域问题的解决方案是对朴素随机搜索算法进行修改，使其能够&quot;爬出&quot;局部极小点的&quot;领域&quot;。<font color="red"><strong>这意味着两次迭代中，算法产生的新点可能会比当前点要差。模拟退火算法就设计了这样的机制。</strong></font></p><h2>2、模拟退火算法</h2><h3>算法步骤</h3><ol><li>令$K=0$，选定初始点$x^{(0)}\in \Omega$</li><li>从$N(x^{(k)})$中随机选定一个备选点$z^{(k)}$</li><li><font color="red"><strong>设计一枚特殊的硬币，使其在一次抛投过程中出现正面的概率为$P(k,f(z^{(k)}),f(x^{(k)}))$。抛一次硬币，如果出现正面，则令$x^{(k+1)}=z^{(k)}$，否则$x^{(k+1)}=x_{(k)}。$</strong></font></li><li>如果满足停止条件，则停止迭代</li><li>令$k=k+1$，回到第2步</li></ol><p>注：其中所说的&quot;抛硬币&quot;实际可理解成一种随机决策。</p><p>算法进行中，第k次迭代，可以追踪到目前最好的点$x_{best}^{(k)}$，即能够对所有的$i \in {0,\cdots ,k },$都有$f(x^{(j)})\leqslant  f(x^{(i)})$成立的$x^{(j)}$。</p><p>$x_{best}^{(k)}$按照以下方式进行更新</p><p><img src="http://img.blog.csdn.net/20170228102458217?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述"></p><p><font color="red"><strong>通过持续追踪并更新当前为止最好的点，可以将模拟退火算法简单视为一个搜索过程，搜索过程的最终目的是出处当前为止最好的点。这种说法适合绝大部分启发式算法。</strong></font></p><h2>3、模拟退火算法与朴素随机搜索算法的区别</h2><p>模拟退火算法与朴素随机搜索算法区别在于步骤3，该步骤中，<font color="red"><strong>模拟退火算法以一定的概率选择备选点作为下一次迭代点，即使这个备选点比当前的迭代点要差。这一概率被称作接受概率，接受概率要合理设定，才能保证迭代过程正确进行</strong>。</font>$$P(k,f(z^{(k)}),f(x^{(k)}))=min(1,exp(\frac{-f(x^{(k)})+f(z^{(k)})}{T_k}))$$$T_k$称为冷却温度</p><p>从上式我们至少可以推出，如果$f(z^{(k)})\leqslant f(x^{(k)})$，则p=1，即$x^{(k+1)}=z^{(k)}$。如果$f(z^{(k)}) &gt;f(x^{(k)})$，则仍有一定概率使得$x^{(k+1)}=z^{(k)}$，这一概率为,$exp(\frac{-f(x^{(k)})+f(z^{(k)})}{T_k})$。</p><p><font color="red"><strong>$f(z^{(k)}) 与f(x^{(k)})$之间差异越大，采用$z^{(k)}$作为下一迭代点的概率就越小。类似的，$T_k$越小，采用$z^{(k)}$作为下一迭代点的概率就越小。</strong></font>通常的做法是令温度$T_k$递减到0（表示冷却过程）。也就是说，随着迭代次数的增加，算法趋于更差点的概率越来越小。</p><p>对于温度参数的研究，可以<a href="https://stuff.mit.edu/afs/athena/course/6/6.435/www/Hajek88.pdf" target="_blank" rel="noopener">参考论文</a></p><h2>4、 模拟退火算法伪代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">* J(y)：在状态y时的评价函数值</span></span><br><span class="line"><span class="comment">* Y(i)：表示当前状态</span></span><br><span class="line"><span class="comment">* Y(i+1)：表示新的状态</span></span><br><span class="line"><span class="comment">* r： 用于控制降温的快慢</span></span><br><span class="line"><span class="comment">* T： 系统的温度，系统初始应该要处于一个高温的状态</span></span><br><span class="line"><span class="comment">* T_min ：温度的下限，若温度T达到T_min，则停止搜索</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">while</span>( T &gt; T_min )</span><br><span class="line">&#123;</span><br><span class="line">　　dE = J( Y(i+<span class="number">1</span>) ) - J( Y(i) ) ; </span><br><span class="line"></span><br><span class="line">　　<span class="keyword">if</span> ( dE &gt;=<span class="number">0</span> ) <span class="comment">//表达移动后得到更优解，则总是接受移动</span></span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　<span class="keyword">else</span></span><br><span class="line">　　&#123;</span><br><span class="line"><span class="comment">// 函数exp( dE/T )的取值范围是(0,1) ，dE/T越大，则exp( dE/T )也</span></span><br><span class="line"><span class="keyword">if</span> ( <span class="built_in">exp</span>( dE/T ) &gt; random( <span class="number">0</span> , <span class="number">1</span> ) )</span><br><span class="line">Y(i+<span class="number">1</span>) = Y(i) ; <span class="comment">//接受从Y(i)到Y(i+1)的移动</span></span><br><span class="line">　　&#125;</span><br><span class="line">　　T = r * T ; <span class="comment">//降温退火 ，0&lt;r&lt;1 。r越大，降温越慢；r越小，降温越快</span></span><br><span class="line">　　<span class="comment">/*</span></span><br><span class="line"><span class="comment">　　* 若r过大，则搜索到全局最优解的可能会较高，但搜索的过程也就较长。若r过小，则搜索的过程会很快，但最终可能会达到一个局部最优值</span></span><br><span class="line"><span class="comment">　　*/</span></span><br><span class="line">　　i ++ ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参考链接：</p><ol><li>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</li><li><a href="http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html" target="_blank" rel="noopener">http://www.cnblogs.com/heaad/archive/2010/12/20/1911614.html</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>广义线性模型(Generalized Linear Model)</title>
      <link href="/2017/01/26/%E5%B9%BF%E4%B9%89%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B(Generalized%20Linear%20Model)/"/>
      <content type="html"><![CDATA[<h2>广义线性模型(Generalized Linear Model)</h2><p>本文沿接接着上节的指数分布族,文章中注了引入指数分布族的概念是为了说明广义线性模型。</p><h2>概念</h2><p>广义线性模型（generalized linear model, GLM)是简单最小二乘回归（OLS)的扩展,在广义线性模式中，假设每个变量的观测值 Y来自某个指数族分布。 该分布的平均数$\mu$可由与该点独立的X解释：$$E(y)=\mu=g(\theta^Tx)$$其中E(y)为y的期望值，$\theta^T x$是由未知待估计参数$\theta$与已知变数X构成的线性估计式，g则为链接函数。在此模式下,y的方差V可表示为：$$Var(y)=V(y)=V(g(\theta ^Tx))$$一般假设V可视为一指数族随机变数的函数。未知参数$\theta$通常会以最大似然、贝叶斯方法估计。</p><h2>例证</h2><p><img src="http://img.blog.csdn.net/20170226105428730?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"><img src="http://img.blog.csdn.net/20170226105451339?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>参考此例：$\eta$与伯努利分布中的参数$\varphi$的关系是Logistic函数，再通过推导可以得到Logistic回归。见下文推导示例。</p><p>通过此例，我们可以推想，$\eta$以不同的映射函数与其他概率分布函数中的参数发生联系，从而得到不同的模型，广义线性模型正是将指数族分布中的所有成员都作为线性模型的扩展，通过非线性的连接函数映射到其他空间从而大大扩大了线性模型可解决的问题。</p><h3>假设条件</h3><p>下面我们看看GLM的形式话定义，GLM的三个假设：</p><ol><li>$y|x;\theta～ExpFamily(\eta)$：给定样本x与参数$\theta$,样本分类y服从指数分布族中的某个分布</li><li>给定一个x，我们需要的目标函数为$h_\theta(x)=E\left[ T(y)|x\right]$</li><li>$\eta=\theta^Tx$</li></ol><h3>上例推导</h3><p>依据三个假设，我们可以推导出logistic模型与最小二乘模型。Logistic模型的推导过程如下：$$h_\theta(x)=E\left[ T(y)|x\right] =E\left[ y|x\right]=\mu=\eta=\theta^Tx$$</p><p>其中，将$\eta$与原始概率分布中的参数联系起来的函数成为正则相应函数，如$\varphi=\frac{1}{1+e^(-\eta)},\mu=\eta$即是正则响应函数。正则响应函数的逆称为正则关联函数。</p><p>所以，对于广义线性模型，需要决策的是选用什么样的分布，当选取高斯分布时，我们可以得到最小二乘模型，当选取伯努利分布时，我们得到logistic模型，这里所说的模型是假设函数h的形式。</p><p>同样，可以将Logistic函数做拉伸变换，可以得到新的连接函数</p><p>$$\varphi=\frac{1}{1+e^{-\lambda\eta}}$$</p><h3>总结</h3><p>总计来说，广义线性模型通过假设一个概率分布函数，得到不同的模型，二支起拿讨论的梯度下降法、牛顿法都是为了求取线性模型中的<strong>线性部分$(\theta ^Tx)$的参数$\theta$的</strong>。</p><p>参考链接：</p><ol><li><a href="https://zh.wikipedia.org/wiki/%E5%BB%A3%E7%BE%A9%E7%B7%9A%E6%80%A7%E6%A8%A1%E5%9E%8B" target="_blank" rel="noopener">https://zh.wikipedia.org/wiki/廣義線性模型</a></li><li><a href="http://blog.csdn.net/stdcoutzyx/article/details/9207047" target="_blank" rel="noopener">http://blog.csdn.net/stdcoutzyx/article/details/9207047</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>等式约束与不等式约束问题</title>
      <link href="/2017/01/26/%E7%AD%89%E5%BC%8F%E7%BA%A6%E6%9D%9F%E4%B8%8E%E4%B8%8D%E7%AD%89%E5%BC%8F%E7%BA%A6%E6%9D%9F%E9%97%AE%E9%A2%98/"/>
      <content type="html"><![CDATA[<p>针对特殊约束条件下的优化问题，有着不同类别适应不同条件的求解算法。包括梯度法、求解线性等式约束问题的投影梯度法、适用于含有等式约束规划和含有不等式规划的拉格朗日乘子法、针对不等式约束的KKT条件法、罚函数法等。</p><a id="more"></a><h2>等式约束问题</h2><p>设目标函数为f(x)，约束条件为$h_k(x)$，形如$$min \quad f(x) \  s.t. \quad h_k(x)=0 \quad k=1,2,\cdots k$$则解决方法是消元法或者拉格朗日法。消元法不再多说，拉格朗日法这里在提一下，因为后面提到的KKT条件是对拉格朗日乘子法的一种泛化。</p><p>$$L(x,\lambda)=f(x)+\sum_{k=1}^{l}\lambda_kh_k(x)$$其中$λ_k$是各个约束条件的待定系数。然后解偏导方程组：$$\frac{\partial F }{\partial x_i}=0 \quad  \frac{\partial F }{\partial \lambda_k}=0 \ \cdots$$</p><p>至于为什么这么做可以求解最优化？维基百科上给出了一个比较好的直观解释。</p><p>举个二维最优化的例子：</p><p>$$min f(x,y)   \s.t. g(x,y) = c$$</p><p>这里画出$z=f(x,y)$的等高线：<img src="https://ss3.bdstatic.com/70cFv8Sh_Q1YnxGkpoWK1HF6hhy/it/u=1364139753,865873880&amp;fm=27&amp;gp=0.jpg" alt="log01"></p><p>绿线标出的是约束$g(x,y)=c$的点的轨迹。蓝线是$f(x,y)$的等高线。箭头表示斜率，和等高线的法线平行。从梯度的方向上来看，显然有$d1&gt;d2$。绿色的线是约束，也就是说，只要正好落在这条绿线上的点才可能是满足要求的点。如果没有这条约束，$f(x,y)$的最小值应该会落在最小那圈等高线内部的某一点上。<font color="red">而现在加上了约束，最小值点应该在哪里呢？</font>显然应该是在f(x,y)的等高线正好和约束线相切的位置，因为如果只是相交意味着肯定还存在其它的等高线在该条等高线的内部或者外部，使得新的等高线与目标函数的交点的值更大或者更小，<font color="red">只有到等高线与目标函数的曲线相切的时候，可能取得最优值。</font></p><p>如果我们对约束也求梯度$∇g(x,y)$，则其梯度如图中绿色箭头所示。很容易看出来，要想让目标函数$f(x,y)$的等高线和约束相切，则他们切点的梯度一定在一条直线上。即：$\partial f(x,y)=\lambda（\partial g(x,y)-C) $其中λ可以是任何非0实数。</p><p>一旦求出$\lambda$的值，将其带入下式，易求在无约束极值和极值所对应的点。</p><p>$$F(x,y)=f(x,y)+\lambda(g(x,y)-c)$$</p><p>这就是拉格朗日函数的由来。</p><h2>不等式约束问题</h2><p>考虑一般形式的优化问题：$$Min\quad f(x) \ s.t. \quad h(x)=0 \ \quad g(x) \geq 0$$</p><p>由上式，对于一个不等式约束$g_j(x)\leqslant 0$，如果在$x^{<em>}$处$g_j(x)= 0$，那么称该不等式约束是$x^{</em>}$处的起作用约束；如果在$x^{*}$ 处 $g_j(x)\geq 0$，那么称该约束是处的不起作用约束。按惯例，把等式约束$h_i(x)=0$当作总是起作用的约束。</p><p>由此，定义不等式约束下的拉格朗日函数L，则L表达式为：$$L(X,\lambda,\mu)=f(X)+\sum_{j==1}^{p}\lambda_jh_j(X)+\sum_{k=1}^{q}\mu_kg_k(X)$$</p><p>其中f(x)是原目标函数，$h_j(x)$是第j个等式约束条件，$\lambda _j$是对应的约束系数，$g_k$是不等式约束，$\mu_k$是对应的约束系数。</p><p>常用的方法是KKT条件，同样地，把所有的不等式约束、等式约束和目标函数全部写为一个式子，简化为$L(a, b, x)= f(x) + a<em>g(x)+b</em>h(x)$</p><p>KKT条件是说最优值必须满足以下条件：</p><ol><li>$\frac{\partial L }{\partial x_i}=0$对x求导为零；</li><li>h(x) =0;</li><li>a*g(x) = 0;</li></ol><p>求取这些等式之后就能得到候选最优值。其中第三个式子非常有趣，因为$g(x)&lt;=0$，如果要满足这个等式，必须a=0或者$g(x)=0$. 这是SVM的很多重要性质的来源，如支持向量的概念。</p><h3>KKT的推导：</h3><p>首先不加证明的给出对偶问题结论：$$\underset{\omega,b}{Min}\underset{b}{Max}L(\omega,b,\alpha)=\underset{b}{Max}\underset{\omega,b}{Min}L(\omega,b,\alpha)$$</p><p><img src="http://images2015.cnblogs.com/blog/520787/201509/520787-20150901140604513-1723209246.jpg" alt="log02"></p><p>参考资料：</p><ol><li>Edwin K.P.Chong  and Stanisslaw H.Zak 最优化导论（第四版）</li><li><a href="http://blog.csdn.net/xianlingmao/article/details/7919597" target="_blank" rel="noopener">http://blog.csdn.net/xianlingmao/article/details/7919597</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MCMC与Gibbs采样</title>
      <link href="/2017/01/25/MCMC%E4%B8%8EGibbs%E9%87%87%E6%A0%B7/"/>
      <content type="html"><![CDATA[<h2>随机模拟</h2><p>  随机模拟(或者统计模拟)方法有一个很酷的别名是蒙特卡罗方法(Monte Carlo Simulation)。这个方法的发展始于20世纪40年代，和原子弹制造的曼哈顿计划密切相关，当时的几个大牛，包括乌拉姆、冯.诺依曼、费米、费曼、Nicholas Metropolis， 在美国洛斯阿拉莫斯国家实验室研究裂变物质的中子连锁反应的时候，开始使用统计模拟的方法,并在最早的计算机上进行编程实现。</p><a id="more"></a><img src="https://cos.name/wp-content/uploads/2013/01/simulation.jpg" width="50%" height="50%"><div align="center">simulation随机模拟与计算机</div><p>  现代的统计模拟方法最早由数学家乌拉姆提出，被Metropolis命名为蒙特卡罗方法，蒙特卡罗是著名的赌场，赌博总是和统计密切关联的，所以这个命名风趣而贴切，很快被大家广泛接受。被不过据说费米之前就已经在实验中使用了，但是没有发表。说起蒙特卡罗方法的源头，可以追溯到18世纪，布丰当年用于计算$\pi$的著名的投针实验就是蒙特卡罗模拟实验。统计采样的方法其实数学家们很早就知道，但是在计算机出现以前，随机数生成的成本很高，所以该方法也没有实用价值。随着计算机技术在二十世纪后半叶的迅猛发展，随机模拟技术很快进入实用阶段。对那些用确定算法不可行或不可能解决的问题，蒙特卡罗方法常常为人们带来希望。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/monte-carlo-simulation.jpg" alt="log2"></p><div align="center">monte-carlo-simulation蒙特卡罗方法</div><p>  统计模拟中有一个重要的问题就是给定一个概率分布$p(x)$，我们如何在计算机中生成它的样本。一般而言均匀分布 $Uniform(0,1)$的样本是相对容易生成的。通过线性同余发生器可以生成伪随机数，我们用确定性算法生成[0,1]之间的伪随机数序列后，这些序列的各种统计指标和均匀分布 $Uniform(0,1)$ 的理论计算结果非常接近。这样的伪随机序列就有比较好的统计性质，可以被当成真实的随机数使用。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/sampling.png" alt="">生成一个概率分布的样本</p><p>  而我们常见的概率分布，无论是连续的还是离散的分布，都可以基于$Uniform(0,1)$的样本生成。例如正态分布可以通过著名的 Box-Muller 变换得到。</p><p><strong>Box-Muller 变换</strong>如果随机变量 $U1,U2$独立且$U1,U2\sim Uniform[0,1]$</p><p>$$Z_0 = \sqrt{-2\ln U_1} cos(2\pi U_2) \\ Z_1 = \sqrt{-2\ln U_1} sin(2\pi U_2)$$则 $Z_0,Z_1$独立且服从标准正态分布。</p><p>其它几个著名的连续分布，包括<strong>指数分布、Gamma 分布、t 分布、F 分布、Beta 分布、Dirichlet 分布</strong>等等,也都可以通过类似的数学变换得到；离散的分布通过均匀分布更加容易生成。更多的统计分布如何通过均匀分布的变换生成出来，大家可以参考统计计算的书，其中 Sheldon M. Ross 的《统计模拟》是写得非常通俗易懂的一本。</p><p>不过我们并不是总是这么幸运的，当p(x)的形式很复杂，或者p(x) 是个高维的分布的时候，样本的生成就可能很困难了。 譬如有如下的情况</p><ul><li>$p(x)=\frac{\tilde{p}(x)}{\int\tilde{p}(x)}dx $,而$\tilde{p}(x)$我们是可以计算的，但是底下的积分式无法显式计算。</li><li>$p(x,y)$是一个二维的分布函数，这个函数本身计算很困难，但是条件分布 $p(x|y),p(y|x)$的计算相对简单;如果 $p(x)$是高维的，这种情形就更加明显。</li></ul><p>此时就需要使用一些更加复杂的随机模拟的方法来生成样本。而本节中将要重点介绍的 **MCMC(Markov Chain Monte Carlo) **和 Gibbs Sampling算法就是最常用的一种，这两个方法在现代贝叶斯分析中被广泛使用。要了解这两个算法，我们首先要对马氏链的平稳分布的性质有基本的认识。</p><h2>马氏链及其平稳分布</h2><p>马氏链的数学定义很简单</p><p>$$P(X_{t+1}=x|X_t, X_{t-1}, \cdots) =P(X_{t+1}=x|X_t)$$</p><p>也就是状态转移的概率只依赖于前一个状态。</p><p>我们先来看马氏链的一个具体的例子。社会学家经常把人按其经济状况分成3类：下层(lower-class)、中层(middle-class)、上层(upper-class)，我们用1,2,3 分别代表这三个阶层。社会学家们发现决定一个人的收入阶层的最重要的因素就是其父母的收入阶层。如果一个人的收入属于下层类别，那么他的孩子属于下层收入的概率是 0.65, 属于中层收入的概率是 0.28, 属于上层收入的概率是 0.07。事实上，从父代到子代，收入阶层的变化的转移概率如下</p><p><img src="https://cos.name/wp-content/uploads/2013/01/table-1.jpg" alt="log3"></p><p>使用矩阵的表示方式，转移概率矩阵记为$$P =\begin{bmatrix}0.65 &amp; 0.28 &amp; 0.07 \\0.15 &amp; 0.67 &amp; 0.18 \\0.12 &amp; 0.36 &amp; 0.52 \\\end{bmatrix}$$</p><p>假设当前这一代人处在下层、中层、上层的人的比例是概率分布向量$ \pi_0=[\pi_0(1), \pi_0(2), \pi_0(3)]$那么他们的子女的分布比例将是 $\pi_{1}=\pi_{0}P$, 他们的孙子代的分布比例将是 $\pi_{2} = \pi_{1}P=\pi_{0}P^2$第n代子孙的收入分布比例将是$\pi_{n} = \pi_{n-1}P = \pi_{0}P^n$假设初始概率分布为$\pi_{0}=[0.21,0.68,0.11]$,则我们可以计算前n代人的分布状况如下</p><p><img src="https://cos.name/wp-content/uploads/2013/01/table-2.jpg" alt="log2"></p><p>我们发现从第7代人开始，这个分布就稳定不变了，这个是偶然的吗？我们换一个初始概率分布$\pi _0=[0.75,0.15,0.1]$试试看，继续计算前n代人的分布状况如下<img src="https://cos.name/wp-content/uploads/2013/01/table-3.jpg" alt="log3">我们发现，到第9代人的时候, 分布又收敛了。最为奇特的是，两次给定不同的初始概率分布，最终都收敛到概率分布 $\pi=[0.286,0.489,0.225]$，也就是说收敛的行为和初始概率分布 $\pi_0$ 无关。这说明这个收敛行为主要是由概率转移矩阵P决定的。我们计算一下 $P_n$$P^{20} = P^{21} = \cdots = P^{100} = \cdots = \begin{bmatrix} 0.286 &amp; 0.489 &amp; 0.225 \\ 0.286 &amp; 0.489 &amp; 0.225 \\ 0.286 &amp; 0.489 &amp; 0.225 \\ \end{bmatrix}$我们发现，当 n 足够大的时候，这个$P_n$矩阵的每一行都是稳定地收敛到$\pi=[0.286,0.489,0.225]$这个概率分布。自然的，这个收敛现象并非是我们这个马氏链独有的，而是绝大多数马氏链的共同行为，关于马氏链的收敛我们有如下漂亮的定理：</p><h3>马氏链定理：</h3><p>如果一个非周期马氏链具有转移概率矩阵PP,且它的任何两个状态是连通的，那么$\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n$存在且与i无关，记$\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n = \pi(j)$, 我们有</p><ol><li><p>$\displaystyle \lim_{n \rightarrow \infty} P^n =\begin{bmatrix} \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \\ \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ \pi(1) &amp; \pi(2) &amp; \cdots &amp; \pi(j) &amp; \cdots \\ \cdots &amp; \cdots &amp; \cdots &amp; \cdots &amp; \cdots \\ \end{bmatrix}$</p></li><li><p>$\displaystyle \pi(j) = \sum_{i=0}^{\infty}\pi(i)P_{ij}$</p></li><li><p>$\pi$是方程$\pi P=\pi $的唯一非负解其中,$$\pi = [\pi(1), \pi(2), \cdots, \pi(j),\cdots ], \\ \sum_{i=0}^{\infty} \pi_i = 1$$</p></li></ol><p>$\pi$称为马氏链的平稳分布。</p><p>这个马氏链的收敛定理非常重要，所有的 MCMC(Markov Chain Monte Carlo) 方法都是以这个定理作为理论基础的。 定理的证明相对复杂，一般的随机过程课本中也不给证明，所以我们就不用纠结它的证明了，直接用这个定理的结论就好了。我们对这个定理的内容做一些解释说明：</p><ol><li>该定理中马氏链的状态不要求有限，可以是有无穷多个的；</li><li>定理中的“非周期“这个概念我们不打算解释了，因为我们遇到的绝大多数马氏链都是非周期的；</li><li>两个状态i,j是连通并非指i可以直接一步转移到$j(P_{i,j}&gt;0)$,而是指 i 可以通过有限的n步转移到达$j(P_{ij&gt;}^n&gt;0)$。马氏链的任何两个状态是连通的含义是指存在一个n, 使得矩阵$P_n$ 中的任何一个元素的数值都大于零。</li><li>我们用 $X_i$ 表示在马氏链上跳转第i步后所处的状态，如果 $\displaystyle \lim_{n\rightarrow\infty}P_{ij}^n = \pi(j)$存在，很容易证明以上定理的第二个结论。由于</li></ol><p>$$P(X_{n+1}=j)=\\ \sum_{i=0}^\infty P(X_n=i) P(X_{n+1}=j|X_n=i) \  = \sum_{i=0}^\infty P(X_n=i) P_{ij} $$</p><p>上式两边取极限就得到$\displaystyle \pi(j) = \sum_{i=0}^{\infty}\pi(i)P_{ij}$</p><p>从初始概率分布$\pi_0$出发，我们在马氏链上做状态转移，记$x_i$的概率分布为$\pi_i$, 则有</p><p>$$X_0 \sim \pi_0(x) \\ X_i \sim \pi_i(x), \\ \pi_i(x) = \pi_{i-1}(x)P = \pi_0(x)P^n$$</p><p>由马氏链收敛的定理, 概率分布$\pi_i(x)$将收敛到平稳分布$\pi(x)$。假设到第n步的时候马氏链收敛，则有</p><p>$$ X_0 \sim \pi_0(x) \\ X_1 \sim \pi_1(x) \\ \cdots \\ X_n \sim \pi_n(x)=\pi(x) \\ X_{n+1} \sim \pi(x) \\ X_{n+2} \sim \pi(x) \\ \cdots $$</p><p>所以 $X_n,X_{n+1},X_{n+2},\cdots \sim \pi(x)$都是同分布的随机变量，当然他们并不独立。如果我们从一个具体的初始状态 $x_0$开始,沿着马氏链按照概率转移矩阵做跳转，那么我们得到一个转移序列 $x_0,x_1,x_2,\cdots,x_n,x_{n+1},\cdots,$ 由于马氏链的收敛行为， $x_n,x_{n+1},\cdots$都将是平稳分布$\pi(x)$的样本。</p><h2>Markov Chain Monte Carlo</h2><p>  对于给定的概率分布p(x),我们希望能有便捷的方式生成它对应的样本。由于马氏链能收敛到平稳分布， 于是一个很的漂亮想法是：如果我们能构造一个转移矩阵为$P$的马氏链，使得该马氏链的平稳分布恰好是$p(x)$, 那么我们从任何一个初始状态$x_0$出发沿着马氏链转移, 得到一个转移序列 $x_0,x_1,x_2,\cdots x_n,x_{n+1},\cdots,$， 如果马氏链在第n步已经收敛了，于是我们就得到了 $\pi(x)$的样本$x_n,x_{n+1},\cdots,x_n,x_{n+1},\cdots$。</p><p>  这个绝妙的想法在1953年被 Metropolis想到了，为了研究粒子系统的平稳性质， Metropolis 考虑了物理学中常见的波尔兹曼分布的采样问题，首次提出了基于马氏链的蒙特卡罗方法，即Metropolis算法，并在最早的计算机上编程实现。Metropolis 算法是首个普适的采样方法，并启发了一系列 MCMC方法，所以人们把它视为随机模拟技术腾飞的起点。 Metropolis的这篇论文被收录在《统计学中的重大突破》中， Metropolis算法也被遴选为二十世纪的十个最重要的算法之一。</p><p>  我们接下来介绍的MCMC 算法是 Metropolis 算法的一个改进变种，即常用的 Metropolis-Hastings 算法。由上一节的例子和定理我们看到了，马氏链的收敛性质主要由转移矩阵$P$决定, 所以基于马氏链做采样的关键问题是如何构造转移矩阵$P$,使得平稳分布恰好是我们要的分布$p(x)$。如何能做到这一点呢？我们主要使用如下的定理。</p><h3>定理：细致平稳条件</h3><p>如果非周期马氏链的转移矩阵$P$和分布$\pi(x)$满足$$ \pi(i)P_{ij} = \pi(j)P_{ji} \qquad for all\quad i,j$$</p><p>则 $\pi(x)$ 是马氏链的平稳分布，上式被称为细致平稳条件(detailed balance condition)。</p><p>其实这个定理是显而易见的，因为细致平稳条件的物理含义就是<strong>对于任何两个状态i,j从 i 转移出去到j 而丢失的概率质量，恰好会被从 j 转移回i 的概率质量补充回来，所以状态i上的概率质量$\pi(i)$是稳定的，从而$\pi(x)$是马氏链的平稳分布</strong>。数学上的证明也很简单，由细致平稳条件可得</p><p>$$\sum_{i=1}^\infty \pi(i)P_{ij} =\sum_{i=1}^\infty \pi(j)P_{ji} = \pi(j) \sum_{i=1}^\infty P_{ji} = \pi(j) \\ \Rightarrow \pi P = \pi$$</p><p>由于$\pi$是方程 $\pi P=\pi $的解，所以$\pi $是平稳分布。</p><p>假设我们已经有一个转移矩阵为Q马氏链$q(i,j)$表示从状态 i转移到状态j的概率，也可以写为 $q(j|i)$ 显然，通常情况下</p><p>$$p(i) q(i,j) \neq p(j) q(j,i)$$</p><p>也就是细致平稳条件不成立，所以$p(x)$不太可能是这个马氏链的平稳分布。我们可否对马氏链做一个改造，使得细致平稳条件成立呢？譬如，我们引入一个 $\alpha(i,j)$, 我们希望</p><p>$$p(i) q(i,j)\alpha(i,j) = p(j) q(j,i)\alpha(j,i)  \quad (*) $$</p><p>$$\alpha(i,j)= p(j) q(j,i),\quad \alpha(j,i) = p(i) q(i,j)$$</p><p>于是(*)式就成立了。所以有</p><p>$$p(i)\underbrace{q(i,j)\alpha(i,j)}<em>{Q^{’}(i,j)} = p(j)\underbrace{q(j,i)\alpha(j,i)}</em>{Q^{’}(j,i)}$$</p><p>于是我们把原来具有转移矩阵$Q$的一个很普通的马氏链，改造为了具有转移矩阵$Q’$的马氏链，而$Q’$恰好满足细致平稳条件，由此马氏链$Q’$的平稳分布就是$p(x)$！</p><p>在改造 Q 的过程中引入的 $\alpha(i,j)$称为接受率，物理意义可以理解为在原来的马氏链上**，从状态 i 以$q(i,j)$ 的概率转跳转到状态j 的时候，我们以$\alpha (i,j)$的概率接受这个转移，于是得到新的马氏链Q′的转移概率为$q(i,j)\alpha(i,j)$。**</p><p><img src="https://cos.name/wp-content/uploads/2013/01/mcmc-transition.jpg" alt=""></p><p>假设我们已经有一个转移矩阵$Q$(对应元素为$q(i,j)$, 把以上的过程整理一下，我们就得到了如下的用于采样概率分布$p(x)$的算法。</p><p><img src="https://cos.name/wp-content/uploads/2013/01/mcmc-algo-1.jpg" alt="">上述过程中 $p(x),q(x|y)$ 说的都是离散的情形，事实上即便这两个分布是连续的，以上算法仍然是有效，于是就得到更一般的连续概率分布 $p(x)$的采样算法，而 $q(x|y)$ 就是任意一个连续二元概率分布对应的条件分布。</p><p>  以上的 MCMC 采样算法已经能很漂亮的工作了，不过它有一个小的问题：马氏链Q在转移的过程中的接受率 $\alpha(i,j)$ 可能偏小，这样采样过程中马氏链容易原地踏步，拒绝大量的跳转，这使得马氏链遍历所有的状态空间要花费太长的时间，收敛到平稳分布$p(x)$的速度太慢。有没有办法提升一些接受率呢?</p><p>假设 $\alpha(i,j)=0.1,\alpha(j,i)=0.2$, 此时满足细致平稳条件，于是</p><p>$$p(i)q(i,j)\times 0.1 = p(j)q(j,i) \times 0.2$$</p><p>上式两边扩大5倍，我们改写为$$p(i)q(i,j) \times 0.5 = p(j)q(j,i) \times 1$$</p><p>看，我们提高了接受率，而细致平稳条件并没有打破！这启发我们可以把细致平稳条件(**) 式中的$\alpha(i,j),\alpha(j,i)$同比例放大，使得两数中最大的一个放大到1，这样我们就提高了采样中的跳转接受率。所以我们可以取</p><p>$$\alpha(i,j) = \min{\frac{p(j)q(j,i)}{p(i)q(i,j)},1}$$</p><p>于是，经过对上述MCMC 采样算法中接受率的微小改造，我们就得到了如下教科书中最常见的 Metropolis-Hastings 算法。<img src="https://cos.name/wp-content/uploads/2013/01/mcmc-algo-2.jpg" alt="log03"></p><p>  对于分布 $p(x)$,我们构造转移矩阵 Q′ 使其满足细致平稳条件</p><p>$$p(x) Q’(x\rightarrow y) = p(y) Q’(y\rightarrow x)$$</p><p>此处$x$并不要求是一维的，对于高维空间的$p(x)$，如果满足细致平稳条件</p><p>$$p(\mathbf{x}) Q’(\mathbf{x}\rightarrow \mathbf{y}) = p(\mathbf{y}) Q’(\mathbf{y}\rightarrow \mathbf{x})$$那么以上的 Metropolis-Hastings 算法一样有效。</p><h2>Gibbs Sampling</h2><p>  对于高维的情形，由于接受率$\alpha$的存在(通常$\alpha&lt;1$), 以上 Metropolis-Hastings 算法的效率不够高。能否找到一个转移矩阵$Q$使得接受率$\alpha=1$呢？我们先看看二维的情形，假设有一个概率分布 $p(x,y)$, 考察x坐标相同的两个点$A(x_1,y_1),B(x_1,y_2)$，我们发现$p(x_1,y_1)p(y_2|x_1) = p(x_1)p(y_1|x_1)p(y_2|x_1) \ p(x_1,y_2)p(y_1|x_1) = p(x_1)p(y_2|x_1)p(y_1|x_1)$</p><p>所以得到$ p(x_1,y_1)p(y_2|x_1) = p(x_1,y_2)p(y_1|x_1)  \quad (***) $即$p(A)p(y_2|x_1) = p(B)p(y_1|x_1)$</p><p><img src="https://cos.name/wp-content/uploads/2013/01/gibbs-transition.png" alt="">平面上马氏链转移矩阵的构造</p><p>$Q(A\rightarrow B) = p(y_B|x_1) \quad \text{if} \quad x_A=x_B=x_1 \\ Q(A\rightarrow C) = p(x_C|y_1) \quad \text{if} \quad y_A=y_C=y_1 \\ Q(A\rightarrow D) = 0 \quad ,\text{others}$</p><p>有了如上的转移矩阵$Q$, 我们很容易验证对平面上任意两点$X,Y$ 满足细致平稳条件</p><p>$$p(X)Q(X\rightarrow Y) = p(Y) Q(Y\rightarrow X)$$</p><p>于是这个二维空间上的马氏链将收敛到平稳分布 p(x,y)p(x,y)。而这个算法就称为 Gibbs Sampling 算法,是 Stuart Geman 和Donald Geman 这两兄弟于1984年提出来的，之所以叫做Gibbs Sampling 是因为他们研究了Gibbs random field, 这个算法在现代贝叶斯分析中占据重要位置。<img src="https://cos.name/wp-content/uploads/2013/01/gibbs-algo-1.jpg" alt=""><img src="https://cos.name/wp-content/uploads/2013/01/two-stage-gibbs.png" alt=""></p><h3>Gibbs Sampling 算法中的马氏链转移</h3><p>  以上采样过程中，如图所示，马氏链的转移只是轮换的沿着坐标轴 xx轴和yy轴做转移，于是得到样本$(x_0,y_0), (x_0,y_1), (x_1,y_1), (x_1,y_2),(x_2,y_2), \cdots$马氏链收敛后，最终得到的样本就是 p(x,y)的样本，而收敛之前的阶段称为 burn-in period。额外说明一下，我们看到教科书上的 Gibbs Sampling 算法大都是坐标轴轮换采样的，但是这其实是不强制要求的。最一般的情形可以是，在t时刻，可以在x轴和y轴之间随机的选一个坐标轴，然后按条件概率做转移，马氏链也是一样收敛的。轮换两个坐标轴只是一种方便的形式。</p><p>  以上的过程我们很容易推广到高维的情形，对于(***) 式，如果$x_1$ 变为多维情形$x_1$，可以看出推导过程不变，所以细致平稳条件同样是成立的</p><p>$ p(\mathbf{x_1},y_1)p(y_2|\mathbf{x_1}) = p(\mathbf{x_1},y_2)p(y_1|\mathbf{x_1}) $此时转移矩阵 Q 由条件分布 $p(y|x_1)$定义。上式只是说明了一根坐标轴的情形，和二维情形类似，很容易验证对所有坐标轴都有类似的结论。所以n维空间中对于概率分布$ p(x1,x2,\cdots ,xn)$ 可以如下定义转移矩阵</p><ol><li>如果当前状态为$(x_1,x_2,\cdots ,x_n)$，马氏链转移的过程中，只能沿着坐标轴做转移。沿着 $x_i$这根坐标轴做转移的时候，转移概率由条件概率 $p(x_i|x_1, \cdots, x_{i-1}, x_{i+1}, \cdots, x_n)$定义；</li><li>其它无法沿着单根坐标轴进行的跳转，转移概率都设置为 0。</li></ol><p>于是我们可以把Gibbs Smapling 算法从采样二维的$p(x,y)$推广到采样n 维的 $p(x_1,x_2,\cdots,x_n)$</p><p><img src="https://cos.name/wp-content/uploads/2013/01/gibbs-algo-2.jpg" alt=""></p><p>以上算法收敛后，得到的就是概率分布$p(x_1,x_2,\cdots ,x_n)$的样本，当然这些样本并不独立，但是我们此处要求的是采样得到的样本符合给定的概率分布，并不要求独立。同样的，在以上算法中，坐标轴轮换采样不是必须的，可以在坐标轴轮换中引入随机性，这时候转移矩阵$Q.$ 中任何两个点的转移概率中就会包含坐标轴选择的概率，而在通常的 Gibbs Sampling 算法中，坐标轴轮换是一个确定性的过程，也就是在给定时刻t，在一根固定的坐标轴上转移的概率是1。</p><blockquote><p>转载自<a href="https://cos.name/2013/01/lda-math-mcmc-and-gibbs-sampling/" target="_blank" rel="noopener">统计之都</a></p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>指数分布族</title>
      <link href="/2017/01/23/%E6%8C%87%E6%95%B0%E5%88%86%E5%B8%83%E6%97%8F/"/>
      <content type="html"><![CDATA[<p>  指数分布族是指可以表示为指数分布的概率分布。指数分布形式如下：$$P(y;\eta)=b(y)exp(\eta^{T}T(y)-\alpha(\eta))$$其中，$\eta$成为分布的自然参数；T(y)是充分统计量，通常$T(y)=y$。当$a、b、T$参数都固定的时候，就定义了一个以$\eta$为参数的指数函数族。</p><a id="more"></a><p>实际上，大多数概率分布都可以表示成上面公式给出的形式：</p><ol><li>伯努利分布：对0、1问题进行建模</li><li>多项式分布：对K个离散结果的事件建模</li><li>泊松分布：对计数过程进行建模</li><li>伽马分布与指数分布：对间隔的正数进行建模</li><li>Beta分布：对小数进行建模</li><li>Dirichlet分布：对小数进行建模</li><li>Wishart分布：对协方差进行建模</li><li>高斯分布</li></ol><h2>示例</h2><p>我们将高斯分布与伯努利分布表示成指数分布族的形式。</p><h3>伯努利分布</h3><p>  伯努利分布是对0、1问题进行建模，特可以表示成如下形式：</p><p>$$P(y;\varphi)=\varphi^y(1-\varphi)^{1-y} \quad y\in{0,1}$$</p><p><img src="http://img.blog.csdn.net/20170226102110215?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01"></p><p>将伯努利分布表示成如下形式，对比指数族分布公示</p><p><img src="http://img.blog.csdn.net/20170226102145230?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>其中可以看到，$\eta$的形式为logisic函数，这是因为logistic模型对问题的先验概率估计是伯努利分布的缘故。</p><h3>高斯分布</h3><p>  高斯分布可以推导出线性模型，由线性模型的假设函数可知，高斯分布的方差与假设函数无关，因而为简便计算，我们将方差设为1，即使不这样做，最后的结果也是作为一个系数而已，高斯分布转换为指数分布形式的推导过程如下：</p><p><img src="http://img.blog.csdn.net/20170226102549656?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log03"></p><p>我们最终一样可以把高斯分布以指数分布族函数的形式表示。</p><h2>后记</h2><ol><li>这里说明指数分布族的目的，是为了说明关于线性模型(Generalized Linear Model).</li><li>凡是符合指数分布族的随机变量，都可以用广义线性模型(GLM)进行分析。</li></ol><h3>备注</h3><p>指数分布族的<strong>无记忆性</strong>，教科书上所说的无记忆性（Memoryless Property，又称遗失记忆性）。这表示如果一个随机变量呈指数分布，它的条件概率遵循：$$P(T&gt;s+t;T&gt;t)=P(T&gt;s), \ for\quad all,\quad s.t&gt;0 $$有兴趣的同学可以深入理解一下。</p>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>矩阵分解相关知识回顾</title>
      <link href="/2017/01/21/%E7%9F%A9%E9%98%B5%E5%88%86%E8%A7%A3%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86%E5%9B%9E%E9%A1%BE/"/>
      <content type="html"><![CDATA[<h2>特征值与特征向量</h2><p>设A是数域F上的n阶矩阵，如果存在数域F中的一个数$\lambda$与数域上F的非零向量$\overrightarrow{\alpha}$，使得：$A\overrightarrow{\alpha}=\lambda \overrightarrow{\alpha}$则称$\lambda$为A的一个特征值(根)(eigenvalue)，称$\overrightarrow{\alpha}$为A的属于特征值$\lambda$的特征向量(eigenvector)。</p><p>显然从上式可以看出，$A\overrightarrow{\alpha} \overrightarrow{\alpha}$平行。</p><p>将上式做一下变换：$A\overrightarrow{\alpha}=\lambda \overrightarrow{\alpha}$$A\overrightarrow{\alpha}-\lambda \overrightarrow{\alpha}=0$$A\overrightarrow{\alpha}-\lambda E\overrightarrow{\alpha}=0$$(A−\lambda E)\overrightarrow{\alpha}=0$$(\lambda E-A)\overrightarrow{\alpha}=0$</p><p>称：$\lambda E−A$为A的特征矩阵行列式$f(\lambda )=|\lambda E−A|$为A的特征多项式$|\lambda E−A|=0$为A的特征方程$(\lambda E−A)\overrightarrow{x}=\overrightarrow{0}$是A关于该λ的齐次线性方程组</p><h2>矩阵对角化</h2><p>设n阶方阵A存在n个线性无关的特征向量$\overrightarrow{ x_{i} }$，将这n个特征向量$\overrightarrow {x_{i} }$组成方阵S(也称为特征向量矩阵），则有：<img src="http://img.blog.csdn.net/20170225194650882?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="这里写图片描述">这个式子称为$A$的$SΛS^{−1}$分解，或特征分解(Eigendecomposition)，或A的对角化。</p><p>根据这个式子可以知道：当方阵$A$可以被分解为某个矩阵$S$乘以某个对角矩阵$\Lambda$再乘以矩阵$S^{−1}$时，就是一次特征分解。</p><p>可以对角化的前提是$A$有$n$个线性无关的特征向量。$A$有$n$个线性无关的特征向量的前提是，所有的$\lambda$都不重复（没有重根）。</p><h2>LU分解</h2><p>设$A$是一个方块矩阵。A的$LU$分解是将它分解成如下形式：$A=LU$其中$L$和$U$分别是下三角矩阵和上三角矩阵。</p><p>例如对于一个 $3*3$的矩阵，就有</p><p><img src="http://img.blog.csdn.net/20170225191810280?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="null"></p><p>一个$LDU$分解是一个如下形式的分解：$A=LDU$其中$D$是对角矩阵，$L$和$U$是单位三角矩阵（对角线上全是1的三角矩阵）。</p><p>一个$LUP$分解是一个如下形式的分解：$A=LUP$其中$L$和$U$仍是三角矩阵，$P$是一个置换矩阵。</p><p>一个充分消元的$LU$分解为如下形式：$PAQ=LU$</p><h3>存在性</h3><p>一个可逆矩阵可以进行$LU$分解当且仅当它的所有子式都非零。如果要求其中的$L$矩阵（或$U$矩阵）为单位三角矩阵，那么分解是唯一的。同理可知，矩阵的$LDU$可分解条件也相同，并且总是唯一的。</p><h2>奇异值分解</h2><p>假设M是一个m×n阶矩阵，其中的元素全部属于域K，也就是实数域或复数域。如此则存在一个分解使得$M=U\sum V^{*}$其中U是m×m阶酉矩阵；$\sum$是m×n阶非负实数对角矩阵；而$V^{*}$，即V的共轭转置，是n×n阶酉矩阵。这样的分解就称作$M$的奇异值分解。</p><h3>几何解释</h3><p>首先，我们来看一个只有两行两列的简单矩阵。第一个例子是对角矩阵<img src="http://img.blog.csdn.net/20170225201907278?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log00">从几何的角度，矩阵可以描述为一个变换：用矩阵乘法将平面上的点（x, y）变换成另外一个点（3x, y）：</p><p><img src="http://img.blog.csdn.net/20170225201947559?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log01">这种变换的效果如下：平面在水平方向被拉伸了3倍，在竖直方向无变化。<img src="http://img.blog.csdn.net/20170225202039887?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log02"></p><p>$2*2$矩阵奇异值分解的几何实质是：对于任意$2*2$矩阵，总能找到某个正交网格到另一个正交网格的转换与矩阵变换相对应。</p><p>用向量解释这个现象：选择适当的正交的单位向量$v_1$和$v_2$，向量$Mv_1$和$Mv_2$也是正交的。<img src="http://img.blog.csdn.net/20170225201208758?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdG91cmlzdG1hbjU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt="log05"></p><p>奇异值分解的魅力在于任何矩阵都可以找到奇异值。</p><p>参考链接：</p><ol><li><a href="http://www.ams.org/samplings/feature-column/fcarc-svd" target="_blank" rel="noopener">http://www.ams.org/samplings/feature-column/fcarc-svd</a></li><li><a href="https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html" target="_blank" rel="noopener">https://www.cnblogs.com/LeftNotEasy/archive/2011/01/19/svd-and-applications.html</a></li></ol>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 统计学 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化算法篇之梯度法</title>
      <link href="/2017/01/15/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AF%87%E4%B9%8B%E6%A2%AF%E5%BA%A6%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>  我们在接触到具体的机器学习算法前，其实很有必要对优化问题进行一些了解。随着学习的深入，越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。</p><a id="more"></a><p>  最常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度方向法等。在大学课程中，数值分析是计算机或数学相关专业一门比较重要的一门课程，笔者也在大学时自学过相关课程，其介绍的诸多对理论的计算机实现方法，对现在的学习依然发挥着很大的作用。</p><p>当然优化算法只是数值分析课程中涉及一部分内容，这一节主要介绍和回顾梯度下降法</p><h2>梯度下降法</h2><p>  梯度下降法是最为常见的最优化方法。梯度下降法实现简单，当目标函数是凸函数时，梯度下降法的解是全局解。在一般情况下，其解不能保证是全局最优解，梯度下降法的速度也未必是最快的。</p><p>  假设$f(x)$是$R^n$上具有一阶连续偏导数的函数，需要求解的无约束最优化问题是：</p><p>$${min}_{x\in R^n}：\quad f(x)$$</p><p>  梯度下降法是一种迭代算法，选取适当的初值$x_0$,反复迭代，更新$x_{i}$的值，进行目标函数的极小化，直至收敛。<img src="http://img.my.csdn.net/uploads/201302/13/1360748597_8621.jpg" alt="梯度方向"></p><p>  由于我们都知道梯度方向$∇f(x)$是函数增长最快的方向，那么自然而然的想到负梯度方向就是函数值下降最快的方向了。因此，我们以负梯度方向作为极小化的下降方向，在迭代的每一步，以负梯度方向来更新$x$的值，从而达到减小函数值目的，这种方法就是梯度下降法。</p><p>  由于$f(x)$具有一阶连续偏导数，若第k次迭代值为$x_k$，则可将$f(x)$在$x_k$处进行一阶泰勒展开：$$f(x)=f(x^{(k)})+g_k^T(x−x^{(k)})$$这里，(方便推广，使用矩阵形式）$$g_k=g(x^{(k)})=∇f(x^{(k)})g_k=g(x^{(k)})=∇f(x^{(k)})$$为$f(x)$在$x_K$的梯度。第$K+1$次迭代值$x_{k+1}$：即$$x_{k+1}=x_{k}+λ_k*p_k$$其中，$p_k$是搜索方向，梯度法中$p_k=-∇f(x)$，取负梯度方向$p_k=−∇f(x^{(k)}),{\lambda_k}$是步长，有时候我们也叫学习率，这个值可以由一维搜索确定，目的在于得到最合适的步长，即${\lambda _k}$使得</p><p>$$Min:\quad \varphi(\lambda)=f(x^{(k)}+λ_kp^{(k)})$$</p><h3>算法过程：</h3><p>1）确定当前位置的损失函数的梯度，对于$(\theta_i)$,其梯度表达式如下：</p><p>$$(\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n))$$</p><p>2）用步长乘以损失函数的梯度，得到当前位置下降的距离，即$(\alpha\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n))$对应于前面登山例子中的某一步。</p><p>3）确定是否所有的$(\theta_i)$,梯度下降的距离都小于$\varepsilon$，如果小于$\varepsilon$则算法终止，当前所有的$\theta_i,(i=0,1,…n)$即为最终结果。否则进入步骤4.</p><p>4）更新所有的$\theta$，对于$\theta_i$，其更新表达式如下。更新完毕后继续转入步骤1.</p><p>$\theta_i = \theta_i – \alpha\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n)$</p><h3>举例</h3><p>下面用线性回归的例子来具体描述梯度下降。假设我们的样本是$(x_1^{(0)}, x_2^{(0)}, …x_n^{(0)}, y_0), (x_1^{(1)}, x_2^{(1)}, …x_n^{(1)},y_1), … (x_1^{(m)}, x_2^{(m)}, …x_n^{(m)}, y_n)$,损失函数如前面先决条件所述：</p><p>$$f(\theta_0, \theta_1…, \theta_n) = \sum\limits_{i=0}^{m}(h_\theta(x_0, x_1, …x_n) – y_i)^2$$。</p><p>则在算法过程步骤1中对于$\theta_i$ 的偏导数计算如下：</p><p>$$\frac{\partial}{\partial\theta_i}f(\theta_0, \theta_1…, \theta_n)= \frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) – y_j)x_i^{j}$$</p><p>由于样本中没有$x_0$上式中令所有的$x_0^{j}$为1.</p><p>步骤4中$\theta_i$的更新表达式如下：</p><p>$$\theta_i = \theta_i – \alpha\frac{1}{m}\sum\limits_{j=0}^{m}(h_\theta(x_0^{j}, x_1^{j}, …x_n^{j}) – y_j)x_i^{j}$$</p><p>从这个例子可以看出当前点的梯度方向是由所有的样本决定的，加$\frac{1}{m}$ 是为了好理解。由于步长也为常数，他们的乘机也为常数，所以这里$\alpha\frac{1}{m}$可以用一个常数表示。</p><p>梯度下降法的搜索迭代示意图如下图所示:<img src="http://images2015.cnblogs.com/blog/743682/201511/743682-20151108163643227-650396065.png" alt="梯度下降法的搜索迭代示意图如下图所示"></p><p>参考书籍：</p><blockquote><p>An introduction to optimization-最优化导论[J]. Edwin K.P.Chong.</p></blockquote>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>优化算法篇之牛顿法</title>
      <link href="/2017/01/14/%E4%BC%98%E5%8C%96%E7%AE%97%E6%B3%95%E7%AF%87%E4%B9%8B%E7%89%9B%E9%A1%BF%E6%B3%95/"/>
      <content type="html"><![CDATA[<p>  我们在接触具体的机器学习算法前，其实很有必要对优化问题进行一些介绍。随着学习的深入，笔者越来越发现最优化方法的重要性，学习和工作中遇到的大多问题都可以建模成一种最优化模型进行求解，比如我们现在学习的机器学习算法，大部分的机器学习算法的本质都是建立优化模型，通过最优化方法对目标函数（或损失函数）进行优化，从而训练出最好的模型。</p><a id="more"></a><p>  最常见的最优化方法有梯度下降法、牛顿法和拟牛顿法、共轭梯度方向法等。在大学课程中，数值分析是计算机或数学相关专业一门比较重要的一门课程，笔者也在大学时自学过相关课程，其介绍的诸多对理论的计算机实现方法，对现在的学习依然发挥着很大的作用。当然优化算法只是数值分析课程中涉及一部分内容，这一节主要介绍和回顾牛顿法。</p><h2>牛顿法</h2><p>  上节介绍的梯度下降法（最速下降法）只用到了目标函数的一阶导数，牛顿法是一种二阶优化算法，相对于梯度下降算法收敛速度更快。首先，选择一个接近函数$f(x)$零点的$x_0$，计算相应的$f(x_0)$ 和切线斜率$f ’ (x_0)$。然后我们计算穿过点$(x_0,  f(x_0))$ 并且斜率为$f ‘(x_0)$的直线和 $X$轴的交点的$x$坐标，也就是求如下方程的解：$f(x_0)+f’(x_0)*(x-x_0)=0$我们将新求得的点的$x$坐标命名为$x_1$，通常$x_1$会比$x_0$更接近方程$f(x) = 0$的解。因此我们现在可以利用$x_1$开始下一轮迭代。迭代公式可化简为如下所示：</p><p>$$x_{n+1}=x_n-\frac{f(x_n)}{f’(x_n)}$$  牛顿法是基于当前位置的切线来确定下一次的位置，所以牛顿法又被很形象地称为是&quot;切线法&quot;。牛顿法的搜索路径（二维情况）如下图所示：</p><p><img src="https://upload.wikimedia.org/wikipedia/commons/e/e0/NewtonIteration_Ani.gif?_=4751804" alt="newton"></p><h4>缺点</h4><p>牛顿法也有很大的缺点，就是每次计算都需要计算Hessian矩阵的逆，因此计算量较大。</p><h3>拟牛顿法</h3><p>  拟牛顿法在一定程度上解决了牛顿法计算量大的问题。其本质思想是改善牛顿法每次需要求解复杂的Hessian矩阵的逆矩阵的缺陷，它<strong>使用正定矩阵来近似Hessian矩阵的逆</strong>，从而简化了运算的复杂度。（在多变量的情况下，如果目标矩阵的Hessain矩阵非正定，牛顿法确定的搜索方向并不一定是目标函数下降的方向）<br>  拟牛顿法和最速下降法一样只要求每一步迭代时知道目标函数的梯度。通过测量梯度的变化，构造一个目标函数的模型使之足以产生超线性收敛性。这类方法大大优于最速下降法，尤其对于困难的问题。另外，因为拟牛顿法不需要二阶导数的信息，所以有时比牛顿法更为有效。如今，优化软件中包含了大量的拟牛顿算法用来解决无约束，约束，和大规模的优化问题。</p><h4>拟牛顿法的Matlab实现：</h4><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">#函数名：quasi_Newton(f,x0,error), </span><br><span class="line">#参数：f:待求梯度函数   x0:初始点   error：允许误差 </span><br><span class="line">#主程序： </span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span>=<span class="title">quasi_Newton</span><span class="params">(f,x0,error)</span> </span></span><br><span class="line">     [a,b]=<span class="built_in">size</span>(x0); </span><br><span class="line">     G0=<span class="built_in">eye</span>(b); </span><br><span class="line">     initial_gradient=gradient_my(f,x0,b); </span><br><span class="line">     norm0=<span class="number">0</span>; </span><br><span class="line">     norm0=initial_gradient*initial_gradient'; </span><br><span class="line">     syms step_zzh; </span><br><span class="line">     A=[x0]; </span><br><span class="line">     search_direction=-initial_gradient; </span><br><span class="line">     x=x0+step_zzh*search_direction; </span><br><span class="line">     f_step=subs(f,findsym(f),x); </span><br><span class="line">     best_step=golden_search(f_step,<span class="number">-15</span>,<span class="number">15</span>); </span><br><span class="line">     x_1=x0+best_step*search_direction; </span><br><span class="line">     A=[A;x_1]; </span><br><span class="line">     k=<span class="number">1</span>; </span><br><span class="line"><span class="keyword">while</span> norm0&gt;error </span><br><span class="line">     ox=x_1-x0; </span><br><span class="line">     og=gradient_my(f,x_1,b)-initial_gradient; </span><br><span class="line">     G1=G0+(ox'*ox)/(ox*og')-(G0*og'*og*G0)/(og*G0*og'); </span><br><span class="line">     <span class="keyword">if</span>  k+<span class="number">1</span>==b </span><br><span class="line">         new_direction=-gradient_my(f,x_1,b); </span><br><span class="line">     <span class="keyword">else</span> </span><br><span class="line">         new_direction=-(G1*(gradient_my(f,x_1,b))')'; </span><br><span class="line">     <span class="keyword">end</span> </span><br><span class="line">     x=x_1+step_zzh*new_direction; </span><br><span class="line">     f_step=subs(f,findsym(f),x); </span><br><span class="line">     best_step=golden_search(f_step,<span class="number">-15</span>,<span class="number">15</span>) </span><br><span class="line">     x_2=x_1+best_step*new_direction </span><br><span class="line">     A=[A;x_2]; </span><br><span class="line">     initial_gradient=gradient_my(f,x_1,b); </span><br><span class="line">     norm0=initial_gradient*initial_gradient'; </span><br><span class="line">     x0=x_1;x_1=x_2; </span><br><span class="line">     G0=G1; </span><br><span class="line">     k=k+<span class="number">1</span>; </span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Mathematic </tag>
            
            <tag> 优化算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>用AngularJS写框架</title>
      <link href="/2016/12/28/%E7%94%A8AngularJS%E5%86%99%E6%A1%86%E6%9E%B6/"/>
      <content type="html"><![CDATA[<h2>1. 模块的定义和加载</h2><h3>1.1 模块的定义</h3><a id="more"></a><p>  先问个问题：我们做模块系统的目的是什么？如果觉得这个问题难以回答，可以从反面来考虑：假如不做模块系统，有什么样的坏处？</p><p>  我们经历过比较粗放、混乱的前端开发阶段，页面里充满了全局变量，全局函数。那时候要复用js文件，就是把某些js函数放到一个文件里，然后让多个页面都来引用。</p><p>  考虑到一个页面可以引用多个这样的js，这些js互相又不知道别人里面写了什么，很容易造成命名的冲突，而产生这种冲突的时候，又没有哪里能够提示出来。所以我们要有一种办法，把作用域比较好地隔开。</p><p>  JavaScript这种语言比较奇怪，奇怪在哪里呢，它的现有版本里没package跟class，要是有，我们也没必要来考虑什么自己做模块化了。那它是要用什么东西来隔绝作用域呢？</p><p>  在很多传统高级语言里，变量作用域的边界是大括号，在{}里面定义的变量，作用域不会传到外面去，但我们的JavaScript大人不是这样的，他的边界是function。所以我们这段代码，i仍然能打出值：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="number">5</span>; i++) &#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line">alert(i);</span><br></pre></td></tr></table></figure><p>  那么，我们只能选用function做变量的容器，把每个模块封装到一个function里。现在问题又来了，这个function本身的作用域是全局的，怎么办？我们想不到办法，拔剑四顾心茫然。</p><p>  我们有没有什么可参照的东西呢？这时候，脑海中一群语言飘过： C语言飘过：“我不是面向对象语言哦~不需要像你这么组织哦~”，“死开！” Java飘过：“我是纯面向对象语言哦，连main都要在类中哦，编译的时候通过装箱清单指定入口哦~”，“死开！” C++飘过：“我也是纯面向对象语言哦”，等等，C++是纯面向对象的语言吗？你的main是什么？？？main是特例，不在任何类中！</p><p>啊，我们发现了什么，既然无法避免全局的作用域，那与其让100个function都全局，不如只让一个来全局，其他的都由它管理。</p><p>本来我们打算自己当上帝的，现在只好改行先当个工商局长。你想开店吗？先来注册，不然封杀你！于是良民们纷纷来注册。店名叫什么，从哪进货，卖什么的，一一登记在案，为了方便下面的讨论，我们连进货的过程都让工商局管理起来。</p><p>店名，指的就是这里的模块名，从哪里进货，代表它依赖什么其他模块，卖什么，表示它对外提供一些什么特性。</p><p>好了，考虑到我们的这个注册管理机构是个全局作用域，我们还得把它挂在window上作为属性，然后再用一个function隔离出来，要不然，别人也定义一个同名的，就把我们覆盖掉了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="comment">//register a module</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>在这个module方法内部，应当怎么去实现呢？我们的module应当有一个地方存储，但存储是要在工商局内部的，不是随便什么人都可以看到的，所以，这个存储结构也放在工商局同样的作用域里。</p><p>用什么结构去存储呢？工商局备案的时候，店名不能跟已有的重复，所以我们发现这是用map的很好场景，考虑到JavaScript语言层面没有map，我们弄个Object来存。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleMap = &#123;&#125;;</span><br><span class="line">    <span class="built_in">window</span>.thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!moduleMap[name]) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    dependencies: dependencies,</span><br><span class="line">                    factory: factory</span><br><span class="line">                &#125;;</span><br><span class="line">                moduleMap[name] = <span class="built_in">module</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> moduleMap[name];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>现在，模块的存储结构就搞好了。</p><h3>1.2 模块的使用</h3><p>  存的部分搞好了，我们来看看怎么取。现在来了一个商家，卖木器的，他需要从一个卖钉子的那边进货，卖钉子的已经来注册过了，现在要让这个木器厂能买到钉子。现在的问题是，两个商家处于不同的作用域，也就是说，它们互相不可见，那通过什么方式，我们才能让他们产生调用关系呢？</p><p>  个人解决不了的问题还是得靠政府，有困难要坚决克服，没有困难就制造困难来克服。现在困难有了，该克服了。商家说，我能不能给你我的进货名单，你帮我查一下它们在哪家店，然后告诉我？这么简单的要求当然一口答应下来，但是采用什么方式传递给你呢？这可犯难了。</p><p>我们参考AngularJS框架，写了一个类似的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"A"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module A</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"B"</span>, [<span class="string">"A"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module B</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看这段代码特别在哪里呢？模块A的定义，毫无特别之处，主要看模块B。它在依赖关系里写了一个字符串的A，然后在工厂方法的形参写了一个真真切切的A类型。嗯？这个有些奇怪啊，你的A类型要怎么传递过来呢？其实是很简单的，因为我们声明了依赖项的数组，所以可以从依赖项，挨个得到对应的工厂方法，然后创建实例，传进来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">use: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">module</span> = moduleMap[name];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!<span class="built_in">module</span>.entity) &#123;</span><br><span class="line">        <span class="keyword">var</span> args = [];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">module</span>.dependencies.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (moduleMap[<span class="built_in">module</span>.dependencies[i]].entity) &#123;</span><br><span class="line">                args.push(moduleMap[<span class="built_in">module</span>.dependencies[i]].entity);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                args.push(<span class="keyword">this</span>.use(<span class="built_in">module</span>.dependencies[i]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">module</span>.entity = <span class="built_in">module</span>.factory.apply(noop, args);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">module</span>.entity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以看到，这里面递归获取了依赖项，然后当作参数，用这个模块的工厂方法来实例化了一下。这里我们多做了一个判断，如果模块工厂已经执行过，就缓存在entity属性上，不需要每次都创建。以此类推，假如一个模块有多个依赖项，也可以用类似的方式写，毫无压力：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"D"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A, B, C</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module D</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>注意了，D模块的工厂，实参的名称未必就要是跟依赖项一致，比如，以后我们代码较多，可以给依赖项和模块名称加命名空间，可能变成这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"foo.D"</span>, [<span class="string">"foo.A"</span>, <span class="string">"foo.B"</span>, <span class="string">"foo.C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">A, B, C</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//module D</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="keyword">new</span> A();</span><br><span class="line">    <span class="keyword">var</span> b = <span class="keyword">new</span> B();</span><br><span class="line">    <span class="keyword">var</span> c = <span class="keyword">new</span> C();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这段代码仍然可以正常运行。我们来做另外一个测试，改变形参的顺序：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"A"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"a"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"B"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"b"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"C"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"c"</span>;</span><br><span class="line">&#125;);</span><br><span class="line">thin.define(<span class="string">"D"</span>, [<span class="string">"A"</span>, <span class="string">"B"</span>, <span class="string">"C"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">B, A, C</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> B + A + C;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> D = thin.use(<span class="string">"D"</span>);</span><br><span class="line">alert(D);</span><br></pre></td></tr></table></figure><p>试试看，我们的D打出什么结果呢？结果是&quot;abc&quot;，所以说，模块工厂的实参只跟依赖项的定义有关，跟形参的顺序无关。我们看到，在AngularJS里面，并非如此，实参的顺序是跟形参一致的，这是怎么做到的呢？</p><p>我们先离开代码，思考这么一个问题：如何得知函数的形参名数组？对，我们是可以用func.length得到形参个数，但无法得到每个形参的变量名，那怎么办呢？</p><p>AngularJS使用了一种比较极端的办法，分析了函数的字面量。众所周知，在JavaScript中，任何对象都隐含了toString方法，对于一个函数来说，它的toString就是自己的实现代码，包含函数签名和注释。下面我贴一下AngularJS里面的这部分代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> FN_ARGS = <span class="regexp">/^function\s*[^\(]*\(\s*([^\)]*)\)/m</span>;</span><br><span class="line"><span class="keyword">var</span> FN_ARG_SPLIT = <span class="regexp">/,/</span>;</span><br><span class="line"><span class="keyword">var</span> FN_ARG = <span class="regexp">/^\s*(_?)(\S+?)\1\s*$/</span>;</span><br><span class="line"><span class="keyword">var</span> STRIP_COMMENTS = <span class="regexp">/((\/\/.*$)|(\/\*[\s\S]*?\*\/))/mg</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">annotate</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> $inject,</span><br><span class="line">      fnText,</span><br><span class="line">      argDecl,</span><br><span class="line">      last;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> fn == <span class="string">'function'</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!($inject = fn.$inject)) &#123;</span><br><span class="line">      $inject = [];</span><br><span class="line">      fnText = fn.toString().replace(STRIP_COMMENTS, <span class="string">''</span>);</span><br><span class="line">      argDecl = fnText.match(FN_ARGS);</span><br><span class="line">      forEach(argDecl[<span class="number">1</span>].split(FN_ARG_SPLIT), <span class="function"><span class="keyword">function</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">        arg.replace(FN_ARG, <span class="function"><span class="keyword">function</span>(<span class="params">all, underscore, name</span>)</span>&#123;</span><br><span class="line">          $inject.push(name);</span><br><span class="line">        &#125;);</span><br><span class="line">      &#125;);</span><br><span class="line">      fn.$inject = $inject;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isArray(fn)) &#123;</span><br><span class="line">    last = fn.length - <span class="number">1</span>;</span><br><span class="line">    assertArgFn(fn[last], <span class="string">'fn'</span>);</span><br><span class="line">    $inject = fn.slice(<span class="number">0</span>, last);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertArgFn(fn, <span class="string">'fn'</span>, <span class="literal">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> $inject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，这个代码也不长，重点是类型为function的那段，首先去除了注释，然后获取了形参列表字符串，这段正则能获取到两个结果，第一个是全函数的实现，第二个才是真正的形参列表，取第二个出来split，就得到了形参的字符串列表了，然后按照这个顺序再去加载依赖模块，就可以让形参列表不对应于依赖项数组了。</p><p>AngularJS的这段代码很强大，但是要损耗一些性能，考虑到我们的框架首要原则是简单，甚至可以为此牺牲一些灵活性，我们不做这么复杂的事情了。</p><h3>1.3 模块的加载</h3><p>  到目前为止，我们可以把多个模块都定义在一个文件中，然后手动引入这个js文件，但是如果一个页面要引用很多个模块，引入工作就变得比较麻烦，比如说，单页应用程序（SPA）一般比较复杂，往往包含数以万计行数的js代码，这些代码至少分布在几十个甚至成百上千的模块中，如果我们也在主界面就加载它们，载入时间会非常难以接受。但我们可以这样看：主界面加载的时候，并不是用到了所有这些功能，能否先加载那些必须的，而把剩下的放在需要用的时候再去加载？</p><p>所以我们可以考虑<strong>万能的AJAX</strong>，从服务端获取一个js的内容，然后……，怎么办，你当然说不能eval了，因为据说eval很evil啦，但是它evil在哪里呢？主要是破坏全局作用域啦，怎么怎么，但是如果这些文件里面都是按照我们规定的模块格式写，好像也没有什么在全局作用域的……，好吧。</p><p>算了，我们还是用最简单的方式了，就是**动态创建script标签，然后设置src，添加到document.head里，然后监听它们的完成事件，做后续操作。**真的很简单，因为我们的框架不需要考虑那么多种情况，不需要AMD，不需要require那么麻烦，用这框架的人必须按照这里的原则写。</p><p>  所以，说真的我们这里没那么复杂啦，要是你们想看更详细原理的不如去看这个，解释得比我好哎：<a href="http://coolshell.cn/articles/9749.html#jtss-tsina" target="_blank" rel="noopener">JavaScript装载与执行</a></p><p>[补一段，@Franky 大神指出了这篇文章中一些不符合现状的地方，我把它也贴在这里，供读者参考]</p><blockquote><p>很多观点都是 史蒂夫那本老书上的观点. 和那时候同期产生的一些数据和资料…所以显得不少东西说的太想当然了… 譬如script标签的加载和执行会阻塞后面资源的加载和执行之类的.说的过于肯定了. 比如chrome7+就开始逐渐改进的 预加载机制 就分 head 里的资源, body里的资源 .两个资源是否跨界三种情形. 不提这些浏览器. 我们看看ie10也同样改进了 死循环10秒 这后面的图片能被提前加载. 就更不用说其他A级浏览器的丰富的优化策略了. 所以还是建议博主, 别拿几年前的老资料作为依据.尤其这些数据是用来说明更新速度像在赛跑一样的各个浏览器了.</p><p>关于 defer , 似乎史蒂夫的老书上是这么说的么? 显然没有测试全非ie浏览器的各个版本.或者是他测试数据的时候ff某大版本的几个beta子版本还没出现?</p><p>其次是就你的加载器提到的预加载策略. 你有测过所有浏览器用object预加载可能涉及到的问题么(比如chrome,8,9的预加载的会话级别的资源类型缓存bug). 抛开这个问题不谈,假设你预加载到一半,用户再次触发了加载.你觉得这种情况如果频繁发生.是否合适? 你的预加载策略连script.onload状态都无法测知,进一步优化的可能性就消失了. 考虑下为什么seajs 的 umd要设计成那个样子?</p><p>最后吐槽下你的代码. 有注意到你用 document.body.appendChild 来向DOM中插入脚本. 我的建议是 永远不要这样做.除非你可以无视ie6用户.以及ie7缺失某些补丁的子版本.</p><p>你可以选择body 可以.但请用insertBefore. 但在某些极端情况下.这仍然会发生问题. 最佳实践是 head.insertBefore 向其第一个子节点插入.(你甚至无需检测是否存在子节点. 这个api会在没有子节点的时候,行为同appendChild). 而更加稳妥的情况是. 如果注入script. 发现document.head还没有被构建时. 可以自己造一个. 这才是一个通用加载器要做到的程度…</p></blockquote><p>我也偷懒了，只是贴一下代码，顺便解释一下，界面把所依赖的js文件路径放在数组里，然后挨个创建script标签，src设置为路径，添加到head中，监听它们的完成事件。在这个完成时间里，我们要做这么一些事情：在fileMap里记录当前js文件的路径，防止以后重复加载，检查列表中所有文件，看看是否全部加载完了，如果全加载好了，就执行回调。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">require</span>: <span class="function"><span class="keyword">function</span> (<span class="params">pathArr, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">        <span class="keyword">var</span> path = pathArr[i];</span><br><span class="line">        <span class="keyword">if</span> (!fileMap[path]) &#123;</span><br><span class="line">            <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">            node.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">            node.async = <span class="string">'true'</span>;</span><br><span class="line">            node.src = path + <span class="string">'.js'</span>;</span><br><span class="line">            node.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                fileMap[path] = <span class="literal">true</span>;</span><br><span class="line">                head.removeChild(node);</span><br><span class="line">                checkAllFiles();</span><br><span class="line">            &#125;;</span><br><span class="line">            head.appendChild(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">checkAllFiles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> allLoaded = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!fileMap[pathArr[i]]) &#123;</span><br><span class="line">                allLoaded = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (allLoaded) &#123;</span><br><span class="line">            callback();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3>1.4 小结</h3><p>到此为止，我们的简易框架的模块定义系统就完成了。完整的代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> moduleMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> fileMap = &#123;&#125;;</span><br><span class="line">    <span class="keyword">var</span> noop = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> thin = &#123;</span><br><span class="line">        define: <span class="function"><span class="keyword">function</span>(<span class="params">name, dependencies, factory</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!moduleMap[name]) &#123;</span><br><span class="line">                <span class="keyword">var</span> <span class="built_in">module</span> = &#123;</span><br><span class="line">                    name: name,</span><br><span class="line">                    dependencies: dependencies,</span><br><span class="line">                    factory: factory</span><br><span class="line">                &#125;;</span><br><span class="line">                moduleMap[name] = <span class="built_in">module</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> moduleMap[name];</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        use: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> <span class="built_in">module</span> = moduleMap[name];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="built_in">module</span>.entity) &#123;</span><br><span class="line">                <span class="keyword">var</span> args = [];</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;<span class="built_in">module</span>.dependencies.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (moduleMap[<span class="built_in">module</span>.dependencies[i]].entity) &#123;</span><br><span class="line">                        args.push(moduleMap[<span class="built_in">module</span>.dependencies[i]].entity);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        args.push(<span class="keyword">this</span>.use(<span class="built_in">module</span>.dependencies[i]));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="built_in">module</span>.entity = <span class="built_in">module</span>.factory.apply(noop, args);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">module</span>.entity;</span><br><span class="line">        &#125;,</span><br><span class="line"></span><br><span class="line">        <span class="built_in">require</span>: <span class="function"><span class="keyword">function</span> (<span class="params">pathArr, callback</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                <span class="keyword">var</span> path = pathArr[i];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (!fileMap[path]) &#123;</span><br><span class="line">                    <span class="keyword">var</span> head = <span class="built_in">document</span>.getElementsByTagName(<span class="string">'head'</span>)[<span class="number">0</span>];</span><br><span class="line">                    <span class="keyword">var</span> node = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</span><br><span class="line">                    node.type = <span class="string">'text/javascript'</span>;</span><br><span class="line">                    node.async = <span class="string">'true'</span>;</span><br><span class="line">                    node.src = path + <span class="string">'.js'</span>;</span><br><span class="line">                    node.onload = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                        fileMap[path] = <span class="literal">true</span>;</span><br><span class="line">                        head.removeChild(node);</span><br><span class="line">                        checkAllFiles();</span><br><span class="line">                    &#125;;</span><br><span class="line">                    head.appendChild(node);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">function</span> <span class="title">checkAllFiles</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                <span class="keyword">var</span> allLoaded = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; pathArr.length; i++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!fileMap[pathArr[i]]) &#123;</span><br><span class="line">                        allLoaded = <span class="literal">false</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (allLoaded) &#123;</span><br><span class="line">                    callback();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">window</span>.thin = thin;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure><p>测试代码如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">thin.define(<span class="string">"constant.PI"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">3.14159</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"shape.Circle"</span>, [<span class="string">"constant.PI"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">pi</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Circle = <span class="function"><span class="keyword">function</span>(<span class="params">r</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.r = r;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Circle.prototype = &#123;</span><br><span class="line">        area : <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> pi * <span class="keyword">this</span>.r * <span class="keyword">this</span>.r;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Circle;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"shape.Rectangle"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> Rectangle = <span class="function"><span class="keyword">function</span>(<span class="params">l, w</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.l = l;</span><br><span class="line">        <span class="keyword">this</span>.w = w;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    Rectangle.prototype = &#123;</span><br><span class="line">        area: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.l * <span class="keyword">this</span>.w;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Rectangle;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"ShapeTypes"</span>, [<span class="string">"shape.Circle"</span>, <span class="string">"shape.Rectangle"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">Circle, Rectangle</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        CIRCLE: Circle,</span><br><span class="line">        RECTANGLE: Rectangle</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">thin.define(<span class="string">"ShapeFactory"</span>, [<span class="string">"ShapeTypes"</span>], <span class="function"><span class="keyword">function</span>(<span class="params">ShapeTypes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        getShape: <span class="function"><span class="keyword">function</span>(<span class="params">type</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">var</span> shape;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"CIRCLE"</span>: &#123;</span><br><span class="line">                    shape = <span class="keyword">new</span> ShapeTypes[type](<span class="built_in">arguments</span>[<span class="number">1</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> <span class="string">"RECTANGLE"</span>:  &#123;</span><br><span class="line">                    shape = <span class="keyword">new</span> ShapeTypes[type](<span class="built_in">arguments</span>[<span class="number">1</span>], <span class="built_in">arguments</span>[<span class="number">2</span>]);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> shape;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> ShapeFactory = thin.use(<span class="string">"ShapeFactory"</span>);</span><br><span class="line">alert(ShapeFactory.getShape(<span class="string">"CIRCLE"</span>, <span class="number">5</span>).area());</span><br><span class="line">alert(ShapeFactory.getShape(<span class="string">"RECTANGLE"</span>, <span class="number">3</span>, <span class="number">4</span>).area());</span><br></pre></td></tr></table></figure><p>在这个例子里定义了四个模块，每个模块只需要定义自己所直接依赖的模块，其他的可以不必定义。也可以来这里看测试链接：<a href="http://xufei.github.io/thin/demo/demo.0.1.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/demo.0.1.html</a></p><h2>2. 数据绑定</h2><h3>2.1 数据绑定的原理</h3><p>数据绑定是一种很便捷的特性，一些RIA框架带有双向绑定功能，比如Flex和Silverlight，当某个数据发生变更时，所绑定的界面元素也发生变更，当界面元素的值发生变化时，数据也跟着变化，这种功能在处理表单数据的填充和收集时，是非常有用的。</p><p>在HTML中，原生是没有这样的功能的，但有些框架做到了，它们是怎么做到的呢？我们来做个简单的试试，顺便探讨一下其中原理。</p><p>先看数据到界面上的的绑定，比如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;input vm-value=&quot;name&quot;/&gt;</span><br><span class="line">var person = &#123;</span><br><span class="line">    name: &quot;Tom&quot;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们给name重新赋值，<a href="http://person.name" target="_blank" rel="noopener">person.name</a> = “Jerry”，怎么才能让界面得到变更？</p><p>从直觉来说，我们需要在name发生改变的时候，触发一个事件，或者调用某个指定的方法，然后才好着手做后面的事情，比如：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    setName: <span class="function"><span class="keyword">function</span>(<span class="params">newName</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = newName;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样我们可以在setName里面去给input赋值。推而广之，为了使得实体包含的多个属性都可以运作，可以这么做：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">"Tom"</span>,</span><br><span class="line">    gender: <span class="number">5</span></span><br><span class="line">    set: <span class="function"><span class="keyword">function</span>(<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>[key] = value;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>或者合并两个方法，只判断是否传了参数：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Person.prototype.name = <span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">arguments</span>.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>._name = value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况下，<a href="http://xn--person-op0jjj079gsvv8ray18m049c.name" target="_blank" rel="noopener">赋值的时候就是person.name</a>(“Tom”)，取值的时候就是var name = <a href="http://person.name" target="_blank" rel="noopener">person.name</a>()了。</p><p>有一些框架是通过这种方式来变通实现数据绑定的，对数据的写入只能通过方法调用。但这种方式很不直接，我们来想点别的办法。</p><p>在C#等一些语言里，有一种东西叫做存取器，比如说：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Person</span><br><span class="line">&#123;</span><br><span class="line">    private string name;</span><br><span class="line"></span><br><span class="line">    public string Name</span><br><span class="line">    &#123;</span><br><span class="line">        get</span><br><span class="line">        &#123;</span><br><span class="line">            return name;</span><br><span class="line">        &#125;</span><br><span class="line">        set</span><br><span class="line">        &#123;</span><br><span class="line">            name = value;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用的时候，<a href="http://person.Name" target="_blank" rel="noopener">person.Name</a> = “Jerry”，就会调用到set里，相当于是个方法。</p><p>这一点非常好，很符合我们的需要，那JavaScript里面有没有类似存取器的特性呢？老早以前是没有的，但现在有了，那就是Object.defineProperty，它的第三个参数就是可选的存取函数。比如说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add an accessor property to the object.</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(person, <span class="string">"name"</span>, &#123;</span><br><span class="line">    set: <span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>._name = value;</span><br><span class="line">        <span class="comment">//do something</span></span><br><span class="line">    &#125;,</span><br><span class="line">    get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>._name;</span><br><span class="line">    &#125;,</span><br><span class="line">    enumerable: <span class="literal">true</span>,</span><br><span class="line">    configurable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>赋值的时候，<a href="http://person.name" target="_blank" rel="noopener">person.name</a> = “Tom”，取值的时候，var name = <a href="http://person.name" target="_blank" rel="noopener">person.name</a>，简直太美妙了。注意这里define的时候，是定义在实例上的，如果想要定义到类型里面，可以在构造器里面定义。</p><p>现在我们从数据到DOM的绑定可以解决掉了，至少我们能够在变量被更改的时候去做一些自己的事情，比如查找这个属性被绑定到哪些控件了，然后挨个对其赋值。框架怎么知道属性被绑定到哪些控件了呢？这个直接在第二部分的实现过程中讨论。</p><p>再看控件到数据的绑定，这个其实很好理解。无非就是给控件添加change之类的事件监听，在这里面把关联到的数据更新掉。到这里，我们在原理方面已经没有什么问题了，现在开始准备把它写出来。</p><h3>2.2 数据绑定的实现</h3><p>我们的框架启动之后，要先把前面所说的这种绑定关系收集起来，这种属性会分布于DOM的各个角落，一个很现实的做法是，递归遍历界面的每个DOM节点，检测该属性，于是我们代码的结构大致如下所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseElement</span>(<span class="params">element</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.attributes.length; i++) &#123;</span><br><span class="line">        parseAttribute(element.attributes[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.children.length; i++) &#123;</span><br><span class="line">        parseElement(element.children[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是我们这时候面临一个问题，比如你的输入框绑定在name变量上，这个name应该从属于什么？它是全局变量吗？</p><p>我们在开始做这个框架的时候强调了一个原则：业务模块不允许定义全局变量，框架内部也尽量少有全局作用域，到目前为止，我们只暴露了thin一个全局入口，所以在这里不能破坏这个原则。</p><p>因此，我们要求业务开发人员去定义一个视图模型，把变量包装起来，所包装的不限于变量，也可以有方法。比如下面，我们定义了一个实体叫Person，带两个变量，两个方法，后面我们来演示一下怎么把它们绑定到HTML界面。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.define(<span class="string">"Person"</span>, [], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = <span class="string">"Tom"</span>;</span><br><span class="line">        <span class="keyword">this</span>.age = <span class="number">5</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Person.prototype = &#123;</span><br><span class="line">        growUp: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.age++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> Person;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>模型方面都准备好了，现在来看界面：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><p>为了使得结构更加容易看，我们把界面的无关属性比如样式之类都去掉了，只留下不能再减少的这么一段。现在我们可以看到，在界面的顶层定义一个vm-model属性，值为实体的名称。两个输入框通过vm-value来绑定到实例属性，vm-init绑定界面的初始化方法，vm-click绑定按钮的点击事件。</p><p>好了，现在我们可以来扫描这个简单的DOM结构了。想要做这么一个绑定，首先要考虑数据从哪里来？在绑定name和code属性之前，毫无疑问，应当先实例化一个Person，我们怎么才能知道需要把Person模块实例化呢？</p><p>当扫描到一个DOM元素的时候，我们要先检测它的vm-model属性，如果有值，就取这个值来实例化，然后，把这个值一直传递下去，在扫描其他属性或者下属DOM元素的时候都带进去。这么一来，parseElement就变成一个递归了，于是它只好有两个参数，变成了这样：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseElement</span>(<span class="params">element, vm</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> model = vm;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (element.getAttribute(<span class="string">"vm-model"</span>)) &#123;</span><br><span class="line">        model = bindModel(element.getAttribute(<span class="string">"vm-model"</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.attributes.length; i++) &#123;</span><br><span class="line">        parseAttribute(element, element.attributes[i], model);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;element.children.length; i++) &#123;</span><br><span class="line">        parseElement(element.children[i], model);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看我们打算怎么来实例化这个模型，这个bindModel方法的参数是模块名，于是我们先去use一下，从工厂里生成出来，然后new一下，先这么return出去吧。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindModel</span>(<span class="params">modelName</span>) </span>&#123;</span><br><span class="line">    thin.log(<span class="string">"model"</span> + modelName);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> model = thin.use(modelName, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> model();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在我们开始关注parseAttribute函数，可能的attribute有哪些种类呢？我列举了一些很常用的：</p><ul><li>init，用于绑定初始化方法</li><li>click，用于绑定点击</li><li>value，绑定变量</li><li>enable和disable，绑定可用状态</li><li>visible和invisible，绑定可见状态</li></ul><p>然后就可以实现我们parseAttribute函数了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">parseAttribute</span>(<span class="params">element, attr, model</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (attr.name.indexOf(<span class="string">"vm-"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">var</span> type = attr.name.slice(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"init"</span>:</span><br><span class="line">                bindInit(element, attr.value, model);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"value"</span>:</span><br><span class="line">                bindValue(element, attr.value, model);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"click"</span>:</span><br><span class="line">                bindClick(element, attr.value, model);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"enable"</span>:</span><br><span class="line">                bindEnable(element, attr.value, model, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"disable"</span>:</span><br><span class="line">                bindEnable(element, attr.value, model, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"visible"</span>:</span><br><span class="line">                bindVisible(element, attr.value, model, <span class="literal">true</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"invisible"</span>:</span><br><span class="line">                bindVisible(element, attr.value, model, <span class="literal">false</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">"element"</span>:</span><br><span class="line">                model[attr.value] = element;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到最后还有个element类型，本来可以不要这个，但我们考虑到将来，一切都是组件化的时候，界面上打算不写id，也不依靠选择器，而是用某个标志来定位元素，所以加上了这个，文章最后的示例中使用了它。</p><p>这么多绑定，不打算都讲，用bindValue函数来说明一下吧：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindValue</span>(<span class="params">element, key, vm</span>) </span>&#123;</span><br><span class="line">    thin.log(<span class="string">"binding value: "</span> + key);</span><br><span class="line"></span><br><span class="line">    vm.$watch(key, <span class="function"><span class="keyword">function</span> (<span class="params">value, oldValue</span>) </span>&#123;</span><br><span class="line">        element.value = value || <span class="string">""</span>;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    element.onkeyup = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm[key] = element.value;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    element.onpaste = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        vm[key] = element.value;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们假定每个模型实例上带有一个$watch方法，用于监控某变量的变化，可以传入一个监听函数，当变量变化的时候，自动调用这个函数，并且把新旧两个值传回来。</p><p>在这个代码里，我们使用$watch方法给传入的key添加一个监听，监听器里面给监听元素赋值。我们这里偷懒了一下，假定所有的绑定元素都是输入框，所以直接给element.value设置值，为了防止值为空导致显示undefined，把值跟空字符串用短路表达式做了个转换。</p><p>接下来，也对element的几个可能导致值变化的事件进行了监听，在里面把模型上对应的值更新掉。这样双向绑定就做好了。</p><p>然后回头来看$watch的实现。很显然这里也要一个map，我们给它取名为$watchers，存放属性的绑定关系，对于每个属性，它的值需要保存一份，供getter获取，同时还有一个数组，存放了该属性绑定的处理函数。当属性发生变更的时候，去挨个把它们调用一下。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Binder = &#123;</span><br><span class="line">    $watch: <span class="function"><span class="keyword">function</span> (<span class="params">key, watcher</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">this</span>.$watchers[key]) &#123;</span><br><span class="line">            <span class="keyword">this</span>.$watchers[key] = &#123;</span><br><span class="line">                value: <span class="keyword">this</span>[key],</span><br><span class="line">                list: []</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            <span class="built_in">Object</span>.defineProperty(<span class="keyword">this</span>, key, &#123;</span><br><span class="line">                set: <span class="function"><span class="keyword">function</span> (<span class="params">val</span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">var</span> oldValue = <span class="keyword">this</span>.$watchers[key].value;</span><br><span class="line">                    <span class="keyword">this</span>.$watchers[key].value = val;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.$watchers[key].list.length; i++) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.$watchers[key].list[i](val, oldValue);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;,</span><br><span class="line"></span><br><span class="line">                get: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">this</span>.$watchers[key].value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">this</span>.$watchers[key].list.push(watcher);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是vm怎么就有$watch呢，每个地方都去判断一下非空然后再去创建其实挺麻烦的，所以，这个属性我们可以直接在实例化模型的时候创建出来。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bindModel</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    thin.log(<span class="string">"binding model: "</span> + name);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> model = thin.use(name, <span class="literal">true</span>);</span><br><span class="line">    <span class="keyword">var</span> instance = <span class="keyword">new</span> model().extend(Binder);</span><br><span class="line">    instance.$watchers = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> instance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看这里的写法，为什么$watchers要额外设置，而$watch就可以放在Binder里面来extend呢？</p><p>先解释extend干了什么，它做的是一个对象的浅拷贝，也就是说，把Binder的属性和方法都复制给了创建出来的model实例，注意，这个所谓的复制，如果是简单类型，那确实复制了，如果是引用类型，那复制的其实只是一个引用，所以如果$watchers也放在Binder里，不同的instance就共享一个$watchers，逻辑就是错误的。那为什么$watch又可以放在这里复制呢？因为它是函数，它的this始终指向当前的执行主体，也就是说，如果放在instance1上执行，指向的就是instance1，放在instance2上执行，指向的就是instance2，我们利用这一点，就可以不用让每个实例都创建一份$watch方法，而是共用同一个。</p><p>同理，我们可以把enable，visible，init，click这些都做起来，init的执行时间放在扫描完vm-model那个element之下的所有DOM节点之后。</p><p>嗯，我们是不是可以试一下了？来写个代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Simple binding demo<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"viewport"</span> <span class="attr">content</span>=<span class="string">"width=device-width, initial-scale=1.0"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"description"</span> <span class="attr">content</span>=<span class="string">"binding"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">"author"</span> <span class="attr">content</span>=<span class="string">"xu.fei@outlook.com"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span> <span class="attr">src</span>=<span class="string">"../js/thin.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"test.Person"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">vm-model</span>=<span class="string">"test.Person"</span> <span class="attr">vm-init</span>=<span class="string">"init"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"name"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">vm-value</span>=<span class="string">"age"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"button"</span> <span class="attr">vm-click</span>=<span class="string">"growUp"</span> <span class="attr">value</span>=<span class="string">"Grow Up"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    thin.define(<span class="string">"test.Person"</span>, [], <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.name = <span class="string">"Tom"</span>;</span></span><br><span class="line"><span class="javascript">            <span class="keyword">this</span>.age = <span class="number">5</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="undefined">        Person.prototype = &#123;</span></span><br><span class="line"><span class="javascript">            init: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.name = <span class="string">"Jerry"</span>;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.age = <span class="number">3</span>;</span></span><br><span class="line"><span class="undefined">            &#125;,</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">            growUp: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">                <span class="keyword">this</span>.age++;</span></span><br><span class="line"><span class="undefined">            &#125;</span></span><br><span class="line"><span class="undefined">        &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> Person;</span></span><br><span class="line"><span class="undefined">    &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>或者访问这里：<a href="http://xufei.github.io/thin/demo/simple-binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/simple-binding.html</a></p><p>以刚才文章提到的内容，还不能完全解释这个例子的效果，因为没看到在哪里调用parseElement的。说来也简单，就在thin.js里面，直接写了一个thin.ready，在那边调用了这个函数，去解析了document.body，于是测试页面里面才可以只写绑定和视图模型。</p><p>我们还有一个更实际一点的例子，结合了另外一个系列里面写的简单DataGrid控件，做了一个很基础的人员管理界面：<a href="http://xufei.github.io/thin/demo/binding.html" target="_blank" rel="noopener">http://xufei.github.io/thin/demo/binding.html</a></p><h3>2.3 小结</h3><p>到此为止，我们的绑定框架勉强能够运行起来了！虽然很简陋，而且要比较新的浏览器才能跑，但毕竟是跑起来了。</p><p>注意Object.defineProperty仅在Chrome等浏览器中可用，IE需要9以上才比较正常。在司徒正美的avalon框架中，巧妙使用VBScript绕过这一限制，利用vbs的property和两种语言的互通，实现了低版本IE的兼容。我们这个框架的目标不是兼容，而是为了说明原理，所以感兴趣的朋友可以去看看avalon的源码。</p>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> AngularJS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解异步</title>
      <link href="/2016/12/20/%E7%90%86%E8%A7%A3%E5%BC%82%E6%AD%A5/"/>
      <content type="html"><![CDATA[<p>JavaScript编程几乎总是伴随着异步操作，传统的异步操作会在操作完成之后，使用回调函数传回结果，而回调函数中则包含了后续的工作。这也是造成异步编程困难的主要原因：</p><a id="more"></a><h2>前述</h2><p><strong>我们一直习惯于“线性”地编写代码逻辑，但是大量异步操作所带来的回调函数，会把我们的算法分解地支离破碎。</strong></p><p>此时我们不能用if来实现逻辑分支，也不能用while/for/do来实现循环，更不用说异步操作之间的组合、错误处理以及取消操作了。因此也就诞生了如jQuery Deferred这样的辅助类库。</p><p>我们常见的异步操作：</p><ul><li>定时器setTimeout</li><li>postmessage</li><li>WebWorkor</li><li>CSS3 动画</li><li>XMLHttpRequest</li><li>HTML5的本地数据</li><li>…</li></ul><p>JavaScript要求在与服务器进行交互时要用异步通信，如同AJAX一样。因为是异步模型，所以在调用Transaction游览器提供的本地数据接口时候类似AJAX（这里我是假设），浏览器自己有内部的XHR方法异步处理，但是此时的JS代码还是会同步往下执行，其实就是无阻塞的代码。</p><p>**问题：**因为无阻塞，代码在发送AJAX这个请求后会继续执行，那么后续的操作如果依赖这个数据的就会出错了，所以这里就需要等待AJAX返回，才能执行后续操作。</p><p>因为异步而导致流程不正确，或者说我们的应用在某个程度上依赖第三方API的数据，那么就会面临一个共同的问题：</p><p>我们无法获悉一个API响应的延迟时间，应用程序的其他部分可能会被阻塞，直到它返回结果。Deferreds 的引入对这个问题提供了一个更好的解决方案，它是非阻塞的，并且与代码完全解耦。</p><p>当然异步操作也可以提供一个类似于成功回调，失败回调的通知接口。</p><p>JS是单线程语言，就简单性而言，把每一件事情（包括GUI事件和渲染）都放在一个线程里来处理是一个很好的程序模型，因为这样就无需再考虑线程同步这些复杂问题。</p><p>另一方面，他也暴露了应用开发中的一个严重问题，单线程环境看起来对用户请求响应迅速，但是当线程忙于处理其它事情时，就不能对用户的鼠标点击和键盘操作做出响应。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定时器改变流程</span></span><br><span class="line">show(<span class="number">1</span>)</span><br><span class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    show(<span class="number">2</span>)&#125;, <span class="number">0</span>)</span><br><span class="line">show(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//执行异步动画</span></span><br><span class="line"><span class="comment">//因为代码的执行是按照从上至下</span></span><br><span class="line"><span class="comment">//但是由于加入了动画，动画形成了异步，所以实际的改变值必须等动画完成才能得到</span></span><br><span class="line"><span class="comment">//但是同步逻辑3其实已经运行，所以3要等待2结束才可以</span></span><br><span class="line">$(<span class="string">"#go"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">var</span> block = $(<span class="string">"#block"</span>);</span><br><span class="line">show(<span class="string">'1.动画流程代码开始,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">block.animate(&#123;</span><br><span class="line">width       : <span class="string">"70%"</span>,</span><br><span class="line">opacity     : <span class="number">0.4</span>,</span><br><span class="line">marginLeft  : <span class="string">"0.6in"</span>,</span><br><span class="line">fontSize    : <span class="string">"3em"</span>,</span><br><span class="line">borderWidth : <span class="string">"10px"</span>,</span><br><span class="line">&#125;, <span class="number">1000</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">show(<span class="string">'2.动画执行结束束,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">&#125;);</span><br><span class="line">show(<span class="string">'3.动画流程代码结束,对象长度'</span>+ block.css(<span class="string">'width'</span>))</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">$(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>Deferred</h2><h3>Deferred是什么</h3><p>前端项目的开发，不仅仅涉及到同步的概念，而且还会经常穿插各种异步的处理。一些大的操作，比如远程获取数据，操作一个大数据处理，这时候是不能马上获取到数据的。假设我们发送一个AJAX请求到接受到数据需要10秒钟，那么从发送到接受数据这个时间段中，前端的处理时间其实是空闲，但是对于开发者来说这种时间是不能浪费了，所以我们可以在10秒钟做很多同步的处理，同时等待异步的数据返回。所以我们需要监听这个回调的数据在成功的时候能够获取到，或者设计一个返回后触发处理的机制，当然原生的JavaScript对这个机制几乎是没有的。为了优化这个形成统一的异步处理方案，jQuery就开始设计了一个Deferred异步模型。</p><p>Deferred 提供了一个抽象的非阻塞的解决方案（如异步请求的响应），它创建一个promise对象，其目的是在未来某个时间点返回一个响应。简单来说就是一个异步/同步回调函数的处理方案。</p><p><code>$.Deferred</code>在jQuery代码内部有四个模块被使用，分别是“<strong>promise方法”、“DOM ready”、“Ajax模块”及“动画模块</strong>”。</p><p>看看jQuery中的最常用的AJAX处理：</p><p><strong>一：Ajax的改造</strong></p><p>传统的jQuery的AJAX操作的传统写法(1.5版之前)：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"aaron.html"</span>,</span><br><span class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">     alert(<span class="string">"成功！"</span>);</span><br><span class="line">  &#125;,</span><br><span class="line">  error:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="string">"失败！"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>$.ajax()接受一个对象参数，这个对象包含两个方法：success方法指定操作成功后的回调函数，error方法指定操作失败后的回调函数。</p><p>在1.5版本后通过新的Deferred引入就改成了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(<span class="string">"aaron.html"</span>)</span><br><span class="line">.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"成功"</span>); &#125;)</span><br><span class="line">.fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; alert(<span class="string">"出错"</span>); &#125;);</span><br></pre></td></tr></table></figure><p>把传参的回调，换成了链式的写法，这样可读性更高了。在jquery 1.5版后，通过$.ajax返回的不是XHR对象了，而是经过包装的Deferred对象，所以就具有promise的一些规范。当然这种写法到底是怎么做的，我们在后续的教程中会详细的讲解到。</p><p><strong>二：提供一种方法来执行一个或多个对象的回调函数</strong></p><p>在实际开发中，我们可能要发送多个异步的请求操作，我们需要等所有的异步都处理完毕后，才能继续下一个动作。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aaron1"</span>&gt;</span>运行案例一<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"aaron2"</span>&gt;</span>运行案例二<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//提供一种方法来执行一个或多个对象的回调函数</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//在实际开发中，我们可能要发送多个异步的请求操作，我们需要等所有的异步都处理完毕后，才能继续下一个动作</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//案例一</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task1</span>(<span class="params">name, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    fn(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 500)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task2</span>(<span class="params">name, fn</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="undefined">    fn(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 1000)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="comment">//任务数</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">var</span> taskNuns = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> num = <span class="number">2</span>; <span class="comment">//2个任务</span></span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">if</span> (num === <span class="number">1</span>) &#123;</span></span><br><span class="line"><span class="javascript">      show(<span class="string">'任务都完成了'</span>,$(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    num--;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined">&#125;()</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#aaron1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="comment">//常规处理</span></span></span><br><span class="line"><span class="javascript">  task1(<span class="string">'任务一'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task1'</span>, $(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    taskNuns()</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">  task2(<span class="string">'任务二'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task2'</span>, $(<span class="string">"#aaron1"</span>))</span></span><br><span class="line"><span class="undefined">    taskNuns();</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="javascript"><span class="comment">//========================分割线============================================</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//案例二</span></span></span><br><span class="line"><span class="javascript"><span class="comment">//通过Deferred改进</span></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task3</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred();</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task3执行完毕'</span>,$(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">    dtd.resolve(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 500)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> dtd;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">task4</span>(<span class="params">name</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  <span class="keyword">var</span> dtd = $.Deferred();</span></span><br><span class="line"><span class="javascript">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'task4执行完毕'</span>,$(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">    dtd.resolve(name)</span></span><br><span class="line"><span class="undefined">  &#125;, 1000)</span></span><br><span class="line"><span class="javascript">  <span class="keyword">return</span> dtd;</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript">$(<span class="string">"#aaron2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  $.when(task3(<span class="string">'task1'</span>), task4(<span class="string">'task2'</span>)).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    show(<span class="string">'when处理成功'</span>, $(<span class="string">"#aaron2"</span>))</span></span><br><span class="line"><span class="undefined">  &#125;)</span></span><br><span class="line"><span class="undefined">&#125;)</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="javascript"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data, ele</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">  (ele || $(<span class="string">"body"</span>)).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>所以我们这里要涉及一个等待的处理。我们自己要做一个计时器，每一个任务执行完毕后，都要触发一次任务的检测。当最后一个调用完毕了，我们就可以执行后面的动作，当前这里的写法也会有些问题，比如错误的时候没有处理。同样的功能，我们换成Deferred就会很简单了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when($.ajax(&quot;a1.html&quot;), $.ajax(&quot;a2.html&quot;))</span><br><span class="line">　　.done(function()&#123; alert(&apos;2次回调都正确返回了&apos;) &#125;)</span><br><span class="line">　　.fail(function()&#123; alert(&apos;出错了&apos;); &#125;);</span><br></pre></td></tr></table></figure><p>这段代码的意思是：先执行两个操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&quot;a1.html&quot;)</span><br><span class="line">$.ajax(&quot;a2.html&quot;)</span><br></pre></td></tr></table></figure><p>如果都成功了，就运行done()指定的回调函数；如果有一个失败或都失败了，就执行fail()指定的回调函数。</p><p><strong>三：可以混入任意的对象接口中</strong></p><p>jQuery的Deferred最好用的地方，就是模块化程度非常高，可以任意配合使用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function task(name) &#123;</span><br><span class="line">  var dtd = $.Deferred();</span><br><span class="line">  setTimeout(function() &#123;</span><br><span class="line">    dtd.resolve(name)</span><br><span class="line">  &#125;, 1000)</span><br><span class="line">  return dtd;</span><br><span class="line">&#125;</span><br><span class="line">$.when(task(&apos;任务一&apos;), task(&apos;任务二&apos;)).done(function() &#123;</span><br><span class="line">  alert(&apos;成功&apos;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>把需要处理的异步操作，用Deferred对象给包装一下，然后通过when方法收集异步的操作，最后再返回出done的成功，这样的处理太赞了！</p><p>所以说，Deferred的引入，为处理事件回调提供了更加强大并且更灵活的编程模型。</p><h3>认识$.Deferred的接口</h3><p>大多情况下，promise作为一个模型，提供了一个在软件工程中描述延时（或将来）概念的解决方案。它背后的思想我们已经介绍过：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">不是执行一个方法，然后阻塞应用程序等待结果返回，而是返回一个promise对象来满足未来值。</span><br></pre></td></tr></table></figure><p>这样看来，Promise/A只是一种规范，Deferred可以看作这种规范的具体实现，旨在提供通用的接口，用来简化异步编程难度，说白了就是:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">一个可链式操作的对象，提供多个回调函数的注册，以及回调列队的回调，并转达任何异步操作成功或失败的消息。</span><br></pre></td></tr></table></figure><p>jQuery.Deferred()背后的设计理念来自 <a href="http://wiki.commonjs.org/wiki/Promises/A" target="_blank" rel="noopener">CommonJS Promises/A</a> , <code>jQuery.Deferred()</code>基于这个理念实现，但并没有完全遵循其设计， 它代表了一种可能会长时间运行而且不一定必须完整的操作的结果，简单的描述下规范中定义的“Promise”。</p><p>promise模式在任何时刻都处于以下三种状态之一：</p><ul><li>未完成（unfulfilled）</li><li>已完成（resolved）</li><li>拒绝（rejected）</li></ul><p>CommonJS Promise/A 标准这样定义的，promise对象上的then方法负责添加针对已完成和拒绝状态下的处理函数。then方法会返回另一个promise对象，这样可以形成“管道”风格。</p><p>看看jQuery的Deferred源码中对动作接口的定义：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[ <span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span> ],</span><br><span class="line">[ <span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span> ],</span><br><span class="line">[ <span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>) ]</span><br></pre></td></tr></table></figure><p>Deferred中定义的动作是非常多的，抽象的看其实可以类似一种观察者模式的实现。</p><p>观察者模式中的订阅方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Done (操作完成)</span><br><span class="line">Fail (操作失败)</span><br><span class="line">Progress (操作进行中</span><br></pre></td></tr></table></figure><p>观察中模式中的发布方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolve（解决）</span><br><span class="line">reject（拒绝）</span><br><span class="line">notify（通知）</span><br></pre></td></tr></table></figure><p>而且还提供了可以定义运行时的this对象的fire，fireWith，所以扩展了3个可以定义上下文的的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">resolveWith</span><br><span class="line">rejectWith</span><br><span class="line">notifyWith</span><br></pre></td></tr></table></figure><p>所以按照这样的规范，我们的使用就应该是这样：见代码。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="aaron1"&gt;例一:基本用法&lt;/</span>button&gt;</span><br><span class="line">&lt;button id=<span class="string">"aaron2"</span>&gt;例二:过滤器&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="aaron3"&gt;例三:promise方法&lt;/</span>button&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">//例一</span></span><br><span class="line">$(<span class="string">"#aaron1"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 构建一个deferred对象</span></span><br><span class="line">  <span class="keyword">var</span> dtd = $.Deferred();</span><br><span class="line">  <span class="comment">// 给deferred注册一个成功后的回调通知</span></span><br><span class="line">  dtd.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    show(<span class="string">'成功'</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// 开始执行一段代码</span></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    dtd.resolve(); <span class="comment">// 改变deferred对象的执行状态</span></span><br><span class="line">  &#125;, <span class="number">2000</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例二：过滤器</span></span><br><span class="line"><span class="keyword">var</span> filterResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defer = $.Deferred(),</span><br><span class="line">    filtered = defer.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">    &#125;);</span><br><span class="line">  defer.resolve(<span class="number">5</span>);</span><br><span class="line">  filtered.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    show(<span class="string">"Value is ( 2*5 = ) 10: "</span> + value);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="string">"#aaron2"</span>).on(<span class="string">"click"</span>, filterResolve)</span><br><span class="line"></span><br><span class="line"><span class="comment">//例三：实现promise方法</span></span><br><span class="line">$(<span class="string">"#aaron3"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> obj = &#123;</span><br><span class="line">    hello: <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">      show(<span class="string">"你好 "</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">    defer = $.Deferred();</span><br><span class="line">  <span class="comment">// 设置一个promise</span></span><br><span class="line">  defer.promise(obj);</span><br><span class="line">  <span class="comment">//解决一个deferred</span></span><br><span class="line">  defer.resolve(<span class="string">"慕课网"</span>);</span><br><span class="line">  obj.done(<span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    obj.hello(name);</span><br><span class="line">  &#125;).hello(<span class="string">"Aaron"</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  $(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span><br><span class="line">&#125;</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h3>$.Deferred的设计</h3><p>由于1.7版本后<code>$.Callbacks从Deferred</code>中抽离出去了，目前版本的Deferred.js代码不过150行，而真正$.Deferred的实现只有100行左右，实现的逻辑是相当犀利的。</p><p>因为Callback被剥离出去后，整个Deferred就显得非常的精简，代码直接通过extend扩展到静态接口上，对于extend的继承这个东东，在之前就提及过jQuery如何处理内部jQuery与<code>init</code>相互引用<code>this</code>的问题，所以当<code>jQuery.extend</code>只有一个参数的时候，其实就是对jQuery静态方法的一个扩展。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">   Deferred:function(func)&#123;</span><br><span class="line">        ...省略代码....</span><br><span class="line">        return deferred</span><br><span class="line">   &#125;,</span><br><span class="line">   when:function(func)&#123;</span><br><span class="line">      ...省略代码....</span><br><span class="line">      return deferred.promise();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>我们来具体看看2个静态方法内部都干了些什么?</p><p>Deferred整体结构：右边代码所示。</p><p>Deferred就是一个简单的工厂方法，有两种方式使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = $.Deferred（）</span><br><span class="line">$.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;)</span><br></pre></td></tr></table></figure><p>内部其实是严重依赖$.Callbacks对象，Callbacks就是用来储存deferred依赖的数据的。</p><p>因为done、fail、progress就是jQuery.Callbacks(“once memory”)所有对应的处理：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> list = jQuery.Callbacks(<span class="string">"once memory"</span>)</span><br><span class="line">promise[<span class="string">'done'</span>] = list.add;</span><br></pre></td></tr></table></figure><p>deferred定义了一系列的接口，堪称一绝，100多行的代码，精练的有些过分。</p><p>Deferred方法内部建议了2个对象，一个是deferred外部接口对象，一个是内部promise对象。</p><p>promise对象解释是一个受限的对象, 这就是所谓的受限制的deferred对象，因为相比之前， 返回的deferred不再拥有resolve(With), reject(With), notify(With)这些能改变deferred对象状态并且执行callbacklist的方法了,只能是then、done、fali等方法。</p><p>其内部通过tuples数组，存储了所有的接口API，通过遍历把所有的接口一次都挂到内部promise与deferred对象上。</p><p>其中定义了done、fail以及progress这几个方法，其实就是Callbacks回调函数中的add方法，用与push外部的的数据，保存在队列上。</p><p>我们通过resolve、reject以及notify其实也就是处理Callbacks中的队列列表。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset=<span class="string">"utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string">// jQuery. Deferred主要处理：</span></span><br><span class="line"><span class="string">//     显而易见Deferred是个工厂类，返回的是内部构建的deferred对象</span></span><br><span class="line"><span class="string">//     tuples 创建三个$.Callbacks对象，分别表示成功，失败，处理中三种状态</span></span><br><span class="line"><span class="string">//     创建了一个promise对象，具有state、always、then、primise方法</span></span><br><span class="line"><span class="string">//     扩展primise对象生成最终的Deferred对象，返回该对象</span></span><br><span class="line"><span class="string">//     primise对象就是一个受限对象，只读</span></span><br><span class="line"><span class="string">var Deferred = function(func) &#123;</span></span><br><span class="line"><span class="string">  var tuples = [</span></span><br><span class="line"><span class="string">    //1 动作</span></span><br><span class="line"><span class="string">    //2 侦听器</span></span><br><span class="line"><span class="string">    //3 最终状态</span></span><br><span class="line"><span class="string">    //后面的操作将是围绕这些接口处理</span></span><br><span class="line"><span class="string">    ["</span>resolve<span class="string">", "</span>done<span class="string">", jQuery.Callbacks("</span>once memory<span class="string">"), "</span>resolved<span class="string">"],</span></span><br><span class="line"><span class="string">    ["</span>reject<span class="string">", "</span>fail<span class="string">", jQuery.Callbacks("</span>once memory<span class="string">"), "</span>rejected<span class="string">"],</span></span><br><span class="line"><span class="string">    ["</span>notify<span class="string">", "</span>progress<span class="string">", jQuery.Callbacks("</span>memory<span class="string">")]</span></span><br><span class="line"><span class="string">  ],</span></span><br><span class="line"><span class="string">  state = "</span>pending<span class="string">",</span></span><br><span class="line"><span class="string">  //扩展的primise对象</span></span><br><span class="line"><span class="string">  promise = &#123;</span></span><br><span class="line"><span class="string">    state: function() &#123;&#125;,</span></span><br><span class="line"><span class="string">    always: function() &#123;&#125;,</span></span><br><span class="line"><span class="string">    then: function( /* fnDone, fnFail, fnProgress */ ) &#123;&#125;,</span></span><br><span class="line"><span class="string">    promise: function(obj) &#123;&#125;</span></span><br><span class="line"><span class="string">  &#125;,</span></span><br><span class="line"><span class="string">  deferred = &#123;&#125;;</span></span><br><span class="line"><span class="string">  //定义管道风格的接口pipe</span></span><br><span class="line"><span class="string">  promise.pipe = promise.then;</span></span><br><span class="line"><span class="string">  //逐个添加所有的接口到deferred对象上</span></span><br><span class="line"><span class="string">  jQuery.each(tuples, function(i, tuple) &#123;</span></span><br><span class="line"><span class="string">    deferred[tuple[0]] = function() &#123;</span></span><br><span class="line"><span class="string">      deferred[tuple[0] + "</span>With<span class="string">"](this === deferred ? promise : this, arguments);</span></span><br><span class="line"><span class="string">      return this;</span></span><br><span class="line"><span class="string">    &#125;;</span></span><br><span class="line"><span class="string">    deferred[tuple[0] + "</span>With<span class="string">"] = list.fireWith;</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">  //转成成promise对象</span></span><br><span class="line"><span class="string">  promise.promise(deferred);</span></span><br><span class="line"><span class="string">  //如果传递的参数是函数，直接运行</span></span><br><span class="line"><span class="string">  if (func) &#123;</span></span><br><span class="line"><span class="string">    func.call(deferred, deferred);</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return deferred;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">//when就是一个合集的处理</span></span><br><span class="line"><span class="string">//可以收集多个异步操作，合并成功后处理</span></span><br><span class="line"><span class="string">//同时也可以绑定Promise 对象的其它方法，如 defered.then</span></span><br><span class="line"><span class="string">//所以when内部必须要创建一个deferred对象</span></span><br><span class="line"><span class="string">var when = function(subordinate /* , ..., subordinateN */ ) &#123;</span></span><br><span class="line"><span class="string">  var i = 0,</span></span><br><span class="line"><span class="string">    resolveValues = slice.call(arguments),</span></span><br><span class="line"><span class="string">    length = resolveValues.length,</span></span><br><span class="line"><span class="string">    deferred = remaining === 1 ? subordinate : jQuery.Deferred(),</span></span><br><span class="line"><span class="string">    updateFunc = function(i, contexts, values) &#123;</span></span><br><span class="line"><span class="string">      return function(value) &#123;&#125;;</span></span><br><span class="line"><span class="string">    &#125;,</span></span><br><span class="line"><span class="string">    progressValues, progressContexts, resolveContexts;</span></span><br><span class="line"><span class="string">  if (length &gt; 1) &#123;</span></span><br><span class="line"><span class="string">    progressValues = new Array(length);</span></span><br><span class="line"><span class="string">    progressContexts = new Array(length);</span></span><br><span class="line"><span class="string">    resolveContexts = new Array(length);</span></span><br><span class="line"><span class="string">    for (; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="string">      if (resolveValues[i] &amp;&amp; jQuery.isFunction(resolveValues[i].promise)) &#123;</span></span><br><span class="line"><span class="string">        resolveValues[i].promise()</span></span><br><span class="line"><span class="string">          .done(updateFunc(i, resolveContexts, resolveValues))</span></span><br><span class="line"><span class="string">          .fail(deferred.reject)</span></span><br><span class="line"><span class="string">          .progress(updateFunc(i, progressContexts, progressValues));</span></span><br><span class="line"><span class="string">      &#125; else &#123;</span></span><br><span class="line"><span class="string">        --remaining;</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  return deferred.promise();</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">&lt;/script&gt;</span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure><h2>Deferred的执行流程</h2><p>用下面的例子分析（见右侧代码编辑器）：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> defer = $.Deferred();</span><br><span class="line">defer.resolve(<span class="number">5</span>);</span><br><span class="line">defer.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;)</span><br><span class="line"><span class="keyword">var</span> filtered = defer.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">&#125;);</span><br><span class="line">filtered.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;&#125;);</span><br></pre></td></tr></table></figure><p>这里有几个关键的问题：</p><p>1、defer延时对象通过resolved触发done成功回调，调用在添加done之前，那么靠什么延时处理？</p><p>2、为什么defer.then对象返回的给filtered.done的数据可以类似管道风格的顺序叠加给后面的done处理？</p><p>一般来说，javascript要实现异步的收集，就需要“等待”，比如defer.resolve(5)虽然触发了，但是done的处理还没添加，我们必须要等待done、then等方法先添加了后才能执行了resolve，那么常规的的用法就是在resolve内部用setTimeout 0，image.onerror行成一个异步的等待操作处理。</p><p>但是jQuery很巧妙的绕过了这个收集方式，</p><p>defer.resolve(5)方法实际就是触发了callback回到函数的fireWith方法，这样可以接受一个上下文deferred与参数5</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred[tuple[0] + &quot;With&quot;](this === deferred ? promise : this, arguments);</span><br></pre></td></tr></table></figure><p>之前 done | fail | progress方法都是通过jQuery.Callbacks(“once memory”) 或 jQuery.Callbacks(“memory”)生成的。</p><p>实际上在Callback源码fire方法有一句 memory = options.memory &amp;&amp; data;这样就很巧妙的缓存当前参数5的值，提供给下一个使用，这个就是then，pipe链式数据的一个基础了，此刻的操作，我们把memory保存了这个数据的值。</p><p>重点来了，下一个defer.done的操作也是走的add的处理，把done的回调函数加入到list队列中的之后，接着就会触发。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">// With memory, if we're not firing then</span></span><br><span class="line"> <span class="comment">// we should call right away</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (memory) &#123;</span><br><span class="line">  firingStart = start;</span><br><span class="line">  fire(memory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为memory在上一个resolve操作的时候，缓存了5了，所以memory的判断显示是为真的，所以立刻就触发了fire(memory)的代码了，所以就算触发的循序与添加的循序不一致，也不会导致错误。 而且jquery很巧妙的避免了异步收集的问题，这样处理更可靠了。可见回调函数模块就是为Deferred模块量身定做的了。</p><p>第二个问题，是关于then，pipe管道风格的处理，这样也是一个很复杂的设计，在后面一章就提到了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> filterResolve = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> defer = $.Deferred();</span><br><span class="line">  <span class="comment">//先执行成功</span></span><br><span class="line">  defer.resolve(<span class="number">5</span>);</span><br><span class="line">  <span class="comment">//后添加</span></span><br><span class="line">  defer.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">"&lt;li&gt;defer.done的值是："</span> + value + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">//实现一个管道方法</span></span><br><span class="line">  <span class="keyword">var</span> filtered = defer.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">//接受上一个值，叠加处理</span></span><br><span class="line">  filtered.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'body'</span>).append(<span class="string">"&lt;li&gt;filtered.done ( 2*5 = ) 10: "</span> + <span class="string">"&lt;/li&gt;"</span>);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br><span class="line">$(<span class="string">"button"</span>).on(<span class="string">"click"</span>, filterResolve);</span><br></pre></td></tr></table></figure><h2>Deferred源码剖析(上)</h2><p>Deferred对接口的设计别出心裁，不是常规的直接定义的，我们可以看tuples这个数组的定义。</p><p><strong>Deferred</strong><strong>自身则围绕这三组数据进行更高层次的抽象</strong></p><ul><li>触发回调函数列表执行(函数名)</li><li>添加回调函数（函数名）</li><li>回调函数列表（jQuery.Callbacks对象）</li><li>Deferred最终状态（第三组数据除外）</li></ul><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tuples = [</span><br><span class="line">  <span class="comment">// action, add listener, listener list, final state</span></span><br><span class="line">  [<span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span>],</span><br><span class="line">  [<span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span>],</span><br><span class="line">  [<span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>)]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里抽象出2组阵营：</p><p><strong>1组：回调方法/事件订阅</strong></p><p><code>done、fail、progress</code></p><p><strong>2组：通知方法/事件发布</strong><code>resolve、reject、notify、resolveWith、rejectWith、notifyWith</code></p><p>Tuples元素集，其实是把相同有共同特性的代码的给合并成一种结构，然后来一次处理。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//代码请看右边代码区域</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>对于Tuples的3条数据集是分2部分处理的：</p><p><strong>第一部分将回调函数存入</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">promise[ tuple[<span class="number">1</span>] ] = list.add;</span><br></pre></td></tr></table></figure><p>其实就是给promise赋予3个回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.done = $.Callbacks(<span class="string">"once memory"</span>).add</span><br><span class="line">promise.fail = $.Callbacks(<span class="string">"once memory"</span>).add</span><br><span class="line">promise.progressl = $.Callbacks(<span class="string">"memory"</span>).add</span><br></pre></td></tr></table></figure><p>如果存在Deferred最终状态，默认会预先向doneList，failList中的list添加三个回调函数。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (stateString) &#123;</span><br><span class="line">  list.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    state = stateString;</span><br><span class="line">  &#125;, tuples[i ^ <span class="number">1</span>][<span class="number">2</span>].disable, tuples[<span class="number">2</span>][<span class="number">2</span>].lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里有个小技巧：</p><p><a href="https://developer.mozilla.org/zh-CN/docs/JavaScript/Reference/Operators/Bitwise_Operators" target="_blank" rel="noopener">按位异或运算符</a></p><p>所以实际上第二个传参数是1、0索引对调了，所以取值是failList.disable与doneList.disable。</p><p><strong>通过stateString有值这个条件，预先向doneList,failList中的list添加三个回调函数，分别是:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">doneList : [changeState, failList.disable, processList.lock]</span><br><span class="line">failList : [changeState, doneList.disable, processList.lock]</span><br></pre></td></tr></table></figure><p>changeState 改变状态的匿名函数，deferred的状态，分为三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)；不论deferred对象最终是resolve（还是reject），在首先改变对象状态之后，都会disable另一个函数列表failList(或者doneList)；然后lock processList保持其状态，最后执行剩下的之前done（或者fail）进来的回调函数。</p><p>所以第一步最终都是围绕这add方法：</p><ul><li>done/fail/是list.add也就是<a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#add" target="_blank" rel="noopener">callbacks.add</a>，将回调函数存入回调对象中。</li></ul><p><strong>第二部分很简单，给Deferred对象扩充6个方法：</strong></p><ul><li><p>resolve/reject/notify 是 <a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith" target="_blank" rel="noopener">callbacks.fireWith</a>，执行回调函数；</p></li><li><p>resolveWith/rejectWith/notifyWith 是 <a href="http://www.cnblogs.com/snandy/archive/2012/11/15/2770237.html#fireWith" target="_blank" rel="noopener">callbacks.fireWith</a> 队列方法引用。</p></li></ul><p>最后合并promise到Deferred。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">promise.promise( deferred );</span><br><span class="line">jQuery.extend( obj, promise );</span><br></pre></td></tr></table></figure><p>所以最终通过工厂方法Deferred构建的异步对象带的所有的方法了，return内部的deferred对象了。</p><h3>测试Deferred代码</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button&gt;测试Deferred&lt;/</span>button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">      </span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">Deferred</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      <span class="comment">//内部deferred对象</span></span><br><span class="line">      <span class="keyword">var</span> deferred = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//定义的基本接口</span></span><br><span class="line">      <span class="comment">//Callbacks(once memory)的用法，就是只执行一次，并且保持以前的值</span></span><br><span class="line">      <span class="comment">// 每个元组分别包含一些与当前deferred相关的信息: </span></span><br><span class="line">      <span class="comment">// 分别是：触发回调函数列表执行(函数名)，添加回调函数（函数名），回调函数列表（jQuery.Callbacks对象），deferred最终状态（第三组数据除外）</span></span><br><span class="line">      <span class="comment">// 总体而言，三个元组会有对应的三个callbacklist对应于doneList, failList, processList</span></span><br><span class="line">      <span class="keyword">var</span> tuples = [</span><br><span class="line">        [<span class="string">"resolve"</span>, <span class="string">"done"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"resolved"</span>],</span><br><span class="line">        [<span class="string">"reject"</span>, <span class="string">"fail"</span>, jQuery.Callbacks(<span class="string">"once memory"</span>), <span class="string">"rejected"</span>],</span><br><span class="line">        [<span class="string">"notify"</span>, <span class="string">"progress"</span>, jQuery.Callbacks(<span class="string">"memory"</span>)]</span><br><span class="line">      ];</span><br><span class="line"></span><br><span class="line">      <span class="comment">//deferred的状态，三种：pending(初始状态), resolved(解决状态), rejected(拒绝状态)</span></span><br><span class="line">      <span class="comment">//其实就是tuples最后定义的</span></span><br><span class="line">      <span class="keyword">var</span> state = <span class="string">"pending"</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//内部promise对象,作用：</span></span><br><span class="line">      <span class="comment">//1：通过promise.promise( deferred );混入到deferred中使用</span></span><br><span class="line">      <span class="comment">//2：可以生成一个受限的deferred对象，</span></span><br><span class="line">      <span class="comment">//   不在拥有resolve(With), reject(With), notify(With)这些能改变deferred对象状态并且执行callbacklist的方法了</span></span><br><span class="line">      <span class="comment">//   换句话只能读，不能改变了</span></span><br><span class="line">      <span class="comment">//扩展</span></span><br><span class="line">      <span class="comment">//  done fail pipe process </span></span><br><span class="line">      <span class="keyword">var</span> promise = &#123;</span><br><span class="line">        state: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        always: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        then: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        promise: <span class="function"><span class="keyword">function</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">          <span class="keyword">return</span> obj != <span class="literal">null</span> ? jQuery.extend(obj, promise) : promise;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//管道接口,API别名</span></span><br><span class="line">      promise.pipe = promise.then;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//遍历tuples</span></span><br><span class="line">      <span class="comment">//把定义的接口混入到deferred中</span></span><br><span class="line">      jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> list = tuple[<span class="number">2</span>],</span><br><span class="line">          stateString = tuple[<span class="number">3</span>];</span><br><span class="line"></span><br><span class="line">          <span class="comment">// 给上面的promise对象添加done，fail，process方法</span></span><br><span class="line">          <span class="comment">// 分别引用三个不同 jQuery.Callbacks("once memory")对象的add方法，在初始化就构建成了对象</span></span><br><span class="line">          <span class="comment">// 向各自的回调函数列表list（各自闭包中）中添加回调函数，互不干扰</span></span><br><span class="line">          <span class="comment">// promise = &#123;</span></span><br><span class="line">          <span class="comment">//    done:</span></span><br><span class="line">          <span class="comment">//    fail:</span></span><br><span class="line">          <span class="comment">//    process</span></span><br><span class="line">          <span class="comment">// &#125;</span></span><br><span class="line">          promise[tuple[<span class="number">1</span>]] = list.add;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stateString) &#123;</span><br><span class="line">          list.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">            state = stateString;</span><br><span class="line">          &#125;, tuples[i ^ <span class="number">1</span>][<span class="number">2</span>].disable, tuples[<span class="number">2</span>][<span class="number">2</span>].lock);</span><br><span class="line">        &#125;</span><br><span class="line">        deferred[tuple[<span class="number">0</span>]] = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">          deferred[tuple[<span class="number">0</span>] + <span class="string">"With"</span>](<span class="keyword">this</span> === deferred ? promise : <span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;;</span><br><span class="line">        deferred[tuple[<span class="number">0</span>] + <span class="string">"With"</span>] = list.fireWith;</span><br><span class="line">      &#125;);</span><br><span class="line">      <span class="comment">//混入方法</span></span><br><span class="line">      promise.promise(deferred);</span><br><span class="line"></span><br><span class="line">      <span class="keyword">return</span> deferred;</span><br><span class="line">    &#125;</span><br><span class="line">  $(<span class="string">"button"</span>).on(<span class="string">"click"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> dtd = Deferred();</span><br><span class="line">    <span class="comment">// 给deferred注册一个成功后的回调通知</span></span><br><span class="line">    dtd.done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       $(<span class="string">'body'</span>).append(<span class="string">'&lt;li&gt;Deferred成功&lt;/li&gt;'</span>)</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="comment">// 开始执行一段代码</span></span><br><span class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      dtd.resolve(); <span class="comment">// 改变deferred对象的执行状态</span></span><br><span class="line">    &#125;, <span class="number">500</span>);</span><br><span class="line">  &#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><h2>Deferred源码剖析(下)</h2><p>在上一节中构建了deferred对象，实现了done/fail/process和resolve/reject/notify等方法，但是最重要的then,pipe管道接口我们还没有实现，我们考虑下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> dfd = $.Deferred()</span><br><span class="line">dfd.then(<span class="function"><span class="keyword">function</span>(<span class="params">preVale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">2</span> * preVale   <span class="comment">//4</span></span><br><span class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">preVale</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span> * preVale   <span class="comment">//12</span></span><br><span class="line">&#125;)</span><br><span class="line">dfd.resolve(<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p>then就是pipe，我们可以想象是一个管道，可以对回调模式使用瀑布模型。如案例所示，下一个回调都能取到上一个回调的值，这样一直可以叠加往后传递。</p><p>不难看出管道的风格就是链式的操作，每一个链上的结果都会反馈后下一个链，那么这个链式是不是传统的返回自身这个对象this呢？</p><p>常规的办法通过数组处理：右侧代码所示。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">aDeferred</span>(<span class="params">）&#123;</span></span></span><br><span class="line"><span class="function"><span class="params">   <span class="regexp">//</span>代码右侧代码</span></span></span><br><span class="line"><span class="function"><span class="params">&#125;</span></span></span><br></pre></td></tr></table></figure><p>这样的结构当然是很简陋的，这里我们最终有一个本质的问题没有解决，jQuery中的then的返回还有可能是另一个新的异步模型对象,如ajax，因此还能实现done，fail,always,then等方法。所以采用简陋的数组的方式保存状态是很肤浅的了。</p><p>这时候jQuery采取了对象保存处理：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们可以把每一次的then操作，当做是创建一个新的deferred对象，那么每一个对象都够保存自己的状态与各自的处理方法。通过一个办法把所有的对象操作都串联起来，这就是then或者pipe管道设计的核心思路了。</span><br></pre></td></tr></table></figure><p>看jQuery的<strong>then</strong>结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">then: <span class="function"><span class="keyword">function</span>(<span class="params"> <span class="regexp">/* fnDone, fnFail, fnProgress */</span> </span>) </span>&#123;</span><br><span class="line">         <span class="keyword">var</span> fns = <span class="built_in">arguments</span>;</span><br><span class="line">         <span class="keyword">return</span> jQuery.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params">newDefer</span>) </span>&#123;</span><br><span class="line">                   jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">                            deferred[tuple[<span class="number">1</span>]](<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">                         <span class="comment">// deferred[ done | fail | progress ]                   </span></span><br><span class="line">                    &#125;);</span><br><span class="line">               &#125;);</span><br><span class="line">         &#125;).promise()</span><br></pre></td></tr></table></figure><p>其实在内部创建了一个新的Deferred对象，不过这里的不同是通过传递一个回调函数，参数是newDefer，其实Deferred内部就是为了改变下上下文this为deferred，然后传递deferred给这个回调函数了，所以newDefer就指向内部的deferred对象了。</p><p>那么对象之间如何关联？</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(tuples, <span class="function"><span class="keyword">function</span>(<span class="params">i, tuple</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//取出参数</span></span><br><span class="line">  <span class="keyword">var</span> fn = jQuery.isFunction(fns[i]) &amp;&amp; fns[i];</span><br><span class="line">  <span class="comment">// deferred[ done | fail | progress ] for forwarding actions to newDefer</span></span><br><span class="line">  <span class="comment">// 添加done fail progress的处理方法</span></span><br><span class="line">  <span class="comment">// 针对延时对象直接做了处理</span></span><br><span class="line">  deferred[tuple[<span class="number">1</span>]](<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> returned = fn &amp;&amp; fn.apply(<span class="keyword">this</span>, <span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (returned &amp;&amp; jQuery.isFunction(returned.promise)) &#123;</span><br><span class="line">      returned.promise()</span><br><span class="line">        .done(newDefer.resolve)</span><br><span class="line">        .fail(newDefer.reject)</span><br><span class="line">        .progress(newDefer.notify);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      newDefer[tuple[<span class="number">0</span>] + <span class="string">"With"</span>](<span class="keyword">this</span> === promise ? newDefer.promise() : <span class="keyword">this</span>, fn ? [returned] : <span class="built_in">arguments</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>把then的方法通过：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deferred.done</span><br><span class="line">deferred.fail</span><br><span class="line">deferred.progress</span><br></pre></td></tr></table></figure><p>加入到上一个对象的各自的执行队列中保存了。这样就实现了不同对象之间的关联调用。</p><p>同样如果then返回的是一个promise对象（ajax）的时候：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (returned &amp;&amp; jQuery.isFunction(returned.promise)) &#123;</span><br><span class="line">  returned.promise()</span><br><span class="line">    .done(newDefer.resolve)</span><br><span class="line">    .fail(newDefer.reject)</span><br><span class="line">    .progress(newDefer.notify);</span><br></pre></td></tr></table></figure><p>也可以直接处理了。</p><h3>模拟的代码测试</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot;&gt;</span><br><span class="line">&lt;script src=&quot;http://code.jquery.com/jquery-latest.js&quot;&gt;&lt;/script&gt;</span><br><span class="line">&lt;title&gt;&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&lt;button&gt;模拟的代码测试&lt;/button&gt;</span><br><span class="line"></span><br><span class="line">&lt;script type=&quot;text/javascript&quot;&gt;</span><br><span class="line">  </span><br><span class="line">  //使用$.Deferred</span><br><span class="line">  var dfd = $.Deferred()</span><br><span class="line">  dfd.then(function(preVale) &#123;</span><br><span class="line">    return 2 * preVale; </span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    return 3 * preVale </span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&apos;&lt;li&gt;使用$.Deferred代码结果:&apos;+ preVale +&apos;&lt;/li&gt;&apos;)</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  dfd.resolve(2)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  //简单模拟</span><br><span class="line">  function aDeferred() &#123;</span><br><span class="line">    var arr = [];</span><br><span class="line">    return &#123;</span><br><span class="line">      then: function(fn) &#123;</span><br><span class="line">        arr.push(fn)</span><br><span class="line">        return this;</span><br><span class="line">      &#125;,</span><br><span class="line">      resolve: function(args) &#123;</span><br><span class="line">        var returned;</span><br><span class="line">        arr.forEach(function(fn, i) &#123;</span><br><span class="line">          var o = returned || args;</span><br><span class="line">          returned = fn(o)</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">$(&quot;button&quot;).on(&quot;click&quot;, function() &#123;</span><br><span class="line">  var d = aDeferred();</span><br><span class="line">  d.then(function(preVale) &#123;</span><br><span class="line">    return 2 * preVale //4</span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    return 3 * preVale //4</span><br><span class="line">  &#125;).then(function(preVale) &#123;</span><br><span class="line">    $(&apos;body&apos;).append(&apos;&lt;li&gt;模拟代码结果:&apos;+ preVale +&apos;&lt;/li&gt;&apos;)</span><br><span class="line">  &#125;);</span><br><span class="line">  d.resolve(2)</span><br><span class="line">&#125;);</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3>when方法的设计</h3><p>when也是一个非常有用的方法，常用于合并多个异步操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when(d1,d2,d3,d4......).done(function(v1, v2,v3...) &#123;</span><br><span class="line">    //等待所有异步加载完毕后执行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>用法很简单，把所有的异步丢到when中，when会处理所有的结果。当然d1,d2,d3都是有规范的，都是通过Deferred产生的。</p><p>如果向 <code>jQuery.when()</code> 传入延迟对象，那么会返回它的 Promise 对象(延迟方法的一个子集)。可以继续绑定 Promise 对象的其它方法，例如， <code>defered.then</code> 。当延迟对象已经被解决（resolved）或被拒绝(rejected）（通常是由创建延迟对象的最初代码执行的），那么就会调用适当的回调函数。例如，由 <code>jQuery.ajax()</code> 返回的 jqXHR 对象是一个延迟对象，可以向下面这样使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$.when($.ajax(<span class="string">"test.aspx"</span>)).then(<span class="function"><span class="keyword">function</span>(<span class="params">data, textStatus, jqXHR</span>) </span>&#123;</span><br><span class="line">  alert(jqXHR.status); <span class="comment">// alerts 200</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>我们通过模拟的代码，可以很简单的分析整个流程：</p><ol><li><p>传递了多个异步对象，然后遍历每个异步对象给每一个对象绑定done、fail、progess方法，无非就是监听每一个异步的状态（成功，失败），如果是完成了自然会激活done方法。</p></li><li><p>updateFunc是监听方法，通过判断异步对象执行的次数来决定是不是已经完成了所有的处理或者是失败处理</p></li><li><p>因为<code>when也要形成异步操作，</code>比如when().done()，<code>所以内部必须新建一个</code>jQuery.Deferred()对象，用来给后面链式调用。</p></li><li><p>此刻监听所有异步对象(d1,d2…)的updateFunc的处理都完毕了，会给一个正确的通知给when后面的done方法，因为done是通过第三步jQuery.Deferred()创建的，所以此时就需要发送消息到这个上面，即：</p></li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">deferred.resolveWith(contexts, values);</span><br></pre></td></tr></table></figure><ol start="5"><li>内部的jQuery.Deferred()因为外部绑定了when().done(),所以done自然就收到了updateFunc给的消息了，可以继续之后的操作了。</li></ol><p>所以整个执行流程就是这样简单，我们通过右边最简单的模拟出这个效果。</p><p>整个when的设计其实最终还是依赖了jQuery.Deferred内部处理的机制，一层套一层。当然jQuery的异步设计逻辑也确实很复杂，需要思维跳转很活跃，某一个时间在这里，下一个片段又要另一个地方去了，不是按照同步代码这样执行的。需要大家有一定的空间跳跃力了。</p><h3>when代码测试</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://code.jquery.com/jquery-latest.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"http://img.mukewang.com/down/541f6ff70001a0a500000000.js"</span> type=<span class="string">"text/javascript"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;title&gt;<span class="xml"><span class="tag">&lt;/<span class="name">title</span>&gt;</span></span></span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button&gt;$.when代码测试&lt;/</span>button&gt;</span><br><span class="line">&lt;button&gt;when模拟的代码测试&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;script type="text/</span>javascript<span class="string">"&gt;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$('button').eq(0).click(function() &#123;</span></span><br><span class="line"><span class="string">  var d1 = new $.Deferred();</span></span><br><span class="line"><span class="string">  var d2 = new $.Deferred();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function()&#123;</span></span><br><span class="line"><span class="string">    d1.resolve("</span>$.when代码测试Fish<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;,500)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function()&#123;</span></span><br><span class="line"><span class="string">    d2.resolve("</span>$.when代码测试Pizza<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;,1000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">$.when(d1, d2).done(function(v1, v2) &#123;</span></span><br><span class="line"><span class="string">  show(v1); // "</span>Fish<span class="string">"</span></span><br><span class="line"><span class="string">  show(v2); // "</span>Pizza<span class="string">"</span></span><br><span class="line"><span class="string">&#125;);  </span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">ul</span></span><br><span class="line"><span class="string">$('button').eq(1).click(function() &#123;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  var d1 = new $.Deferred();</span></span><br><span class="line"><span class="string">  var d2 = new $.Deferred();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function() &#123;</span></span><br><span class="line"><span class="string">    d1.resolve("</span>when模拟:Fish<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;, 500)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  setTimeout(function() &#123;</span></span><br><span class="line"><span class="string">    d2.resolve("</span>when模拟:Pizza<span class="string">");</span></span><br><span class="line"><span class="string">  &#125;, 1000)</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">  function when(d1, d2) &#123;</span></span><br><span class="line"><span class="string">    var i = 0,</span></span><br><span class="line"><span class="string">      resolveValues = [].slice.call(arguments),</span></span><br><span class="line"><span class="string">      length = resolveValues.length;</span></span><br><span class="line"><span class="string">    var len = length;</span></span><br><span class="line"><span class="string">    //收集resolve值</span></span><br><span class="line"><span class="string">    var values = [];</span></span><br><span class="line"><span class="string">    var deferred = jQuery.Deferred();</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">    function updateFunc(value) &#123;</span></span><br><span class="line"><span class="string">      values.push(value);</span></span><br><span class="line"><span class="string">      if (len === 1) &#123;</span></span><br><span class="line"><span class="string">        deferred.resolveWith('contexts', values);</span></span><br><span class="line"><span class="string">      &#125;</span></span><br><span class="line"><span class="string">      len--</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    for (; i &lt; length; i++) &#123;</span></span><br><span class="line"><span class="string">      resolveValues[i].done(updateFunc)</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">    return deferred;</span></span><br><span class="line"><span class="string">  &#125;</span></span><br><span class="line"><span class="string">  when(d1, d2).done(function(v1, v2) &#123;</span></span><br><span class="line"><span class="string">    show(v1); // "</span>Fish<span class="string">"</span></span><br><span class="line"><span class="string">    show(v2); // "</span>Pizza<span class="string">"</span></span><br><span class="line"><span class="string">  &#125;);</span></span><br><span class="line"><span class="string">&#125;)</span></span><br><span class="line"><span class="string">&lt;/script&gt; </span></span><br><span class="line"><span class="string">&lt;/body&gt;</span></span><br><span class="line"><span class="string">&lt;/html&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>理解回调函数</title>
      <link href="/2016/12/10/%E7%90%86%E8%A7%A3%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/"/>
      <content type="html"><![CDATA[<p>主要讲解回调函数在jQuery中的使用技巧与实现原理，概念上的东西看似简单，但是在实际运用中要做到灵活自如却也不是那么容易的事，而且对于部分开发者来说它仍然是一个谜。在阅读本文之后你能深入理解这个“回调函数”。</p><a id="more"></a><p>函数是第一类对象，这是javascript中的一个重要的概念。意味着函数可以像对象一样按照第一类管理被使用，所以在javaScript中的函数：</p><p>**☑ **  能“存储”在变量中</p><p>** ☑**   能作为函数的实参被传递</p><p>**☑ **  能在函数中被创建</p><p>** ☑**   能从函数中返回</p><p><strong>百科里面是这么解释的：</strong></p><p>回调函数就是一个通过函数指针调用的函数。如果你把函数的指针（地址）作为参数传递给另一个函数，当这个指针调用它所指向的函数时，我们就说这是回调函数。回调函数不是由该函数的实现方直接调用，而是在特定的事件或条件发生时由另外的一方调用的，用于对该<strong>事件</strong>或<strong>条件</strong>进行响应。</p><p>因此从上面可以看出来，回调本质上是一种设计原则，并且jQuery的设计原则遵循了这个模式。</p><p>在后端的编程语言中，传统函数以参数形式输入数据，并且使用返回语句返回值。理论上，在函数结尾处有一个return返回语句，结构上就是：一个输入和一个输出。简单的理解函数本质上就<strong>是输入和输出之间实现过程的映射</strong>。</p><p>但是，当函数的实现过程非常漫长，你是选择等待函数完成处理，还是使用回调函数进行异步处理呢？这种情况下，使用回调函数变得至关重要，例如：AJAX请求。若是使用回调函数进行处理，代码就可以继续进行其他任务，而无需空等。实际开发中，经常在javascript中使用异步调用。</p><p><strong>jQuery中遍地都是回调的设计：</strong></p><p><strong>异步回调：</strong></p><p>事件句柄回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(document).ready(callback);</span><br><span class="line">$(document).on(‘click’,callback)</span><br></pre></td></tr></table></figure><p>Ajax异步请求成功失败回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;aaron.html&quot;,</span><br><span class="line">  context: document</span><br><span class="line">&#125;).done(function() &#123; </span><br><span class="line">        //成功执行</span><br><span class="line">&#125;).fail(function() &#123;</span><br><span class="line">        //失败执行</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>动画执行完毕回调</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;#clickme&apos;).click(function() &#123;</span><br><span class="line">    $(&apos;#book&apos;).animate(&#123;</span><br><span class="line">        opacity: 0.25,</span><br><span class="line">        left: &apos;+=50&apos;,</span><br><span class="line">        height: &apos;toggle&apos;</span><br><span class="line">    &#125;, 5000, function() &#123;</span><br><span class="line">        // Animation complete.</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>以上都是jQuery的回调直接运用，运用基本都是将匿名函数作为参数传递给了另一个函数或方法。而且以上都有一个特点，执行的代码都是异步的。</p><p><strong>同步回调：</strong></p><p>当然回调不仅仅只是处理异步，一般同步(很耗时的任务)的场景下也经常用到回调，比如要求执行某些操作后执行回调函数。</p><p>一个同步(阻塞)中使用回调的例子，目的是在test1代码执行完成后执行回调callback</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var test1 = function(callback) &#123;</span><br><span class="line">    //执行长时间操作</span><br><span class="line">    callback();</span><br><span class="line">&#125;</span><br><span class="line">test1(function() &#123;</span><br><span class="line">    //执行回调中的方法</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><strong>所以理解回调函数最重要的2点：</strong></p><p>1、一个回调函数作为参数传递给另一个函数是，我们仅仅传递了函数定义。我们并没有在参数中执行函数。我们并不传递像我们平时执行函数一样带有一对执行小括号()的函数</p><p>2、回调函数并不会马上被执行，它会在包含它的函数内的某个特定时间点被“回调”。</p><h2>回调的灵活运用</h2><p>我们经常会这样使用函数回调：</p><p><strong>☑</strong>  事件触发通知</p><p><strong>☑</strong>  资源加载通知</p><p><strong>☑</strong>  定时器延时</p><p><strong>☑</strong>  ajax、动画通知等等。</p><p>以上都是很单一的事件监听回调的处理方式，但是jQuery把回调函数的用法设计成一个更高的抽像，用于解耦与分离变化。</p><p>如何理解这个设计？我们看下面的例子。</p><p><strong>例子一：</strong></p><p>jQuery针对Dom的处理提供了append、prepend、before、after等方法的处理，这几个方法的特征：</p><p>1、参数的传递可以是HTML字符串、DOM元素、元素数组或者jQuery对象</p><p>2、为了优化性能针对节点的处理需要生成文档碎片</p><p>可见几个方法都是需要实现这2个特性的，那么我们应该如何处理？</p><p><strong>高层接口：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">before: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">after: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.domManip(<span class="built_in">arguments</span>, <span class="function"><span class="keyword">function</span>(<span class="params">elem</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.parentNode) &#123;</span><br><span class="line">            <span class="keyword">this</span>.parentNode.insertBefore(elem, <span class="keyword">this</span>.nextSibling);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p><strong>底层实现：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">domManip: <span class="function"><span class="keyword">function</span>(<span class="params">args, callback</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// Flatten any nested arrays</span></span><br><span class="line">    args = concat.apply([], args);</span><br><span class="line">    <span class="comment">// We can't cloneNode fragments that contain checked, in WebKit</span></span><br><span class="line">    <span class="keyword">if</span> (isFunction ||</span><br><span class="line">        <span class="comment">//多参数处理</span></span><br><span class="line">        self.domManip(args, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l) &#123;</span><br><span class="line">        <span class="comment">//生成文档碎片</span></span><br><span class="line">        fragment = jQuery.buildFragment(args, <span class="keyword">this</span>[<span class="number">0</span>].ownerDocument, <span class="literal">false</span>, <span class="keyword">this</span>);</span><br><span class="line">        callback.call(<span class="keyword">this</span>[i], node, i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们观察下jQuery的实现，通过抽象出一个domManip方法，然后在这个方法中处理共性，合并多个参数的处理与生成文档碎片的处理，然后最终把结果通过回调函数返回给每一个调用者。</p><p><strong>例子二：</strong></p><p>在很多时候需要控制一系列的函数顺序执行。那么一般就需要一个队列函数来处理这个问题。</p><p>我们看一段代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">function Ulson(List, callback) &#123;</span><br><span class="line">    setTimeout(function() &#123;</span><br><span class="line">        var task;</span><br><span class="line">        if (task = List.shift()) &#123;</span><br><span class="line">            task(); //执行函数</span><br><span class="line">        &#125;</span><br><span class="line">        if (List.length &gt; 0) &#123; //递归分解</span><br><span class="line">            arguments.callee(List)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            callback()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 25)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//调用</span><br><span class="line">Ulson([</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;a&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;b&apos;)</span><br><span class="line">    &#125;,</span><br><span class="line">    function() &#123;</span><br><span class="line">        alert(&apos;c&apos;)</span><br><span class="line">    &#125;</span><br><span class="line">], function() &#123;</span><br><span class="line">    alert(&apos;callback&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 分别弹出 ‘a’ , ‘b’ ,&apos;c&apos;,’callback</span><br></pre></td></tr></table></figure><p>传入一组函数参数，靠递归解析，分个执行，其实就是靠setTimeout可以把函数加入到队列末尾才执行的原理，这样的写法就有点就事论事了，聚合对象完全是一个整体，无法再次细分出来，所以我们需要一种方案，用来管理分离每一个独立的对象。</p><p><strong>我们换成jQuery提供的方式:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;a&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.add(function() &#123;</span><br><span class="line">    alert(&apos;b&apos;);</span><br><span class="line">&#125;)</span><br><span class="line">callbacks.fire(); //输出结果: &apos;a&apos; &apos;b&apos;</span><br></pre></td></tr></table></figure><p>是不是便捷很多了，代码又很清晰，所以Callbacks它是一个多用途的回调函数列表对象，提供了一种强大的方法来管理回调函数队列。</p><p>那么我们使用回调函数，总的来说<strong>弱化耦合</strong>，让调用者与被调用者分开，调用者不关心谁是被调用者，所有它需知道的，只是存在一个具有某种特定原型、某些限制条件的被调用函数。</p><h2>理解观察者模式</h2><p>讲解jQuery回调对象之前，我们有必要先理解其背后的设计思想 - “观察者模式”。</p><p>观察者模式 (pub/sub) 的背后，总的想法是在应用程序中增强松耦合性。并非是在其它对象的方法上的单个对象调用。一个对象作为特定任务或是另一对象的活动的观察者，并且在这个任务或活动发生时，通知观察者。观察者也被叫作订阅者（Subscriber），它指向被观察的对象，既被观察者（Publisher 或 subject)。当事件发生时，被观察者（Publisher）就会通知观察者（subscriber）。</p><p><strong>观察者的使用场合</strong></p><p>观察者的使用场合就是：<strong>当一个对象的改变需要同时改变其它对象，并且它不知道具体有多少对象需要改变的时候，就应该考虑使用观察者模式</strong>。先看官网的demo这个例子，涉及到了 add 与 fire方法，熟悉设计模式的童鞋呢，一眼就能看出，其实又是基于发布订阅（Publish/Subscribe）的观察者模式的设计。</p><p>作为 $.Callbacks() 的创建组件的一个演示，只使用回调函数列表，就可以实现 Pub/Sub 系统，将 $.Callbacks 作为一个队列。</p><p><strong>我们来模拟常规下最简单的实现：</strong></p><p>JS里对观察者模式的实现是通过回调来实现的，我们来先定义一个Observable对象，其内部包含了2个方法：订阅add方法与发布fire方法，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      fn();</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用add开始订阅：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(1)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  alert(2)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>使用fire开始发布：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Observable.fire(); // 1, 2</span><br></pre></td></tr></table></figure><p><strong>设计的原理：</strong></p><p>开始构建一个存放回调的数组，如<code>this.callbacks= []</code>添加回调时，将回调push进this.callbacks，执行则遍历this.callbacks执行回调，也弹出1跟2了。当然这只是简洁的设计，便于理解，整体来说设计的思路代码都是挺简单的，那么我们从简单的设计深度挖掘下这种模式的优势。</p><p>注意：如果没有做过复杂交互设计，或者大型应用的开发者，可能一开始无法理解这模式的好处，就简单的设计而言用模式来处理问题，有点把简单的问题复杂化。我们不是为了使用模式而使用的。</p><p><strong>组件开发为了保证组件可以在不同的项目中都适用，其必须是对其常用功能抽象出来加以实现，绝不会包含具体的业务逻辑而某一特定的项目使用者在其业务场景中使用组件时不可避免的要加入不同场景的业务逻辑。</strong></p><h2>模式的实际运用</h2><p>在进行组件开发中，为了保证组件可以在不同的类似项目场景中都能适用，那么就必须是对其常用功能抽象出来加以实现。</p><p>我们来看看具体的实际用处：</p><p>假设一段ajax的请求，成功后通过done返回结果数据：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: <span class="string">"test.html"</span>,</span><br><span class="line">  context: <span class="built_in">document</span>.body</span><br><span class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  <span class="comment">//data数据的处理</span></span><br><span class="line">  $(<span class="string">'aaron1'</span>).html(data.a)</span><br><span class="line">  $(<span class="string">'aaron2'</span>).html(data.b)</span><br><span class="line">  $(<span class="string">'aaron3'</span>).html(data.c)</span><br><span class="line">  <span class="comment">//其余处理</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>咋一看好像都挺好，没什么问题，但是仔细观察我们会发现所有的逻辑是不是都写在done方法里面，这样确实是无可厚非的，但是问题就是逻辑太复杂了。Done里面有数据处理、html渲染、还可能有其它不同场景的业务逻辑。这样如果是换做不同的人去维护代码，增加功能就会显得很混乱而且没有扩展性。那么观察者模式能很好的解决了这个的问题。</p><p>我们优化下代码:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">    pocessData()</span><br><span class="line">    pocessHtml()</span><br><span class="line">    pocessOther()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessData() &#123;</span><br><span class="line">    //处理数据</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessHtml() &#123;</span><br><span class="line">    $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">    $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">    $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  function pocessOther() &#123;</span><br><span class="line">    //处理其他逻辑</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>这种方式的好处是，分离出各种的业务函数，从而降低了代码之间的耦合度，但是这样代码写法几乎就是“就事论事”的处理，达不到<strong>抽象复用</strong>。</p><p>那么我们用之前的观察者模式加工一下上面的代码：（这只是伪代码，用于理解）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessData</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  $(&apos;aaron1&apos;).html(data.a)</span><br><span class="line">  $(&apos;aaron2&apos;).html(data.b)</span><br><span class="line">  $(&apos;aaron3&apos;).html(data.c)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">Observable.add(function() &#123;</span><br><span class="line">  //pocessOther</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$.ajax(&#123;</span><br><span class="line">  url: &quot;test.html&quot;,</span><br><span class="line">  context: document.body</span><br><span class="line">&#125;).done(function(data) &#123;</span><br><span class="line">  Observable.fire(data)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>设计该模式背后的主要动力是促进形成松散耦合。在这种模式中，并不是一个对象调用另一个对象的方法，而是一个对象订阅另一个对象的特定活动并在状态改变后获得通知。订阅者也称为观察者，而被观察的对象称为发布者或主题。当发生了一个重要的事件时，发布者将会通知（调用）所有订阅者并且可能经常以事件对象的形式传递消息。</p><p>总的来说，观察者模式所做的工作就是在解耦，让耦合的双方都依赖于抽象，而不是依赖于具体。从而使得各自的变化都不会影响到另一边的变化。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Observable = &#123;</span><br><span class="line">  callbacks: [],</span><br><span class="line">  add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.callbacks.push(fn);</span><br><span class="line">  &#125;,</span><br><span class="line">  fire: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.callbacks.forEach(</span><br><span class="line">          <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;fn(data);&#125;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajax</span>(<span class="params">arg</span>)</span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    arg.successful(arg.data+ <span class="string">',返回获取到后台的数据'</span>)</span><br><span class="line">  &#125;,<span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用add开始订阅：</span></span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_one: '</span> + data)</span><br><span class="line">&#125;)</span><br><span class="line">Observable.add(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">  show(<span class="string">'Action_two: '</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">//一段ajax请求，成功后处理</span></span><br><span class="line">ajax(&#123;</span><br><span class="line">  data:<span class="string">'Hello'</span>,</span><br><span class="line">  successful:<span class="function"><span class="keyword">function</span>(<span class="params">data</span>)</span>&#123;</span><br><span class="line">    Observable.fire(data); <span class="comment">//触发动作</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2>jQuery回调对象</h2><p>jQuery.Callbacks一般开发者接触的很少，虽然jQuery向开发者提供了外部接口调用，但是$.Callbacks()模块的开发目的是为了给内部$.ajax() 和 $.Deferred()模块提供统一的基本功能组件。它可以用来作为类似基础定义的新组件的功能。</p><p>jQuery.Callbacks是jquery在1.7版本之后加入的，是从1.6版中的_Deferred对象中抽离的，主要用来进行函数队列的add、remove、fire、lock等操作，并提供once、memory、unique、stopOnFalse四个option进行一些特殊的控制。</p><p>这个函数常见的应用场景是事件触发机制，也就是设计模式中的观察者模式的发布、订阅机制，目前Callbacks对象用于queue、ajax、Deferred对象中，本小节主要是一些简单的例子去理解的使用。</p><p>我们看官网提供的demo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以将上述两个方法作为回调函数，并添加到 $.Callbacks 列表中，并按下面的顺序调用它们:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks();</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line"><span class="comment">// outputs: foo!</span></span><br><span class="line">callbacks.fire(<span class="string">"foo!"</span>);</span><br><span class="line">callbacks.add(fn2);</span><br><span class="line"><span class="comment">// outputs: bar!, fn2 says: bar!</span></span><br><span class="line">callbacks.fire(<span class="string">"bar!"</span>)</span><br></pre></td></tr></table></figure><p>这样做的结果是，当构造复杂的回调函数列表时，将会变更很简单。可以根据需要，很方面的就可以向这些回调函数中传入所需的参数。</p><p>上面的例子中，我们使用了 $.Callbacks() 的两个方法: .add() 和 .fire()。 .add() 和 .fire() .add() 支持添加新的回调列表, 而.fire() 提供了一种用于处理在同一列表中的回调方法的途径。</p><p>另一种方法是$.Callbacks 的.remove()方法，用于从回调列表中删除一个特定的回调。下面是.remove()使用的一个例子:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var callbacks = $.Callbacks();</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">// outputs: foo!</span><br><span class="line">callbacks.fire( &quot;foo!&quot; );</span><br><span class="line">callbacks.add( fn2 );</span><br><span class="line">// outputs: bar!, fn2 says: bar!</span><br><span class="line">callbacks.fire( &quot;bar!&quot; );</span><br><span class="line">callbacks.remove( fn2 );</span><br><span class="line">// only outputs foobar, as fn2 has been removed.</span><br><span class="line">callbacks.fire( &quot;foobar&quot; );</span><br></pre></td></tr></table></figure><p>这个运用内部就是观察者模式的一种设计实现，只是相对比较复杂。我们看看jQuery的回调函数到底为哪些模块服务？</p><p>异步队列模块：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Deferred: function(func) &#123;</span><br><span class="line">  var tuples = [</span><br><span class="line">    // action, add listener, listener list, final state</span><br><span class="line">    [&quot;resolve&quot;, &quot;done&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;resolved&quot;],</span><br><span class="line">    [&quot;reject&quot;, &quot;fail&quot;, jQuery.Callbacks(&quot;once memory&quot;), &quot;rejected&quot;],</span><br><span class="line">    [&quot;notify&quot;, &quot;progress&quot;, jQuery.Callbacks(&quot;memory&quot;)]</span><br><span class="line">  ]，………….</span><br></pre></td></tr></table></figure><p>队列模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">_queueHooks: function(elem, type) &#123;</span><br><span class="line">  var key = type + &quot;queueHooks&quot;;</span><br><span class="line">  return data_priv.get(elem, key) || data_priv.access(elem, key, &#123;</span><br><span class="line">    empty: jQuery.Callbacks(&quot;once memory&quot;).add(function() &#123;</span><br><span class="line">      data_priv.remove(elem, [type + &quot;queue&quot;, key]);</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Ajax模块</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ajax: function(url, options) &#123;</span><br><span class="line">  //省略代码</span><br><span class="line">  deferred = jQuery.Deferred(),</span><br><span class="line">  completeDeferred = jQuery.Callbacks(&quot;once memory&quot;)</span><br><span class="line">    ..............</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难发现jQuery.Callbacks还提供“once memory”等参数用来处理：</p><p>☑  once: 确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)。</p><p>☑  memory: 保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p><p>☑  unique: 确保一次只能添加一个回调(所以在列表中没有重复的回调)。</p><p>☑  stopOnFalse: 当一个回调返回false 时中断调用。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> callbacks = $.Callbacks(<span class="string">'once'</span>);</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'a'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.add(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  alert(<span class="string">'b'</span>);</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">callbacks.fire(); <span class="comment">//输出结果: 'a' 'b'</span></span><br><span class="line">callbacks.fire(); <span class="comment">//未执行</span></span><br></pre></td></tr></table></figure><p>once的作用是使callback队列只执行一次。</p><p>最后，我们大概知道这个是干嘛用的了，可以开始上正菜了。</p><h2>jQuery回调模块结构</h2><p>整个$.Callbacks的源码很少，它是一个工厂函数，使用函数调用（非new，它不是一个类）创建对象，它有一个可选参数flags用来设置回调函数的行为，对外的接口也就是self的返回。</p><p>jQuery.Callbacks()的API列表如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">callbacks.add()        ：回调列表中添加一个回调或回调的集合。</span><br><span class="line">callbacks.disable()    ：禁用回调列表中的回调。</span><br><span class="line">callbacks.disabled()   ：确定回调列表是否已被禁用。 </span><br><span class="line">callbacks.empty()      ：从列表中删除所有的回调。</span><br><span class="line">callbacks.fire()       ：用给定的参数调用所有的回调。</span><br><span class="line">callbacks.fired()      ：访问给定的上下文和参数列表中的所有回调。 </span><br><span class="line">callbacks.fireWith()   ：访问给定的上下文和参数列表中的所有回调。</span><br><span class="line">callbacks.has()        ：确定列表中是否提供一个回调。</span><br><span class="line">callbacks.lock()       ：锁定当前状态的回调列表。</span><br><span class="line">callbacks.locked()     ：确定回调列表是否已被锁定。</span><br><span class="line">callbacks.remove()     ：从回调列表中的删除一个回调或回调集合。</span><br></pre></td></tr></table></figure><p>源码结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">jQuery.Callbacks = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    options = <span class="keyword">typeof</span> options === <span class="string">"string"</span> ?</span><br><span class="line">        (optionsCache[options] || createOptions(options)) :</span><br><span class="line">        jQuery.extend(&#123;&#125;, options);</span><br><span class="line">    <span class="comment">//实现代码</span></span><br><span class="line">    fire = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    self = &#123;</span><br><span class="line">        add: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        remove: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        has: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;&#125;,</span><br><span class="line">        empty: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disable: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        disabled: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        lock: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        locked: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fireWith: <span class="function"><span class="keyword">function</span>(<span class="params">context, args</span>) </span>&#123;&#125;,</span><br><span class="line">        fire: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fired: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">return</span> self;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>整个结构要分三部分：</p><p>☑   Options参数缓存</p><p>☑   内部fire触发器的设计</p><p>☑   外部</p><p><strong>参数的缓存设计</strong></p><p>Callbacks是可以是接受的字符串的组合传参数，可以使用空格分割，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var opts = &apos;unique memory&apos;;</span><br><span class="line">var object = &#123;&#125;</span><br><span class="line">jQuery.each(opts.match(/\S+/g) || [], function(_, flag) &#123;</span><br><span class="line">  object[flag] = true;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样的操作其实是不需要重复的，所以我们可以设计一个缓存池，用来储存重复的操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var optionsCache = &#123;&#125;;</span><br><span class="line">function createOptions(options) &#123;</span><br><span class="line">  var object = optionsCache[options] = &#123;&#125;;</span><br><span class="line">  jQuery.each(options.match(rnotwhite) || [], function(_, flag) &#123;</span><br><span class="line">    object[flag] = true;</span><br><span class="line">  &#125;);</span><br><span class="line">  return object;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们传递参数的时候，如果参数是字符串，我们可以直接从optionsCache缓存中去查找：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">options = typeof options === &quot;string&quot; ?</span><br><span class="line">        ( optionsCache[ options ] || createOptions( options ) ) :</span><br><span class="line">        jQuery.extend( &#123;&#125;, options );</span><br></pre></td></tr></table></figure><p><strong>接口的设计：</strong></p><p>通过学习了观察者模式的思路，我们知道callback需要在内部维护着一个list的队列数组，用于保存订阅的对象数据。同时也需要提供了add、remove、fire等订阅、发布、删除类似的接口。</p><p>那么我们代码是不是很简单是就是把订阅对象给push给内部list列表？</p><p>实现思路就是: 构建一个存放回调的数组，如<code>var list = []</code>，通过闭包使这条回调数组保持存在。添加回调时，将回调push进list，执行则遍历list执行回调。</p><p>后面几节我们会通过简单的模拟实现去剖析设计的思路。</p><h2>默认回调对象设计</h2><p>不传入任何参数，调用add的时候将函数add到内部的list中，调用fire的时候顺序触发list中的回调函数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says:&apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks();</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">console.log(&apos;........&apos;)</span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;)</span><br></pre></td></tr></table></figure><p>结果就是按照顺序叠加触发，如下列表：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fn1 says:foo </span><br><span class="line">………………………</span><br><span class="line">fn1 says:bar </span><br><span class="line">fn2 says bar</span><br></pre></td></tr></table></figure><p>这种就是最简单的处理了，可以直接模拟，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks() &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      list.forEach(function(fn) &#123;</span><br><span class="line">        fn(args);</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>once的设计</h2><p>这一小节我们来讲一下once。</p><p>once的作用确保回调列表只执行（.fire()）一次(像一个递延 Deferred)，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val)&#123;</span><br><span class="line">    console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var cbs = $.Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br></pre></td></tr></table></figure><p>结果你会发现cbs.fire(‘foo’)只执行了一次。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo  //只显示一次</span><br></pre></td></tr></table></figure><p>once定义是很明确的，确保这个回调列表只执行（ .fire() ）一次(像一个递延 Deferred)，所以针对这种once的处理可以有多种不同的途径实现。</p><p>1、add的时候抛弃</p><p>2、在fire的时候抛弃多个。</p><p>但是jQuery是在执行第一个fire的时候直接给清空list列表了，然后在add的地方给判断下list是否存在，从而达到这样的处理。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      list.push(fn)</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        list.forEach(function(fn) &#123;</span><br><span class="line">          fn(args);</span><br><span class="line">        &#125;)</span><br><span class="line">        if (options === &apos;once&apos;) &#123;</span><br><span class="line">          list = undefined;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在fire之后，判断参数是否为once，直接把list给清理掉，所以之后的所有fire都被抛弃掉了，而从达到了once的效果。</p><p><strong>jQuery.Callbacks的处理</strong></p><p>在fire中调用了 self.disable(); 方法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 禁用回调列表中的回调。</span><br><span class="line">disable: function() &#123;</span><br><span class="line">    list = stack = memory = undefined;</span><br><span class="line">    return this;</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>memory的设计</h2><p>memory：保持以前的值，将添加到这个列表的后面的最新的值立即执行调用任何回调 (像一个递延 Deferred)。</p><p>回调函数是从异步队列Deferred分离出来的，所以很多的接口设计都是为了契合Deferred接口，memory用的很多，这个缓存的设计这里提及一下</p><p>主要是用来实现deferred的异步收集与pipe管道风格的数据传递的，具体在Deferred有详解，这里大概了解下作用范围。</p><p>memory这个有点不好理解，我们还是通过列子说明下，看下面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">var cbs = Callbacks(&apos;once&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn2(val) &#123;</span><br><span class="line">  console.log(&apos;fn2 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">function fn3(val) &#123;</span><br><span class="line">  console.log(&apos;fn3 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var cbs = $.Callbacks(&apos;memory&apos;);</span><br><span class="line">cbs.add(fn1);</span><br><span class="line">cbs.fire(&apos;foo&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line"></span><br><span class="line">cbs.add(fn2);</span><br><span class="line">cbs.fire(&apos;bar&apos;);</span><br><span class="line"></span><br><span class="line">console.log(&apos;..........&apos;)</span><br><span class="line">cbs.add(fn3);</span><br><span class="line">cbs.fire(&apos;aaron&apos;);</span><br></pre></td></tr></table></figure><p>结果可以看出，我们在执行cbs.add(fn2);的时候，此时除了把fn2添加到了回调队列之外而且还立刻执行了这个方法，唯一的区别就是，参数是用的之前的。所以解释就叫“<strong>保持以前的值</strong>”。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo </span><br><span class="line">.......... </span><br><span class="line">fn2 says foo </span><br><span class="line">fn1 says bar </span><br><span class="line">fn2 says bar </span><br><span class="line">.......... </span><br><span class="line">fn3 says bar </span><br><span class="line">fn1 says aaron </span><br><span class="line">fn2 says aaron </span><br><span class="line">fn3 says aaron</span><br></pre></td></tr></table></figure><p>所以这个<code>memory</code>设计需要解决的问题就是：</p><p>1：如何取到上一个参数</p><p>2：add后如何执行</p><p>看看我们实现的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Callbacks</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> list = [];</span><br><span class="line">  <span class="keyword">var</span> self;</span><br><span class="line">  <span class="keyword">var</span> firingStart;</span><br><span class="line">  <span class="keyword">var</span> memory;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">_fire</span>(<span class="params">data</span>) </span>&#123;</span><br><span class="line">    memory = options === <span class="string">'memory'</span> &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || <span class="number">0</span>;</span><br><span class="line">    firingStart = <span class="number">0</span>;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    <span class="keyword">for</span> (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span>(<span class="params">fn</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> start = list.length;</span><br><span class="line">      list.push(fn)</span><br><span class="line">      <span class="keyword">if</span> (memory) &#123;</span><br><span class="line">        firingStart = start; <span class="comment">//获取最后一值</span></span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">   fire: <span class="function"><span class="keyword">function</span>(<span class="params">args</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先add之后要能触发fire的动作，所以我们把fire作为内部的一个私有方法实现_fire，比较合逻辑，这样外部的fire只是一个门面方法的调用。</p><p>私有变量memory缓存这上一个参数的属性，我们靠firingStart用来定位最后通过add增加的回调数据的索引。在遍历的时候直接通过firingStart的起始索引定位，然后传递memory的参数，而且实现这种“保持以前的值”的设计。</p><h2>unique的设计</h2><p>Unique：确保一次只能添加一个回调(所以在列表中没有重复的回调)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function fn1(val) &#123;</span><br><span class="line">  console.log(&apos;fn1 says &apos; + val);</span><br><span class="line">&#125;</span><br><span class="line">var callbacks = $.Callbacks( &quot;unique&quot; );</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.add( fn1 ); // repeat addition</span><br><span class="line">callbacks.add( fn1 );</span><br><span class="line">callbacks.fire( &quot;foo&quot; );</span><br></pre></td></tr></table></figure><p>结果：过滤了相同的add操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fn1 says foo</span><br></pre></td></tr></table></figure><p>过滤重复的比较简单，因为是数组的保存方式，我们可以在入口处通过indexOf判断即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex = firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      list[firingIndex](data)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2>stopOnFalse</h2><p>stopOnFalse: 当一个回调返回false 时中断调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function fn1(value) &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function fn2(value) &#123;</span><br><span class="line">  fn1(&quot;fn2 says: &quot; + value);</span><br><span class="line">  return false;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var callbacks = $.Callbacks(&quot;stopOnFalse&quot;);</span><br><span class="line">callbacks.add(fn1);</span><br><span class="line">callbacks.fire(&quot;foo&quot;);</span><br><span class="line"></span><br><span class="line">callbacks.add(fn2);</span><br><span class="line">callbacks.fire(&quot;bar&quot;);</span><br></pre></td></tr></table></figure><p>结果虽然fn1被添加到了回调列表，但是因为fn1返回了false，那么意思之后的回调都不会被调用了。如果还有fn3，在f2上返回false，fn3也将不会被调用。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">foo</span><br><span class="line">bar</span><br></pre></td></tr></table></figure><p></p><p>这个设计我们只要控制好函数返回的处理的布尔值，通过这个值用来判断是否需要下一个遍历</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">  break;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>源码可以如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">function Callbacks(options) &#123;</span><br><span class="line">  var list = [];</span><br><span class="line">  var self;</span><br><span class="line">  var firingStart;</span><br><span class="line">  var memory;</span><br><span class="line"></span><br><span class="line">  function _fire(data) &#123;</span><br><span class="line">    memory = options === &apos;memory&apos; &amp;&amp; data;</span><br><span class="line">    firingIndex =</span><br><span class="line">      firingStart || 0;</span><br><span class="line">    firingStart = 0;</span><br><span class="line">    firingLength = list.length;</span><br><span class="line">    for (; list &amp;&amp; firingIndex &lt; firingLength; firingIndex++) &#123;</span><br><span class="line">      if (list[firingIndex](data) === false &amp;&amp; options === &apos;stopOnFalse&apos;) &#123;</span><br><span class="line">        break;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  self = &#123;</span><br><span class="line">    add: function(fn) &#123;</span><br><span class="line">      var start = list.length;</span><br><span class="line">      if (options == &apos;unique&apos;) &#123;</span><br><span class="line">        if (-1 === list.indexOf(fn)) &#123;</span><br><span class="line">          list.push(fn)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        list.push(fn)</span><br><span class="line">      &#125;</span><br><span class="line">      if (memory) &#123;</span><br><span class="line">        firingStart = start; //获取最后一值</span><br><span class="line">        _fire(memory);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    fire: function(args) &#123;</span><br><span class="line">      if (list) &#123;</span><br><span class="line">        _fire(args)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  return self;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是几种单独的处理情况的用法，我们可以看到jQuery都是组合使用的，最常见的就是</p><p>jQuery.Callbacks(“once memory”)的组合了，其实以上的思路都讲解过了，无非就是组合起来的时候要考虑一些判断了。</p>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JQuery源码解读 02-对象构建</title>
      <link href="/2016/10/28/JQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2002-%E5%AF%B9%E8%B1%A1%E6%9E%84%E5%BB%BA/"/>
      <content type="html"><![CDATA[<h2>对象简介</h2><p>面向对象(OOP)的语言都有一个特点，它们都会有类的这一概念，通过类可以抽象出创建具体相同方法与属性的对象。但是ECMAScript中是没有类的概念的，因此它的对象与基于类的语言如java的定义是有所不同的。</p><a id="more"></a><p>在JavaScript世界中函数作为“一等公民”，它不仅拥有一切传统函数的使用方式（声明和调用），而且可以做到像简单值一样赋值、传参、返回，这样的函数也称之为第一级函数。不仅如此，而且还可以通过操作符new来充当类的构造器。</p><p>函数在充当类的构造器时，原型prototype是一个重要的概念。prototype是构造函数的一个属性, 该属性指向一个对象。而这个对象将作为该构造函数所创建的所有实例的基引用(base reference), 可以把对象的基引用想像成一个自动创建的隐藏属性。 当访问对象的一个属性时, 首先查找对象本身, 找到则返回；若不, 则查找基引用指向的对象的属性(如果还找不到实际上还会沿着原型链向上查找,  直至到根)。 只要没有被覆盖的话, 对象原型的属性就能在所有的实例中找到。</p><p>类一：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function ajQuery() &#123;</span><br><span class="line">    this.name = &apos;jQuery&apos;;</span><br><span class="line">    this.sayName = function()&#123;</span><br><span class="line">    return this.name</span><br><span class="line">&#125;</span><br><span class="line">var a = new ajQuery()</span><br><span class="line">var b = new ajQuery()</span><br><span class="line">var c = new ajQuery()</span><br></pre></td></tr></table></figure><p>类二:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function ajQuery() &#123;</span><br><span class="line">    this.name = &apos;jQuery&apos;</span><br><span class="line">&#125;</span><br><span class="line">ajQuery.prototype = &#123;</span><br><span class="line">    sayName: function() &#123;</span><br><span class="line">    return this.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var a = new ajQuery()</span><br><span class="line">var b = new ajQuery()</span><br><span class="line">var c = new ajQuery()</span><br></pre></td></tr></table></figure><p>类一与类二产生的结构几乎是一样的，而本质区别就是：类二new产生的a、b、c三个实例对象共享了原型的sayName方法，这样的好处节省了内存空间，类一则是要为每一个实例复制sayName方法，每个方法属性都占用一定的内存的空间，所以如果把所有属性方法都声明在构造函数中，就会无形的增大很多开销，这些实例化的对象的属性一模一样，都是对this的引用来处理。除此之外类一的所有方法都是拷贝到当前实例对象上。类二则是要通过scope连接到原型链上查找，这样就无形之中要多一层作用域链的查找了。</p><p>jQuery对象的构建如果在性能上考虑，所以就必须采用原型式的结构：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">jQuery = function( selector, context ) &#123;</span><br><span class="line">    return new jQuery.fn.init( selector, context );</span><br><span class="line">&#125;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;</span><br><span class="line">    init：function()&#123;</span><br><span class="line">    return this</span><br><span class="line">&#125;,</span><br><span class="line">    jquery: version,</span><br><span class="line">    constructor: jQuery,</span><br><span class="line">    ………………</span><br><span class="line">&#125;</span><br><span class="line">var a = $() ;</span><br></pre></td></tr></table></figure><p>使用原型结构，性能上是得到了优化，但是ajQuery类这个结构与目标jQuery的结构的还是有很大不一致：</p><p>☑   没有采用new操作符；</p><p>☑   return返回的是一个通过new出来的的对象 。</p><p><a href="https://github.com/JsAaron/jQuery" target="_blank" rel="noopener">所有案例的github下载地址</a></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类一：</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = <span class="string">'jQuery'</span>;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ajQuery()</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line"><span class="comment">// 类二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ajQuery</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'jQuery'</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.prototype = &#123;</span><br><span class="line">    sayName: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> a = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> ajQuery()</span><br><span class="line"><span class="keyword">var</span> c = <span class="keyword">new</span> ajQuery()</span><br><span class="line"></span><br><span class="line"><span class="comment">// jQuery的写法</span></span><br><span class="line"><span class="keyword">var</span> $jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector, context</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> $jQuery.fn.init(selector, context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$jQuery.fn = $jQuery.prototype = &#123;</span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = <span class="string">'aaron'</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">constructor</span>: $jQuery</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">var $a = $jQuery();</span><br><span class="line">show('$jQuery的调用')</span><br><span class="line">show($a);</span><br></pre></td></tr></table></figure><h2>分离构造器</h2><p>通过new操作符构建一个对象，一般经过四步：</p><p><strong>A.创建一个新对象</strong></p><p><strong>B.将构造函数的作用域赋给新对象（所以this就指向了这个新对象）</strong></p><p><strong>C.执行构造函数中的代码</strong></p><p><strong>D.返回这个新对象</strong></p><p>最后一点就说明了，我们只要返回一个新对象即可。其实new操作符主要是把原型链跟实例的this关联起来，这才是最关键的一点，所以我们如果需要原型链就必须要new操作符来进行处理。否则this则变成window对象了。</p><p>我们来剖析下jQuery的这个结构,以下是我们常见的类式写法:</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector; </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span> <span class="comment">//实例化时，返回自身对象,返回后可以调用方法[链式调用]</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">    selectorName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.selector;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">var a = new $$('aaa');  //实例化</span><br><span class="line">a.selectorName() //aaa //得到选择器名字</span><br></pre></td></tr></table></figure><p>首先改造jQuery无new的格式，我们可以通过instanceof判断this是否为当前实例：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!(<span class="keyword">this</span> <span class="keyword">instanceof</span> ajQuery))&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ajQuery(selector);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是注意千万不要像下面这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var $$ = ajQuery = function(selector) &#123;</span><br><span class="line">    this.selector = selector;</span><br><span class="line">    return new ajQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line">Uncaught RangeError: Maximum call stack size exceeded</span><br></pre></td></tr></table></figure><p>这样会无限递归自己，从而造成死循环并且溢出。</p><p>jQuery为了避免出现这种死循环的问题，采取的手段是把原型上的一个init方法作为构造器</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var $$ = ajQuery = function(selector) &#123;</span><br><span class="line">    //把原型上的init作为构造器</span><br><span class="line">    return new ajQuery.fn.init( selector );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">    name: &apos;aaron&apos;,</span><br><span class="line">    init: function() &#123;</span><br><span class="line">        console.log(this)</span><br><span class="line">    &#125;,</span><br><span class="line">    constructor: ajQuery</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样确实解决了循环递归的问题，但是又问题来了，init是ajQuery原型上作为构造器的一个方法，那么其this就不是ajQuery了，所以this就完全引用不到ajQuery的原型了，所以这里通过new把init方法与ajQuery给分离成2个独立的构造器。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//常见写法</span></span><br><span class="line"><span class="keyword">var</span> $$ = ajQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.selector = selector;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">selectorName:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.selector;</span><br><span class="line">&#125;,</span><br><span class="line"><span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">var a = new $$('aaa');  //实例化</span><br><span class="line"></span><br><span class="line">//得到选择器名字</span><br><span class="line">//aaa</span><br><span class="line">$("#test").html( a.selectorName() )</span><br></pre></td></tr></table></figure><h3>Q&amp;A</h3><h4>为什么init作为构造函数可以解决递归循环</h4><h4>return new jQuery.fn.init(selector);为什么不会出现递归循环</h4><p>最佳回答</p><p>去看一下new的过程，new的创建过程分为四步：</p><p>（1）创建一个新对象</p><p>（2）将构造函数的作用域赋值给新的对象</p><p>（3）执行构造函数的代码</p><p>（4）返回新对象</p><p>题目总的代码 return 返回的是一个对象，当然不会产生循环调用</p><h2>静态与实例方法共享设计</h2><p>保留上一节分割出2个构造器的疑问，我们先看看jQuery在接口的设计：</p><p><strong>遍历方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(&quot;.aaron&quot;).each()   //作为实例方法存在</span><br><span class="line">$.each()             //作为静态方法存在</span><br></pre></td></tr></table></figure><p>这是最常见的遍历方法，第一条语句是给有指定的上下文调用的，就是(&quot;.aaron&quot;)获取的DOM合集，第二条语句$.each()函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次都会传递一个数组索引和相应的数组值作为参数。本质上来说2个都是遍历，那么我们是不是要写2个方法呢？</p><p>我们来看看jQuery的源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.prototype = &#123;</span><br><span class="line">    each: function( callback, args ) &#123;</span><br><span class="line">        return jQuery.each( this, callback, args );</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实例方法取于静态方法，换句话来说这是静态与实例方法共享设计，静态方法挂在jQuery构造器上，原型方法挂在哪里呢？</p><p>我们上节不是讲了内部会划分一个新的构造器init吗？jQuery通过new原型prototype上的init方法当作构造器，那么init的原型链方法就是实例的方法了，所以jQuery通过2个构造器划分2种不同的调用方式一种是静态，一种是原型。</p><p>方法是共享的，并且实例方法取于静态方法，2个构造器是完全隔离的 ,这个要如何处理？</p><p><strong>看看jQuery给的方案：</strong></p><p>画龙点睛的一处<code>init.prototype = jQuery.fn</code>，把jQuery.prototype原型的引用赋给jQuery.fn.init.prototype的原型，这样就把2个构造器的原型给关联起来了。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ajQuery.fn = ajQuery.prototype = &#123;</span><br><span class="line">        name: <span class="string">'aaron'</span>,</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">               <span class="keyword">this</span>.selector = selector; <span class="comment">//表示疑问???循环调用问题</span></span><br><span class="line">               <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="keyword">constructor</span>: ajQuery</span><br><span class="line">&#125;</span><br><span class="line">ajQuery.fn.init.prototype = ajQuery.fn</span><br></pre></td></tr></table></figure><p>这段代码就是整个结构设计的最核心的东西了，有这样的一个处理，整个结构就活了！不得不佩服作者的设计思路，别具匠心。</p><p>看看init的的构造图：</p><p><a href="http://img.mukewang.com/540905880001daac05540230.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/540905880001daac05540230.jpg" alt="img"></a></p><p>通过原型传递解决问题，把jQuery的原型传递给jQuery.prototype.init.prototype。换句话说jQuery的原型对象覆盖了init构造器的原型对象，因为是引用传递所以不需要担心这个循环引用的性能问题。</p><h2>方法链式调用的实现</h2><p>jQuery的核心理念是Write less,Do more(写的更少,做的更多)，那么链式方法的设计与这个核心理念不谋而合。那么从深层次考虑这种设计其实就是一种Internal DSL。</p><p>DSL是指Domain Specific Language，也就是用于描述和解决特定领域问题的语言。</p><p>我们看一段链式代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">'input[type="button"]'</span>)</span><br><span class="line">    .eq(<span class="number">0</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="string">'点击我!'</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">1</span>)</span><br><span class="line">.click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">$(<span class="string">'input[type="button"]:eq(0)'</span>).trigger(<span class="string">'click'</span>);</span><br><span class="line">&#125;).end().eq(<span class="number">2</span>)</span><br><span class="line">.toggle(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.aa'</span>).hide(<span class="string">'slow'</span>);</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    $(<span class="string">'.aa'</span>).show(<span class="string">'slow'</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>看这个代码的结构，我们或多或少都能猜到其含义：</p><p>☑  找出type类型为button的input元素</p><p>☑  找到第一个按钮，并绑定click事件处理函数</p><p>☑  返回所有按钮，再找到第二个</p><p>☑  为第二个按钮绑定click事件处理函数</p><p>☑  为第三个按钮绑定toggle事件处理函数</p><p>那么可见jQuery的Internal DSL形式带来的好处——编写代码时，让代码更贴近作者的思维模式；阅读代码时，让读者更容易理解代码的含义；应用DSL可以有效的提高系统的可维护性（缩小了实现模型和领域模型的距离，提高了实现的可读性）和灵活性，并且提供开发的效率。</p><p>jQuery的这种管道风格的DSL链式代码，总的来说：</p><p>☑  节约JS代码；</p><p>☑  所返回的都是同一个对象，可以提高代码的效率。</p><p>通过简单扩展原型方法并通过<code>return this</code>的形式来实现跨浏览器的链式调用。利用JS下的简单工厂方法模式，来将所有对于同一个DOM对象的操作指定同一个实例。</p><p>这个原理就超简单了,如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aQuery().init().name()</span><br></pre></td></tr></table></figure><p>分解：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = aQuery();</span><br><span class="line">a.init()</span><br><span class="line">a.name()</span><br></pre></td></tr></table></figure><p>把代码分解一下，很明显实现链式的基本条件就是要实例对象先创建好，调用自己的方法。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">aQuery.prototype = &#123;</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;,</span><br><span class="line">    name: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以我们如果需要链式的处理，只需要在方法内部方法当前的这个实例对象this就可以了，因为返回当前实例的this，从而又可以访问自己的原型了，这样的就节省代码量，提高代码的效率，代码看起来更优雅。但是这种方法有一个问题是：所有对象的方法返回的都是对象本身，也就是说没有返回值，所以这种方法不一定在任何环境下都适合。</p><p>虽然Javascript是无阻塞语言，但是他并不是没阻塞，而是不能阻塞，所以他需要通过事件来驱动，异步来完成一些本需要阻塞进程的操作，这样处理只是同步链式，除了同步链式还有异步链式，异步链式jQuery从1.5开始就引入了<strong>Promise,jQuery.Deferred</strong>后期再讨论。</p><h2>插件接口的设计</h2><p>如果jQuery没有插件接口的设计，那么他就像个光杆司令没有兵，就是没有手下，只有自己一个封闭的城堡。因此jQuery城堡需要设计一个大门 - 插件接口，从而打开大门开始招兵买马。当然jQuery除了获得“开发者社区”的大力支持外，也有很多大公司纷纷对它投出了橄榄枝，这也是它成功的关键。</p><p>基于插件接口设计的好处也是颇多的，其中一个最重要的好处是把扩展的功能从主体框架中剥离出去，降低了框架的复杂度。接口的设计好比电脑上的配件如：CPU、内存、硬盘都是作为独立的模块分离出去了，但是主板提供模块的接口，例如支持串口的硬盘，我只要这个硬盘的接口能插上，甭管是500G还是1000G的容量的硬盘，都能使用。所以在软件设计中插件接口的提供把独立的功能与框架以一种很宽松的方式松耦合。</p><p>从之前的分析中我们可以知道jQuery对象的原理，所以一般来说，<strong>jQuery插件的开发分为两种：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☑  一种是挂在jQuery命名空间下的全局函数，也可称为静态方法；</span><br><span class="line"></span><br><span class="line">☑  另一种是jQuery对象级别的方法，即挂在jQuery原型下的方法，这样通过选择器获取的jQuery对象实例也能共享该方法。</span><br></pre></td></tr></table></figure><p>提供的接口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$.extend(target, [object1], [objectN])</span><br></pre></td></tr></table></figure><p>接口的使用：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">jQuery.extend(&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    removeData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    data:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;,</span><br><span class="line">    removeData:<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jQuery的主体框架就是之前提到的那样，通过<strong>工厂模式</strong>返回一个内部的init构造器生成的对象。但是根据一般设计者的习惯，如果要为jQuery添加静态方法或者实例方法从封装的角度讲是应该提供一个统一的接口才符合设计的。</p><p>jQuery支持自己扩展属性，这个对外提供了一个接口，jQuery.fn.extend()来对对象增加方法，从jQuery的源码中可以看到，jQuery.extend和jQuery.fn.extend其实是同指向同一方法的不同引用。</p><p>这里有一个设计的重点，通过调用的上下文，我们来确定这个方法是作为静态还是实例处理，在javascript的世界中一共有四种上下文调用方式：方法调用模式、函数调用模式、构造器调用模式、apply调用模式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">☑  jQuery.extend调用的时候上下文指向的是jQuery构造器</span><br><span class="line"></span><br><span class="line">☑  jQuery.fn.extend调用的时候上下文指向的是jQuery构造器的实例对象了</span><br></pre></td></tr></table></figure><p>通过extend()函数可以方便快速的扩展功能，不会破坏jQuery的原型结构，jQuery.extend = jQuery.fn.extend = function(){…}; 这个是连等，也就是2个指向同一个函数，怎么会实现不同的功能呢？这就是<strong>this</strong>力量了！</p><p>fn与jQuery其实是2个不同的对象，在之前有讲解：jQuery.extend 调用的时候，this是指向jQuery对象的(jQuery是函数，也是对象)，所以这里扩展在jQuery上。而jQuery.fn.extend 调用的时候，this指向fn对象，jQuery.fn 和jQuery.prototype指向同一对象，扩展fn就是扩展jQuery.prototype原型对象。这里增加的是原型方法，也就是对象方法了。所以jQuery的API中提供了以上2个扩展函数。</p><p>jQuery的extend代码实现比较长，我们简单说一下重点：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">aAron.extend = aAron.fn.extend = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> options, src, copy,</span><br><span class="line">        target = <span class="built_in">arguments</span>[<span class="number">0</span>] || &#123;&#125;,</span><br><span class="line">        i = <span class="number">1</span>,</span><br><span class="line">        length = <span class="built_in">arguments</span>.length;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只有一个参数，就是对jQuery自身的扩展处理</span></span><br><span class="line">    <span class="comment">//extend,fn.extend</span></span><br><span class="line">    <span class="keyword">if</span> (i === length) &#123;</span><br><span class="line">        target = <span class="keyword">this</span>; <span class="comment">//调用的上下文对象jQuery/或者实例</span></span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//从i开始取参数,不为空开始遍历</span></span><br><span class="line">        <span class="keyword">if</span> ((options = <span class="built_in">arguments</span>[i]) != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (name <span class="keyword">in</span> options) &#123;</span><br><span class="line">                copy = options[name];</span><br><span class="line">                <span class="comment">//覆盖拷贝</span></span><br><span class="line">                target[name] = copy;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我来讲解一下上面的代码：因为extend的核心功能就是通过扩展收集功能（类似于mix混入），所以就会存在收集对象（target）与被收集的数据，因为jQuery.extend并没有明确实参，而且是通过arguments来判断的，所以这样处理起来很灵活。arguments通过判断传递参数的数量可以实现函数重载。其中最重要的一段<code>target = this</code>，通过调用的方式我们就能确实当前的this的指向，所以这时候就能确定target了。最后就很简单了，通过for循环遍历把数据附加到这个target上了。当然在这个附加的过程中我们还可以做<strong>数据过滤、深拷贝</strong>等一系列的操作了。</p><h2>回溯处理的设计</h2><p>接下来了解jQuery对DOM进行遍历背后的工作机制，这样可以在编写代码时有意识地避免一些不必要的重复操作，从而提升代码的性能。</p><p><strong>关于jQuery对象的包装</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var $aaron = $(&quot;aaron&quot;);</span><br></pre></td></tr></table></figure><p>通过对sizzle的分析，我们可以得知Query选择器最终都是通过DOM接口实现取值的, 但是通过jQuery处理后返回的不仅仅只有DOM对象，而是一个包装容器，返回jQuery对象：$aaron。</p><p>我们来看一下代码：</p><p><img src="http://img.mukewang.com/54090d3400019da004300314.jpg" alt="img"></p><p><strong>在jQuery</strong>对象中<strong><strong>有个prevObject</strong></strong>对象，这个是干嘛用的呢?</p><p>如果你想知道prevObject是做什么的，咱们首先得先来了解一下jQuery对象栈，jQuery内部维护着一个jQuery对象栈。每个遍历方法都会找到一组新元素（一个jQuery对象），然后jQuery会把这组元素推入到栈中。</p><p>而每个jQuery对象都有三个属性：context、selector和prevObject，其中的prevObject属性就指向这个对象栈中的前一个对象，而通过这个属性可以回溯到最初的DOM元素集中。</p><p>为了方便理解，我们做几个简单的测试：</p><p>下面有一个父元素ul,嵌套了一个li节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul id=&quot;aaron&quot;&gt;</span><br><span class="line">    parent</span><br><span class="line">    &lt;li&gt;child&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>我们现给li绑定一个事件，这个很简单，找到ul下面的li，绑定即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var aaron = $(&quot;#aaron&quot;);</span><br><span class="line">    aaron.find(&apos;li&apos;).click(function()&#123;</span><br><span class="line">        alert(1);     //1</span><br><span class="line">    &#125;)</span><br></pre></td></tr></table></figure><p>此时我又想给父元素绑定一个事件，我们是不是又要在aaron上绑定一次事件呢？是的，上面代码通过find处理后，此时的上下文是指向每一个li了,所以必须要重新引用aaron元素（li的父元素），然后再绑定click事件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aaron.click(function()&#123;</span><br><span class="line">      alert(2);     //1</span><br><span class="line"> &#125;)</span><br></pre></td></tr></table></figure><p>这样会不会很麻烦，所以jQuery引入一个简单的内部寻址的机制，可以回溯到之前的Dom元素集合，通过end()方法可以实现：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">aaron.find(<span class="string">'li'</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">1</span>);</span><br><span class="line">&#125;).end().click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        alert(<span class="number">2</span>);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>jQuery为我们操作这个内部对象栈提供个非常有用的2个方法</p><p>.end()</p><p>.addBack()</p><p>这里需要指出来可能有些API上是andSelf，因为就Query的api是这样写的，andSelf现在是.addBack()的一个别名。在jQuery1.8和更高版本中应使用.addBack()</p><p>源码其实也是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.andSelf = jQuery.fn.addBack;</span><br></pre></td></tr></table></figure><p>调用第一个方法只是简单地弹出一个对象（结果就是回到前一个jQuery对象）。第二个方法更有意思，调用它会在栈中回溯一个位置，然后把两个位置上的元素集组合起来，并把这个新的、组合之后的元素集推入栈的上方。</p><p>利用这个DOM元素栈可以减少重复的查询和遍历的操作，而减少重复操作也正是优化jQuery代码性能的关键所在。</p><h2>end与addBack</h2><p>大多数jQueryDOM遍历方法来操作jQuery对象实例，并创建一个新的对象，匹配一个不同的DOM元素集合。当发生这种情况时，实际上是新的元素集合被压入到对象内部维护的栈中。每次过滤方法都会被压入栈中。当我们需要返回到前一个状态时，我们可以使用end()进行出栈操作，来返回栈中的前一个状态。</p><p>假设页面上有几个列表项：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"first"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">ul</span> <span class="attr">class</span>=<span class="string">"second"</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"foo"</span>&gt;</span>list item 1<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span>&gt;</span>list item 2<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">li</span> <span class="attr">class</span>=<span class="string">"bar"</span>&gt;</span>list item 3<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><p>end()方法主要用于jQuery的链式属性中。当没有使用链式用法时，我们通常只是调用变量名上的前一个对象，所以我们不需要操作栈。</p><p>使用end()时，我们可以一次性调用所有需要的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;).end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>链式的原理就是要返回当前操作的上下文。</p><p>下面的代码是错误的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;, &apos;red&apos;).find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>上面的代码因为上下文被切换了，所以执行find(‘bar’)时就出错了。</p><p>下面的代码是正确的写法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(&apos;ul.first&apos;).find(&apos;.foo&apos;).css(&apos;background-color&apos;,&apos;red&apos;).end().find(&apos;.bar&apos;).css(&apos;background-color&apos;, &apos;green&apos;);</span><br></pre></td></tr></table></figure><p>首先在链式用法中只在第一个列表中查找样式为 foo 的项目，并将其背景色变成红色。然后end()返回调用find()之前的状态。因此，第二次 find() 将只会查找 <ul class="first"> 中的 ‘.bar’，而不是继续在<li class="foo">中进行查找，结果是将匹配到的元素的背景色变成绿色。上述代码的最终结果是：第一个列表中的第 1 和第 3 个列表项的背景色有颜色，而第二个列表中的任何项目都没有背景色。</li></ul></p><p><strong>总的来说：end方法就是回溯到上一个Dom合集,因此对于链式操作与优化，这个方法还是很有意义的。</strong></p><p><strong>源码实现</strong></p><p>既然是回溯到上一个DOM合集，那么肯定end方法中返回的就是一个jQuery对象了，所以我们看源码其实就是返回prevObject对象了，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">end: function() &#123;</span><br><span class="line">     return this.prevObject || this.constructor(null);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>prevObject在什么情况下会产生？</strong></p><p>在构建jQuery对象的时候，通过pushStack方法构建，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">jQuery.fn.extend(&#123;</span><br><span class="line">    find: <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//...........................省略................................</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//通过sizzle选择器，返回结果集</span></span><br><span class="line">        jQuery.find(selector, self[i], ret);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Needed because $( selector, context ) becomes $( context ).find( selector )</span></span><br><span class="line">        ret = <span class="keyword">this</span>.pushStack(len &gt; <span class="number">1</span> ? jQuery.unique(ret) : ret);</span><br><span class="line">        ret.selector = <span class="keyword">this</span>.selector ? <span class="keyword">this</span>.selector + <span class="string">" "</span> + selector : selector;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到通过jQuery.find后得到了结果ret这个就是通过纯的DOM节点，那么如果变成一个jQuery对象呢？</p><p>接着我们看pushStack对象，作用就通过新的DOM元素去创建一个新的jQuery对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">pushStack: function( elems ) &#123;</span><br><span class="line">    // Build a new jQuery matched element set</span><br><span class="line">    var ret = jQuery.merge( this.constructor(), elems );</span><br><span class="line"></span><br><span class="line">    // Add the old object onto the stack (as a reference)</span><br><span class="line">    ret.prevObject = this;</span><br><span class="line">    ret.context = this.context;</span><br><span class="line"></span><br><span class="line">    // Return the newly-formed element set</span><br><span class="line">    return ret;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>流程解析：</strong></p><p>1、首先构建一个新的jQuery对象，因为constructor是指向构造器的，所以这里就等同于调用jQuery()方法了，返回了一个新的jQuery对象；</p><p>2、然后用jQuery.merge语句把elems节点合并到新的jQuery对象上；</p><p>3、最后给返回的新jQuery对象添加prevObject属性，我们看到prevObject其实还是当前jQuery的一个引用罢了，所以也就是为什么通过prevObject能取到上一个合集的原因了。</p><h2>仿栈与队列的操作</h2><p>jQuery既然是模仿的数组结构，那么肯定会实现一套类数组的处理方法，比如常见的栈与队列操作push、pop、shift、unshift、求和、遍历循环each、排序及筛选等一系的扩展方法。</p><p>jQuery对象栈是一个便于Dom的查找，提供的一系列方法，jQuery可以是集合元素，那么我们怎么快速的找到集合中对应的目标元素呢？</p><p>jQuery提供了.get()、:index()、 :lt()、:gt()、:even()及 :odd()这类索引值相关的选择器，他们的作用可以过滤他们前面的匹配表达式的集合元素，筛选的依据就是这个元素在原先匹配集合中的顺序。</p><p>我们来分别看一下这几个选择器的实现原理:</p><p>get方法–是通过检索匹配jQuery对象得到对应的DOM元素，如下代码实现：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">get: function(num) &#123;</span><br><span class="line">    return num != null ?</span><br><span class="line">    // Return just the one element from the set</span><br><span class="line">    (num &lt; 0 ? this[num + this.length] : this[num]) :</span><br><span class="line">    // Return all the elements in a clean array</span><br><span class="line">    slice.call(this);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原理很简单，因为jQuery查询出来的是一个数组的DOM集合，所以就可以按照数组的方法通过下标的索引取值，当然如果num的值超出范围，比如小于元素数量的负数或等于或大于元素的数量的数，那么它将返回undefined。 假设我们页面上有一个简单的无序列表，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul&gt;</span><br><span class="line">  &lt;li id=&quot;foo&quot;&gt;foo&lt;/li&gt;</span><br><span class="line">  &lt;li id=&quot;bar&quot;&gt;bar&lt;/li&gt;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure><p>如果指定了index参数，.get()则会获取单个元素，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( $( &quot;li&quot; ).get( 0 ) );</span><br></pre></td></tr></table></figure><p>由于索引 index 是以 0 开始计数的，所以上面代码返回了第一个列表项<code>foo</code>。</p><p>然而，这种语法缺少某些 .get() 所具有的附加功能，比如可以指定索引值为负值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console.log( $( &quot;li&quot; ).get(-1) );</span><br></pre></td></tr></table></figure><p>负的索引值表示从匹配的集合中从末尾开始倒数，所以上面这个例子将会返回列表中最后一项：<code>bar</code>。</p><p>由于是数组的关系，所以我们有几个快速方法，比如头跟尾的取值：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">first: function() &#123;</span><br><span class="line">    return this.eq( 0 );</span><br><span class="line">&#125;,</span><br><span class="line"></span><br><span class="line">last: function() &#123;</span><br><span class="line">    return this.eq(-1);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>get与eq的区别</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.eq()  减少匹配元素的集合，根据index索引值，精确指定索引对象。</span><br><span class="line">.get() 通过检索匹配jQuery对象得到对应的DOM元素。</span><br></pre></td></tr></table></figure><p><strong>同样是返回元素，那么eq与get有什么区别呢？</strong></p><p>eq返回的是一个jQuery对象，get返回的是一个DOM对象。举个例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$( &quot;li&quot; ).get( 0 ).css(&quot;color&quot;, &quot;red&quot;); //错误</span><br><span class="line">$( &quot;li&quot; ).eq( 0 ).css(&quot;color&quot;, &quot;red&quot;); //正确</span><br></pre></td></tr></table></figure><p>get方法本质上是把jQuery对象转换成DOM对象，但是css属于jQuery构造器的，DOM是不存在这个方法的，如果需要用jQuery的方法，我们必须这样写：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var li = $( &quot;li&quot; ).get( 0 );</span><br><span class="line">$( li ).css(&quot;color&quot;, &quot;red&quot;); //用$包装</span><br></pre></td></tr></table></figure><p>取出DOM对象li，然后用$再次包装，使之转变成jQuery对象，才能调用css方法，这样要分2步写太麻烦了，所以jQuery给我们提供了一个便捷方法eq()。</p><p>eq()的实现原理就是在上面代码中的把eq方法内部转成jQuery对象：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">eq: function( i ) &#123;</span><br><span class="line">    var len = this.length,</span><br><span class="line">        j = +i + ( i &lt; 0 ? len : 0 );</span><br><span class="line">    return this.pushStack( j &gt;= 0 &amp;&amp; j &lt; len ? [ this[j] ] : [] );</span><br></pre></td></tr></table></figure><p>上面实现代码的逻辑就是跟get是一样的，区别就是通过了pushStack产生了一个新的jQuery对象。</p><p>jQuery的考虑很周到，通过eq方法只能产生一个新的对象，但是如果需要的是一个合集对象要怎么处理？因此jQuery便提供了一个slice方法：</p><p><strong>语法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.slice( start [, end ] )</span><br></pre></td></tr></table></figure><p><strong>作用：</strong></p><p>根据指定的下标范围，过滤匹配的元素集合，并生成一个新的 jQuery 对象。</p><p>因为是数组对象，意味着我们可以用silce来直接取值了，所以针对合集对象我们可以这样写代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var arr = []</span><br><span class="line">arr.push( this.slice(start[,end]) )     </span><br><span class="line">this.pushStack（arr）</span><br></pre></td></tr></table></figure><p>这个this指的是jQuery对象，因为jQuery对象是数组集合，所以我们可以通过原生的silce方法直接取到集合数，然后通过包装处理即可了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">slice: function() &#123;</span><br><span class="line">    return this.pushStack( slice.apply( this, arguments ) );</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><h2>迭代器</h2><p><strong>迭代器是一个框架的重要设计。我们经常需要提供一种方法顺序用来处理聚合对象中各个元素，而又不暴露该对象的内部，这也是设计模式中的迭代器模式(Iterator)。</strong></p><p>jQuery中的$.each方法就是一个典型的迭代器，通过each我们可以传入额外的function，然后来对所有的item项进行迭代操作，如下代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$.each([<span class="number">52</span>, <span class="number">97</span>], <span class="function"><span class="keyword">function</span>(<span class="params">index, value</span>) </span>&#123;</span><br><span class="line">  alert(index + <span class="string">': '</span> + value);</span><br><span class="line">&#125;);</span><br><span class="line">$( <span class="string">"li"</span> ).each(<span class="function"><span class="keyword">function</span>(<span class="params"> index </span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log( index + <span class="string">": "</span><span class="string">" + $(this).text() );</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure><p>针对迭代器，这里有几个特点：</p><p>☑ 访问一个聚合对象的内容而无需暴露它的内部。</p><p>☑ 为遍历不同的集合结构提供一个统一的接口，从而支持同样的算法在不同的集合结构上进行操作。</p><p>☑ 遍历的同时更改迭代器所在的集合结构可能会导致问题。</p><p>简单的说：封装实现，然后迭代器的聚合对象不用关心迭代的过程，从而符合SRP原则。</p><p>抛开jQuery的each方法，我们自己实现一个有简单的迭代器功能的代码：</p><p>1、简单回调</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">each</span>(<span class="params">obj, callback</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> value;</span><br><span class="line">    <span class="keyword">var</span> length = obj.length;</span><br><span class="line">    <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">        callback(obj[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> arr = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line">each(arr, <span class="function"><span class="keyword">function</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(name); </span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这样就满足了迭代模式的设计原则，对于集合内部结果常常变化各异，我们不想暴露其内部结构，但又想让客户代码透明地访问其中的元素，通过回调把逻辑给解耦出来。但是这样的处理其实太简单了，我们还要考虑至少四种情况：</p><p>☑ 聚合对象，可能是对象，字符串或者数组等类型</p><p>☑ 支持参数传递</p><p>☑ 支持上下文的传递</p><p>☑ 支持循环中退出</p><p>我们简单的修改一下上面的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">function each(obj, callback, context, arg) &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    var value;</span><br><span class="line">    var length = obj.length;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">        callback.call(context || null, obj[i], arg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var arr = [&apos;a&apos;, &apos;b&apos;, &apos;c&apos;];</span><br><span class="line">each(arr, function(name, arg) &#123;</span><br><span class="line">    console.log(name, arg ,this);</span><br><span class="line">&#125;, this, &apos;aaa&apos;)</span><br></pre></td></tr></table></figure><p>当然根据回调的处理，从而判断是否要立刻中断这个循环，从而节约性能，也是很简单的，我们可以通过获取处理的返回值来处理，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">function each(obj, callback, context, arg) &#123;</span><br><span class="line">    var i = 0;</span><br><span class="line">    var value;</span><br><span class="line">    var length = obj.length;</span><br><span class="line">    for (; i &lt; length; i++) &#123;</span><br><span class="line">        value = callback.call(context || null, obj[i], arg);</span><br><span class="line">        if (value === false) &#123;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>可见只要通过回调函数callback返回的ture/false的布尔值结果就可以来判断当前是否要强制退出循环。</p><h2>jQuery的each迭代器</h2><p>jQuery的each方法从使用上就要分2种情况：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">☑ $.each()函数</span><br><span class="line">☑ $(selector).each()</span><br></pre></td></tr></table></figure><p>$.each()函数和$(selector).each()是不一样的，后者是专门用来遍历一个jQuery对象的，是为jQuery内部服务的。</p><p>$.each()函数可用于迭代任何集合，无论是“名/值”对象（JavaScript对象）或数组。在迭代数组的情况下，回调函数每次传递一个数组索引和相应的数组值作为参数。（该值也可以通过访问this关键字得到，但是JavaScript始终将this值作为一个Object，即使它是一个简单的字符串或数字值。）该方法返回其第一个参数，这是迭代的对象。</p><p>jQuery的实例方法最终也是调用的静态方法，我们在之前就解释过jQuery的实例与原型方法共享的设计。</p><p>其中each的实例方法如下：</p><p>可见内部是直接调用的静态方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">each: function(callback, args) &#123;</span><br><span class="line">    return jQuery.each(this, callback, args);</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure><p>jQuery.each静态方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">each: <span class="function"><span class="keyword">function</span>(<span class="params">obj, callback, args</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> value,</span><br><span class="line">        i = <span class="number">0</span>,</span><br><span class="line">        length = obj.length,</span><br><span class="line">        isArray = isArraylike(obj);</span><br><span class="line">    <span class="keyword">if</span> (args) &#123;</span><br><span class="line">        <span class="keyword">if</span> (isArray) &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; length; i++) &#123;</span><br><span class="line">                value = callback.apply(obj[i], args);</span><br><span class="line">                <span class="keyword">if</span> (value === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">                value = callback.apply(obj[i], args);</span><br><span class="line">                <span class="keyword">if</span> (value === <span class="literal">false</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>实现原理几乎一致，只是增加了对于参数的判断。对象用for in遍历，数组用for遍历。</p><p>jQuery可以是多个合集数组DOM，所以在处理的时候经常就针对每一个DOM都要单独处理，所以一般都需要调用this.each 方法，如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">dequeue: function( type ) &#123;</span><br><span class="line">        return this.each(function() &#123;</span><br><span class="line">            jQuery.dequeue( this, type );</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;,</span><br></pre></td></tr></table></figure><p>迭代器除了单纯的遍历，在jQuery内部的运用最多的就是接口的<strong>抽象合并</strong>，相同功能的代码功能合并处理：</p><p>例如一：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(<span class="string">"Boolean Number String Function Array Date RegExp Object Error"</span>.split(<span class="string">" "</span>), <span class="function"><span class="keyword">function</span>(<span class="params">i, name</span>) </span>&#123;</span><br><span class="line">    class2type[ <span class="string">"[object "</span> + name + <span class="string">"]"</span> ] = name.toLowerCase();</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>例如二：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">jQuery.each(&#123;</span><br><span class="line">    mouseenter: &quot;mouseover&quot;,</span><br><span class="line">    mouseleave: &quot;mouseout&quot;,</span><br><span class="line">    pointerenter: &quot;pointerover&quot;,</span><br><span class="line">    pointerleave: &quot;pointerout&quot;</span><br><span class="line">&#125;, function( orig, fix ) &#123;</span><br><span class="line">    //处理的代码</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>JQuery源码解读 01</title>
      <link href="/2016/10/23/JQuery%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB%2001/"/>
      <content type="html"><![CDATA[<h2>简介</h2><p>从整体入手理解架构，再深入攻破每个依赖模块，包括回调函数、异步加载、数据缓存、动画队列最后整体分析：选择器、DOM处理、AJAX、动画模块、事件</p><a id="more"></a><h2>jQuery设计理念</h2><p>引用百科的介绍：</p><p>jQuery是继prototype之后又一个优秀的Javascript框架。它是轻量级的js库 ，它兼容CSS3，还兼容各种浏览器（IE 6.0+, FF 1.5+, Safari 2.0+, Opera 9.0+），jQuery2.0及后续版本将不再支持IE6/7/8浏览器。jQuery使用户能更方便地处理<strong>HTML（标准通用标记语言下的一个应用）、events、实现动画效果</strong>，并且方便地为网站提供<strong>AJAX交互</strong>。jQuery还有一个比较大的优势是，它的文档说明很全，而且各种应用也说得很详细，同时还有许多成熟的插件可供选择。jQuery能够使用户的html页面保持代码和html内容分离，也就是说，不用再在html里面插入一堆js来调用命令了，只需定义id即可。</p><p>The Write Less,Do More（写更少，做更多），无疑就是jQuery的核心理念，简洁的API、优雅的链式、强大的查询与便捷的操作。从而把jQuery打造成前端世界的一把利剑，所向披靡！</p><p><strong>简洁的API:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.on</span><br><span class="line">$.css</span><br><span class="line">$.ajax</span><br><span class="line">….</span><br></pre></td></tr></table></figure><p><strong>优雅的链式:</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jqxhr = $.ajax( <span class="string">"example.php"</span> )</span><br><span class="line">    .done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"success"</span>); &#125;)</span><br><span class="line">    .fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"error"</span>); &#125;)</span><br><span class="line">    .always(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; alert(<span class="string">"complete"</span>); &#125;);</span><br></pre></td></tr></table></figure><p><strong>强大的选择器：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"div, span, p.myClass"</span> )</span><br><span class="line">$(<span class="string">"div span:first-child"</span>)</span><br><span class="line">$(<span class="string">"tr:visible"</span>)</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><strong>便捷的操作：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="string">"p"</span>).removeClass(<span class="string">"myClass noClass"</span>).addClass(<span class="string">"yourClass"</span>);</span><br><span class="line">$(<span class="string">"ul li:last"</span>).addClass(<span class="function"><span class="keyword">function</span>(<span class="params">index</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span><span class="string">"item-"</span> + index;</span><br><span class="line">&#125;);</span><br><span class="line">$(<span class="string">'.container'</span>).append($(<span class="string">'h2'</span>));</span><br><span class="line">…</span><br></pre></td></tr></table></figure><p><strong>为什么要做jQuery源码解析？</strong></p><p>虽然jQuery的文档很完善，潜意识降低了前端开发的入门的门槛，要实现一个动画随手拈来，只要简单的调用一个animate方法传递几个执行的参数即可，但如果要我们自己实现一个定制的动画呢？我们要考虑的问题太多太多了，浏览器兼容、各种属性的获取、逻辑流程、性能等等，这些才是前端开发的基础核心。</p><p>如果我们只知道使用jQuery，而不知道其原理，那就是“知其然,而不知其所以然”，说了这么多，那就赶快跟着慕课网进入“高大上”之旅吧，深入来探究jQuery的内部架构！</p><h2>jQuery整体架构</h2><p>任何程序代码不是一开始就复杂的，成功也不是一躇而蹴的，早期jQuery的作者John Resig在2005年提议改进Prototype的“Behaviour”库时，只是想让其使用更简单才发布新的jQuery框架。起初John Resig估计也没料想jQuery会如此的火热。我们可以看到从发布的第一个1.0开始到目前最新的2.1.1其代码膨胀到了9000多行，它兼容CSS3，还兼容各种浏览器，jQuery使用户能更方便地处理DOM、事件、实现动画效果，并且方便地为网站提供AJAX交互。</p><p>1、最新jQuery2.1.1版本的结构：</p><p>1、最新jQuery2.1.1版本的结构：代码请查看右侧代码编辑器（1-24行）</p><p>2、jQuery的模块依赖网：</p><p>2、jQuery的模块依赖网： <a href="http://img.mukewang.com/53fa8fec0001754806930473.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fa8fec0001754806930473.jpg" alt="img"></a></p><p>jQuery一共13个模块，从2.1版开始jQuery支持通过AMD模块划分，jQuery在最开始发布的1.0版本是很简单的，只有CSS选择符、事件处理和AJAX交互3大块。其发展过程中，有几次重要的变革：</p><ul><li>1.2.3 版发布，引入数据缓存，解决循环引用与大数据保存的问题</li><li>1.3 版发布，它使用了全新的选择符引擎Sizzle，在各个浏览器下全面超越其他同类型JavaScript框架的查询速度，程序库的性能也因此有了极大提升</li><li>1.5 版发布，新增延缓对像(Deferred Objects)，并用deferred重写了Ajax模块</li><li>1.7 版发布，抽象出回调对象，提供了强大的的方式来管理回调函数列表。</li></ul><p>每一次大的改进都引入了一些新的机制、新的特性，通过这些新的机制就造就了如今jQuery库，一共13个模块，模块不是单一的，比如jQuery动画，都会依赖异步队列、动画队列、回调队列与数据缓存模块等。</p><p>jQuery抽出了所有可复用的特性，分离出单一模块，通过组合的用法，不管在设计思路与实现手法上jQuery都是非常高明的。</p><h3>五大块：</h3><p>jQuery按我的理解分为五大块，选择器、DOM操作、事件、AJAX与动画，那么为什么有13个模块？因为jQuery的设计中最喜欢的做的一件事，就是抽出共同的特性使之“模块化”，当然也是更贴近S.O.L.I.D五大原则的“单一职责SRP”了，遵守单一职责的好处是可以让我们很容易地来维护这个对象，比如，当一个对象封装了很多职责的时候，一旦一个职责需要修改，势必会影响该对象的其它职责代码。通过解耦可以让每个职责更加有弹性地变化。</p><p>我们来看看jQuery文档针对业务层的Ajax的处理提供了一系列的门面接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.ajaxComplete()</span><br><span class="line">.ajaxError()</span><br><span class="line">.ajaxSend()</span><br><span class="line">.ajaxStart()</span><br><span class="line">.ajaxStop()</span><br><span class="line">.ajaxSuccess()</span><br></pre></td></tr></table></figure><p>底层接口：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax()</span><br><span class="line">jQuery.ajaxSetup()</span><br></pre></td></tr></table></figure><p>快捷方法：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jQuery.get()</span><br><span class="line">jQuery.getJSON()</span><br><span class="line">jQuery.getScript()</span><br><span class="line">jQuery.post()</span><br></pre></td></tr></table></figure><h3>jQuery接口的设计原理</h3><p>业务逻辑是复杂多变的，jQuery的高层API数量非常多，而且也非常的细致，这样做可以更友好的便于开发者的操作，不需要必须在一个接口上重载太多的动作。我们在深入内部看看Ajax的高层方法其实都是统一调用了一个静态的jQuery.ajax方法，</p><p>在jQuery.ajax的内部实现是非常复杂的，首先ajax要考虑异步的处理与回调的统一性，所以就引入了异步队列模块（Deferred）与回调模块（Callbacks）, 所以要把这些模块方法在ajax方法内部再次封装成、构建出一个新的jQXHR对象，针对参数的默认处理，数据传输的格式化等等。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">global, factory</span>) </span>&#123;</span><br><span class="line">    factory(global);</span><br><span class="line">&#125;(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">"undefined"</span> ? <span class="built_in">window</span> : <span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params">window, noGlobal</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"> selector, context </span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> jQuery.fn.init( selector, context );</span><br><span class="line">&#125;;</span><br><span class="line">jQuery.fn = jQuery.prototype = &#123;&#125;;</span><br><span class="line"><span class="comment">// 核心方法</span></span><br><span class="line"><span class="comment">// 回调系统</span></span><br><span class="line"><span class="comment">// 异步队列</span></span><br><span class="line"><span class="comment">// 数据缓存</span></span><br><span class="line"><span class="comment">// 队列操作</span></span><br><span class="line"><span class="comment">// 选择器引</span></span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="comment">// 节点遍历</span></span><br><span class="line"><span class="comment">// 文档处理</span></span><br><span class="line"><span class="comment">// 样式操作</span></span><br><span class="line"><span class="comment">// 属性操作</span></span><br><span class="line"><span class="comment">// 事件体系</span></span><br><span class="line"><span class="comment">// AJAX交互</span></span><br><span class="line"><span class="comment">// 动画引擎</span></span><br><span class="line"><span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure><h2>立即调用表达式</h2><p>任何库与框架设计的第一个要点就是解决<strong>命名空间与变量污染</strong>的问题。jQuery就是利用了JavaScript函数作用域的特性，采用立即调用表达式包裹了自身的方法来解决这个问题。</p><p>jQuery的立即调用函数表达式的写法有三种：</p><p><strong>写法1：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, factory</span>) </span>&#123;</span><br><span class="line">    factory(<span class="built_in">window</span>)</span><br><span class="line">&#125;(<span class="keyword">this</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">       <span class="comment">//jQuery的调用</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure><p>可以看出上面的代码中嵌套了2个函数，而且把一个函数作为参数传递到另一个函数中并且执行，这种方法有点复杂，我们简化一下写法：</p><p><strong>写法2：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> factory = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="comment">//执行方法</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> jQuery = factory();</span><br></pre></td></tr></table></figure><p>上面的代码效果和方法1是等同的，但是这个factory有点变成了简单的<strong>工厂方法模式</strong>，需要自己调用，不像是一个单例的jQuery类，所以我们需要改成“自执行”，而不是另外调用。</p><p><strong>写法3：</strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params">window, undefined</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">    <span class="built_in">window</span>.jQuery = <span class="built_in">window</span>.$ = jQuery;</span><br><span class="line">&#125;)(<span class="built_in">window</span>);</span><br></pre></td></tr></table></figure><p>从上面的代码可看出，自动初始化这个函数，让其只构建一次。详细说一下这种写法的优势：</p><p><strong>1、</strong> <strong>window</strong>和<strong>undefined</strong>都是为了减少变量查找所经过的scope作用域。当window通过传递给闭包内部之后，在闭包内部使用它的时候，可以把它当成一个局部变量，显然比原先在window scope下查找的时候要快一些。</p><p><strong>2、<strong>undefined也是同样的道理，其实这个</strong>undefined</strong>并不是JavaScript数据类型的undefined，而是一个普普通通的变量名。只是因为没给它传递值，它的值就是undefined，undefined并不是JavaScript的保留字。</p><p>关于留言，为什么要传递undefined？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Javascript 中的 undefined 并不是作为关键字，因此可以允许用户对其赋值。</span><br></pre></td></tr></table></figure><p>我们看一个</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="literal">undefined</span> = <span class="string">'ulson'</span></span><br><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">window</span>) </span>&#123;</span><br><span class="line">  alert(<span class="literal">undefined</span>);<span class="comment">//IE8 'ulson'</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p>IE8存在这个问题，当然，大部分浏览器都是不能被修改的</p><p>如果函数调用不传递，参数默认就是undefined</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">;(<span class="function"><span class="keyword">function</span>(<span class="params">window,undefined</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//undefined</span></span><br><span class="line">&#125;)(<span class="built_in">window</span>)</span><br></pre></td></tr></table></figure><p></p><p>####jQuery为什么要创建这样的一个外层包裹，其原理又是如何？</p><p>这里要区分2个概念一个是匿名函数，一个是自执行。顾名思义，匿名函数，就是没有函数名的函数，<strong>也就是不存在外部引用</strong>。但是是否像下面代码实现呢：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面这种写法是错了，声明了它但是又不给名字又没有使用，所以在语法上错误的，那么怎么去执行一个匿名的函数呢？</p><p>要调用一个函数，我们必须要有方法定位它、引用它。所以，我们要取一个名字：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jQuery = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="comment">//代码逻辑</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jQuery使用()将匿名函数括起来，然后后面再加一对小括号（包含参数列表），那么这小括号能把我们的表达式组合分块，并且每一块（也就是每一对小括号），都有一个返回值。这个返回值实际上也就是小括号中表达式的返回值。所以，当我们用一对小括号把匿名函数括起来的时候，实际上小括号返回的，就是一个匿名函数的Function对象。因此，小括号对加上匿名函数就如同有名字的函数般被我们取得它的引用位置了。所以如果在这个引用变量后面再加上参数列表，就会实现普通函数的调用形式。</p><p>最后，我们回到写法1看看jQuery利用写法3的写法，然后把整个函数作为参数传递给另外一个函数，主要是为了判断jQuery在不同平台的下的加载逻辑，主流的库一般都有对 AMD 和 CommonJS 的支持代码，看看jQuery的代码：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">module</span> === <span class="string">"object"</span> &amp;&amp; <span class="keyword">typeof</span> <span class="built_in">module</span>.exports === <span class="string">"object"</span>) &#123;</span><br><span class="line">    <span class="built_in">module</span>.exports = global.document ?</span><br><span class="line">        factory(global, <span class="literal">true</span>) :</span><br><span class="line">        <span class="function"><span class="keyword">function</span>(<span class="params">w</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!w.document) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"jQuery requires a window with a document"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> factory(w);</span><br><span class="line">    &#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    factory(global);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>总结：全局变量是魔鬼, 匿名函数可以有效的保证在页面上写入JavaScript，而不会造成全局变量的污染，通过小括号，让其加载的时候立即初始化，这样就形成了一个单例模式的效果从而只会执行一次。</p><h2>jQuery的类数组对象结构</h2><h4>为什么是类数组对象呢？</h4><p>很多人迷惑的jQuery为什么能像数组一样操作，通过对象get方法或者直接通过下标0索引就能转成DOM对象。</p><p>首先我们看jQuery的入口都是统一的$, 通过传递参数的不同，实现了9种方法的<strong>重载</strong>：</p><ol><li>jQuery([selector,[context]])</li><li>jQuery(element)</li><li>jQuery(elementArray)</li><li>jQuery(object)</li><li>jQuery(jQuery object)</li><li>jQuery(html,[ownerDocument])</li><li>jQuery(html,[attributes])</li><li>jQuery()</li><li>jQuery(callback)</li></ol><p>9种用法整体来说可以分三大块：选择器、dom的处理、dom加载。</p><p>换句话说jQuery就是为了获取DOM、操作DOM而存在的。所以为了更方便这些操作，让<strong>节点与实例对象</strong>通过一个桥梁给关联起来，jQuery内部就采用了一种叫“类数组对象”的方式作为存储结构，所以我们即可以像对象一样处理jQuery操作，也能像数组一样可以使用<strong>push、pop、shift、unshift、sort、each、map</strong>等类数组的方法操作jQuery对象了。</p><p><strong>jQuery对象可用数组下标索引是什么原理？</strong></p><p>通过<code>$(&quot;.Class&quot;)</code>构建的对象结构如下所示：</p><p><a href="http://img.mukewang.com/53fad4240001c7b805050236.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fad4240001c7b805050236.jpg" alt="img"></a></p><p><a href="http://img.mukewang.com/53fad4240001c7b805050236.jpg" target="_blank" rel="noopener"><img src="http://img.mukewang.com/53fad4240001c7b805050236.jpg" alt="img"></a>整个结构很明了，通过对象键值对的关系保存着属性，原型保存着方法。我们来简单的模拟一个这样的数据结构：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&lt;!DOCTYPE HTML&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=utf-8"</span>&gt;</span><br><span class="line">&lt;script src=<span class="string">"http://img.mukewang.com/down/540812440001e40e00000000.js"</span> type=<span class="string">"text/javascript"</span>&gt;&lt;/script&gt;</span><br><span class="line">&lt;style type=<span class="string">"text/css"</span>&gt;</span><br><span class="line">div&#123;<span class="attr">width</span>: <span class="number">30</span>px;height: <span class="number">10</span>px;float:left;&#125;</span><br><span class="line">&lt;<span class="regexp">/style&gt;</span></span><br><span class="line"><span class="regexp">&lt;title&gt;data_structure&lt;/</span>title&gt;</span><br><span class="line">&lt;<span class="regexp">/head&gt;</span></span><br><span class="line"><span class="regexp">&lt;body&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;button id="test1"&gt;jQuey[0]&lt;/</span>button&gt;</span><br><span class="line">&lt;button id=<span class="string">"test2"</span>&gt;jQuey.get&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">&lt;button id="test3"&gt;aQuery[0]&lt;/</span>button&gt;</span><br><span class="line">&lt;button id=<span class="string">"test4"</span>&gt;aQuery.get&lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">&lt;p id="book"&gt;book&lt;/</span>p&gt;</span><br><span class="line">&lt;div id=<span class="string">"show1"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"show2"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"show3"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;div id=<span class="string">"show4"</span>&gt;&lt;/div&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> aQuery = <span class="function"><span class="keyword">function</span>(<span class="params">selector</span>) </span>&#123;</span><br><span class="line">    <span class="comment">//强制为对象</span></span><br><span class="line"><span class="keyword">if</span> (!(<span class="keyword">this</span> <span class="keyword">instanceof</span> aQuery)) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> aQuery(selector);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> elem = <span class="built_in">document</span>.getElementById(<span class="regexp">/[^#].*/</span>.exec(selector)[<span class="number">0</span>]);</span><br><span class="line"><span class="keyword">this</span>.length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">this</span>[<span class="number">0</span>] = elem;</span><br><span class="line"><span class="keyword">this</span>.context = <span class="built_in">document</span>;</span><br><span class="line"><span class="keyword">this</span>.selector = selector;</span><br><span class="line"><span class="keyword">this</span>.get = <span class="function"><span class="keyword">function</span>(<span class="params">num</span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>[num];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//结果是一个dom元素,可以把代码放到Google Chrome下运行</span></span><br><span class="line"><span class="comment">//按F12通过调试命令 console.log() 打印出对象</span></span><br><span class="line">$(<span class="string">"#test1"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show1'</span>).append($(<span class="string">'#book'</span>)[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test2"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show2'</span>).append($(<span class="string">'#book'</span>).get(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test3"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show3'</span>).append(aQuery(<span class="string">"#book"</span>)[<span class="number">0</span>])</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">$(<span class="string">"#test4"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">$(<span class="string">'#show4'</span>).append(aQuery(<span class="string">"#book"</span>).get(<span class="number">0</span>))</span><br><span class="line">&#125;)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&lt;/</span>body&gt;</span><br><span class="line">&lt;<span class="regexp">/html&gt;</span></span><br></pre></td></tr></table></figure><p>以上是模拟jQuery的对象结构，通过aQuery方法抽象出了对象创建的具体过程，这也是软件工程领域中的广为人知的设计模式-工厂方法。</p><h3>jQuery的无new构建原理</h3><p>函数<strong>aQuery()<strong>内部首先保证了必须是通过</strong>new</strong>操作符构建。这样就能保证当前构建的是一个带有<strong>this</strong>的实例对象，既然是对象我们可以把所有的属性与方法作为对象的<strong>key</strong>与<strong>value</strong>的方式给映射到<strong>this</strong>上，所以如上结构就可以模拟出jQuery的这样的操作了，即可通过索引取值，也可以链式方法取值，但是这样的结构是有很大的缺陷的，每次调用<strong>ajQuery</strong>方法等于是创建了一个新的实例，那么类似<strong>get</strong>方法就要在每一个实例上重新创建一遍，性能就大打折扣，所以jQuery在结构上的优化不仅仅只是我们看到的，除了实现类数组结构、方法的原型共享，而且还实现方法的静态与实例的共存，这是我们之后将会重点分析的。</p><h2>jQuery中ready与load事件</h2><p>jQuery有3种针对文档加载的方法</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//document ready 简写</span></span><br><span class="line">$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br><span class="line">$(<span class="built_in">document</span>).load(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ...代码...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><strong>一个是ready一个是load，这两个到底有什么区别呢？</strong></p><p>ready与load谁先执行：</p><p>ready与load谁先执行：大家在面试的过程中，经常会被问到一个问题：ready与load那一个先执行，那一个后执行？答案是<strong>ready先执行，load后执行</strong>。</p><p><strong>DOM文档加载的步骤：</strong></p><p><strong>DOM文档加载的步骤：</strong>要想理解为什么ready先执行，load后执行就要先了解下DOM文档加载的步骤：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(1) 解析HTML结构。</span><br><span class="line">(2) 加载外部脚本和样式表文件。</span><br><span class="line">(3) 解析并执行脚本代码。</span><br><span class="line">(4) 构造HTML DOM模型。//ready</span><br><span class="line">(5) 加载图片等外部文件。</span><br><span class="line">(6) 页面加载完毕。//load</span><br></pre></td></tr></table></figure><p>从上面的描述中大家应该已经理解了吧，ready在第（4）步完成之后就执行了，但是load要在第（6）步完成之后才执行。</p><p><strong>结论：</strong></p><p>ready与load的区别就在于资源文件的加载，ready构建了基本的DOM结构，所以对于代码来说应该越快加载越好。在一个高速浏览的时代，没人愿意等待答案。假如一个网站页面加载超过4秒，不好意思，你1/4的用户将面临着流失，所以对于框架来说用户体验是至关重要的，我们应该越早处理DOM越好，我们不需要等到图片资源都加载后才去处理框架的加载，图片资源过多load事件就会迟迟不会触发。</p><p>我们看看jQuery是如何处理文档加载时机的问题：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ready.promise = <span class="function"><span class="keyword">function</span>(<span class="params"> obj </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( !readyList ) &#123;</span><br><span class="line">        readyList = jQuery.Deferred();</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">document</span>.readyState === <span class="string">"complete"</span> ) &#123;</span><br><span class="line">            <span class="comment">// Handle it asynchronously to allow scripts the opportunity to delay ready</span></span><br><span class="line">            setTimeout( jQuery.ready );</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">document</span>.addEventListener( <span class="string">"DOMContentLoaded"</span>, completed, <span class="literal">false</span> );</span><br><span class="line">            <span class="built_in">window</span>.addEventListener( <span class="string">"load"</span>, completed, <span class="literal">false</span> );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readyList.promise( obj );</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>jQuery的ready是通过promise给包装过的，这也是jQuery擅长的手法，统一了回调体系，以后我们会重点谈到。</p><p>可见jQuery兼容的具体策略**：针对高级的浏览器，我们当前很乐意用DOMContentLoaded事件了，省时省力。**</p><p><strong>那么旧的IE如何处理呢？</strong></p><p>继续看jQuery的方案：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ensure firing before onload, maybe late but safe also for iframes</span></span><br><span class="line"><span class="built_in">document</span>.attachEvent( <span class="string">"onreadystatechange"</span>, completed );</span><br><span class="line"><span class="comment">// A fallback to window.onload, that will always work</span></span><br><span class="line"><span class="built_in">window</span>.attachEvent( <span class="string">"onload"</span>, completed );</span><br><span class="line"><span class="comment">// If IE and not a frame</span></span><br><span class="line"><span class="comment">// continually check to see if the document is ready</span></span><br><span class="line"><span class="keyword">var</span> top = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    top = <span class="built_in">window</span>.frameElement == <span class="literal">null</span> &amp;&amp; <span class="built_in">document</span>.documentElement;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;&#125;</span><br><span class="line"><span class="keyword">if</span> ( top &amp;&amp; top.doScroll ) &#123;</span><br><span class="line">    (<span class="function"><span class="keyword">function</span> <span class="title">doScrollCheck</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> ( !jQuery.isReady ) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Use the trick by Diego Perini</span></span><br><span class="line">                <span class="comment">// http://javascript.nwbox.com/IEContentLoaded/</span></span><br><span class="line">                top.doScroll(<span class="string">"left"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">                <span class="keyword">return</span> setTimeout( doScrollCheck, <span class="number">50</span> );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// detach all dom ready events</span></span><br><span class="line">            detach();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// and execute any waiting functions</span></span><br><span class="line">            jQuery.ready();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果浏览器存在 <code>document.onreadystatechange</code> 事件，当该事件触发时，如果 <code>document.readyState=complete</code> 的时候，可视为 DOM 树已经载入。不过，这个事件不太可靠，比如当页面中存在图片的时候，可能反而在 onload 事件之后才能触发，换言之，它只能正确地执行于页面不包含二进制资源或非常少或者被缓存时作为一个备选吧。</p><h4>针对IE的加载检测</h4><p>DOMContent文章参考：<a href="http://www.alloyteam.com/2014/03/effect-js-css-and-img-event-of-domcontentloaded/" target="_blank" rel="noopener">JS、CSS以及img对DOMContentLoaded事件的影响</a>Diego Perini 在 2007 年的时候，报告了一种检测 IE 是否加载完成的方式，使用 doScroll 方法调用，详情可见http://javascript.nwbox.com/IEContentLoaded/。原理就是对于 IE 在非 iframe 内时，只有不断地通过能否执行 doScroll 判断 DOM 是否加载完毕。在上述中间隔 50 毫秒尝试去执行 doScroll，注意，由于页面没有加载完成的时候，调用 doScroll 会导致异常，所以使用了 try -catch 来捕获异常。结论：所以总的来说当页面 DOM 未加载完成时，调用 doScroll 方法时，会产生异常。那么我们反过来用，如果不异常，那么就是页面DOM加载完毕了。</p><p>这都是我们在第一时间内处理ready加载的问题，如果ready在页面加载完毕后呢？</p><p>jQuery就必须针对这样的情况跳过绑定了：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ( <span class="built_in">document</span>.readyState === <span class="string">"complete"</span> ) &#123;</span><br><span class="line">     <span class="comment">// Handle it asynchronously to allow scripts the opportunity to delay ready</span></span><br><span class="line">     setTimeout( jQuery.ready );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>直接通过查看readyState的状态来确定页面的加载是否完成了。这里会给一个定时器的最小时间后去执行，主要保证执行的正确。</p><h2>jQuery多库共存处理</h2><p>多库共存换句话说可以叫无冲突处理。</p><p>总的来说会有2种情况会遇到：</p><ol><li><p>$太火热，jQuery采用$作为命名空间，不免会与别的库框架或者插件相冲突。</p></li><li><p>jQuery版本更新太快，插件跟不上，导致不同版本对插件的支持度不一样。</p></li></ol><p>出于以上的原因，jQuery给出了解决方案–– noConflict函数。</p><p>引入jQuery运行这个noConflict函数将变量$的控制权让给第一个实现它的那个库，确保jQuery不会与其他库的$对象发生冲突。</p><p>在运行这个函数后，就只能使用jQuery变量访问jQuery对象。例如，在要用到$(“aaron”)的地方，就必须换成jQuery(“aaron”)，因为$的控制权已经让出去了。</p><p>使用DEMO：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">jQuery.noConflict();</span><br><span class="line"><span class="comment">// 使用 jQuery</span></span><br><span class="line">jQuery(<span class="string">"aaron"</span>).show();</span><br><span class="line"><span class="comment">// 使用其他库的 $()</span></span><br><span class="line">$(<span class="string">"aaron"</span>).style.display = ‘block’;</span><br></pre></td></tr></table></figure><p>这个函数必须在你导入jQuery文件之后，并且在导入另一个导致冲突的库之前使用。当然也应当在其他冲突的库被使用之前，除非jQuery是最后一个导入的。</p><p>由于比较简单，我们直接上代码解说：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Var _jQuery = <span class="built_in">window</span>.jQuery,</span><br><span class="line">    _$ = <span class="built_in">window</span>.$;</span><br><span class="line"></span><br><span class="line">jQuery.noConflict = <span class="function"><span class="keyword">function</span>(<span class="params"> deep </span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="built_in">window</span>.$ === jQuery ) &#123;</span><br><span class="line">        <span class="built_in">window</span>.$ = _$;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">if</span> ( deep &amp;&amp; <span class="built_in">window</span>.jQuery === jQuery ) &#123;</span><br><span class="line">        <span class="built_in">window</span>.jQuery = _jQuery;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jQuery;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>如果我们需要同时使用jQuery和其他JavaScript库，我们可以使用 $.noConflict()把$的控制权交给其他库。旧引用的$ 被保存在jQuery的初始化; noConflict() 简单的恢复它们。</p><p>通过类似swap交换的概念，先把之前的存在的命名空间给缓存起来，通过对比当前的命名空间达到交换的目的，首先，我们先判断下当前的的$空间是不是被jQuery接管了，如果是则让出控制权给之前的_$引用的库，如果传入deep为true的话等于是把jQuery的控制权也让出去了。    如果不通过noConflict处理的话其后果可想而知，香喷喷的$大家都“觊觎已久”。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE HTML&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"Content-Type"</span> <span class="attr">content</span>=<span class="string">"text/html; charset=utf-8"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"http://img.mukewang.com/down/540812440001e40e00000000.js"</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>多库共存<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"aaron"</span>&gt;</span>测试noConflict效果<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="javascript">    $(<span class="string">"#aaron"</span>).click(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">        $.noConflict(); <span class="comment">//让出控制权</span></span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (!$) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"使用noConflict后，$不存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> (jQuery) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"使用noConflict后，jQuery存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="javascript"><span class="comment">//通过闭包隔离出$</span></span></span><br><span class="line"><span class="javascript">;(<span class="function"><span class="keyword">function</span>(<span class="params">$</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="keyword">if</span> ($) &#123;</span></span><br><span class="line"><span class="javascript">show(<span class="string">"通过闭包隔离后，转为局部变量$存在"</span>)</span></span><br><span class="line"><span class="undefined">&#125;</span></span><br><span class="line"><span class="undefined">&#125;)(jQuery);</span></span><br><span class="line"><span class="undefined">    &#125;)</span></span><br><span class="line"><span class="javascript">    <span class="function"><span class="keyword">function</span> <span class="title">show</span>(<span class="params">data</span>) </span>&#123;</span></span><br><span class="line"><span class="javascript">    jQuery(<span class="string">"body"</span>).append(<span class="string">'&lt;li&gt;'</span> + data + <span class="string">'&lt;/li&gt;'</span>)</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 前端 </tag>
            
            <tag> JavaScript </tag>
            
            <tag> JQuery </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
